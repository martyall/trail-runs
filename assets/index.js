(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod3) => function __require() {
    return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
  };
  var __export = (target5, all4) => {
    for (var name16 in all4)
      __defProp(target5, name16, { get: all4[name16], enumerable: true });
  };
  var __copyProps = (to, from3, except3, desc) => {
    if (from3 && typeof from3 === "object" || typeof from3 === "function") {
      for (let key of __getOwnPropNames(from3))
        if (!__hasOwnProp.call(to, key) && key !== except3)
          __defProp(to, key, { get: () => from3[key], enumerable: !(desc = __getOwnPropDesc(from3, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod3, isNodeMode, target5) => (target5 = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
    isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target5, "default", { value: mod3, enumerable: true }) : target5,
    mod3
  ));

  // node_modules/hammerjs/hammer.js
  var require_hammer = __commonJS({
    "node_modules/hammerjs/hammer.js"(exports, module) {
      (function(window3, document3, exportName, undefined2) {
        "use strict";
        var VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"];
        var TEST_ELEMENT = document3.createElement("div");
        var TYPE_FUNCTION = "function";
        var round3 = Math.round;
        var abs3 = Math.abs;
        var now2 = Date.now;
        function setTimeoutContext(fn, timeout, context) {
          return setTimeout(bindFn2(fn, context), timeout);
        }
        function invokeArrayArg(arg, fn, context) {
          if (Array.isArray(arg)) {
            each(arg, context[fn], context);
            return true;
          }
          return false;
        }
        function each(obj, iterator2, context) {
          var i;
          if (!obj) {
            return;
          }
          if (obj.forEach) {
            obj.forEach(iterator2, context);
          } else if (obj.length !== undefined2) {
            i = 0;
            while (i < obj.length) {
              iterator2.call(context, obj[i], i, obj);
              i++;
            }
          } else {
            for (i in obj) {
              obj.hasOwnProperty(i) && iterator2.call(context, obj[i], i, obj);
            }
          }
        }
        function deprecate(method2, name16, message2) {
          var deprecationMessage = "DEPRECATED METHOD: " + name16 + "\n" + message2 + " AT \n";
          return function() {
            var e = new Error("get-stack-trace");
            var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
            var log5 = window3.console && (window3.console.warn || window3.console.log);
            if (log5) {
              log5.call(window3.console, deprecationMessage, stack);
            }
            return method2.apply(this, arguments);
          };
        }
        var assign2;
        if (typeof Object.assign !== "function") {
          assign2 = function assign3(target5) {
            if (target5 === undefined2 || target5 === null) {
              throw new TypeError("Cannot convert undefined or null to object");
            }
            var output = Object(target5);
            for (var index5 = 1; index5 < arguments.length; index5++) {
              var source = arguments[index5];
              if (source !== undefined2 && source !== null) {
                for (var nextKey in source) {
                  if (source.hasOwnProperty(nextKey)) {
                    output[nextKey] = source[nextKey];
                  }
                }
              }
            }
            return output;
          };
        } else {
          assign2 = Object.assign;
        }
        var extend4 = deprecate(function extend5(dest, src9, merge2) {
          var keys3 = Object.keys(src9);
          var i = 0;
          while (i < keys3.length) {
            if (!merge2 || merge2 && dest[keys3[i]] === undefined2) {
              dest[keys3[i]] = src9[keys3[i]];
            }
            i++;
          }
          return dest;
        }, "extend", "Use `assign`.");
        var merge = deprecate(function merge2(dest, src9) {
          return extend4(dest, src9, true);
        }, "merge", "Use `assign`.");
        function inherit(child, base, properties) {
          var baseP = base.prototype, childP;
          childP = child.prototype = Object.create(baseP);
          childP.constructor = child;
          childP._super = baseP;
          if (properties) {
            assign2(childP, properties);
          }
        }
        function bindFn2(fn, context) {
          return function boundFn() {
            return fn.apply(context, arguments);
          };
        }
        function boolOrFn(val, args) {
          if (typeof val == TYPE_FUNCTION) {
            return val.apply(args ? args[0] || undefined2 : undefined2, args);
          }
          return val;
        }
        function ifUndefined(val1, val2) {
          return val1 === undefined2 ? val2 : val1;
        }
        function addEventListeners(target5, types, handler) {
          each(splitStr(types), function(type) {
            target5.addEventListener(type, handler, false);
          });
        }
        function removeEventListeners(target5, types, handler) {
          each(splitStr(types), function(type) {
            target5.removeEventListener(type, handler, false);
          });
        }
        function hasParent(node, parent2) {
          while (node) {
            if (node == parent2) {
              return true;
            }
            node = node.parentNode;
          }
          return false;
        }
        function inStr(str, find3) {
          return str.indexOf(find3) > -1;
        }
        function splitStr(str) {
          return str.trim().split(/\s+/g);
        }
        function inArray(src9, find3, findByKey) {
          if (src9.indexOf && !findByKey) {
            return src9.indexOf(find3);
          } else {
            var i = 0;
            while (i < src9.length) {
              if (findByKey && src9[i][findByKey] == find3 || !findByKey && src9[i] === find3) {
                return i;
              }
              i++;
            }
            return -1;
          }
        }
        function toArray5(obj) {
          return Array.prototype.slice.call(obj, 0);
        }
        function uniqueArray(src9, key, sort2) {
          var results = [];
          var values2 = [];
          var i = 0;
          while (i < src9.length) {
            var val = key ? src9[i][key] : src9[i];
            if (inArray(values2, val) < 0) {
              results.push(src9[i]);
            }
            values2[i] = val;
            i++;
          }
          if (sort2) {
            if (!key) {
              results = results.sort();
            } else {
              results = results.sort(function sortUniqueArray(a, b) {
                return a[key] > b[key];
              });
            }
          }
          return results;
        }
        function prefixed(obj, property) {
          var prefix, prop;
          var camelProp = property[0].toUpperCase() + property.slice(1);
          var i = 0;
          while (i < VENDOR_PREFIXES.length) {
            prefix = VENDOR_PREFIXES[i];
            prop = prefix ? prefix + camelProp : property;
            if (prop in obj) {
              return prop;
            }
            i++;
          }
          return undefined2;
        }
        var _uniqueId = 1;
        function uniqueId() {
          return _uniqueId++;
        }
        function getWindowForElement(element) {
          var doc = element.ownerDocument || element;
          return doc.defaultView || doc.parentWindow || window3;
        }
        var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
        var SUPPORT_TOUCH = "ontouchstart" in window3;
        var SUPPORT_POINTER_EVENTS = prefixed(window3, "PointerEvent") !== undefined2;
        var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
        var INPUT_TYPE_TOUCH = "touch";
        var INPUT_TYPE_PEN = "pen";
        var INPUT_TYPE_MOUSE = "mouse";
        var INPUT_TYPE_KINECT = "kinect";
        var COMPUTE_INTERVAL = 25;
        var INPUT_START2 = 1;
        var INPUT_MOVE2 = 2;
        var INPUT_END2 = 4;
        var INPUT_CANCEL = 8;
        var DIRECTION_NONE = 1;
        var DIRECTION_LEFT = 2;
        var DIRECTION_RIGHT = 4;
        var DIRECTION_UP = 8;
        var DIRECTION_DOWN = 16;
        var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
        var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
        var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
        var PROPS_XY = ["x", "y"];
        var PROPS_CLIENT_XY = ["clientX", "clientY"];
        function Input2(manager, callback) {
          var self2 = this;
          this.manager = manager;
          this.callback = callback;
          this.element = manager.element;
          this.target = manager.options.inputTarget;
          this.domHandler = function(ev) {
            if (boolOrFn(manager.options.enable, [manager])) {
              self2.handler(ev);
            }
          };
          this.init();
        }
        Input2.prototype = {
          handler: function() {
          },
          init: function() {
            this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
          },
          destroy: function() {
            this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
            this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
            this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
          }
        };
        function createInputInstance(manager) {
          var Type;
          var inputClass = manager.options.inputClass;
          if (inputClass) {
            Type = inputClass;
          } else if (SUPPORT_POINTER_EVENTS) {
            Type = PointerEventInput2;
          } else if (SUPPORT_ONLY_TOUCH) {
            Type = TouchInput;
          } else if (!SUPPORT_TOUCH) {
            Type = MouseInput2;
          } else {
            Type = TouchMouseInput;
          }
          return new Type(manager, inputHandler);
        }
        function inputHandler(manager, eventType, input) {
          var pointersLen = input.pointers.length;
          var changedPointersLen = input.changedPointers.length;
          var isFirst = eventType & INPUT_START2 && pointersLen - changedPointersLen === 0;
          var isFinal = eventType & (INPUT_END2 | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
          input.isFirst = !!isFirst;
          input.isFinal = !!isFinal;
          if (isFirst) {
            manager.session = {};
          }
          input.eventType = eventType;
          computeInputData(manager, input);
          manager.emit("hammer.input", input);
          manager.recognize(input);
          manager.session.prevInput = input;
        }
        function computeInputData(manager, input) {
          var session = manager.session;
          var pointers = input.pointers;
          var pointersLength = pointers.length;
          if (!session.firstInput) {
            session.firstInput = simpleCloneInputData(input);
          }
          if (pointersLength > 1 && !session.firstMultiple) {
            session.firstMultiple = simpleCloneInputData(input);
          } else if (pointersLength === 1) {
            session.firstMultiple = false;
          }
          var firstInput = session.firstInput;
          var firstMultiple = session.firstMultiple;
          var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
          var center = input.center = getCenter(pointers);
          input.timeStamp = now2();
          input.deltaTime = input.timeStamp - firstInput.timeStamp;
          input.angle = getAngle(offsetCenter, center);
          input.distance = getDistance(offsetCenter, center);
          computeDeltaXY(session, input);
          input.offsetDirection = getDirection(input.deltaX, input.deltaY);
          var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
          input.overallVelocityX = overallVelocity.x;
          input.overallVelocityY = overallVelocity.y;
          input.overallVelocity = abs3(overallVelocity.x) > abs3(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
          input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
          input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
          input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
          computeIntervalInputData(session, input);
          var target5 = manager.element;
          if (hasParent(input.srcEvent.target, target5)) {
            target5 = input.srcEvent.target;
          }
          input.target = target5;
        }
        function computeDeltaXY(session, input) {
          var center = input.center;
          var offset = session.offsetDelta || {};
          var prevDelta = session.prevDelta || {};
          var prevInput = session.prevInput || {};
          if (input.eventType === INPUT_START2 || prevInput.eventType === INPUT_END2) {
            prevDelta = session.prevDelta = {
              x: prevInput.deltaX || 0,
              y: prevInput.deltaY || 0
            };
            offset = session.offsetDelta = {
              x: center.x,
              y: center.y
            };
          }
          input.deltaX = prevDelta.x + (center.x - offset.x);
          input.deltaY = prevDelta.y + (center.y - offset.y);
        }
        function computeIntervalInputData(session, input) {
          var last3 = session.lastInterval || input, deltaTime = input.timeStamp - last3.timeStamp, velocity, velocityX, velocityY, direction;
          if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last3.velocity === undefined2)) {
            var deltaX = input.deltaX - last3.deltaX;
            var deltaY = input.deltaY - last3.deltaY;
            var v = getVelocity(deltaTime, deltaX, deltaY);
            velocityX = v.x;
            velocityY = v.y;
            velocity = abs3(v.x) > abs3(v.y) ? v.x : v.y;
            direction = getDirection(deltaX, deltaY);
            session.lastInterval = input;
          } else {
            velocity = last3.velocity;
            velocityX = last3.velocityX;
            velocityY = last3.velocityY;
            direction = last3.direction;
          }
          input.velocity = velocity;
          input.velocityX = velocityX;
          input.velocityY = velocityY;
          input.direction = direction;
        }
        function simpleCloneInputData(input) {
          var pointers = [];
          var i = 0;
          while (i < input.pointers.length) {
            pointers[i] = {
              clientX: round3(input.pointers[i].clientX),
              clientY: round3(input.pointers[i].clientY)
            };
            i++;
          }
          return {
            timeStamp: now2(),
            pointers,
            center: getCenter(pointers),
            deltaX: input.deltaX,
            deltaY: input.deltaY
          };
        }
        function getCenter(pointers) {
          var pointersLength = pointers.length;
          if (pointersLength === 1) {
            return {
              x: round3(pointers[0].clientX),
              y: round3(pointers[0].clientY)
            };
          }
          var x = 0, y = 0, i = 0;
          while (i < pointersLength) {
            x += pointers[i].clientX;
            y += pointers[i].clientY;
            i++;
          }
          return {
            x: round3(x / pointersLength),
            y: round3(y / pointersLength)
          };
        }
        function getVelocity(deltaTime, x, y) {
          return {
            x: x / deltaTime || 0,
            y: y / deltaTime || 0
          };
        }
        function getDirection(x, y) {
          if (x === y) {
            return DIRECTION_NONE;
          }
          if (abs3(x) >= abs3(y)) {
            return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
          }
          return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
        }
        function getDistance(p1, p2, props) {
          if (!props) {
            props = PROPS_XY;
          }
          var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
          return Math.sqrt(x * x + y * y);
        }
        function getAngle(p1, p2, props) {
          if (!props) {
            props = PROPS_XY;
          }
          var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
          return Math.atan2(y, x) * 180 / Math.PI;
        }
        function getRotation(start2, end) {
          return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start2[1], start2[0], PROPS_CLIENT_XY);
        }
        function getScale(start2, end) {
          return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start2[0], start2[1], PROPS_CLIENT_XY);
        }
        var MOUSE_INPUT_MAP2 = {
          mousedown: INPUT_START2,
          mousemove: INPUT_MOVE2,
          mouseup: INPUT_END2
        };
        var MOUSE_ELEMENT_EVENTS = "mousedown";
        var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
        function MouseInput2() {
          this.evEl = MOUSE_ELEMENT_EVENTS;
          this.evWin = MOUSE_WINDOW_EVENTS;
          this.pressed = false;
          Input2.apply(this, arguments);
        }
        inherit(MouseInput2, Input2, {
          handler: function MEhandler(ev) {
            var eventType = MOUSE_INPUT_MAP2[ev.type];
            if (eventType & INPUT_START2 && ev.button === 0) {
              this.pressed = true;
            }
            if (eventType & INPUT_MOVE2 && ev.which !== 1) {
              eventType = INPUT_END2;
            }
            if (!this.pressed) {
              return;
            }
            if (eventType & INPUT_END2) {
              this.pressed = false;
            }
            this.callback(this.manager, eventType, {
              pointers: [ev],
              changedPointers: [ev],
              pointerType: INPUT_TYPE_MOUSE,
              srcEvent: ev
            });
          }
        });
        var POINTER_INPUT_MAP = {
          pointerdown: INPUT_START2,
          pointermove: INPUT_MOVE2,
          pointerup: INPUT_END2,
          pointercancel: INPUT_CANCEL,
          pointerout: INPUT_CANCEL
        };
        var IE10_POINTER_TYPE_ENUM = {
          2: INPUT_TYPE_TOUCH,
          3: INPUT_TYPE_PEN,
          4: INPUT_TYPE_MOUSE,
          5: INPUT_TYPE_KINECT
        };
        var POINTER_ELEMENT_EVENTS = "pointerdown";
        var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
        if (window3.MSPointerEvent && !window3.PointerEvent) {
          POINTER_ELEMENT_EVENTS = "MSPointerDown";
          POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
        }
        function PointerEventInput2() {
          this.evEl = POINTER_ELEMENT_EVENTS;
          this.evWin = POINTER_WINDOW_EVENTS;
          Input2.apply(this, arguments);
          this.store = this.manager.session.pointerEvents = [];
        }
        inherit(PointerEventInput2, Input2, {
          handler: function PEhandler(ev) {
            var store = this.store;
            var removePointer = false;
            var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
            var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
            var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
            var isTouch = pointerType == INPUT_TYPE_TOUCH;
            var storeIndex = inArray(store, ev.pointerId, "pointerId");
            if (eventType & INPUT_START2 && (ev.button === 0 || isTouch)) {
              if (storeIndex < 0) {
                store.push(ev);
                storeIndex = store.length - 1;
              }
            } else if (eventType & (INPUT_END2 | INPUT_CANCEL)) {
              removePointer = true;
            }
            if (storeIndex < 0) {
              return;
            }
            store[storeIndex] = ev;
            this.callback(this.manager, eventType, {
              pointers: store,
              changedPointers: [ev],
              pointerType,
              srcEvent: ev
            });
            if (removePointer) {
              store.splice(storeIndex, 1);
            }
          }
        });
        var SINGLE_TOUCH_INPUT_MAP = {
          touchstart: INPUT_START2,
          touchmove: INPUT_MOVE2,
          touchend: INPUT_END2,
          touchcancel: INPUT_CANCEL
        };
        var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
        var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
        function SingleTouchInput() {
          this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
          this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
          this.started = false;
          Input2.apply(this, arguments);
        }
        inherit(SingleTouchInput, Input2, {
          handler: function TEhandler(ev) {
            var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
            if (type === INPUT_START2) {
              this.started = true;
            }
            if (!this.started) {
              return;
            }
            var touches = normalizeSingleTouches.call(this, ev, type);
            if (type & (INPUT_END2 | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
              this.started = false;
            }
            this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
            });
          }
        });
        function normalizeSingleTouches(ev, type) {
          var all4 = toArray5(ev.touches);
          var changed = toArray5(ev.changedTouches);
          if (type & (INPUT_END2 | INPUT_CANCEL)) {
            all4 = uniqueArray(all4.concat(changed), "identifier", true);
          }
          return [all4, changed];
        }
        var TOUCH_INPUT_MAP = {
          touchstart: INPUT_START2,
          touchmove: INPUT_MOVE2,
          touchend: INPUT_END2,
          touchcancel: INPUT_CANCEL
        };
        var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
        function TouchInput() {
          this.evTarget = TOUCH_TARGET_EVENTS;
          this.targetIds = {};
          Input2.apply(this, arguments);
        }
        inherit(TouchInput, Input2, {
          handler: function MTEhandler(ev) {
            var type = TOUCH_INPUT_MAP[ev.type];
            var touches = getTouches.call(this, ev, type);
            if (!touches) {
              return;
            }
            this.callback(this.manager, type, {
              pointers: touches[0],
              changedPointers: touches[1],
              pointerType: INPUT_TYPE_TOUCH,
              srcEvent: ev
            });
          }
        });
        function getTouches(ev, type) {
          var allTouches = toArray5(ev.touches);
          var targetIds = this.targetIds;
          if (type & (INPUT_START2 | INPUT_MOVE2) && allTouches.length === 1) {
            targetIds[allTouches[0].identifier] = true;
            return [allTouches, allTouches];
          }
          var i, targetTouches, changedTouches = toArray5(ev.changedTouches), changedTargetTouches = [], target5 = this.target;
          targetTouches = allTouches.filter(function(touch) {
            return hasParent(touch.target, target5);
          });
          if (type === INPUT_START2) {
            i = 0;
            while (i < targetTouches.length) {
              targetIds[targetTouches[i].identifier] = true;
              i++;
            }
          }
          i = 0;
          while (i < changedTouches.length) {
            if (targetIds[changedTouches[i].identifier]) {
              changedTargetTouches.push(changedTouches[i]);
            }
            if (type & (INPUT_END2 | INPUT_CANCEL)) {
              delete targetIds[changedTouches[i].identifier];
            }
            i++;
          }
          if (!changedTargetTouches.length) {
            return;
          }
          return [
            uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
            changedTargetTouches
          ];
        }
        var DEDUP_TIMEOUT = 2500;
        var DEDUP_DISTANCE = 25;
        function TouchMouseInput() {
          Input2.apply(this, arguments);
          var handler = bindFn2(this.handler, this);
          this.touch = new TouchInput(this.manager, handler);
          this.mouse = new MouseInput2(this.manager, handler);
          this.primaryTouch = null;
          this.lastTouches = [];
        }
        inherit(TouchMouseInput, Input2, {
          handler: function TMEhandler(manager, inputEvent, inputData) {
            var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
            if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
              return;
            }
            if (isTouch) {
              recordTouches.call(this, inputEvent, inputData);
            } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
              return;
            }
            this.callback(manager, inputEvent, inputData);
          },
          destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
          }
        });
        function recordTouches(eventType, eventData) {
          if (eventType & INPUT_START2) {
            this.primaryTouch = eventData.changedPointers[0].identifier;
            setLastTouch.call(this, eventData);
          } else if (eventType & (INPUT_END2 | INPUT_CANCEL)) {
            setLastTouch.call(this, eventData);
          }
        }
        function setLastTouch(eventData) {
          var touch = eventData.changedPointers[0];
          if (touch.identifier === this.primaryTouch) {
            var lastTouch = { x: touch.clientX, y: touch.clientY };
            this.lastTouches.push(lastTouch);
            var lts = this.lastTouches;
            var removeLastTouch = function() {
              var i = lts.indexOf(lastTouch);
              if (i > -1) {
                lts.splice(i, 1);
              }
            };
            setTimeout(removeLastTouch, DEDUP_TIMEOUT);
          }
        }
        function isSyntheticEvent(eventData) {
          var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
          for (var i = 0; i < this.lastTouches.length; i++) {
            var t = this.lastTouches[i];
            var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
            if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
              return true;
            }
          }
          return false;
        }
        var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
        var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined2;
        var TOUCH_ACTION_COMPUTE = "compute";
        var TOUCH_ACTION_AUTO = "auto";
        var TOUCH_ACTION_MANIPULATION = "manipulation";
        var TOUCH_ACTION_NONE = "none";
        var TOUCH_ACTION_PAN_X = "pan-x";
        var TOUCH_ACTION_PAN_Y = "pan-y";
        var TOUCH_ACTION_MAP = getTouchActionProps();
        function TouchAction(manager, value13) {
          this.manager = manager;
          this.set(value13);
        }
        TouchAction.prototype = {
          set: function(value13) {
            if (value13 == TOUCH_ACTION_COMPUTE) {
              value13 = this.compute();
            }
            if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value13]) {
              this.manager.element.style[PREFIXED_TOUCH_ACTION] = value13;
            }
            this.actions = value13.toLowerCase().trim();
          },
          update: function() {
            this.set(this.manager.options.touchAction);
          },
          compute: function() {
            var actions = [];
            each(this.manager.recognizers, function(recognizer) {
              if (boolOrFn(recognizer.options.enable, [recognizer])) {
                actions = actions.concat(recognizer.getTouchAction());
              }
            });
            return cleanTouchActions(actions.join(" "));
          },
          preventDefaults: function(input) {
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;
            if (this.manager.session.prevented) {
              srcEvent.preventDefault();
              return;
            }
            var actions = this.actions;
            var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
            var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
            if (hasNone) {
              var isTapPointer = input.pointers.length === 1;
              var isTapMovement = input.distance < 2;
              var isTapTouchTime = input.deltaTime < 250;
              if (isTapPointer && isTapMovement && isTapTouchTime) {
                return;
              }
            }
            if (hasPanX && hasPanY) {
              return;
            }
            if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
              return this.preventSrc(srcEvent);
            }
          },
          preventSrc: function(srcEvent) {
            this.manager.session.prevented = true;
            srcEvent.preventDefault();
          }
        };
        function cleanTouchActions(actions) {
          if (inStr(actions, TOUCH_ACTION_NONE)) {
            return TOUCH_ACTION_NONE;
          }
          var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
          var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
          if (hasPanX && hasPanY) {
            return TOUCH_ACTION_NONE;
          }
          if (hasPanX || hasPanY) {
            return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
          }
          if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
            return TOUCH_ACTION_MANIPULATION;
          }
          return TOUCH_ACTION_AUTO;
        }
        function getTouchActionProps() {
          if (!NATIVE_TOUCH_ACTION) {
            return false;
          }
          var touchMap = {};
          var cssSupports = window3.CSS && window3.CSS.supports;
          ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val) {
            touchMap[val] = cssSupports ? window3.CSS.supports("touch-action", val) : true;
          });
          return touchMap;
        }
        var STATE_POSSIBLE = 1;
        var STATE_BEGAN = 2;
        var STATE_CHANGED = 4;
        var STATE_ENDED = 8;
        var STATE_RECOGNIZED = STATE_ENDED;
        var STATE_CANCELLED = 16;
        var STATE_FAILED = 32;
        function Recognizer(options2) {
          this.options = assign2({}, this.defaults, options2 || {});
          this.id = uniqueId();
          this.manager = null;
          this.options.enable = ifUndefined(this.options.enable, true);
          this.state = STATE_POSSIBLE;
          this.simultaneous = {};
          this.requireFail = [];
        }
        Recognizer.prototype = {
          defaults: {},
          set: function(options2) {
            assign2(this.options, options2);
            this.manager && this.manager.touchAction.update();
            return this;
          },
          recognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
              return this;
            }
            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (!simultaneous[otherRecognizer.id]) {
              simultaneous[otherRecognizer.id] = otherRecognizer;
              otherRecognizer.recognizeWith(this);
            }
            return this;
          },
          dropRecognizeWith: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
              return this;
            }
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            delete this.simultaneous[otherRecognizer.id];
            return this;
          },
          requireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
              return this;
            }
            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            if (inArray(requireFail, otherRecognizer) === -1) {
              requireFail.push(otherRecognizer);
              otherRecognizer.requireFailure(this);
            }
            return this;
          },
          dropRequireFailure: function(otherRecognizer) {
            if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
              return this;
            }
            otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
            var index5 = inArray(this.requireFail, otherRecognizer);
            if (index5 > -1) {
              this.requireFail.splice(index5, 1);
            }
            return this;
          },
          hasRequireFailures: function() {
            return this.requireFail.length > 0;
          },
          canRecognizeWith: function(otherRecognizer) {
            return !!this.simultaneous[otherRecognizer.id];
          },
          emit: function(input) {
            var self2 = this;
            var state3 = this.state;
            function emit(event) {
              self2.manager.emit(event, input);
            }
            if (state3 < STATE_ENDED) {
              emit(self2.options.event + stateStr(state3));
            }
            emit(self2.options.event);
            if (input.additionalEvent) {
              emit(input.additionalEvent);
            }
            if (state3 >= STATE_ENDED) {
              emit(self2.options.event + stateStr(state3));
            }
          },
          tryEmit: function(input) {
            if (this.canEmit()) {
              return this.emit(input);
            }
            this.state = STATE_FAILED;
          },
          canEmit: function() {
            var i = 0;
            while (i < this.requireFail.length) {
              if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) {
                return false;
              }
              i++;
            }
            return true;
          },
          recognize: function(inputData) {
            var inputDataClone = assign2({}, inputData);
            if (!boolOrFn(this.options.enable, [this, inputDataClone])) {
              this.reset();
              this.state = STATE_FAILED;
              return;
            }
            if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
              this.state = STATE_POSSIBLE;
            }
            this.state = this.process(inputDataClone);
            if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
              this.tryEmit(inputDataClone);
            }
          },
          process: function(inputData) {
          },
          getTouchAction: function() {
          },
          reset: function() {
          }
        };
        function stateStr(state3) {
          if (state3 & STATE_CANCELLED) {
            return "cancel";
          } else if (state3 & STATE_ENDED) {
            return "end";
          } else if (state3 & STATE_CHANGED) {
            return "move";
          } else if (state3 & STATE_BEGAN) {
            return "start";
          }
          return "";
        }
        function directionStr(direction) {
          if (direction == DIRECTION_DOWN) {
            return "down";
          } else if (direction == DIRECTION_UP) {
            return "up";
          } else if (direction == DIRECTION_LEFT) {
            return "left";
          } else if (direction == DIRECTION_RIGHT) {
            return "right";
          }
          return "";
        }
        function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
          var manager = recognizer.manager;
          if (manager) {
            return manager.get(otherRecognizer);
          }
          return otherRecognizer;
        }
        function AttrRecognizer() {
          Recognizer.apply(this, arguments);
        }
        inherit(AttrRecognizer, Recognizer, {
          defaults: {
            pointers: 1
          },
          attrTest: function(input) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
          },
          process: function(input) {
            var state3 = this.state;
            var eventType = input.eventType;
            var isRecognized = state3 & (STATE_BEGAN | STATE_CHANGED);
            var isValid3 = this.attrTest(input);
            if (isRecognized && (eventType & INPUT_CANCEL || !isValid3)) {
              return state3 | STATE_CANCELLED;
            } else if (isRecognized || isValid3) {
              if (eventType & INPUT_END2) {
                return state3 | STATE_ENDED;
              } else if (!(state3 & STATE_BEGAN)) {
                return STATE_BEGAN;
              }
              return state3 | STATE_CHANGED;
            }
            return STATE_FAILED;
          }
        });
        function PanRecognizer() {
          AttrRecognizer.apply(this, arguments);
          this.pX = null;
          this.pY = null;
        }
        inherit(PanRecognizer, AttrRecognizer, {
          defaults: {
            event: "pan",
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
          },
          getTouchAction: function() {
            var direction = this.options.direction;
            var actions = [];
            if (direction & DIRECTION_HORIZONTAL) {
              actions.push(TOUCH_ACTION_PAN_Y);
            }
            if (direction & DIRECTION_VERTICAL) {
              actions.push(TOUCH_ACTION_PAN_X);
            }
            return actions;
          },
          directionTest: function(input) {
            var options2 = this.options;
            var hasMoved = true;
            var distance2 = input.distance;
            var direction = input.direction;
            var x = input.deltaX;
            var y = input.deltaY;
            if (!(direction & options2.direction)) {
              if (options2.direction & DIRECTION_HORIZONTAL) {
                direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                hasMoved = x != this.pX;
                distance2 = Math.abs(input.deltaX);
              } else {
                direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                hasMoved = y != this.pY;
                distance2 = Math.abs(input.deltaY);
              }
            }
            input.direction = direction;
            return hasMoved && distance2 > options2.threshold && direction & options2.direction;
          },
          attrTest: function(input) {
            return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
          },
          emit: function(input) {
            this.pX = input.deltaX;
            this.pY = input.deltaY;
            var direction = directionStr(input.direction);
            if (direction) {
              input.additionalEvent = this.options.event + direction;
            }
            this._super.emit.call(this, input);
          }
        });
        function PinchRecognizer() {
          AttrRecognizer.apply(this, arguments);
        }
        inherit(PinchRecognizer, AttrRecognizer, {
          defaults: {
            event: "pinch",
            threshold: 0,
            pointers: 2
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
          },
          attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
          },
          emit: function(input) {
            if (input.scale !== 1) {
              var inOut = input.scale < 1 ? "in" : "out";
              input.additionalEvent = this.options.event + inOut;
            }
            this._super.emit.call(this, input);
          }
        });
        function PressRecognizer() {
          Recognizer.apply(this, arguments);
          this._timer = null;
          this._input = null;
        }
        inherit(PressRecognizer, Recognizer, {
          defaults: {
            event: "press",
            pointers: 1,
            time: 251,
            threshold: 9
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_AUTO];
          },
          process: function(input) {
            var options2 = this.options;
            var validPointers = input.pointers.length === options2.pointers;
            var validMovement = input.distance < options2.threshold;
            var validTime = input.deltaTime > options2.time;
            this._input = input;
            if (!validMovement || !validPointers || input.eventType & (INPUT_END2 | INPUT_CANCEL) && !validTime) {
              this.reset();
            } else if (input.eventType & INPUT_START2) {
              this.reset();
              this._timer = setTimeoutContext(function() {
                this.state = STATE_RECOGNIZED;
                this.tryEmit();
              }, options2.time, this);
            } else if (input.eventType & INPUT_END2) {
              return STATE_RECOGNIZED;
            }
            return STATE_FAILED;
          },
          reset: function() {
            clearTimeout(this._timer);
          },
          emit: function(input) {
            if (this.state !== STATE_RECOGNIZED) {
              return;
            }
            if (input && input.eventType & INPUT_END2) {
              this.manager.emit(this.options.event + "up", input);
            } else {
              this._input.timeStamp = now2();
              this.manager.emit(this.options.event, this._input);
            }
          }
        });
        function RotateRecognizer() {
          AttrRecognizer.apply(this, arguments);
        }
        inherit(RotateRecognizer, AttrRecognizer, {
          defaults: {
            event: "rotate",
            threshold: 0,
            pointers: 2
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_NONE];
          },
          attrTest: function(input) {
            return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
          }
        });
        function SwipeRecognizer() {
          AttrRecognizer.apply(this, arguments);
        }
        inherit(SwipeRecognizer, AttrRecognizer, {
          defaults: {
            event: "swipe",
            threshold: 10,
            velocity: 0.3,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
          },
          getTouchAction: function() {
            return PanRecognizer.prototype.getTouchAction.call(this);
          },
          attrTest: function(input) {
            var direction = this.options.direction;
            var velocity;
            if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
              velocity = input.overallVelocity;
            } else if (direction & DIRECTION_HORIZONTAL) {
              velocity = input.overallVelocityX;
            } else if (direction & DIRECTION_VERTICAL) {
              velocity = input.overallVelocityY;
            }
            return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs3(velocity) > this.options.velocity && input.eventType & INPUT_END2;
          },
          emit: function(input) {
            var direction = directionStr(input.offsetDirection);
            if (direction) {
              this.manager.emit(this.options.event + direction, input);
            }
            this.manager.emit(this.options.event, input);
          }
        });
        function TapRecognizer() {
          Recognizer.apply(this, arguments);
          this.pTime = false;
          this.pCenter = false;
          this._timer = null;
          this._input = null;
          this.count = 0;
        }
        inherit(TapRecognizer, Recognizer, {
          defaults: {
            event: "tap",
            pointers: 1,
            taps: 1,
            interval: 300,
            time: 250,
            threshold: 9,
            posThreshold: 10
          },
          getTouchAction: function() {
            return [TOUCH_ACTION_MANIPULATION];
          },
          process: function(input) {
            var options2 = this.options;
            var validPointers = input.pointers.length === options2.pointers;
            var validMovement = input.distance < options2.threshold;
            var validTouchTime = input.deltaTime < options2.time;
            this.reset();
            if (input.eventType & INPUT_START2 && this.count === 0) {
              return this.failTimeout();
            }
            if (validMovement && validTouchTime && validPointers) {
              if (input.eventType != INPUT_END2) {
                return this.failTimeout();
              }
              var validInterval = this.pTime ? input.timeStamp - this.pTime < options2.interval : true;
              var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options2.posThreshold;
              this.pTime = input.timeStamp;
              this.pCenter = input.center;
              if (!validMultiTap || !validInterval) {
                this.count = 1;
              } else {
                this.count += 1;
              }
              this._input = input;
              var tapCount = this.count % options2.taps;
              if (tapCount === 0) {
                if (!this.hasRequireFailures()) {
                  return STATE_RECOGNIZED;
                } else {
                  this._timer = setTimeoutContext(function() {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                  }, options2.interval, this);
                  return STATE_BEGAN;
                }
              }
            }
            return STATE_FAILED;
          },
          failTimeout: function() {
            this._timer = setTimeoutContext(function() {
              this.state = STATE_FAILED;
            }, this.options.interval, this);
            return STATE_FAILED;
          },
          reset: function() {
            clearTimeout(this._timer);
          },
          emit: function() {
            if (this.state == STATE_RECOGNIZED) {
              this._input.tapCount = this.count;
              this.manager.emit(this.options.event, this._input);
            }
          }
        });
        function Hammer(element, options2) {
          options2 = options2 || {};
          options2.recognizers = ifUndefined(options2.recognizers, Hammer.defaults.preset);
          return new Manager3(element, options2);
        }
        Hammer.VERSION = "2.0.7";
        Hammer.defaults = {
          domEvents: false,
          touchAction: TOUCH_ACTION_COMPUTE,
          enable: true,
          inputTarget: null,
          inputClass: null,
          preset: [
            [RotateRecognizer, { enable: false }],
            [PinchRecognizer, { enable: false }, ["rotate"]],
            [SwipeRecognizer, { direction: DIRECTION_HORIZONTAL }],
            [PanRecognizer, { direction: DIRECTION_HORIZONTAL }, ["swipe"]],
            [TapRecognizer],
            [TapRecognizer, { event: "doubletap", taps: 2 }, ["tap"]],
            [PressRecognizer]
          ],
          cssProps: {
            userSelect: "none",
            touchSelect: "none",
            touchCallout: "none",
            contentZooming: "none",
            userDrag: "none",
            tapHighlightColor: "rgba(0,0,0,0)"
          }
        };
        var STOP = 1;
        var FORCED_STOP = 2;
        function Manager3(element, options2) {
          this.options = assign2({}, Hammer.defaults, options2 || {});
          this.options.inputTarget = this.options.inputTarget || element;
          this.handlers = {};
          this.session = {};
          this.recognizers = [];
          this.oldCssProps = {};
          this.element = element;
          this.input = createInputInstance(this);
          this.touchAction = new TouchAction(this, this.options.touchAction);
          toggleCssProps(this, true);
          each(this.options.recognizers, function(item) {
            var recognizer = this.add(new item[0](item[1]));
            item[2] && recognizer.recognizeWith(item[2]);
            item[3] && recognizer.requireFailure(item[3]);
          }, this);
        }
        Manager3.prototype = {
          set: function(options2) {
            assign2(this.options, options2);
            if (options2.touchAction) {
              this.touchAction.update();
            }
            if (options2.inputTarget) {
              this.input.destroy();
              this.input.target = options2.inputTarget;
              this.input.init();
            }
            return this;
          },
          stop: function(force) {
            this.session.stopped = force ? FORCED_STOP : STOP;
          },
          recognize: function(inputData) {
            var session = this.session;
            if (session.stopped) {
              return;
            }
            this.touchAction.preventDefaults(inputData);
            var recognizer;
            var recognizers = this.recognizers;
            var curRecognizer = session.curRecognizer;
            if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
              curRecognizer = session.curRecognizer = null;
            }
            var i = 0;
            while (i < recognizers.length) {
              recognizer = recognizers[i];
              if (session.stopped !== FORCED_STOP && (!curRecognizer || recognizer == curRecognizer || recognizer.canRecognizeWith(curRecognizer))) {
                recognizer.recognize(inputData);
              } else {
                recognizer.reset();
              }
              if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                curRecognizer = session.curRecognizer = recognizer;
              }
              i++;
            }
          },
          get: function(recognizer) {
            if (recognizer instanceof Recognizer) {
              return recognizer;
            }
            var recognizers = this.recognizers;
            for (var i = 0; i < recognizers.length; i++) {
              if (recognizers[i].options.event == recognizer) {
                return recognizers[i];
              }
            }
            return null;
          },
          add: function(recognizer) {
            if (invokeArrayArg(recognizer, "add", this)) {
              return this;
            }
            var existing = this.get(recognizer.options.event);
            if (existing) {
              this.remove(existing);
            }
            this.recognizers.push(recognizer);
            recognizer.manager = this;
            this.touchAction.update();
            return recognizer;
          },
          remove: function(recognizer) {
            if (invokeArrayArg(recognizer, "remove", this)) {
              return this;
            }
            recognizer = this.get(recognizer);
            if (recognizer) {
              var recognizers = this.recognizers;
              var index5 = inArray(recognizers, recognizer);
              if (index5 !== -1) {
                recognizers.splice(index5, 1);
                this.touchAction.update();
              }
            }
            return this;
          },
          on: function(events, handler) {
            if (events === undefined2) {
              return;
            }
            if (handler === undefined2) {
              return;
            }
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
              handlers[event] = handlers[event] || [];
              handlers[event].push(handler);
            });
            return this;
          },
          off: function(events, handler) {
            if (events === undefined2) {
              return;
            }
            var handlers = this.handlers;
            each(splitStr(events), function(event) {
              if (!handler) {
                delete handlers[event];
              } else {
                handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1);
              }
            });
            return this;
          },
          emit: function(event, data) {
            if (this.options.domEvents) {
              triggerDomEvent(event, data);
            }
            var handlers = this.handlers[event] && this.handlers[event].slice();
            if (!handlers || !handlers.length) {
              return;
            }
            data.type = event;
            data.preventDefault = function() {
              data.srcEvent.preventDefault();
            };
            var i = 0;
            while (i < handlers.length) {
              handlers[i](data);
              i++;
            }
          },
          destroy: function() {
            this.element && toggleCssProps(this, false);
            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
          }
        };
        function toggleCssProps(manager, add5) {
          var element = manager.element;
          if (!element.style) {
            return;
          }
          var prop;
          each(manager.options.cssProps, function(value13, name16) {
            prop = prefixed(element.style, name16);
            if (add5) {
              manager.oldCssProps[prop] = element.style[prop];
              element.style[prop] = value13;
            } else {
              element.style[prop] = manager.oldCssProps[prop] || "";
            }
          });
          if (!add5) {
            manager.oldCssProps = {};
          }
        }
        function triggerDomEvent(event, data) {
          var gestureEvent = document3.createEvent("Event");
          gestureEvent.initEvent(event, true, true);
          gestureEvent.gesture = data;
          data.target.dispatchEvent(gestureEvent);
        }
        assign2(Hammer, {
          INPUT_START: INPUT_START2,
          INPUT_MOVE: INPUT_MOVE2,
          INPUT_END: INPUT_END2,
          INPUT_CANCEL,
          STATE_POSSIBLE,
          STATE_BEGAN,
          STATE_CHANGED,
          STATE_ENDED,
          STATE_RECOGNIZED,
          STATE_CANCELLED,
          STATE_FAILED,
          DIRECTION_NONE,
          DIRECTION_LEFT,
          DIRECTION_RIGHT,
          DIRECTION_UP,
          DIRECTION_DOWN,
          DIRECTION_HORIZONTAL,
          DIRECTION_VERTICAL,
          DIRECTION_ALL,
          Manager: Manager3,
          Input: Input2,
          TouchAction,
          TouchInput,
          MouseInput: MouseInput2,
          PointerEventInput: PointerEventInput2,
          TouchMouseInput,
          SingleTouchInput,
          Recognizer,
          AttrRecognizer,
          Tap: TapRecognizer,
          Pan: PanRecognizer,
          Swipe: SwipeRecognizer,
          Pinch: PinchRecognizer,
          Rotate: RotateRecognizer,
          Press: PressRecognizer,
          on: addEventListeners,
          off: removeEventListeners,
          each,
          merge,
          extend: extend4,
          assign: assign2,
          inherit,
          bindFn: bindFn2,
          prefixed
        });
        var freeGlobal = typeof window3 !== "undefined" ? window3 : typeof self !== "undefined" ? self : {};
        freeGlobal.Hammer = Hammer;
        if (typeof define === "function" && define.amd) {
          define(function() {
            return Hammer;
          });
        } else if (typeof module != "undefined" && module.exports) {
          module.exports = Hammer;
        } else {
          window3[exportName] = Hammer;
        }
      })(window, document, "Hammer");
    }
  });

  // node_modules/react/cjs/react.development.js
  var require_react_development = __commonJS({
    "node_modules/react/cjs/react.development.js"(exports, module) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var ReactVersion = "18.2.0";
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var ReactCurrentDispatcher = {
            current: null
          };
          var ReactCurrentBatchConfig = {
            transition: null
          };
          var ReactCurrentActQueue = {
            current: null,
            isBatchingLegacy: false,
            didScheduleLegacyUpdate: false
          };
          var ReactCurrentOwner = {
            current: null
          };
          var ReactDebugCurrentFrame = {};
          var currentExtraStackFrame = null;
          function setExtraStackFrame(stack) {
            {
              currentExtraStackFrame = stack;
            }
          }
          {
            ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
              {
                currentExtraStackFrame = stack;
              }
            };
            ReactDebugCurrentFrame.getCurrentStack = null;
            ReactDebugCurrentFrame.getStackAddendum = function() {
              var stack = "";
              if (currentExtraStackFrame) {
                stack += currentExtraStackFrame;
              }
              var impl = ReactDebugCurrentFrame.getCurrentStack;
              if (impl) {
                stack += impl() || "";
              }
              return stack;
            };
          }
          var enableScopeAPI = false;
          var enableCacheElement = false;
          var enableTransitionTracing = false;
          var enableLegacyHidden = false;
          var enableDebugTracing = false;
          var ReactSharedInternals = {
            ReactCurrentDispatcher,
            ReactCurrentBatchConfig,
            ReactCurrentOwner
          };
          {
            ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
            ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
          }
          function warn(format) {
            {
              {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format, args);
              }
            }
          }
          function error3(format) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format, args);
              }
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var didWarnStateUpdateForUnmountedComponent = {};
          function warnNoop(publicInstance, callerName) {
            {
              var _constructor = publicInstance.constructor;
              var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
              var warningKey = componentName + "." + callerName;
              if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
                return;
              }
              error3("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", callerName, componentName);
              didWarnStateUpdateForUnmountedComponent[warningKey] = true;
            }
          }
          var ReactNoopUpdateQueue = {
            isMounted: function(publicInstance) {
              return false;
            },
            enqueueForceUpdate: function(publicInstance, callback, callerName) {
              warnNoop(publicInstance, "forceUpdate");
            },
            enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
              warnNoop(publicInstance, "replaceState");
            },
            enqueueSetState: function(publicInstance, partialState, callback, callerName) {
              warnNoop(publicInstance, "setState");
            }
          };
          var assign2 = Object.assign;
          var emptyObject = {};
          {
            Object.freeze(emptyObject);
          }
          function Component2(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          Component2.prototype.isReactComponent = {};
          Component2.prototype.setState = function(partialState, callback) {
            if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
              throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
            }
            this.updater.enqueueSetState(this, partialState, callback, "setState");
          };
          Component2.prototype.forceUpdate = function(callback) {
            this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
          };
          {
            var deprecatedAPIs = {
              isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
              replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
            };
            var defineDeprecationWarning = function(methodName, info) {
              Object.defineProperty(Component2.prototype, methodName, {
                get: function() {
                  warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
                  return void 0;
                }
              });
            };
            for (var fnName in deprecatedAPIs) {
              if (deprecatedAPIs.hasOwnProperty(fnName)) {
                defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
              }
            }
          }
          function ComponentDummy() {
          }
          ComponentDummy.prototype = Component2.prototype;
          function PureComponent2(props, context, updater) {
            this.props = props;
            this.context = context;
            this.refs = emptyObject;
            this.updater = updater || ReactNoopUpdateQueue;
          }
          var pureComponentPrototype = PureComponent2.prototype = new ComponentDummy();
          pureComponentPrototype.constructor = PureComponent2;
          assign2(pureComponentPrototype, Component2.prototype);
          pureComponentPrototype.isPureReactComponent = true;
          function createRef2() {
            var refObject = {
              current: null
            };
            {
              Object.seal(refObject);
            }
            return refObject;
          }
          var isArrayImpl = Array.isArray;
          function isArray6(a) {
            return isArrayImpl(a);
          }
          function typeName(value13) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value13[Symbol.toStringTag] || value13.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value13) {
            {
              try {
                testStringCoercion(value13);
                return false;
              } catch (e) {
                return true;
              }
            }
          }
          function testStringCoercion(value13) {
            return "" + value13;
          }
          function checkKeyStringCoercion(value13) {
            {
              if (willCoercionThrow(value13)) {
                error3("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value13));
                return testStringCoercion(value13);
              }
            }
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error3("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init3 = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init3(payload));
                  } catch (x) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var hasOwnProperty3 = Object.prototype.hasOwnProperty;
          var RESERVED_PROPS = {
            key: true,
            ref: true,
            __self: true,
            __source: true
          };
          var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
          {
            didWarnAboutStringRefs = {};
          }
          function hasValidRef(config2) {
            {
              if (hasOwnProperty3.call(config2, "ref")) {
                var getter = Object.getOwnPropertyDescriptor(config2, "ref").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config2.ref !== void 0;
          }
          function hasValidKey(config2) {
            {
              if (hasOwnProperty3.call(config2, "key")) {
                var getter = Object.getOwnPropertyDescriptor(config2, "key").get;
                if (getter && getter.isReactWarning) {
                  return false;
                }
              }
            }
            return config2.key !== void 0;
          }
          function defineKeyPropWarningGetter(props, displayName) {
            var warnAboutAccessingKey = function() {
              {
                if (!specialPropKeyWarningShown) {
                  specialPropKeyWarningShown = true;
                  error3("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingKey.isReactWarning = true;
            Object.defineProperty(props, "key", {
              get: warnAboutAccessingKey,
              configurable: true
            });
          }
          function defineRefPropWarningGetter(props, displayName) {
            var warnAboutAccessingRef = function() {
              {
                if (!specialPropRefWarningShown) {
                  specialPropRefWarningShown = true;
                  error3("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", displayName);
                }
              }
            };
            warnAboutAccessingRef.isReactWarning = true;
            Object.defineProperty(props, "ref", {
              get: warnAboutAccessingRef,
              configurable: true
            });
          }
          function warnIfStringRefCannotBeAutoConverted(config2) {
            {
              if (typeof config2.ref === "string" && ReactCurrentOwner.current && config2.__self && ReactCurrentOwner.current.stateNode !== config2.__self) {
                var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
                if (!didWarnAboutStringRefs[componentName]) {
                  error3('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, config2.ref);
                  didWarnAboutStringRefs[componentName] = true;
                }
              }
            }
          }
          var ReactElement = function(type, key, ref, self2, source, owner, props) {
            var element = {
              $$typeof: REACT_ELEMENT_TYPE,
              type,
              key,
              ref,
              props,
              _owner: owner
            };
            {
              element._store = {};
              Object.defineProperty(element._store, "validated", {
                configurable: false,
                enumerable: false,
                writable: true,
                value: false
              });
              Object.defineProperty(element, "_self", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: self2
              });
              Object.defineProperty(element, "_source", {
                configurable: false,
                enumerable: false,
                writable: false,
                value: source
              });
              if (Object.freeze) {
                Object.freeze(element.props);
                Object.freeze(element);
              }
            }
            return element;
          };
          function createElement21(type, config2, children) {
            var propName;
            var props = {};
            var key = null;
            var ref = null;
            var self2 = null;
            var source = null;
            if (config2 != null) {
              if (hasValidRef(config2)) {
                ref = config2.ref;
                {
                  warnIfStringRefCannotBeAutoConverted(config2);
                }
              }
              if (hasValidKey(config2)) {
                {
                  checkKeyStringCoercion(config2.key);
                }
                key = "" + config2.key;
              }
              self2 = config2.__self === void 0 ? null : config2.__self;
              source = config2.__source === void 0 ? null : config2.__source;
              for (propName in config2) {
                if (hasOwnProperty3.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  props[propName] = config2[propName];
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i = 0; i < childrenLength; i++) {
                childArray[i] = arguments[i + 2];
              }
              {
                if (Object.freeze) {
                  Object.freeze(childArray);
                }
              }
              props.children = childArray;
            }
            if (type && type.defaultProps) {
              var defaultProps19 = type.defaultProps;
              for (propName in defaultProps19) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps19[propName];
                }
              }
            }
            {
              if (key || ref) {
                var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
                if (key) {
                  defineKeyPropWarningGetter(props, displayName);
                }
                if (ref) {
                  defineRefPropWarningGetter(props, displayName);
                }
              }
            }
            return ReactElement(type, key, ref, self2, source, ReactCurrentOwner.current, props);
          }
          function cloneAndReplaceKey(oldElement, newKey) {
            var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
            return newElement;
          }
          function cloneElement3(element, config2, children) {
            if (element === null || element === void 0) {
              throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
            }
            var propName;
            var props = assign2({}, element.props);
            var key = element.key;
            var ref = element.ref;
            var self2 = element._self;
            var source = element._source;
            var owner = element._owner;
            if (config2 != null) {
              if (hasValidRef(config2)) {
                ref = config2.ref;
                owner = ReactCurrentOwner.current;
              }
              if (hasValidKey(config2)) {
                {
                  checkKeyStringCoercion(config2.key);
                }
                key = "" + config2.key;
              }
              var defaultProps19;
              if (element.type && element.type.defaultProps) {
                defaultProps19 = element.type.defaultProps;
              }
              for (propName in config2) {
                if (hasOwnProperty3.call(config2, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
                  if (config2[propName] === void 0 && defaultProps19 !== void 0) {
                    props[propName] = defaultProps19[propName];
                  } else {
                    props[propName] = config2[propName];
                  }
                }
              }
            }
            var childrenLength = arguments.length - 2;
            if (childrenLength === 1) {
              props.children = children;
            } else if (childrenLength > 1) {
              var childArray = Array(childrenLength);
              for (var i = 0; i < childrenLength; i++) {
                childArray[i] = arguments[i + 2];
              }
              props.children = childArray;
            }
            return ReactElement(element.type, key, ref, self2, source, owner, props);
          }
          function isValidElement(object12) {
            return typeof object12 === "object" && object12 !== null && object12.$$typeof === REACT_ELEMENT_TYPE;
          }
          var SEPARATOR = ".";
          var SUBSEPARATOR = ":";
          function escape(key) {
            var escapeRegex = /[=:]/g;
            var escaperLookup = {
              "=": "=0",
              ":": "=2"
            };
            var escapedString = key.replace(escapeRegex, function(match) {
              return escaperLookup[match];
            });
            return "$" + escapedString;
          }
          var didWarnAboutMaps = false;
          var userProvidedKeyEscapeRegex = /\/+/g;
          function escapeUserProvidedKey(text5) {
            return text5.replace(userProvidedKeyEscapeRegex, "$&/");
          }
          function getElementKey(element, index5) {
            if (typeof element === "object" && element !== null && element.key != null) {
              {
                checkKeyStringCoercion(element.key);
              }
              return escape("" + element.key);
            }
            return index5.toString(36);
          }
          function mapIntoArray(children, array2, escapedPrefix, nameSoFar, callback) {
            var type = typeof children;
            if (type === "undefined" || type === "boolean") {
              children = null;
            }
            var invokeCallback = false;
            if (children === null) {
              invokeCallback = true;
            } else {
              switch (type) {
                case "string":
                case "number":
                  invokeCallback = true;
                  break;
                case "object":
                  switch (children.$$typeof) {
                    case REACT_ELEMENT_TYPE:
                    case REACT_PORTAL_TYPE:
                      invokeCallback = true;
                  }
              }
            }
            if (invokeCallback) {
              var _child = children;
              var mappedChild = callback(_child);
              var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
              if (isArray6(mappedChild)) {
                var escapedChildKey = "";
                if (childKey != null) {
                  escapedChildKey = escapeUserProvidedKey(childKey) + "/";
                }
                mapIntoArray(mappedChild, array2, escapedChildKey, "", function(c) {
                  return c;
                });
              } else if (mappedChild != null) {
                if (isValidElement(mappedChild)) {
                  {
                    if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                      checkKeyStringCoercion(mappedChild.key);
                    }
                  }
                  mappedChild = cloneAndReplaceKey(
                    mappedChild,
                    escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey
                  );
                }
                array2.push(mappedChild);
              }
              return 1;
            }
            var child;
            var nextName;
            var subtreeCount = 0;
            var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
            if (isArray6(children)) {
              for (var i = 0; i < children.length; i++) {
                child = children[i];
                nextName = nextNamePrefix + getElementKey(child, i);
                subtreeCount += mapIntoArray(child, array2, escapedPrefix, nextName, callback);
              }
            } else {
              var iteratorFn = getIteratorFn(children);
              if (typeof iteratorFn === "function") {
                var iterableChildren = children;
                {
                  if (iteratorFn === iterableChildren.entries) {
                    if (!didWarnAboutMaps) {
                      warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                    }
                    didWarnAboutMaps = true;
                  }
                }
                var iterator2 = iteratorFn.call(iterableChildren);
                var step2;
                var ii = 0;
                while (!(step2 = iterator2.next()).done) {
                  child = step2.value;
                  nextName = nextNamePrefix + getElementKey(child, ii++);
                  subtreeCount += mapIntoArray(child, array2, escapedPrefix, nextName, callback);
                }
              } else if (type === "object") {
                var childrenString = String(children);
                throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). If you meant to render a collection of children, use an array instead.");
              }
            }
            return subtreeCount;
          }
          function mapChildren(children, func11, context) {
            if (children == null) {
              return children;
            }
            var result = [];
            var count2 = 0;
            mapIntoArray(children, result, "", "", function(child) {
              return func11.call(context, child, count2++);
            });
            return result;
          }
          function countChildren(children) {
            var n = 0;
            mapChildren(children, function() {
              n++;
            });
            return n;
          }
          function forEachChildren(children, forEachFunc, forEachContext) {
            mapChildren(children, function() {
              forEachFunc.apply(this, arguments);
            }, forEachContext);
          }
          function toArray5(children) {
            return mapChildren(children, function(child) {
              return child;
            }) || [];
          }
          function onlyChild(children) {
            if (!isValidElement(children)) {
              throw new Error("React.Children.only expected to receive a single React element child.");
            }
            return children;
          }
          function createContext3(defaultValue4) {
            var context = {
              $$typeof: REACT_CONTEXT_TYPE,
              _currentValue: defaultValue4,
              _currentValue2: defaultValue4,
              _threadCount: 0,
              Provider: null,
              Consumer: null,
              _defaultValue: null,
              _globalName: null
            };
            context.Provider = {
              $$typeof: REACT_PROVIDER_TYPE,
              _context: context
            };
            var hasWarnedAboutUsingNestedContextConsumers = false;
            var hasWarnedAboutUsingConsumerProvider = false;
            var hasWarnedAboutDisplayNameOnConsumer = false;
            {
              var Consumer = {
                $$typeof: REACT_CONTEXT_TYPE,
                _context: context
              };
              Object.defineProperties(Consumer, {
                Provider: {
                  get: function() {
                    if (!hasWarnedAboutUsingConsumerProvider) {
                      hasWarnedAboutUsingConsumerProvider = true;
                      error3("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?");
                    }
                    return context.Provider;
                  },
                  set: function(_Provider) {
                    context.Provider = _Provider;
                  }
                },
                _currentValue: {
                  get: function() {
                    return context._currentValue;
                  },
                  set: function(_currentValue) {
                    context._currentValue = _currentValue;
                  }
                },
                _currentValue2: {
                  get: function() {
                    return context._currentValue2;
                  },
                  set: function(_currentValue2) {
                    context._currentValue2 = _currentValue2;
                  }
                },
                _threadCount: {
                  get: function() {
                    return context._threadCount;
                  },
                  set: function(_threadCount) {
                    context._threadCount = _threadCount;
                  }
                },
                Consumer: {
                  get: function() {
                    if (!hasWarnedAboutUsingNestedContextConsumers) {
                      hasWarnedAboutUsingNestedContextConsumers = true;
                      error3("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                    }
                    return context.Consumer;
                  }
                },
                displayName: {
                  get: function() {
                    return context.displayName;
                  },
                  set: function(displayName) {
                    if (!hasWarnedAboutDisplayNameOnConsumer) {
                      warn("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", displayName);
                      hasWarnedAboutDisplayNameOnConsumer = true;
                    }
                  }
                }
              });
              context.Consumer = Consumer;
            }
            {
              context._currentRenderer = null;
              context._currentRenderer2 = null;
            }
            return context;
          }
          var Uninitialized = -1;
          var Pending = 0;
          var Resolved = 1;
          var Rejected = 2;
          function lazyInitializer(payload) {
            if (payload._status === Uninitialized) {
              var ctor = payload._result;
              var thenable = ctor();
              thenable.then(function(moduleObject2) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var resolved = payload;
                  resolved._status = Resolved;
                  resolved._result = moduleObject2;
                }
              }, function(error4) {
                if (payload._status === Pending || payload._status === Uninitialized) {
                  var rejected = payload;
                  rejected._status = Rejected;
                  rejected._result = error4;
                }
              });
              if (payload._status === Uninitialized) {
                var pending = payload;
                pending._status = Pending;
                pending._result = thenable;
              }
            }
            if (payload._status === Resolved) {
              var moduleObject = payload._result;
              {
                if (moduleObject === void 0) {
                  error3("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", moduleObject);
                }
              }
              {
                if (!("default" in moduleObject)) {
                  error3("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", moduleObject);
                }
              }
              return moduleObject.default;
            } else {
              throw payload._result;
            }
          }
          function lazy(ctor) {
            var payload = {
              _status: Uninitialized,
              _result: ctor
            };
            var lazyType = {
              $$typeof: REACT_LAZY_TYPE,
              _payload: payload,
              _init: lazyInitializer
            };
            {
              var defaultProps19;
              var propTypes16;
              Object.defineProperties(lazyType, {
                defaultProps: {
                  configurable: true,
                  get: function() {
                    return defaultProps19;
                  },
                  set: function(newDefaultProps) {
                    error3("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    defaultProps19 = newDefaultProps;
                    Object.defineProperty(lazyType, "defaultProps", {
                      enumerable: true
                    });
                  }
                },
                propTypes: {
                  configurable: true,
                  get: function() {
                    return propTypes16;
                  },
                  set: function(newPropTypes) {
                    error3("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it.");
                    propTypes16 = newPropTypes;
                    Object.defineProperty(lazyType, "propTypes", {
                      enumerable: true
                    });
                  }
                }
              });
            }
            return lazyType;
          }
          function forwardRef4(render2) {
            {
              if (render2 != null && render2.$$typeof === REACT_MEMO_TYPE) {
                error3("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).");
              } else if (typeof render2 !== "function") {
                error3("forwardRef requires a render function but was given %s.", render2 === null ? "null" : typeof render2);
              } else {
                if (render2.length !== 0 && render2.length !== 2) {
                  error3("forwardRef render functions accept exactly two parameters: props and ref. %s", render2.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
                }
              }
              if (render2 != null) {
                if (render2.defaultProps != null || render2.propTypes != null) {
                  error3("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
                }
              }
            }
            var elementType = {
              $$typeof: REACT_FORWARD_REF_TYPE,
              render: render2
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name16) {
                  ownName = name16;
                  if (!render2.name && !render2.displayName) {
                    render2.displayName = name16;
                  }
                }
              });
            }
            return elementType;
          }
          var REACT_MODULE_REFERENCE;
          {
            REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
          }
          function isValidElementType(type) {
            if (typeof type === "string" || typeof type === "function") {
              return true;
            }
            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
              return true;
            }
            if (typeof type === "object" && type !== null) {
              if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {
                return true;
              }
            }
            return false;
          }
          function memo8(type, compare2) {
            {
              if (!isValidElementType(type)) {
                error3("memo: The first argument must be a component. Instead received: %s", type === null ? "null" : typeof type);
              }
            }
            var elementType = {
              $$typeof: REACT_MEMO_TYPE,
              type,
              compare: compare2 === void 0 ? null : compare2
            };
            {
              var ownName;
              Object.defineProperty(elementType, "displayName", {
                enumerable: false,
                configurable: true,
                get: function() {
                  return ownName;
                },
                set: function(name16) {
                  ownName = name16;
                  if (!type.name && !type.displayName) {
                    type.displayName = name16;
                  }
                }
              });
            }
            return elementType;
          }
          function resolveDispatcher() {
            var dispatcher = ReactCurrentDispatcher.current;
            {
              if (dispatcher === null) {
                error3("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
              }
            }
            return dispatcher;
          }
          function useContext7(Context) {
            var dispatcher = resolveDispatcher();
            {
              if (Context._context !== void 0) {
                var realContext = Context._context;
                if (realContext.Consumer === Context) {
                  error3("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?");
                } else if (realContext.Provider === Context) {
                  error3("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
                }
              }
            }
            return dispatcher.useContext(Context);
          }
          function useState13(initialState) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useState(initialState);
          }
          function useReducer(reducer, initialArg, init3) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useReducer(reducer, initialArg, init3);
          }
          function useRef10(initialValue) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useRef(initialValue);
          }
          function useEffect15(create6, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useEffect(create6, deps);
          }
          function useInsertionEffect(create6, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useInsertionEffect(create6, deps);
          }
          function useLayoutEffect3(create6, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useLayoutEffect(create6, deps);
          }
          function useCallback5(callback, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useCallback(callback, deps);
          }
          function useMemo11(create6, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useMemo(create6, deps);
          }
          function useImperativeHandle4(ref, create6, deps) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useImperativeHandle(ref, create6, deps);
          }
          function useDebugValue(value13, formatterFn) {
            {
              var dispatcher = resolveDispatcher();
              return dispatcher.useDebugValue(value13, formatterFn);
            }
          }
          function useTransition() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useTransition();
          }
          function useDeferredValue(value13) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useDeferredValue(value13);
          }
          function useId() {
            var dispatcher = resolveDispatcher();
            return dispatcher.useId();
          }
          function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var dispatcher = resolveDispatcher();
            return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          }
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign2({}, props, {
                    value: prevLog
                  }),
                  info: assign2({}, props, {
                    value: prevInfo
                  }),
                  warn: assign2({}, props, {
                    value: prevWarn
                  }),
                  error: assign2({}, props, {
                    value: prevError
                  }),
                  group: assign2({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign2({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign2({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error3("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name16, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x) {
                  var match = x.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name16;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher$1.current;
              ReactCurrentDispatcher$1.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x) {
                    control = x;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x) {
                  control = x;
                }
                fn();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                  c--;
                }
                for (; s >= 1 && c >= 0; s--, c--) {
                  if (sampleLines[s] !== controlLines[c]) {
                    if (s !== 1 || c !== 1) {
                      do {
                        s--;
                        c--;
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                          var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                          if (fn.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn.displayName);
                          }
                          {
                            if (typeof fn === "function") {
                              componentFrameCache.set(fn, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s >= 1 && c >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher$1.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name16 = fn ? fn.displayName || fn.name : "";
            var syntheticFrame = name16 ? describeBuiltInComponentFrame(name16) : "";
            {
              if (typeof fn === "function") {
                componentFrameCache.set(fn, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn, false);
            }
          }
          function shouldConstruct(Component3) {
            var prototype = Component3.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init3 = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init3(payload), source, ownerFn);
                  } catch (x) {
                  }
                }
              }
            }
            return "";
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes3(typeSpecs, values2, location2, componentName, element) {
            {
              var has = Function.call.bind(hasOwnProperty3);
              for (var typeSpecName in typeSpecs) {
                if (has(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error3("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error3("Failed %s type: %s", location2, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          function setCurrentlyValidatingElement$1(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                setExtraStackFrame(stack);
              } else {
                setExtraStackFrame(null);
              }
            }
          }
          var propTypesMisspellWarningShown;
          {
            propTypesMisspellWarningShown = false;
          }
          function getDeclarationErrorAddendum() {
            if (ReactCurrentOwner.current) {
              var name16 = getComponentNameFromType(ReactCurrentOwner.current.type);
              if (name16) {
                return "\n\nCheck the render method of `" + name16 + "`.";
              }
            }
            return "";
          }
          function getSourceInfoErrorAddendum(source) {
            if (source !== void 0) {
              var fileName = source.fileName.replace(/^.*[\\\/]/, "");
              var lineNumber = source.lineNumber;
              return "\n\nCheck your code at " + fileName + ":" + lineNumber + ".";
            }
            return "";
          }
          function getSourceInfoErrorAddendumForProps(elementProps) {
            if (elementProps !== null && elementProps !== void 0) {
              return getSourceInfoErrorAddendum(elementProps.__source);
            }
            return "";
          }
          var ownerHasKeyUseWarning = {};
          function getCurrentComponentErrorInfo(parentType) {
            var info = getDeclarationErrorAddendum();
            if (!info) {
              var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
              if (parentName) {
                info = "\n\nCheck the top-level render call using <" + parentName + ">.";
              }
            }
            return info;
          }
          function validateExplicitKey(element, parentType) {
            if (!element._store || element._store.validated || element.key != null) {
              return;
            }
            element._store.validated = true;
            var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
            if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
              return;
            }
            ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
            var childOwner = "";
            if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
              childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
            }
            {
              setCurrentlyValidatingElement$1(element);
              error3('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);
              setCurrentlyValidatingElement$1(null);
            }
          }
          function validateChildKeys(node, parentType) {
            if (typeof node !== "object") {
              return;
            }
            if (isArray6(node)) {
              for (var i = 0; i < node.length; i++) {
                var child = node[i];
                if (isValidElement(child)) {
                  validateExplicitKey(child, parentType);
                }
              }
            } else if (isValidElement(node)) {
              if (node._store) {
                node._store.validated = true;
              }
            } else if (node) {
              var iteratorFn = getIteratorFn(node);
              if (typeof iteratorFn === "function") {
                if (iteratorFn !== node.entries) {
                  var iterator2 = iteratorFn.call(node);
                  var step2;
                  while (!(step2 = iterator2.next()).done) {
                    if (isValidElement(step2.value)) {
                      validateExplicitKey(step2.value, parentType);
                    }
                  }
                }
              }
            }
          }
          function validatePropTypes(element) {
            {
              var type = element.type;
              if (type === null || type === void 0 || typeof type === "string") {
                return;
              }
              var propTypes16;
              if (typeof type === "function") {
                propTypes16 = type.propTypes;
              } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
                propTypes16 = type.propTypes;
              } else {
                return;
              }
              if (propTypes16) {
                var name16 = getComponentNameFromType(type);
                checkPropTypes3(propTypes16, element.props, "prop", name16, element);
              } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {
                propTypesMisspellWarningShown = true;
                var _name = getComponentNameFromType(type);
                error3("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
              }
              if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
                error3("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
              }
            }
          }
          function validateFragmentProps(fragment2) {
            {
              var keys3 = Object.keys(fragment2.props);
              for (var i = 0; i < keys3.length; i++) {
                var key = keys3[i];
                if (key !== "children" && key !== "key") {
                  setCurrentlyValidatingElement$1(fragment2);
                  error3("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", key);
                  setCurrentlyValidatingElement$1(null);
                  break;
                }
              }
              if (fragment2.ref !== null) {
                setCurrentlyValidatingElement$1(fragment2);
                error3("Invalid attribute `ref` supplied to `React.Fragment`.");
                setCurrentlyValidatingElement$1(null);
              }
            }
          }
          function createElementWithValidation(type, props, children) {
            var validType = isValidElementType(type);
            if (!validType) {
              var info = "";
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
              var sourceInfo = getSourceInfoErrorAddendumForProps(props);
              if (sourceInfo) {
                info += sourceInfo;
              } else {
                info += getDeclarationErrorAddendum();
              }
              var typeString;
              if (type === null) {
                typeString = "null";
              } else if (isArray6(type)) {
                typeString = "array";
              } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {
                typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
                info = " Did you accidentally export a JSX literal instead of a component?";
              } else {
                typeString = typeof type;
              }
              {
                error3("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", typeString, info);
              }
            }
            var element = createElement21.apply(this, arguments);
            if (element == null) {
              return element;
            }
            if (validType) {
              for (var i = 2; i < arguments.length; i++) {
                validateChildKeys(arguments[i], type);
              }
            }
            if (type === REACT_FRAGMENT_TYPE) {
              validateFragmentProps(element);
            } else {
              validatePropTypes(element);
            }
            return element;
          }
          var didWarnAboutDeprecatedCreateFactory = false;
          function createFactoryWithValidation(type) {
            var validatedFactory = createElementWithValidation.bind(null, type);
            validatedFactory.type = type;
            {
              if (!didWarnAboutDeprecatedCreateFactory) {
                didWarnAboutDeprecatedCreateFactory = true;
                warn("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.");
              }
              Object.defineProperty(validatedFactory, "type", {
                enumerable: false,
                get: function() {
                  warn("Factory.type is deprecated. Access the class directly before passing it to createFactory.");
                  Object.defineProperty(this, "type", {
                    value: type
                  });
                  return type;
                }
              });
            }
            return validatedFactory;
          }
          function cloneElementWithValidation(element, props, children) {
            var newElement = cloneElement3.apply(this, arguments);
            for (var i = 2; i < arguments.length; i++) {
              validateChildKeys(arguments[i], newElement.type);
            }
            validatePropTypes(newElement);
            return newElement;
          }
          function startTransition(scope2, options2) {
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = {};
            var currentTransition = ReactCurrentBatchConfig.transition;
            {
              ReactCurrentBatchConfig.transition._updatedFibers = /* @__PURE__ */ new Set();
            }
            try {
              scope2();
            } finally {
              ReactCurrentBatchConfig.transition = prevTransition;
              {
                if (prevTransition === null && currentTransition._updatedFibers) {
                  var updatedFibersCount = currentTransition._updatedFibers.size;
                  if (updatedFibersCount > 10) {
                    warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                  }
                  currentTransition._updatedFibers.clear();
                }
              }
            }
          }
          var didWarnAboutMessageChannel = false;
          var enqueueTaskImpl = null;
          function enqueueTask(task) {
            if (enqueueTaskImpl === null) {
              try {
                var requireString = ("require" + Math.random()).slice(0, 7);
                var nodeRequire = module && module[requireString];
                enqueueTaskImpl = nodeRequire.call(module, "timers").setImmediate;
              } catch (_err) {
                enqueueTaskImpl = function(callback) {
                  {
                    if (didWarnAboutMessageChannel === false) {
                      didWarnAboutMessageChannel = true;
                      if (typeof MessageChannel === "undefined") {
                        error3("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning.");
                      }
                    }
                  }
                  var channel = new MessageChannel();
                  channel.port1.onmessage = callback;
                  channel.port2.postMessage(void 0);
                };
              }
            }
            return enqueueTaskImpl(task);
          }
          var actScopeDepth = 0;
          var didWarnNoAwaitAct = false;
          function act(callback) {
            {
              var prevActScopeDepth = actScopeDepth;
              actScopeDepth++;
              if (ReactCurrentActQueue.current === null) {
                ReactCurrentActQueue.current = [];
              }
              var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
              var result;
              try {
                ReactCurrentActQueue.isBatchingLegacy = true;
                result = callback();
                if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
                  var queue = ReactCurrentActQueue.current;
                  if (queue !== null) {
                    ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                    flushActQueue(queue);
                  }
                }
              } catch (error4) {
                popActScope(prevActScopeDepth);
                throw error4;
              } finally {
                ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
              }
              if (result !== null && typeof result === "object" && typeof result.then === "function") {
                var thenableResult = result;
                var wasAwaited = false;
                var thenable = {
                  then: function(resolve2, reject) {
                    wasAwaited = true;
                    thenableResult.then(function(returnValue2) {
                      popActScope(prevActScopeDepth);
                      if (actScopeDepth === 0) {
                        recursivelyFlushAsyncActWork(returnValue2, resolve2, reject);
                      } else {
                        resolve2(returnValue2);
                      }
                    }, function(error4) {
                      popActScope(prevActScopeDepth);
                      reject(error4);
                    });
                  }
                };
                {
                  if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                    Promise.resolve().then(function() {
                    }).then(function() {
                      if (!wasAwaited) {
                        didWarnNoAwaitAct = true;
                        error3("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);");
                      }
                    });
                  }
                }
                return thenable;
              } else {
                var returnValue = result;
                popActScope(prevActScopeDepth);
                if (actScopeDepth === 0) {
                  var _queue = ReactCurrentActQueue.current;
                  if (_queue !== null) {
                    flushActQueue(_queue);
                    ReactCurrentActQueue.current = null;
                  }
                  var _thenable = {
                    then: function(resolve2, reject) {
                      if (ReactCurrentActQueue.current === null) {
                        ReactCurrentActQueue.current = [];
                        recursivelyFlushAsyncActWork(returnValue, resolve2, reject);
                      } else {
                        resolve2(returnValue);
                      }
                    }
                  };
                  return _thenable;
                } else {
                  var _thenable2 = {
                    then: function(resolve2, reject) {
                      resolve2(returnValue);
                    }
                  };
                  return _thenable2;
                }
              }
            }
          }
          function popActScope(prevActScopeDepth) {
            {
              if (prevActScopeDepth !== actScopeDepth - 1) {
                error3("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. ");
              }
              actScopeDepth = prevActScopeDepth;
            }
          }
          function recursivelyFlushAsyncActWork(returnValue, resolve2, reject) {
            {
              var queue = ReactCurrentActQueue.current;
              if (queue !== null) {
                try {
                  flushActQueue(queue);
                  enqueueTask(function() {
                    if (queue.length === 0) {
                      ReactCurrentActQueue.current = null;
                      resolve2(returnValue);
                    } else {
                      recursivelyFlushAsyncActWork(returnValue, resolve2, reject);
                    }
                  });
                } catch (error4) {
                  reject(error4);
                }
              } else {
                resolve2(returnValue);
              }
            }
          }
          var isFlushing = false;
          function flushActQueue(queue) {
            {
              if (!isFlushing) {
                isFlushing = true;
                var i = 0;
                try {
                  for (; i < queue.length; i++) {
                    var callback = queue[i];
                    do {
                      callback = callback(true);
                    } while (callback !== null);
                  }
                  queue.length = 0;
                } catch (error4) {
                  queue = queue.slice(i + 1);
                  throw error4;
                } finally {
                  isFlushing = false;
                }
              }
            }
          }
          var createElement$1 = createElementWithValidation;
          var cloneElement$1 = cloneElementWithValidation;
          var createFactory = createFactoryWithValidation;
          var Children3 = {
            map: mapChildren,
            forEach: forEachChildren,
            count: countChildren,
            toArray: toArray5,
            only: onlyChild
          };
          exports.Children = Children3;
          exports.Component = Component2;
          exports.Fragment = REACT_FRAGMENT_TYPE;
          exports.Profiler = REACT_PROFILER_TYPE;
          exports.PureComponent = PureComponent2;
          exports.StrictMode = REACT_STRICT_MODE_TYPE;
          exports.Suspense = REACT_SUSPENSE_TYPE;
          exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
          exports.cloneElement = cloneElement$1;
          exports.createContext = createContext3;
          exports.createElement = createElement$1;
          exports.createFactory = createFactory;
          exports.createRef = createRef2;
          exports.forwardRef = forwardRef4;
          exports.isValidElement = isValidElement;
          exports.lazy = lazy;
          exports.memo = memo8;
          exports.startTransition = startTransition;
          exports.unstable_act = act;
          exports.useCallback = useCallback5;
          exports.useContext = useContext7;
          exports.useDebugValue = useDebugValue;
          exports.useDeferredValue = useDeferredValue;
          exports.useEffect = useEffect15;
          exports.useId = useId;
          exports.useImperativeHandle = useImperativeHandle4;
          exports.useInsertionEffect = useInsertionEffect;
          exports.useLayoutEffect = useLayoutEffect3;
          exports.useMemo = useMemo11;
          exports.useReducer = useReducer;
          exports.useRef = useRef10;
          exports.useState = useState13;
          exports.useSyncExternalStore = useSyncExternalStore;
          exports.useTransition = useTransition;
          exports.version = ReactVersion;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_development();
      }
    }
  });

  // node_modules/react-is/cjs/react-is.development.js
  var require_react_is_development = __commonJS({
    "node_modules/react-is/cjs/react-is.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var hasSymbol = typeof Symbol === "function" && Symbol.for;
          var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
          var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
          var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
          var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
          var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
          var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
          var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
          var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
          var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
          var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
          var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
          var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
          var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
          var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
          var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
          var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
          var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
          var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
          function isValidElementType(type) {
            return typeof type === "string" || typeof type === "function" || type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
          }
          function typeOf2(object12) {
            if (typeof object12 === "object" && object12 !== null) {
              var $$typeof = object12.$$typeof;
              switch ($$typeof) {
                case REACT_ELEMENT_TYPE:
                  var type = object12.type;
                  switch (type) {
                    case REACT_ASYNC_MODE_TYPE:
                    case REACT_CONCURRENT_MODE_TYPE:
                    case REACT_FRAGMENT_TYPE:
                    case REACT_PROFILER_TYPE:
                    case REACT_STRICT_MODE_TYPE:
                    case REACT_SUSPENSE_TYPE:
                      return type;
                    default:
                      var $$typeofType = type && type.$$typeof;
                      switch ($$typeofType) {
                        case REACT_CONTEXT_TYPE:
                        case REACT_FORWARD_REF_TYPE:
                        case REACT_LAZY_TYPE:
                        case REACT_MEMO_TYPE:
                        case REACT_PROVIDER_TYPE:
                          return $$typeofType;
                        default:
                          return $$typeof;
                      }
                  }
                case REACT_PORTAL_TYPE:
                  return $$typeof;
              }
            }
            return void 0;
          }
          var AsyncMode = REACT_ASYNC_MODE_TYPE;
          var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
          var ContextConsumer = REACT_CONTEXT_TYPE;
          var ContextProvider = REACT_PROVIDER_TYPE;
          var Element2 = REACT_ELEMENT_TYPE;
          var ForwardRef = REACT_FORWARD_REF_TYPE;
          var Fragment2 = REACT_FRAGMENT_TYPE;
          var Lazy = REACT_LAZY_TYPE;
          var Memo = REACT_MEMO_TYPE;
          var Portal = REACT_PORTAL_TYPE;
          var Profiler = REACT_PROFILER_TYPE;
          var StrictMode = REACT_STRICT_MODE_TYPE;
          var Suspense = REACT_SUSPENSE_TYPE;
          var hasWarnedAboutDeprecatedIsAsyncMode = false;
          function isAsyncMode(object12) {
            {
              if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                hasWarnedAboutDeprecatedIsAsyncMode = true;
                console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
              }
            }
            return isConcurrentMode(object12) || typeOf2(object12) === REACT_ASYNC_MODE_TYPE;
          }
          function isConcurrentMode(object12) {
            return typeOf2(object12) === REACT_CONCURRENT_MODE_TYPE;
          }
          function isContextConsumer(object12) {
            return typeOf2(object12) === REACT_CONTEXT_TYPE;
          }
          function isContextProvider(object12) {
            return typeOf2(object12) === REACT_PROVIDER_TYPE;
          }
          function isElement(object12) {
            return typeof object12 === "object" && object12 !== null && object12.$$typeof === REACT_ELEMENT_TYPE;
          }
          function isForwardRef(object12) {
            return typeOf2(object12) === REACT_FORWARD_REF_TYPE;
          }
          function isFragment(object12) {
            return typeOf2(object12) === REACT_FRAGMENT_TYPE;
          }
          function isLazy(object12) {
            return typeOf2(object12) === REACT_LAZY_TYPE;
          }
          function isMemo(object12) {
            return typeOf2(object12) === REACT_MEMO_TYPE;
          }
          function isPortal(object12) {
            return typeOf2(object12) === REACT_PORTAL_TYPE;
          }
          function isProfiler(object12) {
            return typeOf2(object12) === REACT_PROFILER_TYPE;
          }
          function isStrictMode(object12) {
            return typeOf2(object12) === REACT_STRICT_MODE_TYPE;
          }
          function isSuspense(object12) {
            return typeOf2(object12) === REACT_SUSPENSE_TYPE;
          }
          exports.AsyncMode = AsyncMode;
          exports.ConcurrentMode = ConcurrentMode;
          exports.ContextConsumer = ContextConsumer;
          exports.ContextProvider = ContextProvider;
          exports.Element = Element2;
          exports.ForwardRef = ForwardRef;
          exports.Fragment = Fragment2;
          exports.Lazy = Lazy;
          exports.Memo = Memo;
          exports.Portal = Portal;
          exports.Profiler = Profiler;
          exports.StrictMode = StrictMode;
          exports.Suspense = Suspense;
          exports.isAsyncMode = isAsyncMode;
          exports.isConcurrentMode = isConcurrentMode;
          exports.isContextConsumer = isContextConsumer;
          exports.isContextProvider = isContextProvider;
          exports.isElement = isElement;
          exports.isForwardRef = isForwardRef;
          exports.isFragment = isFragment;
          exports.isLazy = isLazy;
          exports.isMemo = isMemo;
          exports.isPortal = isPortal;
          exports.isProfiler = isProfiler;
          exports.isStrictMode = isStrictMode;
          exports.isSuspense = isSuspense;
          exports.isValidElementType = isValidElementType;
          exports.typeOf = typeOf2;
        })();
      }
    }
  });

  // node_modules/react-is/index.js
  var require_react_is = __commonJS({
    "node_modules/react-is/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_react_is_development();
      }
    }
  });

  // node_modules/object-assign/index.js
  var require_object_assign = __commonJS({
    "node_modules/object-assign/index.js"(exports, module) {
      "use strict";
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var hasOwnProperty3 = Object.prototype.hasOwnProperty;
      var propIsEnumerable = Object.prototype.propertyIsEnumerable;
      function toObject2(val) {
        if (val === null || val === void 0) {
          throw new TypeError("Object.assign cannot be called with null or undefined");
        }
        return Object(val);
      }
      function shouldUseNative() {
        try {
          if (!Object.assign) {
            return false;
          }
          var test1 = new String("abc");
          test1[5] = "de";
          if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
          }
          var test2 = {};
          for (var i = 0; i < 10; i++) {
            test2["_" + String.fromCharCode(i)] = i;
          }
          var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
          });
          if (order2.join("") !== "0123456789") {
            return false;
          }
          var test3 = {};
          "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
          });
          if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
          }
          return true;
        } catch (err) {
          return false;
        }
      }
      module.exports = shouldUseNative() ? Object.assign : function(target5, source) {
        var from3;
        var to = toObject2(target5);
        var symbols;
        for (var s = 1; s < arguments.length; s++) {
          from3 = Object(arguments[s]);
          for (var key in from3) {
            if (hasOwnProperty3.call(from3, key)) {
              to[key] = from3[key];
            }
          }
          if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from3);
            for (var i = 0; i < symbols.length; i++) {
              if (propIsEnumerable.call(from3, symbols[i])) {
                to[symbols[i]] = from3[symbols[i]];
              }
            }
          }
        }
        return to;
      };
    }
  });

  // node_modules/prop-types/lib/ReactPropTypesSecret.js
  var require_ReactPropTypesSecret = __commonJS({
    "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
      "use strict";
      var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
      module.exports = ReactPropTypesSecret;
    }
  });

  // node_modules/prop-types/lib/has.js
  var require_has = __commonJS({
    "node_modules/prop-types/lib/has.js"(exports, module) {
      module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
    }
  });

  // node_modules/prop-types/checkPropTypes.js
  var require_checkPropTypes = __commonJS({
    "node_modules/prop-types/checkPropTypes.js"(exports, module) {
      "use strict";
      var printWarning = function() {
      };
      if (true) {
        ReactPropTypesSecret = require_ReactPropTypesSecret();
        loggedTypeFailures = {};
        has = require_has();
        printWarning = function(text5) {
          var message2 = "Warning: " + text5;
          if (typeof console !== "undefined") {
            console.error(message2);
          }
          try {
            throw new Error(message2);
          } catch (x) {
          }
        };
      }
      var ReactPropTypesSecret;
      var loggedTypeFailures;
      var has;
      function checkPropTypes3(typeSpecs, values2, location2, componentName, getStack) {
        if (true) {
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error3;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error(
                    (componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                  );
                  err.name = "Invariant Violation";
                  throw err;
                }
                error3 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location2, null, ReactPropTypesSecret);
              } catch (ex) {
                error3 = ex;
              }
              if (error3 && !(error3 instanceof Error)) {
                printWarning(
                  (componentName || "React class") + ": type specification of " + location2 + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error3 + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
                );
              }
              if (error3 instanceof Error && !(error3.message in loggedTypeFailures)) {
                loggedTypeFailures[error3.message] = true;
                var stack = getStack ? getStack() : "";
                printWarning(
                  "Failed " + location2 + " type: " + error3.message + (stack != null ? stack : "")
                );
              }
            }
          }
        }
      }
      checkPropTypes3.resetWarningCache = function() {
        if (true) {
          loggedTypeFailures = {};
        }
      };
      module.exports = checkPropTypes3;
    }
  });

  // node_modules/prop-types/factoryWithTypeCheckers.js
  var require_factoryWithTypeCheckers = __commonJS({
    "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
      "use strict";
      var ReactIs = require_react_is();
      var assign2 = require_object_assign();
      var ReactPropTypesSecret = require_ReactPropTypesSecret();
      var has = require_has();
      var checkPropTypes3 = require_checkPropTypes();
      var printWarning = function() {
      };
      if (true) {
        printWarning = function(text5) {
          var message2 = "Warning: " + text5;
          if (typeof console !== "undefined") {
            console.error(message2);
          }
          try {
            throw new Error(message2);
          } catch (x) {
          }
        };
      }
      function emptyFunctionThatReturnsNull() {
        return null;
      }
      module.exports = function(isValidElement, throwOnDirectAccess) {
        var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
        var FAUX_ITERATOR_SYMBOL = "@@iterator";
        function getIteratorFn(maybeIterable) {
          var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
          if (typeof iteratorFn === "function") {
            return iteratorFn;
          }
        }
        var ANONYMOUS = "<<anonymous>>";
        var ReactPropTypes = {
          array: createPrimitiveTypeChecker("array"),
          bigint: createPrimitiveTypeChecker("bigint"),
          bool: createPrimitiveTypeChecker("boolean"),
          func: createPrimitiveTypeChecker("function"),
          number: createPrimitiveTypeChecker("number"),
          object: createPrimitiveTypeChecker("object"),
          string: createPrimitiveTypeChecker("string"),
          symbol: createPrimitiveTypeChecker("symbol"),
          any: createAnyTypeChecker(),
          arrayOf: createArrayOfTypeChecker,
          element: createElementTypeChecker(),
          elementType: createElementTypeTypeChecker(),
          instanceOf: createInstanceTypeChecker,
          node: createNodeChecker(),
          objectOf: createObjectOfTypeChecker,
          oneOf: createEnumTypeChecker,
          oneOfType: createUnionTypeChecker,
          shape: createShapeTypeChecker,
          exact: createStrictShapeTypeChecker
        };
        function is(x, y) {
          if (x === y) {
            return x !== 0 || 1 / x === 1 / y;
          } else {
            return x !== x && y !== y;
          }
        }
        function PropTypeError(message2, data) {
          this.message = message2;
          this.data = data && typeof data === "object" ? data : {};
          this.stack = "";
        }
        PropTypeError.prototype = Error.prototype;
        function createChainableTypeChecker(validate) {
          if (true) {
            var manualPropTypeCallCache = {};
            var manualPropTypeWarningCount = 0;
          }
          function checkType(isRequired, props, propName, componentName, location2, propFullName, secret) {
            componentName = componentName || ANONYMOUS;
            propFullName = propFullName || propName;
            if (secret !== ReactPropTypesSecret) {
              if (throwOnDirectAccess) {
                var err = new Error(
                  "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
                );
                err.name = "Invariant Violation";
                throw err;
              } else if (typeof console !== "undefined") {
                var cacheKey = componentName + ":" + propName;
                if (!manualPropTypeCallCache[cacheKey] && manualPropTypeWarningCount < 3) {
                  printWarning(
                    "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                  );
                  manualPropTypeCallCache[cacheKey] = true;
                  manualPropTypeWarningCount++;
                }
              }
            }
            if (props[propName] == null) {
              if (isRequired) {
                if (props[propName] === null) {
                  return new PropTypeError("The " + location2 + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
                }
                return new PropTypeError("The " + location2 + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
              }
              return null;
            } else {
              return validate(props, propName, componentName, location2, propFullName);
            }
          }
          var chainedCheckType = checkType.bind(null, false);
          chainedCheckType.isRequired = checkType.bind(null, true);
          return chainedCheckType;
        }
        function createPrimitiveTypeChecker(expectedType) {
          function validate(props, propName, componentName, location2, propFullName, secret) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== expectedType) {
              var preciseType = getPreciseType(propValue);
              return new PropTypeError(
                "Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
                { expectedType }
              );
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createAnyTypeChecker() {
          return createChainableTypeChecker(emptyFunctionThatReturnsNull);
        }
        function createArrayOfTypeChecker(typeChecker) {
          function validate(props, propName, componentName, location2, propFullName) {
            if (typeof typeChecker !== "function") {
              return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
            }
            var propValue = props[propName];
            if (!Array.isArray(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
            }
            for (var i = 0; i < propValue.length; i++) {
              var error3 = typeChecker(propValue, i, componentName, location2, propFullName + "[" + i + "]", ReactPropTypesSecret);
              if (error3 instanceof Error) {
                return error3;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createElementTypeChecker() {
          function validate(props, propName, componentName, location2, propFullName) {
            var propValue = props[propName];
            if (!isValidElement(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createElementTypeTypeChecker() {
          function validate(props, propName, componentName, location2, propFullName) {
            var propValue = props[propName];
            if (!ReactIs.isValidElementType(propValue)) {
              var propType = getPropType(propValue);
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createInstanceTypeChecker(expectedClass) {
          function validate(props, propName, componentName, location2, propFullName) {
            if (!(props[propName] instanceof expectedClass)) {
              var expectedClassName = expectedClass.name || ANONYMOUS;
              var actualClassName = getClassName(props[propName]);
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createEnumTypeChecker(expectedValues) {
          if (!Array.isArray(expectedValues)) {
            if (true) {
              if (arguments.length > 1) {
                printWarning(
                  "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
                );
              } else {
                printWarning("Invalid argument supplied to oneOf, expected an array.");
              }
            }
            return emptyFunctionThatReturnsNull;
          }
          function validate(props, propName, componentName, location2, propFullName) {
            var propValue = props[propName];
            for (var i = 0; i < expectedValues.length; i++) {
              if (is(propValue, expectedValues[i])) {
                return null;
              }
            }
            var valuesString = JSON.stringify(expectedValues, function replacer(key, value13) {
              var type = getPreciseType(value13);
              if (type === "symbol") {
                return String(value13);
              }
              return value13;
            });
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
          }
          return createChainableTypeChecker(validate);
        }
        function createObjectOfTypeChecker(typeChecker) {
          function validate(props, propName, componentName, location2, propFullName) {
            if (typeof typeChecker !== "function") {
              return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
            }
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
            }
            for (var key in propValue) {
              if (has(propValue, key)) {
                var error3 = typeChecker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
                if (error3 instanceof Error) {
                  return error3;
                }
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createUnionTypeChecker(arrayOfTypeCheckers) {
          if (!Array.isArray(arrayOfTypeCheckers)) {
            true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
            return emptyFunctionThatReturnsNull;
          }
          for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
            var checker = arrayOfTypeCheckers[i];
            if (typeof checker !== "function") {
              printWarning(
                "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
              );
              return emptyFunctionThatReturnsNull;
            }
          }
          function validate(props, propName, componentName, location2, propFullName) {
            var expectedTypes = [];
            for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
              var checker2 = arrayOfTypeCheckers[i2];
              var checkerResult = checker2(props, propName, componentName, location2, propFullName, ReactPropTypesSecret);
              if (checkerResult == null) {
                return null;
              }
              if (checkerResult.data && has(checkerResult.data, "expectedType")) {
                expectedTypes.push(checkerResult.data.expectedType);
              }
            }
            var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
            return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
          }
          return createChainableTypeChecker(validate);
        }
        function createNodeChecker() {
          function validate(props, propName, componentName, location2, propFullName) {
            if (!isNode(props[propName])) {
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function invalidValidatorError(componentName, location2, propFullName, key, type) {
          return new PropTypeError(
            (componentName || "React class") + ": " + location2 + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
          );
        }
        function createShapeTypeChecker(shapeTypes) {
          function validate(props, propName, componentName, location2, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            for (var key in shapeTypes) {
              var checker = shapeTypes[key];
              if (typeof checker !== "function") {
                return invalidValidatorError(componentName, location2, propFullName, key, getPreciseType(checker));
              }
              var error3 = checker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
              if (error3) {
                return error3;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function createStrictShapeTypeChecker(shapeTypes) {
          function validate(props, propName, componentName, location2, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== "object") {
              return new PropTypeError("Invalid " + location2 + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
            }
            var allKeys = assign2({}, props[propName], shapeTypes);
            for (var key in allKeys) {
              var checker = shapeTypes[key];
              if (has(shapeTypes, key) && typeof checker !== "function") {
                return invalidValidatorError(componentName, location2, propFullName, key, getPreciseType(checker));
              }
              if (!checker) {
                return new PropTypeError(
                  "Invalid " + location2 + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
                );
              }
              var error3 = checker(propValue, key, componentName, location2, propFullName + "." + key, ReactPropTypesSecret);
              if (error3) {
                return error3;
              }
            }
            return null;
          }
          return createChainableTypeChecker(validate);
        }
        function isNode(propValue) {
          switch (typeof propValue) {
            case "number":
            case "string":
            case "undefined":
              return true;
            case "boolean":
              return !propValue;
            case "object":
              if (Array.isArray(propValue)) {
                return propValue.every(isNode);
              }
              if (propValue === null || isValidElement(propValue)) {
                return true;
              }
              var iteratorFn = getIteratorFn(propValue);
              if (iteratorFn) {
                var iterator2 = iteratorFn.call(propValue);
                var step2;
                if (iteratorFn !== propValue.entries) {
                  while (!(step2 = iterator2.next()).done) {
                    if (!isNode(step2.value)) {
                      return false;
                    }
                  }
                } else {
                  while (!(step2 = iterator2.next()).done) {
                    var entry = step2.value;
                    if (entry) {
                      if (!isNode(entry[1])) {
                        return false;
                      }
                    }
                  }
                }
              } else {
                return false;
              }
              return true;
            default:
              return false;
          }
        }
        function isSymbol(propType, propValue) {
          if (propType === "symbol") {
            return true;
          }
          if (!propValue) {
            return false;
          }
          if (propValue["@@toStringTag"] === "Symbol") {
            return true;
          }
          if (typeof Symbol === "function" && propValue instanceof Symbol) {
            return true;
          }
          return false;
        }
        function getPropType(propValue) {
          var propType = typeof propValue;
          if (Array.isArray(propValue)) {
            return "array";
          }
          if (propValue instanceof RegExp) {
            return "object";
          }
          if (isSymbol(propType, propValue)) {
            return "symbol";
          }
          return propType;
        }
        function getPreciseType(propValue) {
          if (typeof propValue === "undefined" || propValue === null) {
            return "" + propValue;
          }
          var propType = getPropType(propValue);
          if (propType === "object") {
            if (propValue instanceof Date) {
              return "date";
            } else if (propValue instanceof RegExp) {
              return "regexp";
            }
          }
          return propType;
        }
        function getPostfixForTypeWarning(value13) {
          var type = getPreciseType(value13);
          switch (type) {
            case "array":
            case "object":
              return "an " + type;
            case "boolean":
            case "date":
            case "regexp":
              return "a " + type;
            default:
              return type;
          }
        }
        function getClassName(propValue) {
          if (!propValue.constructor || !propValue.constructor.name) {
            return ANONYMOUS;
          }
          return propValue.constructor.name;
        }
        ReactPropTypes.checkPropTypes = checkPropTypes3;
        ReactPropTypes.resetWarningCache = checkPropTypes3.resetWarningCache;
        ReactPropTypes.PropTypes = ReactPropTypes;
        return ReactPropTypes;
      };
    }
  });

  // node_modules/prop-types/index.js
  var require_prop_types = __commonJS({
    "node_modules/prop-types/index.js"(exports, module) {
      if (true) {
        ReactIs = require_react_is();
        throwOnDirectAccess = true;
        module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
      } else {
        module.exports = null();
      }
      var ReactIs;
      var throwOnDirectAccess;
    }
  });

  // node_modules/mapbox-gl/dist/mapbox-gl.js
  var require_mapbox_gl = __commonJS({
    "node_modules/mapbox-gl/dist/mapbox-gl.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.mapboxgl = factory());
      })(exports, function() {
        "use strict";
        var shared, worker, mapboxgl;
        function define2(_, chunk) {
          if (!shared) {
            shared = chunk;
          } else if (!worker) {
            worker = chunk;
          } else {
            var workerBundleString = "var sharedChunk = {}; (" + shared + ")(sharedChunk); (" + worker + ")(sharedChunk);";
            var sharedChunk = {};
            shared(sharedChunk);
            mapboxgl = chunk(sharedChunk);
            if (typeof window !== "undefined") {
              mapboxgl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
            }
          }
        }
        define2(["exports"], function(t) {
          "use strict";
          function e(t2, e2) {
            return t2(e2 = { exports: {} }, e2.exports), e2.exports;
          }
          var r = n;
          function n(t2, e2, r2, n2) {
            this.cx = 3 * t2, this.bx = 3 * (r2 - t2) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e2, this.by = 3 * (n2 - e2) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t2, this.p1y = n2, this.p2x = r2, this.p2y = n2;
          }
          n.prototype.sampleCurveX = function(t2) {
            return ((this.ax * t2 + this.bx) * t2 + this.cx) * t2;
          }, n.prototype.sampleCurveY = function(t2) {
            return ((this.ay * t2 + this.by) * t2 + this.cy) * t2;
          }, n.prototype.sampleCurveDerivativeX = function(t2) {
            return (3 * this.ax * t2 + 2 * this.bx) * t2 + this.cx;
          }, n.prototype.solveCurveX = function(t2, e2) {
            var r2, n2, i2, a2, o2;
            for (void 0 === e2 && (e2 = 1e-6), i2 = t2, o2 = 0; o2 < 8; o2++) {
              if (a2 = this.sampleCurveX(i2) - t2, Math.abs(a2) < e2)
                return i2;
              var s2 = this.sampleCurveDerivativeX(i2);
              if (Math.abs(s2) < 1e-6)
                break;
              i2 -= a2 / s2;
            }
            if ((i2 = t2) < (r2 = 0))
              return r2;
            if (i2 > (n2 = 1))
              return n2;
            for (; r2 < n2; ) {
              if (a2 = this.sampleCurveX(i2), Math.abs(a2 - t2) < e2)
                return i2;
              t2 > a2 ? r2 = i2 : n2 = i2, i2 = 0.5 * (n2 - r2) + r2;
            }
            return i2;
          }, n.prototype.solve = function(t2, e2) {
            return this.sampleCurveY(this.solveCurveX(t2, e2));
          };
          var i = a;
          function a(t2, e2) {
            this.x = t2, this.y = e2;
          }
          a.prototype = { clone: function() {
            return new a(this.x, this.y);
          }, add: function(t2) {
            return this.clone()._add(t2);
          }, sub: function(t2) {
            return this.clone()._sub(t2);
          }, multByPoint: function(t2) {
            return this.clone()._multByPoint(t2);
          }, divByPoint: function(t2) {
            return this.clone()._divByPoint(t2);
          }, mult: function(t2) {
            return this.clone()._mult(t2);
          }, div: function(t2) {
            return this.clone()._div(t2);
          }, rotate: function(t2) {
            return this.clone()._rotate(t2);
          }, rotateAround: function(t2, e2) {
            return this.clone()._rotateAround(t2, e2);
          }, matMult: function(t2) {
            return this.clone()._matMult(t2);
          }, unit: function() {
            return this.clone()._unit();
          }, perp: function() {
            return this.clone()._perp();
          }, round: function() {
            return this.clone()._round();
          }, mag: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          }, equals: function(t2) {
            return this.x === t2.x && this.y === t2.y;
          }, dist: function(t2) {
            return Math.sqrt(this.distSqr(t2));
          }, distSqr: function(t2) {
            var e2 = t2.x - this.x, r2 = t2.y - this.y;
            return e2 * e2 + r2 * r2;
          }, angle: function() {
            return Math.atan2(this.y, this.x);
          }, angleTo: function(t2) {
            return Math.atan2(this.y - t2.y, this.x - t2.x);
          }, angleWith: function(t2) {
            return this.angleWithSep(t2.x, t2.y);
          }, angleWithSep: function(t2, e2) {
            return Math.atan2(this.x * e2 - this.y * t2, this.x * t2 + this.y * e2);
          }, _matMult: function(t2) {
            var e2 = t2[2] * this.x + t2[3] * this.y;
            return this.x = t2[0] * this.x + t2[1] * this.y, this.y = e2, this;
          }, _add: function(t2) {
            return this.x += t2.x, this.y += t2.y, this;
          }, _sub: function(t2) {
            return this.x -= t2.x, this.y -= t2.y, this;
          }, _mult: function(t2) {
            return this.x *= t2, this.y *= t2, this;
          }, _div: function(t2) {
            return this.x /= t2, this.y /= t2, this;
          }, _multByPoint: function(t2) {
            return this.x *= t2.x, this.y *= t2.y, this;
          }, _divByPoint: function(t2) {
            return this.x /= t2.x, this.y /= t2.y, this;
          }, _unit: function() {
            return this._div(this.mag()), this;
          }, _perp: function() {
            var t2 = this.y;
            return this.y = this.x, this.x = -t2, this;
          }, _rotate: function(t2) {
            var e2 = Math.cos(t2), r2 = Math.sin(t2), n2 = r2 * this.x + e2 * this.y;
            return this.x = e2 * this.x - r2 * this.y, this.y = n2, this;
          }, _rotateAround: function(t2, e2) {
            var r2 = Math.cos(t2), n2 = Math.sin(t2), i2 = e2.y + n2 * (this.x - e2.x) + r2 * (this.y - e2.y);
            return this.x = e2.x + r2 * (this.x - e2.x) - n2 * (this.y - e2.y), this.y = i2, this;
          }, _round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
          } }, a.convert = function(t2) {
            return t2 instanceof a ? t2 : Array.isArray(t2) ? new a(t2[0], t2[1]) : t2;
          };
          var o = "undefined" != typeof self ? self : {}, s = Math.pow(2, 53) - 1;
          function u(t2, e2, n2, i2) {
            var a2 = new r(t2, e2, n2, i2);
            return function(t3) {
              return a2.solve(t3);
            };
          }
          var l = u(0.25, 0.1, 0.25, 1);
          function p(t2, e2, r2) {
            return Math.min(r2, Math.max(e2, t2));
          }
          function c(t2, e2, r2) {
            var n2 = r2 - e2, i2 = ((t2 - e2) % n2 + n2) % n2 + e2;
            return i2 === e2 ? r2 : i2;
          }
          function h(t2) {
            for (var e2 = [], r2 = arguments.length - 1; r2-- > 0; )
              e2[r2] = arguments[r2 + 1];
            for (var n2 = 0, i2 = e2; n2 < i2.length; n2 += 1) {
              var a2 = i2[n2];
              for (var o2 in a2)
                t2[o2] = a2[o2];
            }
            return t2;
          }
          var f = 1;
          function y() {
            return f++;
          }
          function d() {
            return function t2(e2) {
              return e2 ? (e2 ^ 16 * Math.random() >> e2 / 4).toString(16) : ([1e7] + -[1e3] + -4e3 + -8e3 + -1e11).replace(/[018]/g, t2);
            }();
          }
          function m(t2) {
            return !!t2 && /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(t2);
          }
          function v(t2, e2) {
            t2.forEach(function(t3) {
              e2[t3] && (e2[t3] = e2[t3].bind(e2));
            });
          }
          function g(t2, e2) {
            return -1 !== t2.indexOf(e2, t2.length - e2.length);
          }
          function x(t2, e2, r2) {
            var n2 = {};
            for (var i2 in t2)
              n2[i2] = e2.call(r2 || this, t2[i2], i2, t2);
            return n2;
          }
          function b(t2, e2, r2) {
            var n2 = {};
            for (var i2 in t2)
              e2.call(r2 || this, t2[i2], i2, t2) && (n2[i2] = t2[i2]);
            return n2;
          }
          function w(t2) {
            return Array.isArray(t2) ? t2.map(w) : "object" == typeof t2 && t2 ? x(t2, w) : t2;
          }
          var _ = {};
          function A(t2) {
            _[t2] || ("undefined" != typeof console && console.warn(t2), _[t2] = true);
          }
          function S(t2, e2, r2) {
            return (r2.y - t2.y) * (e2.x - t2.x) > (e2.y - t2.y) * (r2.x - t2.x);
          }
          function k(t2) {
            for (var e2 = 0, r2 = 0, n2 = t2.length, i2 = n2 - 1, a2 = void 0, o2 = void 0; r2 < n2; i2 = r2++)
              e2 += ((o2 = t2[i2]).x - (a2 = t2[r2]).x) * (a2.y + o2.y);
            return e2;
          }
          function I() {
            return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
          }
          function z(t2) {
            var e2 = {};
            if (t2.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, function(t3, r3, n2, i2) {
              var a2 = n2 || i2;
              return e2[r3] = !a2 || a2.toLowerCase(), "";
            }), e2["max-age"]) {
              var r2 = parseInt(e2["max-age"], 10);
              isNaN(r2) ? delete e2["max-age"] : e2["max-age"] = r2;
            }
            return e2;
          }
          var C = null;
          function E(t2) {
            if (null == C) {
              var e2 = t2.navigator ? t2.navigator.userAgent : null;
              C = !!t2.safari || !(!e2 || !(/\b(iPad|iPhone|iPod)\b/.test(e2) || e2.match("Safari") && !e2.match("Chrome")));
            }
            return C;
          }
          function P(t2) {
            try {
              var e2 = o[t2];
              return e2.setItem("_mapbox_test_", 1), e2.removeItem("_mapbox_test_"), true;
            } catch (t3) {
              return false;
            }
          }
          var M, B, T, V, F = o.performance && o.performance.now ? o.performance.now.bind(o.performance) : Date.now.bind(Date), D = o.requestAnimationFrame || o.mozRequestAnimationFrame || o.webkitRequestAnimationFrame || o.msRequestAnimationFrame, L = o.cancelAnimationFrame || o.mozCancelAnimationFrame || o.webkitCancelAnimationFrame || o.msCancelAnimationFrame, O = { now: F, frame: function(t2) {
            var e2 = D(t2);
            return { cancel: function() {
              return L(e2);
            } };
          }, getImageData: function(t2, e2) {
            void 0 === e2 && (e2 = 0);
            var r2 = o.document.createElement("canvas"), n2 = r2.getContext("2d");
            if (!n2)
              throw new Error("failed to create canvas 2d context");
            return r2.width = t2.width, r2.height = t2.height, n2.drawImage(t2, 0, 0, t2.width, t2.height), n2.getImageData(-e2, -e2, t2.width + 2 * e2, t2.height + 2 * e2);
          }, resolveURL: function(t2) {
            return M || (M = o.document.createElement("a")), M.href = t2, M.href;
          }, hardwareConcurrency: o.navigator && o.navigator.hardwareConcurrency || 4, get devicePixelRatio() {
            return o.devicePixelRatio;
          }, get prefersReducedMotion() {
            return !!o.matchMedia && (null == B && (B = o.matchMedia("(prefers-reduced-motion: reduce)")), B.matches);
          } }, R = { API_URL: "https://api.mapbox.com", get EVENTS_URL() {
            return this.API_URL ? 0 === this.API_URL.indexOf("https://api.mapbox.cn") ? "https://events.mapbox.cn/events/v2" : 0 === this.API_URL.indexOf("https://api.mapbox.com") ? "https://events.mapbox.com/events/v2" : null : null;
          }, FEEDBACK_URL: "https://apps.mapbox.com/feedback", REQUIRE_ACCESS_TOKEN: true, ACCESS_TOKEN: null, MAX_PARALLEL_IMAGE_REQUESTS: 16 }, U = { supported: false, testSupport: function(t2) {
            !j && V && (q ? N(t2) : T = t2);
          } }, j = false, q = false;
          function N(t2) {
            var e2 = t2.createTexture();
            t2.bindTexture(t2.TEXTURE_2D, e2);
            try {
              if (t2.texImage2D(t2.TEXTURE_2D, 0, t2.RGBA, t2.RGBA, t2.UNSIGNED_BYTE, V), t2.isContextLost())
                return;
              U.supported = true;
            } catch (t3) {
            }
            t2.deleteTexture(e2), j = true;
          }
          o.document && ((V = o.document.createElement("img")).onload = function() {
            T && N(T), T = null, q = true;
          }, V.onerror = function() {
            j = true, T = null;
          }, V.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA=");
          var K = "01", G = function(t2, e2) {
            this._transformRequestFn = t2, this._customAccessToken = e2, this._createSkuToken();
          };
          function Z(t2) {
            return 0 === t2.indexOf("mapbox:");
          }
          G.prototype._createSkuToken = function() {
            var t2 = function() {
              for (var t3 = "", e2 = 0; e2 < 10; e2++)
                t3 += "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(62 * Math.random())];
              return { token: ["1", K, t3].join(""), tokenExpiresAt: Date.now() + 432e5 };
            }();
            this._skuToken = t2.token, this._skuTokenExpiresAt = t2.tokenExpiresAt;
          }, G.prototype._isSkuTokenExpired = function() {
            return Date.now() > this._skuTokenExpiresAt;
          }, G.prototype.transformRequest = function(t2, e2) {
            return this._transformRequestFn && this._transformRequestFn(t2, e2) || { url: t2 };
          }, G.prototype.normalizeStyleURL = function(t2, e2) {
            if (!Z(t2))
              return t2;
            var r2 = Y(t2);
            return r2.path = "/styles/v1" + r2.path, this._makeAPIURL(r2, this._customAccessToken || e2);
          }, G.prototype.normalizeGlyphsURL = function(t2, e2) {
            if (!Z(t2))
              return t2;
            var r2 = Y(t2);
            return r2.path = "/fonts/v1" + r2.path, this._makeAPIURL(r2, this._customAccessToken || e2);
          }, G.prototype.normalizeSourceURL = function(t2, e2) {
            if (!Z(t2))
              return t2;
            var r2 = Y(t2);
            return r2.path = "/v4/" + r2.authority + ".json", r2.params.push("secure"), this._makeAPIURL(r2, this._customAccessToken || e2);
          }, G.prototype.normalizeSpriteURL = function(t2, e2, r2, n2) {
            var i2 = Y(t2);
            return Z(t2) ? (i2.path = "/styles/v1" + i2.path + "/sprite" + e2 + r2, this._makeAPIURL(i2, this._customAccessToken || n2)) : (i2.path += "" + e2 + r2, $(i2));
          }, G.prototype.normalizeTileURL = function(t2, e2) {
            if (this._isSkuTokenExpired() && this._createSkuToken(), t2 && !Z(t2))
              return t2;
            var r2 = Y(t2);
            r2.path = r2.path.replace(/(\.(png|jpg)\d*)(?=$)/, (O.devicePixelRatio >= 2 || 512 === e2 ? "@2x" : "") + (U.supported ? ".webp" : "$1")), r2.path = r2.path.replace(/^.+\/v4\//, "/"), r2.path = "/v4" + r2.path;
            var n2 = this._customAccessToken || function(t3) {
              for (var e3 = 0, r3 = t3; e3 < r3.length; e3 += 1) {
                var n3 = r3[e3].match(/^access_token=(.*)$/);
                if (n3)
                  return n3[1];
              }
              return null;
            }(r2.params) || R.ACCESS_TOKEN;
            return R.REQUIRE_ACCESS_TOKEN && n2 && this._skuToken && r2.params.push("sku=" + this._skuToken), this._makeAPIURL(r2, n2);
          }, G.prototype.canonicalizeTileURL = function(t2, e2) {
            var r2 = Y(t2);
            if (!r2.path.match(/(^\/v4\/)/) || !r2.path.match(/\.[\w]+$/))
              return t2;
            var n2 = "mapbox://tiles/";
            n2 += r2.path.replace("/v4/", "");
            var i2 = r2.params;
            return e2 && (i2 = i2.filter(function(t3) {
              return !t3.match(/^access_token=/);
            })), i2.length && (n2 += "?" + i2.join("&")), n2;
          }, G.prototype.canonicalizeTileset = function(t2, e2) {
            for (var r2 = !!e2 && Z(e2), n2 = [], i2 = 0, a2 = t2.tiles || []; i2 < a2.length; i2 += 1) {
              var o2 = a2[i2];
              J(o2) ? n2.push(this.canonicalizeTileURL(o2, r2)) : n2.push(o2);
            }
            return n2;
          }, G.prototype._makeAPIURL = function(t2, e2) {
            var r2 = "See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes", n2 = Y(R.API_URL);
            if (t2.protocol = n2.protocol, t2.authority = n2.authority, "http" === t2.protocol) {
              var i2 = t2.params.indexOf("secure");
              i2 >= 0 && t2.params.splice(i2, 1);
            }
            if ("/" !== n2.path && (t2.path = "" + n2.path + t2.path), !R.REQUIRE_ACCESS_TOKEN)
              return $(t2);
            if (!(e2 = e2 || R.ACCESS_TOKEN))
              throw new Error("An API access token is required to use Mapbox GL. " + r2);
            if ("s" === e2[0])
              throw new Error("Use a public access token (pk.*) with Mapbox GL, not a secret access token (sk.*). " + r2);
            return t2.params = t2.params.filter(function(t3) {
              return -1 === t3.indexOf("access_token");
            }), t2.params.push("access_token=" + e2), $(t2);
          };
          var X = /^((https?:)?\/\/)?([^\/]+\.)?mapbox\.c(n|om)(\/|\?|$)/i;
          function J(t2) {
            return X.test(t2);
          }
          var H = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
          function Y(t2) {
            var e2 = t2.match(H);
            if (!e2)
              throw new Error("Unable to parse URL object");
            return { protocol: e2[1], authority: e2[2], path: e2[3] || "/", params: e2[4] ? e2[4].split("&") : [] };
          }
          function $(t2) {
            var e2 = t2.params.length ? "?" + t2.params.join("&") : "";
            return t2.protocol + "://" + t2.authority + t2.path + e2;
          }
          function W(t2) {
            if (!t2)
              return null;
            var e2 = t2.split(".");
            if (!e2 || 3 !== e2.length)
              return null;
            try {
              return JSON.parse(decodeURIComponent(o.atob(e2[1]).split("").map(function(t3) {
                return "%" + ("00" + t3.charCodeAt(0).toString(16)).slice(-2);
              }).join("")));
            } catch (t3) {
              return null;
            }
          }
          var Q = function(t2) {
            this.type = t2, this.anonId = null, this.eventData = {}, this.queue = [], this.pendingRequest = null;
          };
          Q.prototype.getStorageKey = function(t2) {
            var e2, r2 = W(R.ACCESS_TOKEN);
            return e2 = r2 && r2.u ? o.btoa(encodeURIComponent(r2.u).replace(/%([0-9A-F]{2})/g, function(t3, e3) {
              return String.fromCharCode(Number("0x" + e3));
            })) : R.ACCESS_TOKEN || "", t2 ? "mapbox.eventData." + t2 + ":" + e2 : "mapbox.eventData:" + e2;
          }, Q.prototype.fetchEventData = function() {
            var t2 = P("localStorage"), e2 = this.getStorageKey(), r2 = this.getStorageKey("uuid");
            if (t2)
              try {
                var n2 = o.localStorage.getItem(e2);
                n2 && (this.eventData = JSON.parse(n2));
                var i2 = o.localStorage.getItem(r2);
                i2 && (this.anonId = i2);
              } catch (t3) {
                A("Unable to read from LocalStorage");
              }
          }, Q.prototype.saveEventData = function() {
            var t2 = P("localStorage"), e2 = this.getStorageKey(), r2 = this.getStorageKey("uuid");
            if (t2)
              try {
                o.localStorage.setItem(r2, this.anonId), Object.keys(this.eventData).length >= 1 && o.localStorage.setItem(e2, JSON.stringify(this.eventData));
              } catch (t3) {
                A("Unable to write to LocalStorage");
              }
          }, Q.prototype.processRequests = function(t2) {
          }, Q.prototype.postEvent = function(t2, e2, r2, n2) {
            var i2 = this;
            if (R.EVENTS_URL) {
              var a2 = Y(R.EVENTS_URL);
              a2.params.push("access_token=" + (n2 || R.ACCESS_TOKEN || ""));
              var o2 = { event: this.type, created: new Date(t2).toISOString(), sdkIdentifier: "mapbox-gl-js", sdkVersion: "1.13.3", skuId: K, userId: this.anonId }, s2 = e2 ? h(o2, e2) : o2, u2 = { url: $(a2), headers: { "Content-Type": "text/plain" }, body: JSON.stringify([s2]) };
              this.pendingRequest = wt(u2, function(t3) {
                i2.pendingRequest = null, r2(t3), i2.saveEventData(), i2.processRequests(n2);
              });
            }
          }, Q.prototype.queueRequest = function(t2, e2) {
            this.queue.push(t2), this.processRequests(e2);
          };
          var tt2, et, rt = function(t2) {
            function e2() {
              t2.call(this, "map.load"), this.success = {}, this.skuToken = "";
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.postMapLoadEvent = function(t3, e3, r2, n2) {
              this.skuToken = r2;
              var i2 = !(!n2 && !R.ACCESS_TOKEN), a2 = Array.isArray(t3) && t3.some(function(t4) {
                return Z(t4) || J(t4);
              });
              R.EVENTS_URL && i2 && a2 && this.queueRequest({ id: e3, timestamp: Date.now() }, n2);
            }, e2.prototype.processRequests = function(t3) {
              var e3 = this;
              if (!this.pendingRequest && 0 !== this.queue.length) {
                var r2 = this.queue.shift(), n2 = r2.id, i2 = r2.timestamp;
                n2 && this.success[n2] || (this.anonId || this.fetchEventData(), m(this.anonId) || (this.anonId = d()), this.postEvent(i2, { skuToken: this.skuToken }, function(t4) {
                  t4 || n2 && (e3.success[n2] = true);
                }, t3));
              }
            }, e2;
          }(Q), nt = new (function(t2) {
            function e2(e3) {
              t2.call(this, "appUserTurnstile"), this._customAccessToken = e3;
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.postTurnstileEvent = function(t3, e3) {
              R.EVENTS_URL && R.ACCESS_TOKEN && Array.isArray(t3) && t3.some(function(t4) {
                return Z(t4) || J(t4);
              }) && this.queueRequest(Date.now(), e3);
            }, e2.prototype.processRequests = function(t3) {
              var e3 = this;
              if (!this.pendingRequest && 0 !== this.queue.length) {
                this.anonId && this.eventData.lastSuccess && this.eventData.tokenU || this.fetchEventData();
                var r2 = W(R.ACCESS_TOKEN), n2 = r2 ? r2.u : R.ACCESS_TOKEN, i2 = n2 !== this.eventData.tokenU;
                m(this.anonId) || (this.anonId = d(), i2 = true);
                var a2 = this.queue.shift();
                if (this.eventData.lastSuccess) {
                  var o2 = new Date(this.eventData.lastSuccess), s2 = new Date(a2), u2 = (a2 - this.eventData.lastSuccess) / 864e5;
                  i2 = i2 || u2 >= 1 || u2 < -1 || o2.getDate() !== s2.getDate();
                } else
                  i2 = true;
                if (!i2)
                  return this.processRequests();
                this.postEvent(a2, { "enabled.telemetry": false }, function(t4) {
                  t4 || (e3.eventData.lastSuccess = a2, e3.eventData.tokenU = n2);
                }, t3);
              }
            }, e2;
          }(Q))(), it = nt.postTurnstileEvent.bind(nt), at = new rt(), ot = at.postMapLoadEvent.bind(at), st = 500, ut = 50;
          function lt() {
            o.caches && !tt2 && (tt2 = o.caches.open("mapbox-tiles"));
          }
          function pt(t2) {
            var e2 = t2.indexOf("?");
            return e2 < 0 ? t2 : t2.slice(0, e2);
          }
          var ct, ht = 1 / 0;
          function ft() {
            return null == ct && (ct = o.OffscreenCanvas && new o.OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof o.createImageBitmap), ct;
          }
          var yt = { Unknown: "Unknown", Style: "Style", Source: "Source", Tile: "Tile", Glyphs: "Glyphs", SpriteImage: "SpriteImage", SpriteJSON: "SpriteJSON", Image: "Image" };
          "function" == typeof Object.freeze && Object.freeze(yt);
          var dt = function(t2) {
            function e2(e3, r2, n2) {
              401 === r2 && J(n2) && (e3 += ": you may have provided an invalid Mapbox access token. See https://www.mapbox.com/api-documentation/#access-tokens-and-token-scopes"), t2.call(this, e3), this.status = r2, this.url = n2, this.name = this.constructor.name, this.message = e3;
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.toString = function() {
              return this.name + ": " + this.message + " (" + this.status + "): " + this.url;
            }, e2;
          }(Error), mt = I() ? function() {
            return self.worker && self.worker.referrer;
          } : function() {
            return ("blob:" === o.location.protocol ? o.parent : o).location.href;
          };
          var vt, gt, xt = function(t2, e2) {
            if (!(/^file:/.test(r2 = t2.url) || /^file:/.test(mt()) && !/^\w+:/.test(r2))) {
              if (o.fetch && o.Request && o.AbortController && o.Request.prototype.hasOwnProperty("signal"))
                return function(t3, e3) {
                  var r3, n2 = new o.AbortController(), i2 = new o.Request(t3.url, { method: t3.method || "GET", body: t3.body, credentials: t3.credentials, headers: t3.headers, referrer: mt(), signal: n2.signal }), a2 = false, s2 = false, u2 = (r3 = i2.url).indexOf("sku=") > 0 && J(r3);
                  "json" === t3.type && i2.headers.set("Accept", "application/json");
                  var l2 = function(r4, n3, a3) {
                    if (!s2) {
                      if (r4 && "SecurityError" !== r4.message && A(r4), n3 && a3)
                        return p2(n3);
                      var l3 = Date.now();
                      o.fetch(i2).then(function(r5) {
                        if (r5.ok) {
                          var n4 = u2 ? r5.clone() : null;
                          return p2(r5, n4, l3);
                        }
                        return e3(new dt(r5.statusText, r5.status, t3.url));
                      }).catch(function(t4) {
                        20 !== t4.code && e3(new Error(t4.message));
                      });
                    }
                  }, p2 = function(r4, n3, u3) {
                    ("arrayBuffer" === t3.type ? r4.arrayBuffer() : "json" === t3.type ? r4.json() : r4.text()).then(function(t4) {
                      s2 || (n3 && u3 && function(t5, e4, r5) {
                        if (lt(), tt2) {
                          var n4 = { status: e4.status, statusText: e4.statusText, headers: new o.Headers() };
                          e4.headers.forEach(function(t6, e5) {
                            return n4.headers.set(e5, t6);
                          });
                          var i3 = z(e4.headers.get("Cache-Control") || "");
                          i3["no-store"] || (i3["max-age"] && n4.headers.set("Expires", new Date(r5 + 1e3 * i3["max-age"]).toUTCString()), new Date(n4.headers.get("Expires")).getTime() - r5 < 42e4 || function(t6, e5) {
                            if (void 0 === et)
                              try {
                                new Response(new ReadableStream()), et = true;
                              } catch (t7) {
                                et = false;
                              }
                            et ? e5(t6.body) : t6.blob().then(e5);
                          }(e4, function(e5) {
                            var r6 = new o.Response(e5, n4);
                            lt(), tt2 && tt2.then(function(e6) {
                              return e6.put(pt(t5.url), r6);
                            }).catch(function(t6) {
                              return A(t6.message);
                            });
                          }));
                        }
                      }(i2, n3, u3), a2 = true, e3(null, t4, r4.headers.get("Cache-Control"), r4.headers.get("Expires")));
                    }).catch(function(t4) {
                      s2 || e3(new Error(t4.message));
                    });
                  };
                  return u2 ? function(t4, e4) {
                    if (lt(), !tt2)
                      return e4(null);
                    var r4 = pt(t4.url);
                    tt2.then(function(t5) {
                      t5.match(r4).then(function(n3) {
                        var i3 = function(t6) {
                          if (!t6)
                            return false;
                          var e5 = new Date(t6.headers.get("Expires") || 0), r5 = z(t6.headers.get("Cache-Control") || "");
                          return e5 > Date.now() && !r5["no-cache"];
                        }(n3);
                        t5.delete(r4), i3 && t5.put(r4, n3.clone()), e4(null, n3, i3);
                      }).catch(e4);
                    }).catch(e4);
                  }(i2, l2) : l2(null, null), { cancel: function() {
                    s2 = true, a2 || n2.abort();
                  } };
                }(t2, e2);
              if (I() && self.worker && self.worker.actor)
                return self.worker.actor.send("getResource", t2, e2, void 0, true);
            }
            var r2;
            return function(t3, e3) {
              var r3 = new o.XMLHttpRequest();
              for (var n2 in r3.open(t3.method || "GET", t3.url, true), "arrayBuffer" === t3.type && (r3.responseType = "arraybuffer"), t3.headers)
                r3.setRequestHeader(n2, t3.headers[n2]);
              return "json" === t3.type && (r3.responseType = "text", r3.setRequestHeader("Accept", "application/json")), r3.withCredentials = "include" === t3.credentials, r3.onerror = function() {
                e3(new Error(r3.statusText));
              }, r3.onload = function() {
                if ((r3.status >= 200 && r3.status < 300 || 0 === r3.status) && null !== r3.response) {
                  var n3 = r3.response;
                  if ("json" === t3.type)
                    try {
                      n3 = JSON.parse(r3.response);
                    } catch (t4) {
                      return e3(t4);
                    }
                  e3(null, n3, r3.getResponseHeader("Cache-Control"), r3.getResponseHeader("Expires"));
                } else
                  e3(new dt(r3.statusText, r3.status, t3.url));
              }, r3.send(t3.body), { cancel: function() {
                return r3.abort();
              } };
            }(t2, e2);
          }, bt = function(t2, e2) {
            return xt(h(t2, { type: "arrayBuffer" }), e2);
          }, wt = function(t2, e2) {
            return xt(h(t2, { method: "POST" }), e2);
          }, _t = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
          vt = [], gt = 0;
          var At = function(t2, e2) {
            if (U.supported && (t2.headers || (t2.headers = {}), t2.headers.accept = "image/webp,*/*"), gt >= R.MAX_PARALLEL_IMAGE_REQUESTS) {
              var r2 = { requestParameters: t2, callback: e2, cancelled: false, cancel: function() {
                this.cancelled = true;
              } };
              return vt.push(r2), r2;
            }
            gt++;
            var n2 = false, i2 = function() {
              if (!n2)
                for (n2 = true, gt--; vt.length && gt < R.MAX_PARALLEL_IMAGE_REQUESTS; ) {
                  var t3 = vt.shift();
                  t3.cancelled || (t3.cancel = At(t3.requestParameters, t3.callback).cancel);
                }
            }, a2 = bt(t2, function(t3, r3, n3, a3) {
              i2(), t3 ? e2(t3) : r3 && (ft() ? function(t4, e3) {
                var r4 = new o.Blob([new Uint8Array(t4)], { type: "image/png" });
                o.createImageBitmap(r4).then(function(t5) {
                  e3(null, t5);
                }).catch(function(t5) {
                  e3(new Error("Could not load image because of " + t5.message + ". Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                });
              }(r3, e2) : function(t4, e3, r4, n4) {
                var i3 = new o.Image(), a4 = o.URL;
                i3.onload = function() {
                  e3(null, i3), a4.revokeObjectURL(i3.src), i3.onload = null, o.requestAnimationFrame(function() {
                    i3.src = _t;
                  });
                }, i3.onerror = function() {
                  return e3(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                };
                var s2 = new o.Blob([new Uint8Array(t4)], { type: "image/png" });
                i3.cacheControl = r4, i3.expires = n4, i3.src = t4.byteLength ? a4.createObjectURL(s2) : _t;
              }(r3, e2, n3, a3));
            });
            return { cancel: function() {
              a2.cancel(), i2();
            } };
          };
          function St(t2, e2, r2) {
            r2[t2] && -1 !== r2[t2].indexOf(e2) || (r2[t2] = r2[t2] || [], r2[t2].push(e2));
          }
          function kt(t2, e2, r2) {
            if (r2 && r2[t2]) {
              var n2 = r2[t2].indexOf(e2);
              -1 !== n2 && r2[t2].splice(n2, 1);
            }
          }
          var It = function(t2, e2) {
            void 0 === e2 && (e2 = {}), h(this, e2), this.type = t2;
          }, zt = function(t2) {
            function e2(e3, r2) {
              void 0 === r2 && (r2 = {}), t2.call(this, "error", h({ error: e3 }, r2));
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2;
          }(It), Ct = function() {
          };
          Ct.prototype.on = function(t2, e2) {
            return this._listeners = this._listeners || {}, St(t2, e2, this._listeners), this;
          }, Ct.prototype.off = function(t2, e2) {
            return kt(t2, e2, this._listeners), kt(t2, e2, this._oneTimeListeners), this;
          }, Ct.prototype.once = function(t2, e2) {
            return this._oneTimeListeners = this._oneTimeListeners || {}, St(t2, e2, this._oneTimeListeners), this;
          }, Ct.prototype.fire = function(t2, e2) {
            "string" == typeof t2 && (t2 = new It(t2, e2 || {}));
            var r2 = t2.type;
            if (this.listens(r2)) {
              t2.target = this;
              for (var n2 = 0, i2 = this._listeners && this._listeners[r2] ? this._listeners[r2].slice() : []; n2 < i2.length; n2 += 1)
                i2[n2].call(this, t2);
              for (var a2 = 0, o2 = this._oneTimeListeners && this._oneTimeListeners[r2] ? this._oneTimeListeners[r2].slice() : []; a2 < o2.length; a2 += 1) {
                var s2 = o2[a2];
                kt(r2, s2, this._oneTimeListeners), s2.call(this, t2);
              }
              var u2 = this._eventedParent;
              u2 && (h(t2, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), u2.fire(t2));
            } else
              t2 instanceof zt && console.error(t2.error);
            return this;
          }, Ct.prototype.listens = function(t2) {
            return this._listeners && this._listeners[t2] && this._listeners[t2].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t2] && this._oneTimeListeners[t2].length > 0 || this._eventedParent && this._eventedParent.listens(t2);
          }, Ct.prototype.setEventedParent = function(t2, e2) {
            return this._eventedParent = t2, this._eventedParentData = e2, this;
          };
          var Et = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, sources: { required: true, type: "sources" }, sprite: { type: "string" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {} }, default: "mapbox" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } }, Pt = function(t2, e2, r2, n2) {
            this.message = (t2 ? t2 + ": " : "") + r2, n2 && (this.identifier = n2), null != e2 && e2.__line__ && (this.line = e2.__line__);
          };
          function Mt(t2) {
            var e2 = t2.value;
            return e2 ? [new Pt(t2.key, e2, "constants have been deprecated as of v8")] : [];
          }
          function Bt(t2) {
            for (var e2 = [], r2 = arguments.length - 1; r2-- > 0; )
              e2[r2] = arguments[r2 + 1];
            for (var n2 = 0, i2 = e2; n2 < i2.length; n2 += 1) {
              var a2 = i2[n2];
              for (var o2 in a2)
                t2[o2] = a2[o2];
            }
            return t2;
          }
          function Tt(t2) {
            return t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean ? t2.valueOf() : t2;
          }
          function Vt(t2) {
            if (Array.isArray(t2))
              return t2.map(Vt);
            if (t2 instanceof Object && !(t2 instanceof Number || t2 instanceof String || t2 instanceof Boolean)) {
              var e2 = {};
              for (var r2 in t2)
                e2[r2] = Vt(t2[r2]);
              return e2;
            }
            return Tt(t2);
          }
          var Ft = function(t2) {
            function e2(e3, r2) {
              t2.call(this, r2), this.message = r2, this.key = e3;
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2;
          }(Error), Dt = function(t2, e2) {
            void 0 === e2 && (e2 = []), this.parent = t2, this.bindings = {};
            for (var r2 = 0, n2 = e2; r2 < n2.length; r2 += 1) {
              var i2 = n2[r2];
              this.bindings[i2[0]] = i2[1];
            }
          };
          Dt.prototype.concat = function(t2) {
            return new Dt(this, t2);
          }, Dt.prototype.get = function(t2) {
            if (this.bindings[t2])
              return this.bindings[t2];
            if (this.parent)
              return this.parent.get(t2);
            throw new Error(t2 + " not found in scope.");
          }, Dt.prototype.has = function(t2) {
            return !!this.bindings[t2] || !!this.parent && this.parent.has(t2);
          };
          var Lt = { kind: "null" }, Ot = { kind: "number" }, Rt = { kind: "string" }, Ut = { kind: "boolean" }, jt = { kind: "color" }, qt = { kind: "object" }, Nt = { kind: "value" }, Kt = { kind: "collator" }, Gt = { kind: "formatted" }, Zt = { kind: "resolvedImage" };
          function Xt(t2, e2) {
            return { kind: "array", itemType: t2, N: e2 };
          }
          function Jt(t2) {
            if ("array" === t2.kind) {
              var e2 = Jt(t2.itemType);
              return "number" == typeof t2.N ? "array<" + e2 + ", " + t2.N + ">" : "value" === t2.itemType.kind ? "array" : "array<" + e2 + ">";
            }
            return t2.kind;
          }
          var Ht = [Lt, Ot, Rt, Ut, jt, Gt, qt, Xt(Nt), Zt];
          function Yt(t2, e2) {
            if ("error" === e2.kind)
              return null;
            if ("array" === t2.kind) {
              if ("array" === e2.kind && (0 === e2.N && "value" === e2.itemType.kind || !Yt(t2.itemType, e2.itemType)) && ("number" != typeof t2.N || t2.N === e2.N))
                return null;
            } else {
              if (t2.kind === e2.kind)
                return null;
              if ("value" === t2.kind) {
                for (var r2 = 0, n2 = Ht; r2 < n2.length; r2 += 1)
                  if (!Yt(n2[r2], e2))
                    return null;
              }
            }
            return "Expected " + Jt(t2) + " but found " + Jt(e2) + " instead.";
          }
          function $t(t2, e2) {
            return e2.some(function(e3) {
              return e3.kind === t2.kind;
            });
          }
          function Wt(t2, e2) {
            return e2.some(function(e3) {
              return "null" === e3 ? null === t2 : "array" === e3 ? Array.isArray(t2) : "object" === e3 ? t2 && !Array.isArray(t2) && "object" == typeof t2 : e3 === typeof t2;
            });
          }
          var Qt = e(function(t2, e2) {
            var r2 = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], rebeccapurple: [102, 51, 153, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] };
            function n2(t3) {
              return (t3 = Math.round(t3)) < 0 ? 0 : t3 > 255 ? 255 : t3;
            }
            function i2(t3) {
              return n2("%" === t3[t3.length - 1] ? parseFloat(t3) / 100 * 255 : parseInt(t3));
            }
            function a2(t3) {
              return (e3 = "%" === t3[t3.length - 1] ? parseFloat(t3) / 100 : parseFloat(t3)) < 0 ? 0 : e3 > 1 ? 1 : e3;
              var e3;
            }
            function o2(t3, e3, r3) {
              return r3 < 0 ? r3 += 1 : r3 > 1 && (r3 -= 1), 6 * r3 < 1 ? t3 + (e3 - t3) * r3 * 6 : 2 * r3 < 1 ? e3 : 3 * r3 < 2 ? t3 + (e3 - t3) * (2 / 3 - r3) * 6 : t3;
            }
            try {
              e2.parseCSSColor = function(t3) {
                var e3, s2 = t3.replace(/ /g, "").toLowerCase();
                if (s2 in r2)
                  return r2[s2].slice();
                if ("#" === s2[0])
                  return 4 === s2.length ? (e3 = parseInt(s2.substr(1), 16)) >= 0 && e3 <= 4095 ? [(3840 & e3) >> 4 | (3840 & e3) >> 8, 240 & e3 | (240 & e3) >> 4, 15 & e3 | (15 & e3) << 4, 1] : null : 7 === s2.length && (e3 = parseInt(s2.substr(1), 16)) >= 0 && e3 <= 16777215 ? [(16711680 & e3) >> 16, (65280 & e3) >> 8, 255 & e3, 1] : null;
                var u2 = s2.indexOf("("), l2 = s2.indexOf(")");
                if (-1 !== u2 && l2 + 1 === s2.length) {
                  var p2 = s2.substr(0, u2), c2 = s2.substr(u2 + 1, l2 - (u2 + 1)).split(","), h2 = 1;
                  switch (p2) {
                    case "rgba":
                      if (4 !== c2.length)
                        return null;
                      h2 = a2(c2.pop());
                    case "rgb":
                      return 3 !== c2.length ? null : [i2(c2[0]), i2(c2[1]), i2(c2[2]), h2];
                    case "hsla":
                      if (4 !== c2.length)
                        return null;
                      h2 = a2(c2.pop());
                    case "hsl":
                      if (3 !== c2.length)
                        return null;
                      var f2 = (parseFloat(c2[0]) % 360 + 360) % 360 / 360, y2 = a2(c2[1]), d2 = a2(c2[2]), m2 = d2 <= 0.5 ? d2 * (y2 + 1) : d2 + y2 - d2 * y2, v2 = 2 * d2 - m2;
                      return [n2(255 * o2(v2, m2, f2 + 1 / 3)), n2(255 * o2(v2, m2, f2)), n2(255 * o2(v2, m2, f2 - 1 / 3)), h2];
                    default:
                      return null;
                  }
                }
                return null;
              };
            } catch (t3) {
            }
          }).parseCSSColor, te = function(t2, e2, r2, n2) {
            void 0 === n2 && (n2 = 1), this.r = t2, this.g = e2, this.b = r2, this.a = n2;
          };
          te.parse = function(t2) {
            if (t2) {
              if (t2 instanceof te)
                return t2;
              if ("string" == typeof t2) {
                var e2 = Qt(t2);
                if (e2)
                  return new te(e2[0] / 255 * e2[3], e2[1] / 255 * e2[3], e2[2] / 255 * e2[3], e2[3]);
              }
            }
          }, te.prototype.toString = function() {
            var t2 = this.toArray(), e2 = t2[1], r2 = t2[2], n2 = t2[3];
            return "rgba(" + Math.round(t2[0]) + "," + Math.round(e2) + "," + Math.round(r2) + "," + n2 + ")";
          }, te.prototype.toArray = function() {
            var t2 = this.a;
            return 0 === t2 ? [0, 0, 0, 0] : [255 * this.r / t2, 255 * this.g / t2, 255 * this.b / t2, t2];
          }, te.black = new te(0, 0, 0, 1), te.white = new te(1, 1, 1, 1), te.transparent = new te(0, 0, 0, 0), te.red = new te(1, 0, 0, 1);
          var ee = function(t2, e2, r2) {
            this.sensitivity = t2 ? e2 ? "variant" : "case" : e2 ? "accent" : "base", this.locale = r2, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
          };
          ee.prototype.compare = function(t2, e2) {
            return this.collator.compare(t2, e2);
          }, ee.prototype.resolvedLocale = function() {
            return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
          };
          var re = function(t2, e2, r2, n2, i2) {
            this.text = t2, this.image = e2, this.scale = r2, this.fontStack = n2, this.textColor = i2;
          }, ne = function(t2) {
            this.sections = t2;
          };
          ne.fromString = function(t2) {
            return new ne([new re(t2, null, null, null, null)]);
          }, ne.prototype.isEmpty = function() {
            return 0 === this.sections.length || !this.sections.some(function(t2) {
              return 0 !== t2.text.length || t2.image && 0 !== t2.image.name.length;
            });
          }, ne.factory = function(t2) {
            return t2 instanceof ne ? t2 : ne.fromString(t2);
          }, ne.prototype.toString = function() {
            return 0 === this.sections.length ? "" : this.sections.map(function(t2) {
              return t2.text;
            }).join("");
          }, ne.prototype.serialize = function() {
            for (var t2 = ["format"], e2 = 0, r2 = this.sections; e2 < r2.length; e2 += 1) {
              var n2 = r2[e2];
              if (n2.image)
                t2.push(["image", n2.image.name]);
              else {
                t2.push(n2.text);
                var i2 = {};
                n2.fontStack && (i2["text-font"] = ["literal", n2.fontStack.split(",")]), n2.scale && (i2["font-scale"] = n2.scale), n2.textColor && (i2["text-color"] = ["rgba"].concat(n2.textColor.toArray())), t2.push(i2);
              }
            }
            return t2;
          };
          var ie = function(t2) {
            this.name = t2.name, this.available = t2.available;
          };
          function ae(t2, e2, r2, n2) {
            return "number" == typeof t2 && t2 >= 0 && t2 <= 255 && "number" == typeof e2 && e2 >= 0 && e2 <= 255 && "number" == typeof r2 && r2 >= 0 && r2 <= 255 ? void 0 === n2 || "number" == typeof n2 && n2 >= 0 && n2 <= 1 ? null : "Invalid rgba value [" + [t2, e2, r2, n2].join(", ") + "]: 'a' must be between 0 and 1." : "Invalid rgba value [" + ("number" == typeof n2 ? [t2, e2, r2, n2] : [t2, e2, r2]).join(", ") + "]: 'r', 'g', and 'b' must be between 0 and 255.";
          }
          function oe(t2) {
            if (null === t2)
              return true;
            if ("string" == typeof t2)
              return true;
            if ("boolean" == typeof t2)
              return true;
            if ("number" == typeof t2)
              return true;
            if (t2 instanceof te)
              return true;
            if (t2 instanceof ee)
              return true;
            if (t2 instanceof ne)
              return true;
            if (t2 instanceof ie)
              return true;
            if (Array.isArray(t2)) {
              for (var e2 = 0, r2 = t2; e2 < r2.length; e2 += 1)
                if (!oe(r2[e2]))
                  return false;
              return true;
            }
            if ("object" == typeof t2) {
              for (var n2 in t2)
                if (!oe(t2[n2]))
                  return false;
              return true;
            }
            return false;
          }
          function se(t2) {
            if (null === t2)
              return Lt;
            if ("string" == typeof t2)
              return Rt;
            if ("boolean" == typeof t2)
              return Ut;
            if ("number" == typeof t2)
              return Ot;
            if (t2 instanceof te)
              return jt;
            if (t2 instanceof ee)
              return Kt;
            if (t2 instanceof ne)
              return Gt;
            if (t2 instanceof ie)
              return Zt;
            if (Array.isArray(t2)) {
              for (var e2, r2 = t2.length, n2 = 0, i2 = t2; n2 < i2.length; n2 += 1) {
                var a2 = se(i2[n2]);
                if (e2) {
                  if (e2 === a2)
                    continue;
                  e2 = Nt;
                  break;
                }
                e2 = a2;
              }
              return Xt(e2 || Nt, r2);
            }
            return qt;
          }
          function ue(t2) {
            var e2 = typeof t2;
            return null === t2 ? "" : "string" === e2 || "number" === e2 || "boolean" === e2 ? String(t2) : t2 instanceof te || t2 instanceof ne || t2 instanceof ie ? t2.toString() : JSON.stringify(t2);
          }
          ie.prototype.toString = function() {
            return this.name;
          }, ie.fromString = function(t2) {
            return t2 ? new ie({ name: t2, available: false }) : null;
          }, ie.prototype.serialize = function() {
            return ["image", this.name];
          };
          var le = function(t2, e2) {
            this.type = t2, this.value = e2;
          };
          le.parse = function(t2, e2) {
            if (2 !== t2.length)
              return e2.error("'literal' expression requires exactly one argument, but found " + (t2.length - 1) + " instead.");
            if (!oe(t2[1]))
              return e2.error("invalid value");
            var r2 = t2[1], n2 = se(r2), i2 = e2.expectedType;
            return "array" !== n2.kind || 0 !== n2.N || !i2 || "array" !== i2.kind || "number" == typeof i2.N && 0 !== i2.N || (n2 = i2), new le(n2, r2);
          }, le.prototype.evaluate = function() {
            return this.value;
          }, le.prototype.eachChild = function() {
          }, le.prototype.outputDefined = function() {
            return true;
          }, le.prototype.serialize = function() {
            return "array" === this.type.kind || "object" === this.type.kind ? ["literal", this.value] : this.value instanceof te ? ["rgba"].concat(this.value.toArray()) : this.value instanceof ne ? this.value.serialize() : this.value;
          };
          var pe = function(t2) {
            this.name = "ExpressionEvaluationError", this.message = t2;
          };
          pe.prototype.toJSON = function() {
            return this.message;
          };
          var ce = { string: Rt, number: Ot, boolean: Ut, object: qt }, he = function(t2, e2) {
            this.type = t2, this.args = e2;
          };
          he.parse = function(t2, e2) {
            if (t2.length < 2)
              return e2.error("Expected at least one argument.");
            var r2, n2 = 1, i2 = t2[0];
            if ("array" === i2) {
              var a2, o2;
              if (t2.length > 2) {
                var s2 = t2[1];
                if ("string" != typeof s2 || !(s2 in ce) || "object" === s2)
                  return e2.error('The item type argument of "array" must be one of string, number, boolean', 1);
                a2 = ce[s2], n2++;
              } else
                a2 = Nt;
              if (t2.length > 3) {
                if (null !== t2[2] && ("number" != typeof t2[2] || t2[2] < 0 || t2[2] !== Math.floor(t2[2])))
                  return e2.error('The length argument to "array" must be a positive integer literal', 2);
                o2 = t2[2], n2++;
              }
              r2 = Xt(a2, o2);
            } else
              r2 = ce[i2];
            for (var u2 = []; n2 < t2.length; n2++) {
              var l2 = e2.parse(t2[n2], n2, Nt);
              if (!l2)
                return null;
              u2.push(l2);
            }
            return new he(r2, u2);
          }, he.prototype.evaluate = function(t2) {
            for (var e2 = 0; e2 < this.args.length; e2++) {
              var r2 = this.args[e2].evaluate(t2);
              if (!Yt(this.type, se(r2)))
                return r2;
              if (e2 === this.args.length - 1)
                throw new pe("Expected value to be of type " + Jt(this.type) + ", but found " + Jt(se(r2)) + " instead.");
            }
            return null;
          }, he.prototype.eachChild = function(t2) {
            this.args.forEach(t2);
          }, he.prototype.outputDefined = function() {
            return this.args.every(function(t2) {
              return t2.outputDefined();
            });
          }, he.prototype.serialize = function() {
            var t2 = this.type, e2 = [t2.kind];
            if ("array" === t2.kind) {
              var r2 = t2.itemType;
              if ("string" === r2.kind || "number" === r2.kind || "boolean" === r2.kind) {
                e2.push(r2.kind);
                var n2 = t2.N;
                ("number" == typeof n2 || this.args.length > 1) && e2.push(n2);
              }
            }
            return e2.concat(this.args.map(function(t3) {
              return t3.serialize();
            }));
          };
          var fe = function(t2) {
            this.type = Gt, this.sections = t2;
          };
          fe.parse = function(t2, e2) {
            if (t2.length < 2)
              return e2.error("Expected at least one argument.");
            var r2 = t2[1];
            if (!Array.isArray(r2) && "object" == typeof r2)
              return e2.error("First argument must be an image or text section.");
            for (var n2 = [], i2 = false, a2 = 1; a2 <= t2.length - 1; ++a2) {
              var o2 = t2[a2];
              if (i2 && "object" == typeof o2 && !Array.isArray(o2)) {
                i2 = false;
                var s2 = null;
                if (o2["font-scale"] && !(s2 = e2.parse(o2["font-scale"], 1, Ot)))
                  return null;
                var u2 = null;
                if (o2["text-font"] && !(u2 = e2.parse(o2["text-font"], 1, Xt(Rt))))
                  return null;
                var l2 = null;
                if (o2["text-color"] && !(l2 = e2.parse(o2["text-color"], 1, jt)))
                  return null;
                var p2 = n2[n2.length - 1];
                p2.scale = s2, p2.font = u2, p2.textColor = l2;
              } else {
                var c2 = e2.parse(t2[a2], 1, Nt);
                if (!c2)
                  return null;
                var h2 = c2.type.kind;
                if ("string" !== h2 && "value" !== h2 && "null" !== h2 && "resolvedImage" !== h2)
                  return e2.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                i2 = true, n2.push({ content: c2, scale: null, font: null, textColor: null });
              }
            }
            return new fe(n2);
          }, fe.prototype.evaluate = function(t2) {
            return new ne(this.sections.map(function(e2) {
              var r2 = e2.content.evaluate(t2);
              return se(r2) === Zt ? new re("", r2, null, null, null) : new re(ue(r2), null, e2.scale ? e2.scale.evaluate(t2) : null, e2.font ? e2.font.evaluate(t2).join(",") : null, e2.textColor ? e2.textColor.evaluate(t2) : null);
            }));
          }, fe.prototype.eachChild = function(t2) {
            for (var e2 = 0, r2 = this.sections; e2 < r2.length; e2 += 1) {
              var n2 = r2[e2];
              t2(n2.content), n2.scale && t2(n2.scale), n2.font && t2(n2.font), n2.textColor && t2(n2.textColor);
            }
          }, fe.prototype.outputDefined = function() {
            return false;
          }, fe.prototype.serialize = function() {
            for (var t2 = ["format"], e2 = 0, r2 = this.sections; e2 < r2.length; e2 += 1) {
              var n2 = r2[e2];
              t2.push(n2.content.serialize());
              var i2 = {};
              n2.scale && (i2["font-scale"] = n2.scale.serialize()), n2.font && (i2["text-font"] = n2.font.serialize()), n2.textColor && (i2["text-color"] = n2.textColor.serialize()), t2.push(i2);
            }
            return t2;
          };
          var ye = function(t2) {
            this.type = Zt, this.input = t2;
          };
          ye.parse = function(t2, e2) {
            if (2 !== t2.length)
              return e2.error("Expected two arguments.");
            var r2 = e2.parse(t2[1], 1, Rt);
            return r2 ? new ye(r2) : e2.error("No image name provided.");
          }, ye.prototype.evaluate = function(t2) {
            var e2 = this.input.evaluate(t2), r2 = ie.fromString(e2);
            return r2 && t2.availableImages && (r2.available = t2.availableImages.indexOf(e2) > -1), r2;
          }, ye.prototype.eachChild = function(t2) {
            t2(this.input);
          }, ye.prototype.outputDefined = function() {
            return false;
          }, ye.prototype.serialize = function() {
            return ["image", this.input.serialize()];
          };
          var de = { "to-boolean": Ut, "to-color": jt, "to-number": Ot, "to-string": Rt }, me = function(t2, e2) {
            this.type = t2, this.args = e2;
          };
          me.parse = function(t2, e2) {
            if (t2.length < 2)
              return e2.error("Expected at least one argument.");
            var r2 = t2[0];
            if (("to-boolean" === r2 || "to-string" === r2) && 2 !== t2.length)
              return e2.error("Expected one argument.");
            for (var n2 = de[r2], i2 = [], a2 = 1; a2 < t2.length; a2++) {
              var o2 = e2.parse(t2[a2], a2, Nt);
              if (!o2)
                return null;
              i2.push(o2);
            }
            return new me(n2, i2);
          }, me.prototype.evaluate = function(t2) {
            if ("boolean" === this.type.kind)
              return Boolean(this.args[0].evaluate(t2));
            if ("color" === this.type.kind) {
              for (var e2, r2, n2 = 0, i2 = this.args; n2 < i2.length; n2 += 1) {
                if (r2 = null, (e2 = i2[n2].evaluate(t2)) instanceof te)
                  return e2;
                if ("string" == typeof e2) {
                  var a2 = t2.parseColor(e2);
                  if (a2)
                    return a2;
                } else if (Array.isArray(e2) && !(r2 = e2.length < 3 || e2.length > 4 ? "Invalid rbga value " + JSON.stringify(e2) + ": expected an array containing either three or four numeric values." : ae(e2[0], e2[1], e2[2], e2[3])))
                  return new te(e2[0] / 255, e2[1] / 255, e2[2] / 255, e2[3]);
              }
              throw new pe(r2 || "Could not parse color from value '" + ("string" == typeof e2 ? e2 : String(JSON.stringify(e2))) + "'");
            }
            if ("number" === this.type.kind) {
              for (var o2 = null, s2 = 0, u2 = this.args; s2 < u2.length; s2 += 1) {
                if (null === (o2 = u2[s2].evaluate(t2)))
                  return 0;
                var l2 = Number(o2);
                if (!isNaN(l2))
                  return l2;
              }
              throw new pe("Could not convert " + JSON.stringify(o2) + " to number.");
            }
            return "formatted" === this.type.kind ? ne.fromString(ue(this.args[0].evaluate(t2))) : "resolvedImage" === this.type.kind ? ie.fromString(ue(this.args[0].evaluate(t2))) : ue(this.args[0].evaluate(t2));
          }, me.prototype.eachChild = function(t2) {
            this.args.forEach(t2);
          }, me.prototype.outputDefined = function() {
            return this.args.every(function(t2) {
              return t2.outputDefined();
            });
          }, me.prototype.serialize = function() {
            if ("formatted" === this.type.kind)
              return new fe([{ content: this.args[0], scale: null, font: null, textColor: null }]).serialize();
            if ("resolvedImage" === this.type.kind)
              return new ye(this.args[0]).serialize();
            var t2 = ["to-" + this.type.kind];
            return this.eachChild(function(e2) {
              t2.push(e2.serialize());
            }), t2;
          };
          var ve = ["Unknown", "Point", "LineString", "Polygon"], ge = function() {
            this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
          };
          ge.prototype.id = function() {
            return this.feature && "id" in this.feature ? this.feature.id : null;
          }, ge.prototype.geometryType = function() {
            return this.feature ? "number" == typeof this.feature.type ? ve[this.feature.type] : this.feature.type : null;
          }, ge.prototype.geometry = function() {
            return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
          }, ge.prototype.canonicalID = function() {
            return this.canonical;
          }, ge.prototype.properties = function() {
            return this.feature && this.feature.properties || {};
          }, ge.prototype.parseColor = function(t2) {
            var e2 = this._parseColorCache[t2];
            return e2 || (e2 = this._parseColorCache[t2] = te.parse(t2)), e2;
          };
          var xe = function(t2, e2, r2, n2) {
            this.name = t2, this.type = e2, this._evaluate = r2, this.args = n2;
          };
          xe.prototype.evaluate = function(t2) {
            return this._evaluate(t2, this.args);
          }, xe.prototype.eachChild = function(t2) {
            this.args.forEach(t2);
          }, xe.prototype.outputDefined = function() {
            return false;
          }, xe.prototype.serialize = function() {
            return [this.name].concat(this.args.map(function(t2) {
              return t2.serialize();
            }));
          }, xe.parse = function(t2, e2) {
            var r2, n2 = t2[0], i2 = xe.definitions[n2];
            if (!i2)
              return e2.error('Unknown expression "' + n2 + '". If you wanted a literal array, use ["literal", [...]].', 0);
            for (var a2 = Array.isArray(i2) ? i2[0] : i2.type, o2 = Array.isArray(i2) ? [[i2[1], i2[2]]] : i2.overloads, s2 = o2.filter(function(e3) {
              var r3 = e3[0];
              return !Array.isArray(r3) || r3.length === t2.length - 1;
            }), u2 = null, l2 = 0, p2 = s2; l2 < p2.length; l2 += 1) {
              var c2 = p2[l2], h2 = c2[0], f2 = c2[1];
              u2 = new je(e2.registry, e2.path, null, e2.scope);
              for (var y2 = [], d2 = false, m2 = 1; m2 < t2.length; m2++) {
                var v2 = t2[m2], g2 = Array.isArray(h2) ? h2[m2 - 1] : h2.type, x2 = u2.parse(v2, 1 + y2.length, g2);
                if (!x2) {
                  d2 = true;
                  break;
                }
                y2.push(x2);
              }
              if (!d2)
                if (Array.isArray(h2) && h2.length !== y2.length)
                  u2.error("Expected " + h2.length + " arguments, but found " + y2.length + " instead.");
                else {
                  for (var b2 = 0; b2 < y2.length; b2++) {
                    var w2 = Array.isArray(h2) ? h2[b2] : h2.type, _2 = y2[b2];
                    u2.concat(b2 + 1).checkSubtype(w2, _2.type);
                  }
                  if (0 === u2.errors.length)
                    return new xe(n2, a2, f2, y2);
                }
            }
            if (1 === s2.length)
              (r2 = e2.errors).push.apply(r2, u2.errors);
            else {
              for (var A2 = (s2.length ? s2 : o2).map(function(t3) {
                var e3;
                return e3 = t3[0], Array.isArray(e3) ? "(" + e3.map(Jt).join(", ") + ")" : "(" + Jt(e3.type) + "...)";
              }).join(" | "), S2 = [], k2 = 1; k2 < t2.length; k2++) {
                var I2 = e2.parse(t2[k2], 1 + S2.length);
                if (!I2)
                  return null;
                S2.push(Jt(I2.type));
              }
              e2.error("Expected arguments of type " + A2 + ", but found (" + S2.join(", ") + ") instead.");
            }
            return null;
          }, xe.register = function(t2, e2) {
            for (var r2 in xe.definitions = e2, e2)
              t2[r2] = xe;
          };
          var be = function(t2, e2, r2) {
            this.type = Kt, this.locale = r2, this.caseSensitive = t2, this.diacriticSensitive = e2;
          };
          function we(t2, e2) {
            t2[0] = Math.min(t2[0], e2[0]), t2[1] = Math.min(t2[1], e2[1]), t2[2] = Math.max(t2[2], e2[0]), t2[3] = Math.max(t2[3], e2[1]);
          }
          function _e(t2, e2) {
            return !(t2[0] <= e2[0] || t2[2] >= e2[2] || t2[1] <= e2[1] || t2[3] >= e2[3]);
          }
          function Ae(t2, e2) {
            var r2 = (180 + t2[0]) / 360, n2 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2[1] * Math.PI / 360))) / 360, i2 = Math.pow(2, e2.z);
            return [Math.round(r2 * i2 * 8192), Math.round(n2 * i2 * 8192)];
          }
          function Se(t2, e2, r2) {
            return e2[1] > t2[1] != r2[1] > t2[1] && t2[0] < (r2[0] - e2[0]) * (t2[1] - e2[1]) / (r2[1] - e2[1]) + e2[0];
          }
          function ke(t2, e2) {
            for (var r2, n2, i2, a2, o2, s2, u2, l2 = false, p2 = 0, c2 = e2.length; p2 < c2; p2++)
              for (var h2 = e2[p2], f2 = 0, y2 = h2.length; f2 < y2 - 1; f2++) {
                if ((a2 = (r2 = t2)[0] - (n2 = h2[f2])[0]) * (u2 = r2[1] - (i2 = h2[f2 + 1])[1]) - (s2 = r2[0] - i2[0]) * (o2 = r2[1] - n2[1]) == 0 && a2 * s2 <= 0 && o2 * u2 <= 0)
                  return false;
                Se(t2, h2[f2], h2[f2 + 1]) && (l2 = !l2);
              }
            return l2;
          }
          function Ie(t2, e2) {
            for (var r2 = 0; r2 < e2.length; r2++)
              if (ke(t2, e2[r2]))
                return true;
            return false;
          }
          function ze(t2, e2, r2, n2) {
            var i2 = n2[0] - r2[0], a2 = n2[1] - r2[1], o2 = (t2[0] - r2[0]) * a2 - i2 * (t2[1] - r2[1]), s2 = (e2[0] - r2[0]) * a2 - i2 * (e2[1] - r2[1]);
            return o2 > 0 && s2 < 0 || o2 < 0 && s2 > 0;
          }
          function Ce(t2, e2, r2) {
            for (var n2 = 0, i2 = r2; n2 < i2.length; n2 += 1)
              for (var a2 = i2[n2], o2 = 0; o2 < a2.length - 1; ++o2)
                if (0 != (c2 = [(p2 = a2[o2 + 1])[0] - (l2 = a2[o2])[0], p2[1] - l2[1]])[0] * (h2 = [(u2 = e2)[0] - (s2 = t2)[0], u2[1] - s2[1]])[1] - c2[1] * h2[0] && ze(s2, u2, l2, p2) && ze(l2, p2, s2, u2))
                  return true;
            var s2, u2, l2, p2, c2, h2;
            return false;
          }
          function Ee(t2, e2) {
            for (var r2 = 0; r2 < t2.length; ++r2)
              if (!ke(t2[r2], e2))
                return false;
            for (var n2 = 0; n2 < t2.length - 1; ++n2)
              if (Ce(t2[n2], t2[n2 + 1], e2))
                return false;
            return true;
          }
          function Pe(t2, e2) {
            for (var r2 = 0; r2 < e2.length; r2++)
              if (Ee(t2, e2[r2]))
                return true;
            return false;
          }
          function Me(t2, e2, r2) {
            for (var n2 = [], i2 = 0; i2 < t2.length; i2++) {
              for (var a2 = [], o2 = 0; o2 < t2[i2].length; o2++) {
                var s2 = Ae(t2[i2][o2], r2);
                we(e2, s2), a2.push(s2);
              }
              n2.push(a2);
            }
            return n2;
          }
          function Be(t2, e2, r2) {
            for (var n2 = [], i2 = 0; i2 < t2.length; i2++) {
              var a2 = Me(t2[i2], e2, r2);
              n2.push(a2);
            }
            return n2;
          }
          function Te(t2, e2, r2, n2) {
            if (t2[0] < r2[0] || t2[0] > r2[2]) {
              var i2 = 0.5 * n2, a2 = t2[0] - r2[0] > i2 ? -n2 : r2[0] - t2[0] > i2 ? n2 : 0;
              0 === a2 && (a2 = t2[0] - r2[2] > i2 ? -n2 : r2[2] - t2[0] > i2 ? n2 : 0), t2[0] += a2;
            }
            we(e2, t2);
          }
          function Ve(t2, e2, r2, n2) {
            for (var i2 = 8192 * Math.pow(2, n2.z), a2 = [8192 * n2.x, 8192 * n2.y], o2 = [], s2 = 0, u2 = t2; s2 < u2.length; s2 += 1)
              for (var l2 = 0, p2 = u2[s2]; l2 < p2.length; l2 += 1) {
                var c2 = p2[l2], h2 = [c2.x + a2[0], c2.y + a2[1]];
                Te(h2, e2, r2, i2), o2.push(h2);
              }
            return o2;
          }
          function Fe(t2, e2, r2, n2) {
            for (var i2, a2 = 8192 * Math.pow(2, n2.z), o2 = [8192 * n2.x, 8192 * n2.y], s2 = [], u2 = 0, l2 = t2; u2 < l2.length; u2 += 1) {
              for (var p2 = [], c2 = 0, h2 = l2[u2]; c2 < h2.length; c2 += 1) {
                var f2 = h2[c2], y2 = [f2.x + o2[0], f2.y + o2[1]];
                we(e2, y2), p2.push(y2);
              }
              s2.push(p2);
            }
            if (e2[2] - e2[0] <= a2 / 2) {
              (i2 = e2)[0] = i2[1] = 1 / 0, i2[2] = i2[3] = -1 / 0;
              for (var d2 = 0, m2 = s2; d2 < m2.length; d2 += 1)
                for (var v2 = 0, g2 = m2[d2]; v2 < g2.length; v2 += 1)
                  Te(g2[v2], e2, r2, a2);
            }
            return s2;
          }
          be.parse = function(t2, e2) {
            if (2 !== t2.length)
              return e2.error("Expected one argument.");
            var r2 = t2[1];
            if ("object" != typeof r2 || Array.isArray(r2))
              return e2.error("Collator options argument must be an object.");
            var n2 = e2.parse(void 0 !== r2["case-sensitive"] && r2["case-sensitive"], 1, Ut);
            if (!n2)
              return null;
            var i2 = e2.parse(void 0 !== r2["diacritic-sensitive"] && r2["diacritic-sensitive"], 1, Ut);
            if (!i2)
              return null;
            var a2 = null;
            return r2.locale && !(a2 = e2.parse(r2.locale, 1, Rt)) ? null : new be(n2, i2, a2);
          }, be.prototype.evaluate = function(t2) {
            return new ee(this.caseSensitive.evaluate(t2), this.diacriticSensitive.evaluate(t2), this.locale ? this.locale.evaluate(t2) : null);
          }, be.prototype.eachChild = function(t2) {
            t2(this.caseSensitive), t2(this.diacriticSensitive), this.locale && t2(this.locale);
          }, be.prototype.outputDefined = function() {
            return false;
          }, be.prototype.serialize = function() {
            var t2 = {};
            return t2["case-sensitive"] = this.caseSensitive.serialize(), t2["diacritic-sensitive"] = this.diacriticSensitive.serialize(), this.locale && (t2.locale = this.locale.serialize()), ["collator", t2];
          };
          var De = function(t2, e2) {
            this.type = Ut, this.geojson = t2, this.geometries = e2;
          };
          function Le(t2) {
            if (t2 instanceof xe) {
              if ("get" === t2.name && 1 === t2.args.length)
                return false;
              if ("feature-state" === t2.name)
                return false;
              if ("has" === t2.name && 1 === t2.args.length)
                return false;
              if ("properties" === t2.name || "geometry-type" === t2.name || "id" === t2.name)
                return false;
              if (/^filter-/.test(t2.name))
                return false;
            }
            if (t2 instanceof De)
              return false;
            var e2 = true;
            return t2.eachChild(function(t3) {
              e2 && !Le(t3) && (e2 = false);
            }), e2;
          }
          function Oe(t2) {
            if (t2 instanceof xe && "feature-state" === t2.name)
              return false;
            var e2 = true;
            return t2.eachChild(function(t3) {
              e2 && !Oe(t3) && (e2 = false);
            }), e2;
          }
          function Re(t2, e2) {
            if (t2 instanceof xe && e2.indexOf(t2.name) >= 0)
              return false;
            var r2 = true;
            return t2.eachChild(function(t3) {
              r2 && !Re(t3, e2) && (r2 = false);
            }), r2;
          }
          De.parse = function(t2, e2) {
            if (2 !== t2.length)
              return e2.error("'within' expression requires exactly one argument, but found " + (t2.length - 1) + " instead.");
            if (oe(t2[1])) {
              var r2 = t2[1];
              if ("FeatureCollection" === r2.type)
                for (var n2 = 0; n2 < r2.features.length; ++n2) {
                  var i2 = r2.features[n2].geometry.type;
                  if ("Polygon" === i2 || "MultiPolygon" === i2)
                    return new De(r2, r2.features[n2].geometry);
                }
              else if ("Feature" === r2.type) {
                var a2 = r2.geometry.type;
                if ("Polygon" === a2 || "MultiPolygon" === a2)
                  return new De(r2, r2.geometry);
              } else if ("Polygon" === r2.type || "MultiPolygon" === r2.type)
                return new De(r2, r2);
            }
            return e2.error("'within' expression requires valid geojson object that contains polygon geometry type.");
          }, De.prototype.evaluate = function(t2) {
            if (null != t2.geometry() && null != t2.canonicalID()) {
              if ("Point" === t2.geometryType())
                return function(t3, e2) {
                  var r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                  if ("Polygon" === e2.type) {
                    var a2 = Me(e2.coordinates, n2, i2), o2 = Ve(t3.geometry(), r2, n2, i2);
                    if (!_e(r2, n2))
                      return false;
                    for (var s2 = 0, u2 = o2; s2 < u2.length; s2 += 1)
                      if (!ke(u2[s2], a2))
                        return false;
                  }
                  if ("MultiPolygon" === e2.type) {
                    var l2 = Be(e2.coordinates, n2, i2), p2 = Ve(t3.geometry(), r2, n2, i2);
                    if (!_e(r2, n2))
                      return false;
                    for (var c2 = 0, h2 = p2; c2 < h2.length; c2 += 1)
                      if (!Ie(h2[c2], l2))
                        return false;
                  }
                  return true;
                }(t2, this.geometries);
              if ("LineString" === t2.geometryType())
                return function(t3, e2) {
                  var r2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i2 = t3.canonicalID();
                  if ("Polygon" === e2.type) {
                    var a2 = Me(e2.coordinates, n2, i2), o2 = Fe(t3.geometry(), r2, n2, i2);
                    if (!_e(r2, n2))
                      return false;
                    for (var s2 = 0, u2 = o2; s2 < u2.length; s2 += 1)
                      if (!Ee(u2[s2], a2))
                        return false;
                  }
                  if ("MultiPolygon" === e2.type) {
                    var l2 = Be(e2.coordinates, n2, i2), p2 = Fe(t3.geometry(), r2, n2, i2);
                    if (!_e(r2, n2))
                      return false;
                    for (var c2 = 0, h2 = p2; c2 < h2.length; c2 += 1)
                      if (!Pe(h2[c2], l2))
                        return false;
                  }
                  return true;
                }(t2, this.geometries);
            }
            return false;
          }, De.prototype.eachChild = function() {
          }, De.prototype.outputDefined = function() {
            return true;
          }, De.prototype.serialize = function() {
            return ["within", this.geojson];
          };
          var Ue = function(t2, e2) {
            this.type = e2.type, this.name = t2, this.boundExpression = e2;
          };
          Ue.parse = function(t2, e2) {
            if (2 !== t2.length || "string" != typeof t2[1])
              return e2.error("'var' expression requires exactly one string literal argument.");
            var r2 = t2[1];
            return e2.scope.has(r2) ? new Ue(r2, e2.scope.get(r2)) : e2.error('Unknown variable "' + r2 + '". Make sure "' + r2 + '" has been bound in an enclosing "let" expression before using it.', 1);
          }, Ue.prototype.evaluate = function(t2) {
            return this.boundExpression.evaluate(t2);
          }, Ue.prototype.eachChild = function() {
          }, Ue.prototype.outputDefined = function() {
            return false;
          }, Ue.prototype.serialize = function() {
            return ["var", this.name];
          };
          var je = function(t2, e2, r2, n2, i2) {
            void 0 === e2 && (e2 = []), void 0 === n2 && (n2 = new Dt()), void 0 === i2 && (i2 = []), this.registry = t2, this.path = e2, this.key = e2.map(function(t3) {
              return "[" + t3 + "]";
            }).join(""), this.scope = n2, this.errors = i2, this.expectedType = r2;
          };
          function qe(t2, e2) {
            for (var r2, n2 = t2.length - 1, i2 = 0, a2 = n2, o2 = 0; i2 <= a2; )
              if ((r2 = t2[o2 = Math.floor((i2 + a2) / 2)]) <= e2) {
                if (o2 === n2 || e2 < t2[o2 + 1])
                  return o2;
                i2 = o2 + 1;
              } else {
                if (!(r2 > e2))
                  throw new pe("Input is not a number.");
                a2 = o2 - 1;
              }
            return 0;
          }
          je.prototype.parse = function(t2, e2, r2, n2, i2) {
            return void 0 === i2 && (i2 = {}), e2 ? this.concat(e2, r2, n2)._parse(t2, i2) : this._parse(t2, i2);
          }, je.prototype._parse = function(t2, e2) {
            function r2(t3, e3, r3) {
              return "assert" === r3 ? new he(e3, [t3]) : "coerce" === r3 ? new me(e3, [t3]) : t3;
            }
            if (null !== t2 && "string" != typeof t2 && "boolean" != typeof t2 && "number" != typeof t2 || (t2 = ["literal", t2]), Array.isArray(t2)) {
              if (0 === t2.length)
                return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
              var n2 = t2[0];
              if ("string" != typeof n2)
                return this.error("Expression name must be a string, but found " + typeof n2 + ' instead. If you wanted a literal array, use ["literal", [...]].', 0), null;
              var i2 = this.registry[n2];
              if (i2) {
                var a2 = i2.parse(t2, this);
                if (!a2)
                  return null;
                if (this.expectedType) {
                  var o2 = this.expectedType, s2 = a2.type;
                  if ("string" !== o2.kind && "number" !== o2.kind && "boolean" !== o2.kind && "object" !== o2.kind && "array" !== o2.kind || "value" !== s2.kind)
                    if ("color" !== o2.kind && "formatted" !== o2.kind && "resolvedImage" !== o2.kind || "value" !== s2.kind && "string" !== s2.kind) {
                      if (this.checkSubtype(o2, s2))
                        return null;
                    } else
                      a2 = r2(a2, o2, e2.typeAnnotation || "coerce");
                  else
                    a2 = r2(a2, o2, e2.typeAnnotation || "assert");
                }
                if (!(a2 instanceof le) && "resolvedImage" !== a2.type.kind && function t3(e3) {
                  if (e3 instanceof Ue)
                    return t3(e3.boundExpression);
                  if (e3 instanceof xe && "error" === e3.name)
                    return false;
                  if (e3 instanceof be)
                    return false;
                  if (e3 instanceof De)
                    return false;
                  var r3 = e3 instanceof me || e3 instanceof he, n3 = true;
                  return e3.eachChild(function(e4) {
                    n3 = r3 ? n3 && t3(e4) : n3 && e4 instanceof le;
                  }), !!n3 && Le(e3) && Re(e3, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
                }(a2)) {
                  var u2 = new ge();
                  try {
                    a2 = new le(a2.type, a2.evaluate(u2));
                  } catch (t3) {
                    return this.error(t3.message), null;
                  }
                }
                return a2;
              }
              return this.error('Unknown expression "' + n2 + '". If you wanted a literal array, use ["literal", [...]].', 0);
            }
            return this.error(void 0 === t2 ? "'undefined' value invalid. Use null instead." : "object" == typeof t2 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : "Expected an array, but found " + typeof t2 + " instead.");
          }, je.prototype.concat = function(t2, e2, r2) {
            var n2 = "number" == typeof t2 ? this.path.concat(t2) : this.path, i2 = r2 ? this.scope.concat(r2) : this.scope;
            return new je(this.registry, n2, e2 || null, i2, this.errors);
          }, je.prototype.error = function(t2) {
            for (var e2 = [], r2 = arguments.length - 1; r2-- > 0; )
              e2[r2] = arguments[r2 + 1];
            var n2 = "" + this.key + e2.map(function(t3) {
              return "[" + t3 + "]";
            }).join("");
            this.errors.push(new Ft(n2, t2));
          }, je.prototype.checkSubtype = function(t2, e2) {
            var r2 = Yt(t2, e2);
            return r2 && this.error(r2), r2;
          };
          var Ne = function(t2, e2, r2) {
            this.type = t2, this.input = e2, this.labels = [], this.outputs = [];
            for (var n2 = 0, i2 = r2; n2 < i2.length; n2 += 1) {
              var a2 = i2[n2], o2 = a2[1];
              this.labels.push(a2[0]), this.outputs.push(o2);
            }
          };
          function Ke(t2, e2, r2) {
            return t2 * (1 - r2) + e2 * r2;
          }
          Ne.parse = function(t2, e2) {
            if (t2.length - 1 < 4)
              return e2.error("Expected at least 4 arguments, but found only " + (t2.length - 1) + ".");
            if ((t2.length - 1) % 2 != 0)
              return e2.error("Expected an even number of arguments.");
            var r2 = e2.parse(t2[1], 1, Ot);
            if (!r2)
              return null;
            var n2 = [], i2 = null;
            e2.expectedType && "value" !== e2.expectedType.kind && (i2 = e2.expectedType);
            for (var a2 = 1; a2 < t2.length; a2 += 2) {
              var o2 = 1 === a2 ? -1 / 0 : t2[a2], s2 = t2[a2 + 1], u2 = a2, l2 = a2 + 1;
              if ("number" != typeof o2)
                return e2.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', u2);
              if (n2.length && n2[n2.length - 1][0] >= o2)
                return e2.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', u2);
              var p2 = e2.parse(s2, l2, i2);
              if (!p2)
                return null;
              i2 = i2 || p2.type, n2.push([o2, p2]);
            }
            return new Ne(i2, r2, n2);
          }, Ne.prototype.evaluate = function(t2) {
            var e2 = this.labels, r2 = this.outputs;
            if (1 === e2.length)
              return r2[0].evaluate(t2);
            var n2 = this.input.evaluate(t2);
            if (n2 <= e2[0])
              return r2[0].evaluate(t2);
            var i2 = e2.length;
            return n2 >= e2[i2 - 1] ? r2[i2 - 1].evaluate(t2) : r2[qe(e2, n2)].evaluate(t2);
          }, Ne.prototype.eachChild = function(t2) {
            t2(this.input);
            for (var e2 = 0, r2 = this.outputs; e2 < r2.length; e2 += 1)
              t2(r2[e2]);
          }, Ne.prototype.outputDefined = function() {
            return this.outputs.every(function(t2) {
              return t2.outputDefined();
            });
          }, Ne.prototype.serialize = function() {
            for (var t2 = ["step", this.input.serialize()], e2 = 0; e2 < this.labels.length; e2++)
              e2 > 0 && t2.push(this.labels[e2]), t2.push(this.outputs[e2].serialize());
            return t2;
          };
          var Ge = Object.freeze({ __proto__: null, number: Ke, color: function(t2, e2, r2) {
            return new te(Ke(t2.r, e2.r, r2), Ke(t2.g, e2.g, r2), Ke(t2.b, e2.b, r2), Ke(t2.a, e2.a, r2));
          }, array: function(t2, e2, r2) {
            return t2.map(function(t3, n2) {
              return Ke(t3, e2[n2], r2);
            });
          } }), Ze = 6 / 29 * 3 * (6 / 29), Xe = Math.PI / 180, Je = 180 / Math.PI;
          function He(t2) {
            return t2 > 0.008856451679035631 ? Math.pow(t2, 1 / 3) : t2 / Ze + 4 / 29;
          }
          function Ye(t2) {
            return t2 > 6 / 29 ? t2 * t2 * t2 : Ze * (t2 - 4 / 29);
          }
          function $e(t2) {
            return 255 * (t2 <= 31308e-7 ? 12.92 * t2 : 1.055 * Math.pow(t2, 1 / 2.4) - 0.055);
          }
          function We(t2) {
            return (t2 /= 255) <= 0.04045 ? t2 / 12.92 : Math.pow((t2 + 0.055) / 1.055, 2.4);
          }
          function Qe(t2) {
            var e2 = We(t2.r), r2 = We(t2.g), n2 = We(t2.b), i2 = He((0.4124564 * e2 + 0.3575761 * r2 + 0.1804375 * n2) / 0.95047), a2 = He((0.2126729 * e2 + 0.7151522 * r2 + 0.072175 * n2) / 1);
            return { l: 116 * a2 - 16, a: 500 * (i2 - a2), b: 200 * (a2 - He((0.0193339 * e2 + 0.119192 * r2 + 0.9503041 * n2) / 1.08883)), alpha: t2.a };
          }
          function tr(t2) {
            var e2 = (t2.l + 16) / 116, r2 = isNaN(t2.a) ? e2 : e2 + t2.a / 500, n2 = isNaN(t2.b) ? e2 : e2 - t2.b / 200;
            return e2 = 1 * Ye(e2), r2 = 0.95047 * Ye(r2), n2 = 1.08883 * Ye(n2), new te($e(3.2404542 * r2 - 1.5371385 * e2 - 0.4985314 * n2), $e(-0.969266 * r2 + 1.8760108 * e2 + 0.041556 * n2), $e(0.0556434 * r2 - 0.2040259 * e2 + 1.0572252 * n2), t2.alpha);
          }
          function er(t2, e2, r2) {
            var n2 = e2 - t2;
            return t2 + r2 * (n2 > 180 || n2 < -180 ? n2 - 360 * Math.round(n2 / 360) : n2);
          }
          var rr = { forward: Qe, reverse: tr, interpolate: function(t2, e2, r2) {
            return { l: Ke(t2.l, e2.l, r2), a: Ke(t2.a, e2.a, r2), b: Ke(t2.b, e2.b, r2), alpha: Ke(t2.alpha, e2.alpha, r2) };
          } }, nr = { forward: function(t2) {
            var e2 = Qe(t2), r2 = e2.l, n2 = e2.a, i2 = e2.b, a2 = Math.atan2(i2, n2) * Je;
            return { h: a2 < 0 ? a2 + 360 : a2, c: Math.sqrt(n2 * n2 + i2 * i2), l: r2, alpha: t2.a };
          }, reverse: function(t2) {
            var e2 = t2.h * Xe, r2 = t2.c;
            return tr({ l: t2.l, a: Math.cos(e2) * r2, b: Math.sin(e2) * r2, alpha: t2.alpha });
          }, interpolate: function(t2, e2, r2) {
            return { h: er(t2.h, e2.h, r2), c: Ke(t2.c, e2.c, r2), l: Ke(t2.l, e2.l, r2), alpha: Ke(t2.alpha, e2.alpha, r2) };
          } }, ir = Object.freeze({ __proto__: null, lab: rr, hcl: nr }), ar = function(t2, e2, r2, n2, i2) {
            this.type = t2, this.operator = e2, this.interpolation = r2, this.input = n2, this.labels = [], this.outputs = [];
            for (var a2 = 0, o2 = i2; a2 < o2.length; a2 += 1) {
              var s2 = o2[a2], u2 = s2[1];
              this.labels.push(s2[0]), this.outputs.push(u2);
            }
          };
          function or2(t2, e2, r2, n2) {
            var i2 = n2 - r2, a2 = t2 - r2;
            return 0 === i2 ? 0 : 1 === e2 ? a2 / i2 : (Math.pow(e2, a2) - 1) / (Math.pow(e2, i2) - 1);
          }
          ar.interpolationFactor = function(t2, e2, n2, i2) {
            var a2 = 0;
            if ("exponential" === t2.name)
              a2 = or2(e2, t2.base, n2, i2);
            else if ("linear" === t2.name)
              a2 = or2(e2, 1, n2, i2);
            else if ("cubic-bezier" === t2.name) {
              var o2 = t2.controlPoints;
              a2 = new r(o2[0], o2[1], o2[2], o2[3]).solve(or2(e2, 1, n2, i2));
            }
            return a2;
          }, ar.parse = function(t2, e2) {
            var r2 = t2[0], n2 = t2[1], i2 = t2[2], a2 = t2.slice(3);
            if (!Array.isArray(n2) || 0 === n2.length)
              return e2.error("Expected an interpolation type expression.", 1);
            if ("linear" === n2[0])
              n2 = { name: "linear" };
            else if ("exponential" === n2[0]) {
              var o2 = n2[1];
              if ("number" != typeof o2)
                return e2.error("Exponential interpolation requires a numeric base.", 1, 1);
              n2 = { name: "exponential", base: o2 };
            } else {
              if ("cubic-bezier" !== n2[0])
                return e2.error("Unknown interpolation type " + String(n2[0]), 1, 0);
              var s2 = n2.slice(1);
              if (4 !== s2.length || s2.some(function(t3) {
                return "number" != typeof t3 || t3 < 0 || t3 > 1;
              }))
                return e2.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
              n2 = { name: "cubic-bezier", controlPoints: s2 };
            }
            if (t2.length - 1 < 4)
              return e2.error("Expected at least 4 arguments, but found only " + (t2.length - 1) + ".");
            if ((t2.length - 1) % 2 != 0)
              return e2.error("Expected an even number of arguments.");
            if (!(i2 = e2.parse(i2, 2, Ot)))
              return null;
            var u2 = [], l2 = null;
            "interpolate-hcl" === r2 || "interpolate-lab" === r2 ? l2 = jt : e2.expectedType && "value" !== e2.expectedType.kind && (l2 = e2.expectedType);
            for (var p2 = 0; p2 < a2.length; p2 += 2) {
              var c2 = a2[p2], h2 = a2[p2 + 1], f2 = p2 + 3, y2 = p2 + 4;
              if ("number" != typeof c2)
                return e2.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', f2);
              if (u2.length && u2[u2.length - 1][0] >= c2)
                return e2.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', f2);
              var d2 = e2.parse(h2, y2, l2);
              if (!d2)
                return null;
              l2 = l2 || d2.type, u2.push([c2, d2]);
            }
            return "number" === l2.kind || "color" === l2.kind || "array" === l2.kind && "number" === l2.itemType.kind && "number" == typeof l2.N ? new ar(l2, r2, n2, i2, u2) : e2.error("Type " + Jt(l2) + " is not interpolatable.");
          }, ar.prototype.evaluate = function(t2) {
            var e2 = this.labels, r2 = this.outputs;
            if (1 === e2.length)
              return r2[0].evaluate(t2);
            var n2 = this.input.evaluate(t2);
            if (n2 <= e2[0])
              return r2[0].evaluate(t2);
            var i2 = e2.length;
            if (n2 >= e2[i2 - 1])
              return r2[i2 - 1].evaluate(t2);
            var a2 = qe(e2, n2), o2 = ar.interpolationFactor(this.interpolation, n2, e2[a2], e2[a2 + 1]), s2 = r2[a2].evaluate(t2), u2 = r2[a2 + 1].evaluate(t2);
            return "interpolate" === this.operator ? Ge[this.type.kind.toLowerCase()](s2, u2, o2) : "interpolate-hcl" === this.operator ? nr.reverse(nr.interpolate(nr.forward(s2), nr.forward(u2), o2)) : rr.reverse(rr.interpolate(rr.forward(s2), rr.forward(u2), o2));
          }, ar.prototype.eachChild = function(t2) {
            t2(this.input);
            for (var e2 = 0, r2 = this.outputs; e2 < r2.length; e2 += 1)
              t2(r2[e2]);
          }, ar.prototype.outputDefined = function() {
            return this.outputs.every(function(t2) {
              return t2.outputDefined();
            });
          }, ar.prototype.serialize = function() {
            var t2;
            t2 = "linear" === this.interpolation.name ? ["linear"] : "exponential" === this.interpolation.name ? 1 === this.interpolation.base ? ["linear"] : ["exponential", this.interpolation.base] : ["cubic-bezier"].concat(this.interpolation.controlPoints);
            for (var e2 = [this.operator, t2, this.input.serialize()], r2 = 0; r2 < this.labels.length; r2++)
              e2.push(this.labels[r2], this.outputs[r2].serialize());
            return e2;
          };
          var sr = function(t2, e2) {
            this.type = t2, this.args = e2;
          };
          sr.parse = function(t2, e2) {
            if (t2.length < 2)
              return e2.error("Expectected at least one argument.");
            var r2 = null, n2 = e2.expectedType;
            n2 && "value" !== n2.kind && (r2 = n2);
            for (var i2 = [], a2 = 0, o2 = t2.slice(1); a2 < o2.length; a2 += 1) {
              var s2 = e2.parse(o2[a2], 1 + i2.length, r2, void 0, { typeAnnotation: "omit" });
              if (!s2)
                return null;
              r2 = r2 || s2.type, i2.push(s2);
            }
            var u2 = n2 && i2.some(function(t3) {
              return Yt(n2, t3.type);
            });
            return new sr(u2 ? Nt : r2, i2);
          }, sr.prototype.evaluate = function(t2) {
            for (var e2, r2 = null, n2 = 0, i2 = 0, a2 = this.args; i2 < a2.length && (n2++, (r2 = a2[i2].evaluate(t2)) && r2 instanceof ie && !r2.available && (e2 || (e2 = r2.name), r2 = null, n2 === this.args.length && (r2 = e2)), null === r2); i2 += 1)
              ;
            return r2;
          }, sr.prototype.eachChild = function(t2) {
            this.args.forEach(t2);
          }, sr.prototype.outputDefined = function() {
            return this.args.every(function(t2) {
              return t2.outputDefined();
            });
          }, sr.prototype.serialize = function() {
            var t2 = ["coalesce"];
            return this.eachChild(function(e2) {
              t2.push(e2.serialize());
            }), t2;
          };
          var ur = function(t2, e2) {
            this.type = e2.type, this.bindings = [].concat(t2), this.result = e2;
          };
          ur.prototype.evaluate = function(t2) {
            return this.result.evaluate(t2);
          }, ur.prototype.eachChild = function(t2) {
            for (var e2 = 0, r2 = this.bindings; e2 < r2.length; e2 += 1)
              t2(r2[e2][1]);
            t2(this.result);
          }, ur.parse = function(t2, e2) {
            if (t2.length < 4)
              return e2.error("Expected at least 3 arguments, but found " + (t2.length - 1) + " instead.");
            for (var r2 = [], n2 = 1; n2 < t2.length - 1; n2 += 2) {
              var i2 = t2[n2];
              if ("string" != typeof i2)
                return e2.error("Expected string, but found " + typeof i2 + " instead.", n2);
              if (/[^a-zA-Z0-9_]/.test(i2))
                return e2.error("Variable names must contain only alphanumeric characters or '_'.", n2);
              var a2 = e2.parse(t2[n2 + 1], n2 + 1);
              if (!a2)
                return null;
              r2.push([i2, a2]);
            }
            var o2 = e2.parse(t2[t2.length - 1], t2.length - 1, e2.expectedType, r2);
            return o2 ? new ur(r2, o2) : null;
          }, ur.prototype.outputDefined = function() {
            return this.result.outputDefined();
          }, ur.prototype.serialize = function() {
            for (var t2 = ["let"], e2 = 0, r2 = this.bindings; e2 < r2.length; e2 += 1) {
              var n2 = r2[e2];
              t2.push(n2[0], n2[1].serialize());
            }
            return t2.push(this.result.serialize()), t2;
          };
          var lr = function(t2, e2, r2) {
            this.type = t2, this.index = e2, this.input = r2;
          };
          lr.parse = function(t2, e2) {
            if (3 !== t2.length)
              return e2.error("Expected 2 arguments, but found " + (t2.length - 1) + " instead.");
            var r2 = e2.parse(t2[1], 1, Ot), n2 = e2.parse(t2[2], 2, Xt(e2.expectedType || Nt));
            return r2 && n2 ? new lr(n2.type.itemType, r2, n2) : null;
          }, lr.prototype.evaluate = function(t2) {
            var e2 = this.index.evaluate(t2), r2 = this.input.evaluate(t2);
            if (e2 < 0)
              throw new pe("Array index out of bounds: " + e2 + " < 0.");
            if (e2 >= r2.length)
              throw new pe("Array index out of bounds: " + e2 + " > " + (r2.length - 1) + ".");
            if (e2 !== Math.floor(e2))
              throw new pe("Array index must be an integer, but found " + e2 + " instead.");
            return r2[e2];
          }, lr.prototype.eachChild = function(t2) {
            t2(this.index), t2(this.input);
          }, lr.prototype.outputDefined = function() {
            return false;
          }, lr.prototype.serialize = function() {
            return ["at", this.index.serialize(), this.input.serialize()];
          };
          var pr = function(t2, e2) {
            this.type = Ut, this.needle = t2, this.haystack = e2;
          };
          pr.parse = function(t2, e2) {
            if (3 !== t2.length)
              return e2.error("Expected 2 arguments, but found " + (t2.length - 1) + " instead.");
            var r2 = e2.parse(t2[1], 1, Nt), n2 = e2.parse(t2[2], 2, Nt);
            return r2 && n2 ? $t(r2.type, [Ut, Rt, Ot, Lt, Nt]) ? new pr(r2, n2) : e2.error("Expected first argument to be of type boolean, string, number or null, but found " + Jt(r2.type) + " instead") : null;
          }, pr.prototype.evaluate = function(t2) {
            var e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
            if (!r2)
              return false;
            if (!Wt(e2, ["boolean", "string", "number", "null"]))
              throw new pe("Expected first argument to be of type boolean, string, number or null, but found " + Jt(se(e2)) + " instead.");
            if (!Wt(r2, ["string", "array"]))
              throw new pe("Expected second argument to be of type array or string, but found " + Jt(se(r2)) + " instead.");
            return r2.indexOf(e2) >= 0;
          }, pr.prototype.eachChild = function(t2) {
            t2(this.needle), t2(this.haystack);
          }, pr.prototype.outputDefined = function() {
            return true;
          }, pr.prototype.serialize = function() {
            return ["in", this.needle.serialize(), this.haystack.serialize()];
          };
          var cr = function(t2, e2, r2) {
            this.type = Ot, this.needle = t2, this.haystack = e2, this.fromIndex = r2;
          };
          cr.parse = function(t2, e2) {
            if (t2.length <= 2 || t2.length >= 5)
              return e2.error("Expected 3 or 4 arguments, but found " + (t2.length - 1) + " instead.");
            var r2 = e2.parse(t2[1], 1, Nt), n2 = e2.parse(t2[2], 2, Nt);
            if (!r2 || !n2)
              return null;
            if (!$t(r2.type, [Ut, Rt, Ot, Lt, Nt]))
              return e2.error("Expected first argument to be of type boolean, string, number or null, but found " + Jt(r2.type) + " instead");
            if (4 === t2.length) {
              var i2 = e2.parse(t2[3], 3, Ot);
              return i2 ? new cr(r2, n2, i2) : null;
            }
            return new cr(r2, n2);
          }, cr.prototype.evaluate = function(t2) {
            var e2 = this.needle.evaluate(t2), r2 = this.haystack.evaluate(t2);
            if (!Wt(e2, ["boolean", "string", "number", "null"]))
              throw new pe("Expected first argument to be of type boolean, string, number or null, but found " + Jt(se(e2)) + " instead.");
            if (!Wt(r2, ["string", "array"]))
              throw new pe("Expected second argument to be of type array or string, but found " + Jt(se(r2)) + " instead.");
            if (this.fromIndex) {
              var n2 = this.fromIndex.evaluate(t2);
              return r2.indexOf(e2, n2);
            }
            return r2.indexOf(e2);
          }, cr.prototype.eachChild = function(t2) {
            t2(this.needle), t2(this.haystack), this.fromIndex && t2(this.fromIndex);
          }, cr.prototype.outputDefined = function() {
            return false;
          }, cr.prototype.serialize = function() {
            if (null != this.fromIndex && void 0 !== this.fromIndex) {
              var t2 = this.fromIndex.serialize();
              return ["index-of", this.needle.serialize(), this.haystack.serialize(), t2];
            }
            return ["index-of", this.needle.serialize(), this.haystack.serialize()];
          };
          var hr = function(t2, e2, r2, n2, i2, a2) {
            this.inputType = t2, this.type = e2, this.input = r2, this.cases = n2, this.outputs = i2, this.otherwise = a2;
          };
          hr.parse = function(t2, e2) {
            if (t2.length < 5)
              return e2.error("Expected at least 4 arguments, but found only " + (t2.length - 1) + ".");
            if (t2.length % 2 != 1)
              return e2.error("Expected an even number of arguments.");
            var r2, n2;
            e2.expectedType && "value" !== e2.expectedType.kind && (n2 = e2.expectedType);
            for (var i2 = {}, a2 = [], o2 = 2; o2 < t2.length - 1; o2 += 2) {
              var s2 = t2[o2], u2 = t2[o2 + 1];
              Array.isArray(s2) || (s2 = [s2]);
              var l2 = e2.concat(o2);
              if (0 === s2.length)
                return l2.error("Expected at least one branch label.");
              for (var p2 = 0, c2 = s2; p2 < c2.length; p2 += 1) {
                var h2 = c2[p2];
                if ("number" != typeof h2 && "string" != typeof h2)
                  return l2.error("Branch labels must be numbers or strings.");
                if ("number" == typeof h2 && Math.abs(h2) > Number.MAX_SAFE_INTEGER)
                  return l2.error("Branch labels must be integers no larger than " + Number.MAX_SAFE_INTEGER + ".");
                if ("number" == typeof h2 && Math.floor(h2) !== h2)
                  return l2.error("Numeric branch labels must be integer values.");
                if (r2) {
                  if (l2.checkSubtype(r2, se(h2)))
                    return null;
                } else
                  r2 = se(h2);
                if (void 0 !== i2[String(h2)])
                  return l2.error("Branch labels must be unique.");
                i2[String(h2)] = a2.length;
              }
              var f2 = e2.parse(u2, o2, n2);
              if (!f2)
                return null;
              n2 = n2 || f2.type, a2.push(f2);
            }
            var y2 = e2.parse(t2[1], 1, Nt);
            if (!y2)
              return null;
            var d2 = e2.parse(t2[t2.length - 1], t2.length - 1, n2);
            return d2 ? "value" !== y2.type.kind && e2.concat(1).checkSubtype(r2, y2.type) ? null : new hr(r2, n2, y2, i2, a2, d2) : null;
          }, hr.prototype.evaluate = function(t2) {
            var e2 = this.input.evaluate(t2);
            return (se(e2) === this.inputType && this.outputs[this.cases[e2]] || this.otherwise).evaluate(t2);
          }, hr.prototype.eachChild = function(t2) {
            t2(this.input), this.outputs.forEach(t2), t2(this.otherwise);
          }, hr.prototype.outputDefined = function() {
            return this.outputs.every(function(t2) {
              return t2.outputDefined();
            }) && this.otherwise.outputDefined();
          }, hr.prototype.serialize = function() {
            for (var t2 = this, e2 = ["match", this.input.serialize()], r2 = [], n2 = {}, i2 = 0, a2 = Object.keys(this.cases).sort(); i2 < a2.length; i2 += 1) {
              var o2 = a2[i2];
              void 0 === (c2 = n2[this.cases[o2]]) ? (n2[this.cases[o2]] = r2.length, r2.push([this.cases[o2], [o2]])) : r2[c2][1].push(o2);
            }
            for (var s2 = function(e3) {
              return "number" === t2.inputType.kind ? Number(e3) : e3;
            }, u2 = 0, l2 = r2; u2 < l2.length; u2 += 1) {
              var p2 = l2[u2], c2 = p2[0], h2 = p2[1];
              e2.push(1 === h2.length ? s2(h2[0]) : h2.map(s2)), e2.push(this.outputs[outputIndex$1].serialize());
            }
            return e2.push(this.otherwise.serialize()), e2;
          };
          var fr = function(t2, e2, r2) {
            this.type = t2, this.branches = e2, this.otherwise = r2;
          };
          fr.parse = function(t2, e2) {
            if (t2.length < 4)
              return e2.error("Expected at least 3 arguments, but found only " + (t2.length - 1) + ".");
            if (t2.length % 2 != 0)
              return e2.error("Expected an odd number of arguments.");
            var r2;
            e2.expectedType && "value" !== e2.expectedType.kind && (r2 = e2.expectedType);
            for (var n2 = [], i2 = 1; i2 < t2.length - 1; i2 += 2) {
              var a2 = e2.parse(t2[i2], i2, Ut);
              if (!a2)
                return null;
              var o2 = e2.parse(t2[i2 + 1], i2 + 1, r2);
              if (!o2)
                return null;
              n2.push([a2, o2]), r2 = r2 || o2.type;
            }
            var s2 = e2.parse(t2[t2.length - 1], t2.length - 1, r2);
            return s2 ? new fr(r2, n2, s2) : null;
          }, fr.prototype.evaluate = function(t2) {
            for (var e2 = 0, r2 = this.branches; e2 < r2.length; e2 += 1) {
              var n2 = r2[e2], i2 = n2[1];
              if (n2[0].evaluate(t2))
                return i2.evaluate(t2);
            }
            return this.otherwise.evaluate(t2);
          }, fr.prototype.eachChild = function(t2) {
            for (var e2 = 0, r2 = this.branches; e2 < r2.length; e2 += 1) {
              var n2 = r2[e2], i2 = n2[1];
              t2(n2[0]), t2(i2);
            }
            t2(this.otherwise);
          }, fr.prototype.outputDefined = function() {
            return this.branches.every(function(t2) {
              return t2[1].outputDefined();
            }) && this.otherwise.outputDefined();
          }, fr.prototype.serialize = function() {
            var t2 = ["case"];
            return this.eachChild(function(e2) {
              t2.push(e2.serialize());
            }), t2;
          };
          var yr = function(t2, e2, r2, n2) {
            this.type = t2, this.input = e2, this.beginIndex = r2, this.endIndex = n2;
          };
          function dr(t2, e2) {
            return "==" === t2 || "!=" === t2 ? "boolean" === e2.kind || "string" === e2.kind || "number" === e2.kind || "null" === e2.kind || "value" === e2.kind : "string" === e2.kind || "number" === e2.kind || "value" === e2.kind;
          }
          function mr(t2, e2, r2, n2) {
            return 0 === n2.compare(e2, r2);
          }
          function vr(t2, e2, r2) {
            var n2 = "==" !== t2 && "!=" !== t2;
            return function() {
              function i2(t3, e3, r3) {
                this.type = Ut, this.lhs = t3, this.rhs = e3, this.collator = r3, this.hasUntypedArgument = "value" === t3.type.kind || "value" === e3.type.kind;
              }
              return i2.parse = function(t3, e3) {
                if (3 !== t3.length && 4 !== t3.length)
                  return e3.error("Expected two or three arguments.");
                var r3 = t3[0], a2 = e3.parse(t3[1], 1, Nt);
                if (!a2)
                  return null;
                if (!dr(r3, a2.type))
                  return e3.concat(1).error('"' + r3 + `" comparisons are not supported for type '` + Jt(a2.type) + "'.");
                var o2 = e3.parse(t3[2], 2, Nt);
                if (!o2)
                  return null;
                if (!dr(r3, o2.type))
                  return e3.concat(2).error('"' + r3 + `" comparisons are not supported for type '` + Jt(o2.type) + "'.");
                if (a2.type.kind !== o2.type.kind && "value" !== a2.type.kind && "value" !== o2.type.kind)
                  return e3.error("Cannot compare types '" + Jt(a2.type) + "' and '" + Jt(o2.type) + "'.");
                n2 && ("value" === a2.type.kind && "value" !== o2.type.kind ? a2 = new he(o2.type, [a2]) : "value" !== a2.type.kind && "value" === o2.type.kind && (o2 = new he(a2.type, [o2])));
                var s2 = null;
                if (4 === t3.length) {
                  if ("string" !== a2.type.kind && "string" !== o2.type.kind && "value" !== a2.type.kind && "value" !== o2.type.kind)
                    return e3.error("Cannot use collator to compare non-string types.");
                  if (!(s2 = e3.parse(t3[3], 3, Kt)))
                    return null;
                }
                return new i2(a2, o2, s2);
              }, i2.prototype.evaluate = function(i3) {
                var a2 = this.lhs.evaluate(i3), o2 = this.rhs.evaluate(i3);
                if (n2 && this.hasUntypedArgument) {
                  var s2 = se(a2), u2 = se(o2);
                  if (s2.kind !== u2.kind || "string" !== s2.kind && "number" !== s2.kind)
                    throw new pe('Expected arguments for "' + t2 + '" to be (string, string) or (number, number), but found (' + s2.kind + ", " + u2.kind + ") instead.");
                }
                if (this.collator && !n2 && this.hasUntypedArgument) {
                  var l2 = se(a2), p2 = se(o2);
                  if ("string" !== l2.kind || "string" !== p2.kind)
                    return e2(i3, a2, o2);
                }
                return this.collator ? r2(i3, a2, o2, this.collator.evaluate(i3)) : e2(i3, a2, o2);
              }, i2.prototype.eachChild = function(t3) {
                t3(this.lhs), t3(this.rhs), this.collator && t3(this.collator);
              }, i2.prototype.outputDefined = function() {
                return true;
              }, i2.prototype.serialize = function() {
                var e3 = [t2];
                return this.eachChild(function(t3) {
                  e3.push(t3.serialize());
                }), e3;
              }, i2;
            }();
          }
          yr.parse = function(t2, e2) {
            if (t2.length <= 2 || t2.length >= 5)
              return e2.error("Expected 3 or 4 arguments, but found " + (t2.length - 1) + " instead.");
            var r2 = e2.parse(t2[1], 1, Nt), n2 = e2.parse(t2[2], 2, Ot);
            if (!r2 || !n2)
              return null;
            if (!$t(r2.type, [Xt(Nt), Rt, Nt]))
              return e2.error("Expected first argument to be of type array or string, but found " + Jt(r2.type) + " instead");
            if (4 === t2.length) {
              var i2 = e2.parse(t2[3], 3, Ot);
              return i2 ? new yr(r2.type, r2, n2, i2) : null;
            }
            return new yr(r2.type, r2, n2);
          }, yr.prototype.evaluate = function(t2) {
            var e2 = this.input.evaluate(t2), r2 = this.beginIndex.evaluate(t2);
            if (!Wt(e2, ["string", "array"]))
              throw new pe("Expected first argument to be of type array or string, but found " + Jt(se(e2)) + " instead.");
            if (this.endIndex) {
              var n2 = this.endIndex.evaluate(t2);
              return e2.slice(r2, n2);
            }
            return e2.slice(r2);
          }, yr.prototype.eachChild = function(t2) {
            t2(this.input), t2(this.beginIndex), this.endIndex && t2(this.endIndex);
          }, yr.prototype.outputDefined = function() {
            return false;
          }, yr.prototype.serialize = function() {
            if (null != this.endIndex && void 0 !== this.endIndex) {
              var t2 = this.endIndex.serialize();
              return ["slice", this.input.serialize(), this.beginIndex.serialize(), t2];
            }
            return ["slice", this.input.serialize(), this.beginIndex.serialize()];
          };
          var gr = vr("==", function(t2, e2, r2) {
            return e2 === r2;
          }, mr), xr = vr("!=", function(t2, e2, r2) {
            return e2 !== r2;
          }, function(t2, e2, r2, n2) {
            return !mr(0, e2, r2, n2);
          }), br = vr("<", function(t2, e2, r2) {
            return e2 < r2;
          }, function(t2, e2, r2, n2) {
            return n2.compare(e2, r2) < 0;
          }), wr = vr(">", function(t2, e2, r2) {
            return e2 > r2;
          }, function(t2, e2, r2, n2) {
            return n2.compare(e2, r2) > 0;
          }), _r = vr("<=", function(t2, e2, r2) {
            return e2 <= r2;
          }, function(t2, e2, r2, n2) {
            return n2.compare(e2, r2) <= 0;
          }), Ar = vr(">=", function(t2, e2, r2) {
            return e2 >= r2;
          }, function(t2, e2, r2, n2) {
            return n2.compare(e2, r2) >= 0;
          }), Sr = function(t2, e2, r2, n2, i2) {
            this.type = Rt, this.number = t2, this.locale = e2, this.currency = r2, this.minFractionDigits = n2, this.maxFractionDigits = i2;
          };
          Sr.parse = function(t2, e2) {
            if (3 !== t2.length)
              return e2.error("Expected two arguments.");
            var r2 = e2.parse(t2[1], 1, Ot);
            if (!r2)
              return null;
            var n2 = t2[2];
            if ("object" != typeof n2 || Array.isArray(n2))
              return e2.error("NumberFormat options argument must be an object.");
            var i2 = null;
            if (n2.locale && !(i2 = e2.parse(n2.locale, 1, Rt)))
              return null;
            var a2 = null;
            if (n2.currency && !(a2 = e2.parse(n2.currency, 1, Rt)))
              return null;
            var o2 = null;
            if (n2["min-fraction-digits"] && !(o2 = e2.parse(n2["min-fraction-digits"], 1, Ot)))
              return null;
            var s2 = null;
            return n2["max-fraction-digits"] && !(s2 = e2.parse(n2["max-fraction-digits"], 1, Ot)) ? null : new Sr(r2, i2, a2, o2, s2);
          }, Sr.prototype.evaluate = function(t2) {
            return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t2) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t2) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t2) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t2) : void 0 }).format(this.number.evaluate(t2));
          }, Sr.prototype.eachChild = function(t2) {
            t2(this.number), this.locale && t2(this.locale), this.currency && t2(this.currency), this.minFractionDigits && t2(this.minFractionDigits), this.maxFractionDigits && t2(this.maxFractionDigits);
          }, Sr.prototype.outputDefined = function() {
            return false;
          }, Sr.prototype.serialize = function() {
            var t2 = {};
            return this.locale && (t2.locale = this.locale.serialize()), this.currency && (t2.currency = this.currency.serialize()), this.minFractionDigits && (t2["min-fraction-digits"] = this.minFractionDigits.serialize()), this.maxFractionDigits && (t2["max-fraction-digits"] = this.maxFractionDigits.serialize()), ["number-format", this.number.serialize(), t2];
          };
          var kr = function(t2) {
            this.type = Ot, this.input = t2;
          };
          kr.parse = function(t2, e2) {
            if (2 !== t2.length)
              return e2.error("Expected 1 argument, but found " + (t2.length - 1) + " instead.");
            var r2 = e2.parse(t2[1], 1);
            return r2 ? "array" !== r2.type.kind && "string" !== r2.type.kind && "value" !== r2.type.kind ? e2.error("Expected argument of type string or array, but found " + Jt(r2.type) + " instead.") : new kr(r2) : null;
          }, kr.prototype.evaluate = function(t2) {
            var e2 = this.input.evaluate(t2);
            if ("string" == typeof e2)
              return e2.length;
            if (Array.isArray(e2))
              return e2.length;
            throw new pe("Expected value to be of type string or array, but found " + Jt(se(e2)) + " instead.");
          }, kr.prototype.eachChild = function(t2) {
            t2(this.input);
          }, kr.prototype.outputDefined = function() {
            return false;
          }, kr.prototype.serialize = function() {
            var t2 = ["length"];
            return this.eachChild(function(e2) {
              t2.push(e2.serialize());
            }), t2;
          };
          var Ir = { "==": gr, "!=": xr, ">": wr, "<": br, ">=": Ar, "<=": _r, array: he, at: lr, boolean: he, case: fr, coalesce: sr, collator: be, format: fe, image: ye, in: pr, "index-of": cr, interpolate: ar, "interpolate-hcl": ar, "interpolate-lab": ar, length: kr, let: ur, literal: le, match: hr, number: he, "number-format": Sr, object: he, slice: yr, step: Ne, string: he, "to-boolean": me, "to-color": me, "to-number": me, "to-string": me, var: Ue, within: De };
          function zr(t2, e2) {
            var r2 = e2[0], n2 = e2[1], i2 = e2[2], a2 = e2[3];
            r2 = r2.evaluate(t2), n2 = n2.evaluate(t2), i2 = i2.evaluate(t2);
            var o2 = a2 ? a2.evaluate(t2) : 1, s2 = ae(r2, n2, i2, o2);
            if (s2)
              throw new pe(s2);
            return new te(r2 / 255 * o2, n2 / 255 * o2, i2 / 255 * o2, o2);
          }
          function Cr(t2, e2) {
            return t2 in e2;
          }
          function Er(t2, e2) {
            var r2 = e2[t2];
            return void 0 === r2 ? null : r2;
          }
          function Pr(t2) {
            return { type: t2 };
          }
          function Mr(t2) {
            return { result: "success", value: t2 };
          }
          function Br(t2) {
            return { result: "error", value: t2 };
          }
          function Tr(t2) {
            return "data-driven" === t2["property-type"] || "cross-faded-data-driven" === t2["property-type"];
          }
          function Vr(t2) {
            return !!t2.expression && t2.expression.parameters.indexOf("zoom") > -1;
          }
          function Fr(t2) {
            return !!t2.expression && t2.expression.interpolated;
          }
          function Dr(t2) {
            return t2 instanceof Number ? "number" : t2 instanceof String ? "string" : t2 instanceof Boolean ? "boolean" : Array.isArray(t2) ? "array" : null === t2 ? "null" : typeof t2;
          }
          function Lr(t2) {
            return "object" == typeof t2 && null !== t2 && !Array.isArray(t2);
          }
          function Or(t2) {
            return t2;
          }
          function Rr(t2, e2, r2) {
            return void 0 !== t2 ? t2 : void 0 !== e2 ? e2 : void 0 !== r2 ? r2 : void 0;
          }
          function Ur(t2, e2, r2, n2, i2) {
            return Rr(typeof r2 === i2 ? n2[r2] : void 0, t2.default, e2.default);
          }
          function jr(t2, e2, r2) {
            if ("number" !== Dr(r2))
              return Rr(t2.default, e2.default);
            var n2 = t2.stops.length;
            if (1 === n2)
              return t2.stops[0][1];
            if (r2 <= t2.stops[0][0])
              return t2.stops[0][1];
            if (r2 >= t2.stops[n2 - 1][0])
              return t2.stops[n2 - 1][1];
            var i2 = qe(t2.stops.map(function(t3) {
              return t3[0];
            }), r2);
            return t2.stops[i2][1];
          }
          function qr(t2, e2, r2) {
            var n2 = void 0 !== t2.base ? t2.base : 1;
            if ("number" !== Dr(r2))
              return Rr(t2.default, e2.default);
            var i2 = t2.stops.length;
            if (1 === i2)
              return t2.stops[0][1];
            if (r2 <= t2.stops[0][0])
              return t2.stops[0][1];
            if (r2 >= t2.stops[i2 - 1][0])
              return t2.stops[i2 - 1][1];
            var a2 = qe(t2.stops.map(function(t3) {
              return t3[0];
            }), r2), o2 = function(t3, e3, r3, n3) {
              var i3 = n3 - r3, a3 = t3 - r3;
              return 0 === i3 ? 0 : 1 === e3 ? a3 / i3 : (Math.pow(e3, a3) - 1) / (Math.pow(e3, i3) - 1);
            }(r2, n2, t2.stops[a2][0], t2.stops[a2 + 1][0]), s2 = t2.stops[a2][1], u2 = t2.stops[a2 + 1][1], l2 = Ge[e2.type] || Or;
            if (t2.colorSpace && "rgb" !== t2.colorSpace) {
              var p2 = ir[t2.colorSpace];
              l2 = function(t3, e3) {
                return p2.reverse(p2.interpolate(p2.forward(t3), p2.forward(e3), o2));
              };
            }
            return "function" == typeof s2.evaluate ? { evaluate: function() {
              for (var t3 = [], e3 = arguments.length; e3--; )
                t3[e3] = arguments[e3];
              var r3 = s2.evaluate.apply(void 0, t3), n3 = u2.evaluate.apply(void 0, t3);
              if (void 0 !== r3 && void 0 !== n3)
                return l2(r3, n3, o2);
            } } : l2(s2, u2, o2);
          }
          function Nr(t2, e2, r2) {
            return "color" === e2.type ? r2 = te.parse(r2) : "formatted" === e2.type ? r2 = ne.fromString(r2.toString()) : "resolvedImage" === e2.type ? r2 = ie.fromString(r2.toString()) : Dr(r2) === e2.type || "enum" === e2.type && e2.values[r2] || (r2 = void 0), Rr(r2, t2.default, e2.default);
          }
          xe.register(Ir, { error: [{ kind: "error" }, [Rt], function(t2, e2) {
            throw new pe(e2[0].evaluate(t2));
          }], typeof: [Rt, [Nt], function(t2, e2) {
            return Jt(se(e2[0].evaluate(t2)));
          }], "to-rgba": [Xt(Ot, 4), [jt], function(t2, e2) {
            return e2[0].evaluate(t2).toArray();
          }], rgb: [jt, [Ot, Ot, Ot], zr], rgba: [jt, [Ot, Ot, Ot, Ot], zr], has: { type: Ut, overloads: [[[Rt], function(t2, e2) {
            return Cr(e2[0].evaluate(t2), t2.properties());
          }], [[Rt, qt], function(t2, e2) {
            var r2 = e2[1];
            return Cr(e2[0].evaluate(t2), r2.evaluate(t2));
          }]] }, get: { type: Nt, overloads: [[[Rt], function(t2, e2) {
            return Er(e2[0].evaluate(t2), t2.properties());
          }], [[Rt, qt], function(t2, e2) {
            var r2 = e2[1];
            return Er(e2[0].evaluate(t2), r2.evaluate(t2));
          }]] }, "feature-state": [Nt, [Rt], function(t2, e2) {
            return Er(e2[0].evaluate(t2), t2.featureState || {});
          }], properties: [qt, [], function(t2) {
            return t2.properties();
          }], "geometry-type": [Rt, [], function(t2) {
            return t2.geometryType();
          }], id: [Nt, [], function(t2) {
            return t2.id();
          }], zoom: [Ot, [], function(t2) {
            return t2.globals.zoom;
          }], "heatmap-density": [Ot, [], function(t2) {
            return t2.globals.heatmapDensity || 0;
          }], "line-progress": [Ot, [], function(t2) {
            return t2.globals.lineProgress || 0;
          }], accumulated: [Nt, [], function(t2) {
            return void 0 === t2.globals.accumulated ? null : t2.globals.accumulated;
          }], "+": [Ot, Pr(Ot), function(t2, e2) {
            for (var r2 = 0, n2 = 0, i2 = e2; n2 < i2.length; n2 += 1)
              r2 += i2[n2].evaluate(t2);
            return r2;
          }], "*": [Ot, Pr(Ot), function(t2, e2) {
            for (var r2 = 1, n2 = 0, i2 = e2; n2 < i2.length; n2 += 1)
              r2 *= i2[n2].evaluate(t2);
            return r2;
          }], "-": { type: Ot, overloads: [[[Ot, Ot], function(t2, e2) {
            var r2 = e2[1];
            return e2[0].evaluate(t2) - r2.evaluate(t2);
          }], [[Ot], function(t2, e2) {
            return -e2[0].evaluate(t2);
          }]] }, "/": [Ot, [Ot, Ot], function(t2, e2) {
            var r2 = e2[1];
            return e2[0].evaluate(t2) / r2.evaluate(t2);
          }], "%": [Ot, [Ot, Ot], function(t2, e2) {
            var r2 = e2[1];
            return e2[0].evaluate(t2) % r2.evaluate(t2);
          }], ln2: [Ot, [], function() {
            return Math.LN2;
          }], pi: [Ot, [], function() {
            return Math.PI;
          }], e: [Ot, [], function() {
            return Math.E;
          }], "^": [Ot, [Ot, Ot], function(t2, e2) {
            var r2 = e2[1];
            return Math.pow(e2[0].evaluate(t2), r2.evaluate(t2));
          }], sqrt: [Ot, [Ot], function(t2, e2) {
            return Math.sqrt(e2[0].evaluate(t2));
          }], log10: [Ot, [Ot], function(t2, e2) {
            return Math.log(e2[0].evaluate(t2)) / Math.LN10;
          }], ln: [Ot, [Ot], function(t2, e2) {
            return Math.log(e2[0].evaluate(t2));
          }], log2: [Ot, [Ot], function(t2, e2) {
            return Math.log(e2[0].evaluate(t2)) / Math.LN2;
          }], sin: [Ot, [Ot], function(t2, e2) {
            return Math.sin(e2[0].evaluate(t2));
          }], cos: [Ot, [Ot], function(t2, e2) {
            return Math.cos(e2[0].evaluate(t2));
          }], tan: [Ot, [Ot], function(t2, e2) {
            return Math.tan(e2[0].evaluate(t2));
          }], asin: [Ot, [Ot], function(t2, e2) {
            return Math.asin(e2[0].evaluate(t2));
          }], acos: [Ot, [Ot], function(t2, e2) {
            return Math.acos(e2[0].evaluate(t2));
          }], atan: [Ot, [Ot], function(t2, e2) {
            return Math.atan(e2[0].evaluate(t2));
          }], min: [Ot, Pr(Ot), function(t2, e2) {
            return Math.min.apply(Math, e2.map(function(e3) {
              return e3.evaluate(t2);
            }));
          }], max: [Ot, Pr(Ot), function(t2, e2) {
            return Math.max.apply(Math, e2.map(function(e3) {
              return e3.evaluate(t2);
            }));
          }], abs: [Ot, [Ot], function(t2, e2) {
            return Math.abs(e2[0].evaluate(t2));
          }], round: [Ot, [Ot], function(t2, e2) {
            var r2 = e2[0].evaluate(t2);
            return r2 < 0 ? -Math.round(-r2) : Math.round(r2);
          }], floor: [Ot, [Ot], function(t2, e2) {
            return Math.floor(e2[0].evaluate(t2));
          }], ceil: [Ot, [Ot], function(t2, e2) {
            return Math.ceil(e2[0].evaluate(t2));
          }], "filter-==": [Ut, [Rt, Nt], function(t2, e2) {
            var r2 = e2[0], n2 = e2[1];
            return t2.properties()[r2.value] === n2.value;
          }], "filter-id-==": [Ut, [Nt], function(t2, e2) {
            var r2 = e2[0];
            return t2.id() === r2.value;
          }], "filter-type-==": [Ut, [Rt], function(t2, e2) {
            var r2 = e2[0];
            return t2.geometryType() === r2.value;
          }], "filter-<": [Ut, [Rt, Nt], function(t2, e2) {
            var r2 = e2[0], n2 = e2[1], i2 = t2.properties()[r2.value], a2 = n2.value;
            return typeof i2 == typeof a2 && i2 < a2;
          }], "filter-id-<": [Ut, [Nt], function(t2, e2) {
            var r2 = e2[0], n2 = t2.id(), i2 = r2.value;
            return typeof n2 == typeof i2 && n2 < i2;
          }], "filter->": [Ut, [Rt, Nt], function(t2, e2) {
            var r2 = e2[0], n2 = e2[1], i2 = t2.properties()[r2.value], a2 = n2.value;
            return typeof i2 == typeof a2 && i2 > a2;
          }], "filter-id->": [Ut, [Nt], function(t2, e2) {
            var r2 = e2[0], n2 = t2.id(), i2 = r2.value;
            return typeof n2 == typeof i2 && n2 > i2;
          }], "filter-<=": [Ut, [Rt, Nt], function(t2, e2) {
            var r2 = e2[0], n2 = e2[1], i2 = t2.properties()[r2.value], a2 = n2.value;
            return typeof i2 == typeof a2 && i2 <= a2;
          }], "filter-id-<=": [Ut, [Nt], function(t2, e2) {
            var r2 = e2[0], n2 = t2.id(), i2 = r2.value;
            return typeof n2 == typeof i2 && n2 <= i2;
          }], "filter->=": [Ut, [Rt, Nt], function(t2, e2) {
            var r2 = e2[0], n2 = e2[1], i2 = t2.properties()[r2.value], a2 = n2.value;
            return typeof i2 == typeof a2 && i2 >= a2;
          }], "filter-id->=": [Ut, [Nt], function(t2, e2) {
            var r2 = e2[0], n2 = t2.id(), i2 = r2.value;
            return typeof n2 == typeof i2 && n2 >= i2;
          }], "filter-has": [Ut, [Nt], function(t2, e2) {
            return e2[0].value in t2.properties();
          }], "filter-has-id": [Ut, [], function(t2) {
            return null !== t2.id() && void 0 !== t2.id();
          }], "filter-type-in": [Ut, [Xt(Rt)], function(t2, e2) {
            return e2[0].value.indexOf(t2.geometryType()) >= 0;
          }], "filter-id-in": [Ut, [Xt(Nt)], function(t2, e2) {
            return e2[0].value.indexOf(t2.id()) >= 0;
          }], "filter-in-small": [Ut, [Rt, Xt(Nt)], function(t2, e2) {
            var r2 = e2[0];
            return e2[1].value.indexOf(t2.properties()[r2.value]) >= 0;
          }], "filter-in-large": [Ut, [Rt, Xt(Nt)], function(t2, e2) {
            var r2 = e2[0], n2 = e2[1];
            return function(t3, e3, r3, n3) {
              for (; r3 <= n3; ) {
                var i2 = r3 + n3 >> 1;
                if (e3[i2] === t3)
                  return true;
                e3[i2] > t3 ? n3 = i2 - 1 : r3 = i2 + 1;
              }
              return false;
            }(t2.properties()[r2.value], n2.value, 0, n2.value.length - 1);
          }], all: { type: Ut, overloads: [[[Ut, Ut], function(t2, e2) {
            var r2 = e2[1];
            return e2[0].evaluate(t2) && r2.evaluate(t2);
          }], [Pr(Ut), function(t2, e2) {
            for (var r2 = 0, n2 = e2; r2 < n2.length; r2 += 1)
              if (!n2[r2].evaluate(t2))
                return false;
            return true;
          }]] }, any: { type: Ut, overloads: [[[Ut, Ut], function(t2, e2) {
            var r2 = e2[1];
            return e2[0].evaluate(t2) || r2.evaluate(t2);
          }], [Pr(Ut), function(t2, e2) {
            for (var r2 = 0, n2 = e2; r2 < n2.length; r2 += 1)
              if (n2[r2].evaluate(t2))
                return true;
            return false;
          }]] }, "!": [Ut, [Ut], function(t2, e2) {
            return !e2[0].evaluate(t2);
          }], "is-supported-script": [Ut, [Rt], function(t2, e2) {
            var r2 = t2.globals && t2.globals.isSupportedScript;
            return !r2 || r2(e2[0].evaluate(t2));
          }], upcase: [Rt, [Rt], function(t2, e2) {
            return e2[0].evaluate(t2).toUpperCase();
          }], downcase: [Rt, [Rt], function(t2, e2) {
            return e2[0].evaluate(t2).toLowerCase();
          }], concat: [Rt, Pr(Nt), function(t2, e2) {
            return e2.map(function(e3) {
              return ue(e3.evaluate(t2));
            }).join("");
          }], "resolved-locale": [Rt, [Kt], function(t2, e2) {
            return e2[0].evaluate(t2).resolvedLocale();
          }] });
          var Kr = function(t2, e2) {
            this.expression = t2, this._warningHistory = {}, this._evaluator = new ge(), this._defaultValue = e2 ? function(t3) {
              return "color" === t3.type && Lr(t3.default) ? new te(0, 0, 0, 0) : "color" === t3.type ? te.parse(t3.default) || null : void 0 === t3.default ? null : t3.default;
            }(e2) : null, this._enumValues = e2 && "enum" === e2.type ? e2.values : null;
          };
          function Gr(t2) {
            return Array.isArray(t2) && t2.length > 0 && "string" == typeof t2[0] && t2[0] in Ir;
          }
          function Zr(t2, e2) {
            var r2 = new je(Ir, [], e2 ? function(t3) {
              var e3 = { color: jt, string: Rt, number: Ot, enum: Rt, boolean: Ut, formatted: Gt, resolvedImage: Zt };
              return "array" === t3.type ? Xt(e3[t3.value] || Nt, t3.length) : e3[t3.type];
            }(e2) : void 0), n2 = r2.parse(t2, void 0, void 0, void 0, e2 && "string" === e2.type ? { typeAnnotation: "coerce" } : void 0);
            return n2 ? Mr(new Kr(n2, e2)) : Br(r2.errors);
          }
          Kr.prototype.evaluateWithoutErrorHandling = function(t2, e2, r2, n2, i2, a2) {
            return this._evaluator.globals = t2, this._evaluator.feature = e2, this._evaluator.featureState = r2, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = a2, this.expression.evaluate(this._evaluator);
          }, Kr.prototype.evaluate = function(t2, e2, r2, n2, i2, a2) {
            this._evaluator.globals = t2, this._evaluator.feature = e2 || null, this._evaluator.featureState = r2 || null, this._evaluator.canonical = n2, this._evaluator.availableImages = i2 || null, this._evaluator.formattedSection = a2 || null;
            try {
              var o2 = this.expression.evaluate(this._evaluator);
              if (null == o2 || "number" == typeof o2 && o2 != o2)
                return this._defaultValue;
              if (this._enumValues && !(o2 in this._enumValues))
                throw new pe("Expected value to be one of " + Object.keys(this._enumValues).map(function(t3) {
                  return JSON.stringify(t3);
                }).join(", ") + ", but found " + JSON.stringify(o2) + " instead.");
              return o2;
            } catch (t3) {
              return this._warningHistory[t3.message] || (this._warningHistory[t3.message] = true, "undefined" != typeof console && console.warn(t3.message)), this._defaultValue;
            }
          };
          var Xr = function(t2, e2) {
            this.kind = t2, this._styleExpression = e2, this.isStateDependent = "constant" !== t2 && !Oe(e2.expression);
          };
          Xr.prototype.evaluateWithoutErrorHandling = function(t2, e2, r2, n2, i2, a2) {
            return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, a2);
          }, Xr.prototype.evaluate = function(t2, e2, r2, n2, i2, a2) {
            return this._styleExpression.evaluate(t2, e2, r2, n2, i2, a2);
          };
          var Jr = function(t2, e2, r2, n2) {
            this.kind = t2, this.zoomStops = r2, this._styleExpression = e2, this.isStateDependent = "camera" !== t2 && !Oe(e2.expression), this.interpolationType = n2;
          };
          function Hr(t2, e2) {
            if ("error" === (t2 = Zr(t2, e2)).result)
              return t2;
            var r2 = t2.value.expression, n2 = Le(r2);
            if (!n2 && !Tr(e2))
              return Br([new Ft("", "data expressions not supported")]);
            var i2 = Re(r2, ["zoom"]);
            if (!i2 && !Vr(e2))
              return Br([new Ft("", "zoom expressions not supported")]);
            var a2 = function t3(e3) {
              var r3 = null;
              if (e3 instanceof ur)
                r3 = t3(e3.result);
              else if (e3 instanceof sr)
                for (var n3 = 0, i3 = e3.args; n3 < i3.length && !(r3 = t3(i3[n3])); n3 += 1)
                  ;
              else
                (e3 instanceof Ne || e3 instanceof ar) && e3.input instanceof xe && "zoom" === e3.input.name && (r3 = e3);
              return r3 instanceof Ft || e3.eachChild(function(e4) {
                var n4 = t3(e4);
                n4 instanceof Ft ? r3 = n4 : !r3 && n4 ? r3 = new Ft("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : r3 && n4 && r3 !== n4 && (r3 = new Ft("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
              }), r3;
            }(r2);
            return a2 || i2 ? a2 instanceof Ft ? Br([a2]) : a2 instanceof ar && !Fr(e2) ? Br([new Ft("", '"interpolate" expressions cannot be used with this property')]) : Mr(a2 ? new Jr(n2 ? "camera" : "composite", t2.value, a2.labels, a2 instanceof ar ? a2.interpolation : void 0) : new Xr(n2 ? "constant" : "source", t2.value)) : Br([new Ft("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
          }
          Jr.prototype.evaluateWithoutErrorHandling = function(t2, e2, r2, n2, i2, a2) {
            return this._styleExpression.evaluateWithoutErrorHandling(t2, e2, r2, n2, i2, a2);
          }, Jr.prototype.evaluate = function(t2, e2, r2, n2, i2, a2) {
            return this._styleExpression.evaluate(t2, e2, r2, n2, i2, a2);
          }, Jr.prototype.interpolationFactor = function(t2, e2, r2) {
            return this.interpolationType ? ar.interpolationFactor(this.interpolationType, t2, e2, r2) : 0;
          };
          var Yr = function(t2, e2) {
            this._parameters = t2, this._specification = e2, Bt(this, function t3(e3, r2) {
              var n2, i2, a2, o2 = "color" === r2.type, s2 = e3.stops && "object" == typeof e3.stops[0][0], u2 = s2 || !(s2 || void 0 !== e3.property), l2 = e3.type || (Fr(r2) ? "exponential" : "interval");
              if (o2 && ((e3 = Bt({}, e3)).stops && (e3.stops = e3.stops.map(function(t4) {
                return [t4[0], te.parse(t4[1])];
              })), e3.default = te.parse(e3.default ? e3.default : r2.default)), e3.colorSpace && "rgb" !== e3.colorSpace && !ir[e3.colorSpace])
                throw new Error("Unknown color space: " + e3.colorSpace);
              if ("exponential" === l2)
                n2 = qr;
              else if ("interval" === l2)
                n2 = jr;
              else if ("categorical" === l2) {
                n2 = Ur, i2 = /* @__PURE__ */ Object.create(null);
                for (var p2 = 0, c2 = e3.stops; p2 < c2.length; p2 += 1) {
                  var h2 = c2[p2];
                  i2[h2[0]] = h2[1];
                }
                a2 = typeof e3.stops[0][0];
              } else {
                if ("identity" !== l2)
                  throw new Error('Unknown function type "' + l2 + '"');
                n2 = Nr;
              }
              if (s2) {
                for (var f2 = {}, y2 = [], d2 = 0; d2 < e3.stops.length; d2++) {
                  var m2 = e3.stops[d2], v2 = m2[0].zoom;
                  void 0 === f2[v2] && (f2[v2] = { zoom: v2, type: e3.type, property: e3.property, default: e3.default, stops: [] }, y2.push(v2)), f2[v2].stops.push([m2[0].value, m2[1]]);
                }
                for (var g2 = [], x2 = 0, b2 = y2; x2 < b2.length; x2 += 1) {
                  var w2 = b2[x2];
                  g2.push([f2[w2].zoom, t3(f2[w2], r2)]);
                }
                var _2 = { name: "linear" };
                return { kind: "composite", interpolationType: _2, interpolationFactor: ar.interpolationFactor.bind(void 0, _2), zoomStops: g2.map(function(t4) {
                  return t4[0];
                }), evaluate: function(t4, n3) {
                  var i3 = t4.zoom;
                  return qr({ stops: g2, base: e3.base }, r2, i3).evaluate(i3, n3);
                } };
              }
              if (u2) {
                var A2 = "exponential" === l2 ? { name: "exponential", base: void 0 !== e3.base ? e3.base : 1 } : null;
                return { kind: "camera", interpolationType: A2, interpolationFactor: ar.interpolationFactor.bind(void 0, A2), zoomStops: e3.stops.map(function(t4) {
                  return t4[0];
                }), evaluate: function(t4) {
                  return n2(e3, r2, t4.zoom, i2, a2);
                } };
              }
              return { kind: "source", evaluate: function(t4, o3) {
                var s3 = o3 && o3.properties ? o3.properties[e3.property] : void 0;
                return void 0 === s3 ? Rr(e3.default, r2.default) : n2(e3, r2, s3, i2, a2);
              } };
            }(this._parameters, this._specification));
          };
          function $r(t2) {
            var e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec || {}, i2 = t2.objectElementValidators || {}, a2 = t2.style, o2 = t2.styleSpec, s2 = [], u2 = Dr(r2);
            if ("object" !== u2)
              return [new Pt(e2, r2, "object expected, " + u2 + " found")];
            for (var l2 in r2) {
              var p2 = l2.split(".")[0], c2 = n2[p2] || n2["*"], h2 = void 0;
              if (i2[p2])
                h2 = i2[p2];
              else if (n2[p2])
                h2 = An;
              else if (i2["*"])
                h2 = i2["*"];
              else {
                if (!n2["*"]) {
                  s2.push(new Pt(e2, r2[l2], 'unknown property "' + l2 + '"'));
                  continue;
                }
                h2 = An;
              }
              s2 = s2.concat(h2({ key: (e2 ? e2 + "." : e2) + l2, value: r2[l2], valueSpec: c2, style: a2, styleSpec: o2, object: r2, objectKey: l2 }, r2));
            }
            for (var f2 in n2)
              i2[f2] || n2[f2].required && void 0 === n2[f2].default && void 0 === r2[f2] && s2.push(new Pt(e2, r2, 'missing required property "' + f2 + '"'));
            return s2;
          }
          function Wr(t2) {
            var e2 = t2.value, r2 = t2.valueSpec, n2 = t2.style, i2 = t2.styleSpec, a2 = t2.key, o2 = t2.arrayElementValidator || An;
            if ("array" !== Dr(e2))
              return [new Pt(a2, e2, "array expected, " + Dr(e2) + " found")];
            if (r2.length && e2.length !== r2.length)
              return [new Pt(a2, e2, "array length " + r2.length + " expected, length " + e2.length + " found")];
            if (r2["min-length"] && e2.length < r2["min-length"])
              return [new Pt(a2, e2, "array length at least " + r2["min-length"] + " expected, length " + e2.length + " found")];
            var s2 = { type: r2.value, values: r2.values };
            i2.$version < 7 && (s2.function = r2.function), "object" === Dr(r2.value) && (s2 = r2.value);
            for (var u2 = [], l2 = 0; l2 < e2.length; l2++)
              u2 = u2.concat(o2({ array: e2, arrayIndex: l2, value: e2[l2], valueSpec: s2, style: n2, styleSpec: i2, key: a2 + "[" + l2 + "]" }));
            return u2;
          }
          function Qr(t2) {
            var e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec, i2 = Dr(r2);
            return "number" === i2 && r2 != r2 && (i2 = "NaN"), "number" !== i2 ? [new Pt(e2, r2, "number expected, " + i2 + " found")] : "minimum" in n2 && r2 < n2.minimum ? [new Pt(e2, r2, r2 + " is less than the minimum value " + n2.minimum)] : "maximum" in n2 && r2 > n2.maximum ? [new Pt(e2, r2, r2 + " is greater than the maximum value " + n2.maximum)] : [];
          }
          function tn(t2) {
            var e2, r2, n2, i2 = t2.valueSpec, a2 = Tt(t2.value.type), o2 = {}, s2 = "categorical" !== a2 && void 0 === t2.value.property, u2 = !s2, l2 = "array" === Dr(t2.value.stops) && "array" === Dr(t2.value.stops[0]) && "object" === Dr(t2.value.stops[0][0]), p2 = $r({ key: t2.key, value: t2.value, valueSpec: t2.styleSpec.function, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { stops: function(t3) {
              if ("identity" === a2)
                return [new Pt(t3.key, t3.value, 'identity function may not have a "stops" property')];
              var e3 = [], r3 = t3.value;
              return e3 = e3.concat(Wr({ key: t3.key, value: r3, valueSpec: t3.valueSpec, style: t3.style, styleSpec: t3.styleSpec, arrayElementValidator: c2 })), "array" === Dr(r3) && 0 === r3.length && e3.push(new Pt(t3.key, r3, "array must have at least one stop")), e3;
            }, default: function(t3) {
              return An({ key: t3.key, value: t3.value, valueSpec: i2, style: t3.style, styleSpec: t3.styleSpec });
            } } });
            return "identity" === a2 && s2 && p2.push(new Pt(t2.key, t2.value, 'missing required property "property"')), "identity" === a2 || t2.value.stops || p2.push(new Pt(t2.key, t2.value, 'missing required property "stops"')), "exponential" === a2 && t2.valueSpec.expression && !Fr(t2.valueSpec) && p2.push(new Pt(t2.key, t2.value, "exponential functions not supported")), t2.styleSpec.$version >= 8 && (u2 && !Tr(t2.valueSpec) ? p2.push(new Pt(t2.key, t2.value, "property functions not supported")) : s2 && !Vr(t2.valueSpec) && p2.push(new Pt(t2.key, t2.value, "zoom functions not supported"))), "categorical" !== a2 && !l2 || void 0 !== t2.value.property || p2.push(new Pt(t2.key, t2.value, '"property" property is required')), p2;
            function c2(t3) {
              var e3 = [], a3 = t3.value, s3 = t3.key;
              if ("array" !== Dr(a3))
                return [new Pt(s3, a3, "array expected, " + Dr(a3) + " found")];
              if (2 !== a3.length)
                return [new Pt(s3, a3, "array length 2 expected, length " + a3.length + " found")];
              if (l2) {
                if ("object" !== Dr(a3[0]))
                  return [new Pt(s3, a3, "object expected, " + Dr(a3[0]) + " found")];
                if (void 0 === a3[0].zoom)
                  return [new Pt(s3, a3, "object stop key must have zoom")];
                if (void 0 === a3[0].value)
                  return [new Pt(s3, a3, "object stop key must have value")];
                if (n2 && n2 > Tt(a3[0].zoom))
                  return [new Pt(s3, a3[0].zoom, "stop zoom values must appear in ascending order")];
                Tt(a3[0].zoom) !== n2 && (n2 = Tt(a3[0].zoom), r2 = void 0, o2 = {}), e3 = e3.concat($r({ key: s3 + "[0]", value: a3[0], valueSpec: { zoom: {} }, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { zoom: Qr, value: h2 } }));
              } else
                e3 = e3.concat(h2({ key: s3 + "[0]", value: a3[0], valueSpec: {}, style: t3.style, styleSpec: t3.styleSpec }, a3));
              return Gr(Vt(a3[1])) ? e3.concat([new Pt(s3 + "[1]", a3[1], "expressions are not allowed in function stops.")]) : e3.concat(An({ key: s3 + "[1]", value: a3[1], valueSpec: i2, style: t3.style, styleSpec: t3.styleSpec }));
            }
            function h2(t3, n3) {
              var s3 = Dr(t3.value), u3 = Tt(t3.value), l3 = null !== t3.value ? t3.value : n3;
              if (e2) {
                if (s3 !== e2)
                  return [new Pt(t3.key, l3, s3 + " stop domain type must match previous stop domain type " + e2)];
              } else
                e2 = s3;
              if ("number" !== s3 && "string" !== s3 && "boolean" !== s3)
                return [new Pt(t3.key, l3, "stop domain value must be a number, string, or boolean")];
              if ("number" !== s3 && "categorical" !== a2) {
                var p3 = "number expected, " + s3 + " found";
                return Tr(i2) && void 0 === a2 && (p3 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new Pt(t3.key, l3, p3)];
              }
              return "categorical" !== a2 || "number" !== s3 || isFinite(u3) && Math.floor(u3) === u3 ? "categorical" !== a2 && "number" === s3 && void 0 !== r2 && u3 < r2 ? [new Pt(t3.key, l3, "stop domain values must appear in ascending order")] : (r2 = u3, "categorical" === a2 && u3 in o2 ? [new Pt(t3.key, l3, "stop domain values must be unique")] : (o2[u3] = true, [])) : [new Pt(t3.key, l3, "integer expected, found " + u3)];
            }
          }
          function en(t2) {
            var e2 = ("property" === t2.expressionContext ? Hr : Zr)(Vt(t2.value), t2.valueSpec);
            if ("error" === e2.result)
              return e2.value.map(function(e3) {
                return new Pt("" + t2.key + e3.key, t2.value, e3.message);
              });
            var r2 = e2.value.expression || e2.value._styleExpression.expression;
            if ("property" === t2.expressionContext && "text-font" === t2.propertyKey && !r2.outputDefined())
              return [new Pt(t2.key, t2.value, 'Invalid data expression for "' + t2.propertyKey + '". Output values must be contained as literals within the expression.')];
            if ("property" === t2.expressionContext && "layout" === t2.propertyType && !Oe(r2))
              return [new Pt(t2.key, t2.value, '"feature-state" data expressions are not supported with layout properties.')];
            if ("filter" === t2.expressionContext && !Oe(r2))
              return [new Pt(t2.key, t2.value, '"feature-state" data expressions are not supported with filters.')];
            if (t2.expressionContext && 0 === t2.expressionContext.indexOf("cluster")) {
              if (!Re(r2, ["zoom", "feature-state"]))
                return [new Pt(t2.key, t2.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
              if ("cluster-initial" === t2.expressionContext && !Le(r2))
                return [new Pt(t2.key, t2.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
            }
            return [];
          }
          function rn(t2) {
            var e2 = t2.key, r2 = t2.value, n2 = t2.valueSpec, i2 = [];
            return Array.isArray(n2.values) ? -1 === n2.values.indexOf(Tt(r2)) && i2.push(new Pt(e2, r2, "expected one of [" + n2.values.join(", ") + "], " + JSON.stringify(r2) + " found")) : -1 === Object.keys(n2.values).indexOf(Tt(r2)) && i2.push(new Pt(e2, r2, "expected one of [" + Object.keys(n2.values).join(", ") + "], " + JSON.stringify(r2) + " found")), i2;
          }
          function nn(t2) {
            if (true === t2 || false === t2)
              return true;
            if (!Array.isArray(t2) || 0 === t2.length)
              return false;
            switch (t2[0]) {
              case "has":
                return t2.length >= 2 && "$id" !== t2[1] && "$type" !== t2[1];
              case "in":
                return t2.length >= 3 && ("string" != typeof t2[1] || Array.isArray(t2[2]));
              case "!in":
              case "!has":
              case "none":
                return false;
              case "==":
              case "!=":
              case ">":
              case ">=":
              case "<":
              case "<=":
                return 3 !== t2.length || Array.isArray(t2[1]) || Array.isArray(t2[2]);
              case "any":
              case "all":
                for (var e2 = 0, r2 = t2.slice(1); e2 < r2.length; e2 += 1) {
                  var n2 = r2[e2];
                  if (!nn(n2) && "boolean" != typeof n2)
                    return false;
                }
                return true;
              default:
                return true;
            }
          }
          Yr.deserialize = function(t2) {
            return new Yr(t2._parameters, t2._specification);
          }, Yr.serialize = function(t2) {
            return { _parameters: t2._parameters, _specification: t2._specification };
          };
          var an = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
          function on2(t2) {
            if (null == t2)
              return { filter: function() {
                return true;
              }, needGeometry: false };
            nn(t2) || (t2 = un3(t2));
            var e2 = Zr(t2, an);
            if ("error" === e2.result)
              throw new Error(e2.value.map(function(t3) {
                return t3.key + ": " + t3.message;
              }).join(", "));
            return { filter: function(t3, r2, n2) {
              return e2.value.evaluate(t3, r2, {}, n2);
            }, needGeometry: function t3(e3) {
              if (!Array.isArray(e3))
                return false;
              if ("within" === e3[0])
                return true;
              for (var r2 = 1; r2 < e3.length; r2++)
                if (t3(e3[r2]))
                  return true;
              return false;
            }(t2) };
          }
          function sn(t2, e2) {
            return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
          }
          function un3(t2) {
            if (!t2)
              return true;
            var e2, r2 = t2[0];
            return t2.length <= 1 ? "any" !== r2 : "==" === r2 ? ln(t2[1], t2[2], "==") : "!=" === r2 ? hn(ln(t2[1], t2[2], "==")) : "<" === r2 || ">" === r2 || "<=" === r2 || ">=" === r2 ? ln(t2[1], t2[2], r2) : "any" === r2 ? (e2 = t2.slice(1), ["any"].concat(e2.map(un3))) : "all" === r2 ? ["all"].concat(t2.slice(1).map(un3)) : "none" === r2 ? ["all"].concat(t2.slice(1).map(un3).map(hn)) : "in" === r2 ? pn(t2[1], t2.slice(2)) : "!in" === r2 ? hn(pn(t2[1], t2.slice(2))) : "has" === r2 ? cn(t2[1]) : "!has" === r2 ? hn(cn(t2[1])) : "within" !== r2 || t2;
          }
          function ln(t2, e2, r2) {
            switch (t2) {
              case "$type":
                return ["filter-type-" + r2, e2];
              case "$id":
                return ["filter-id-" + r2, e2];
              default:
                return ["filter-" + r2, t2, e2];
            }
          }
          function pn(t2, e2) {
            if (0 === e2.length)
              return false;
            switch (t2) {
              case "$type":
                return ["filter-type-in", ["literal", e2]];
              case "$id":
                return ["filter-id-in", ["literal", e2]];
              default:
                return e2.length > 200 && !e2.some(function(t3) {
                  return typeof t3 != typeof e2[0];
                }) ? ["filter-in-large", t2, ["literal", e2.sort(sn)]] : ["filter-in-small", t2, ["literal", e2]];
            }
          }
          function cn(t2) {
            switch (t2) {
              case "$type":
                return true;
              case "$id":
                return ["filter-has-id"];
              default:
                return ["filter-has", t2];
            }
          }
          function hn(t2) {
            return ["!", t2];
          }
          function fn(t2) {
            return nn(Vt(t2.value)) ? en(Bt({}, t2, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : function t3(e2) {
              var r2 = e2.value, n2 = e2.key;
              if ("array" !== Dr(r2))
                return [new Pt(n2, r2, "array expected, " + Dr(r2) + " found")];
              var i2, a2 = e2.styleSpec, o2 = [];
              if (r2.length < 1)
                return [new Pt(n2, r2, "filter array must have at least 1 element")];
              switch (o2 = o2.concat(rn({ key: n2 + "[0]", value: r2[0], valueSpec: a2.filter_operator, style: e2.style, styleSpec: e2.styleSpec })), Tt(r2[0])) {
                case "<":
                case "<=":
                case ">":
                case ">=":
                  r2.length >= 2 && "$type" === Tt(r2[1]) && o2.push(new Pt(n2, r2, '"$type" cannot be use with operator "' + r2[0] + '"'));
                case "==":
                case "!=":
                  3 !== r2.length && o2.push(new Pt(n2, r2, 'filter array for operator "' + r2[0] + '" must have 3 elements'));
                case "in":
                case "!in":
                  r2.length >= 2 && "string" !== (i2 = Dr(r2[1])) && o2.push(new Pt(n2 + "[1]", r2[1], "string expected, " + i2 + " found"));
                  for (var s2 = 2; s2 < r2.length; s2++)
                    i2 = Dr(r2[s2]), "$type" === Tt(r2[1]) ? o2 = o2.concat(rn({ key: n2 + "[" + s2 + "]", value: r2[s2], valueSpec: a2.geometry_type, style: e2.style, styleSpec: e2.styleSpec })) : "string" !== i2 && "number" !== i2 && "boolean" !== i2 && o2.push(new Pt(n2 + "[" + s2 + "]", r2[s2], "string, number, or boolean expected, " + i2 + " found"));
                  break;
                case "any":
                case "all":
                case "none":
                  for (var u2 = 1; u2 < r2.length; u2++)
                    o2 = o2.concat(t3({ key: n2 + "[" + u2 + "]", value: r2[u2], style: e2.style, styleSpec: e2.styleSpec }));
                  break;
                case "has":
                case "!has":
                  i2 = Dr(r2[1]), 2 !== r2.length ? o2.push(new Pt(n2, r2, 'filter array for "' + r2[0] + '" operator must have 2 elements')) : "string" !== i2 && o2.push(new Pt(n2 + "[1]", r2[1], "string expected, " + i2 + " found"));
                  break;
                case "within":
                  i2 = Dr(r2[1]), 2 !== r2.length ? o2.push(new Pt(n2, r2, 'filter array for "' + r2[0] + '" operator must have 2 elements')) : "object" !== i2 && o2.push(new Pt(n2 + "[1]", r2[1], "object expected, " + i2 + " found"));
              }
              return o2;
            }(t2);
          }
          function yn(t2, e2) {
            var r2 = t2.key, n2 = t2.style, i2 = t2.styleSpec, a2 = t2.value, o2 = t2.objectKey, s2 = i2[e2 + "_" + t2.layerType];
            if (!s2)
              return [];
            var u2 = o2.match(/^(.*)-transition$/);
            if ("paint" === e2 && u2 && s2[u2[1]] && s2[u2[1]].transition)
              return An({ key: r2, value: a2, valueSpec: i2.transition, style: n2, styleSpec: i2 });
            var l2, p2 = t2.valueSpec || s2[o2];
            if (!p2)
              return [new Pt(r2, a2, 'unknown property "' + o2 + '"')];
            if ("string" === Dr(a2) && Tr(p2) && !p2.tokens && (l2 = /^{([^}]+)}$/.exec(a2)))
              return [new Pt(r2, a2, '"' + o2 + '" does not support interpolation syntax\nUse an identity property function instead: `{ "type": "identity", "property": ' + JSON.stringify(l2[1]) + " }`.")];
            var c2 = [];
            return "symbol" === t2.layerType && ("text-field" === o2 && n2 && !n2.glyphs && c2.push(new Pt(r2, a2, 'use of "text-field" requires a style "glyphs" property')), "text-font" === o2 && Lr(Vt(a2)) && "identity" === Tt(a2.type) && c2.push(new Pt(r2, a2, '"text-font" does not support identity functions'))), c2.concat(An({ key: t2.key, value: a2, valueSpec: p2, style: n2, styleSpec: i2, expressionContext: "property", propertyType: e2, propertyKey: o2 }));
          }
          function dn(t2) {
            return yn(t2, "paint");
          }
          function mn(t2) {
            return yn(t2, "layout");
          }
          function vn(t2) {
            var e2 = [], r2 = t2.value, n2 = t2.key, i2 = t2.style, a2 = t2.styleSpec;
            r2.type || r2.ref || e2.push(new Pt(n2, r2, 'either "type" or "ref" is required'));
            var o2, s2 = Tt(r2.type), u2 = Tt(r2.ref);
            if (r2.id)
              for (var l2 = Tt(r2.id), p2 = 0; p2 < t2.arrayIndex; p2++) {
                var c2 = i2.layers[p2];
                Tt(c2.id) === l2 && e2.push(new Pt(n2, r2.id, 'duplicate layer id "' + r2.id + '", previously used at line ' + c2.id.__line__));
              }
            if ("ref" in r2)
              ["type", "source", "source-layer", "filter", "layout"].forEach(function(t3) {
                t3 in r2 && e2.push(new Pt(n2, r2[t3], '"' + t3 + '" is prohibited for ref layers'));
              }), i2.layers.forEach(function(t3) {
                Tt(t3.id) === u2 && (o2 = t3);
              }), o2 ? o2.ref ? e2.push(new Pt(n2, r2.ref, "ref cannot reference another ref layer")) : s2 = Tt(o2.type) : e2.push(new Pt(n2, r2.ref, 'ref layer "' + u2 + '" not found'));
            else if ("background" !== s2)
              if (r2.source) {
                var h2 = i2.sources && i2.sources[r2.source], f2 = h2 && Tt(h2.type);
                h2 ? "vector" === f2 && "raster" === s2 ? e2.push(new Pt(n2, r2.source, 'layer "' + r2.id + '" requires a raster source')) : "raster" === f2 && "raster" !== s2 ? e2.push(new Pt(n2, r2.source, 'layer "' + r2.id + '" requires a vector source')) : "vector" !== f2 || r2["source-layer"] ? "raster-dem" === f2 && "hillshade" !== s2 ? e2.push(new Pt(n2, r2.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== s2 || !r2.paint || !r2.paint["line-gradient"] || "geojson" === f2 && h2.lineMetrics || e2.push(new Pt(n2, r2, 'layer "' + r2.id + '" specifies a line-gradient, which requires a GeoJSON source with `lineMetrics` enabled.')) : e2.push(new Pt(n2, r2, 'layer "' + r2.id + '" must specify a "source-layer"')) : e2.push(new Pt(n2, r2.source, 'source "' + r2.source + '" not found'));
              } else
                e2.push(new Pt(n2, r2, 'missing required property "source"'));
            return e2 = e2.concat($r({ key: n2, value: r2, valueSpec: a2.layer, style: t2.style, styleSpec: t2.styleSpec, objectElementValidators: { "*": function() {
              return [];
            }, type: function() {
              return An({ key: n2 + ".type", value: r2.type, valueSpec: a2.layer.type, style: t2.style, styleSpec: t2.styleSpec, object: r2, objectKey: "type" });
            }, filter: fn, layout: function(t3) {
              return $r({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": function(t4) {
                return mn(Bt({ layerType: s2 }, t4));
              } } });
            }, paint: function(t3) {
              return $r({ layer: r2, key: t3.key, value: t3.value, style: t3.style, styleSpec: t3.styleSpec, objectElementValidators: { "*": function(t4) {
                return dn(Bt({ layerType: s2 }, t4));
              } } });
            } } }));
          }
          function gn(t2) {
            var e2 = t2.value, r2 = t2.key, n2 = Dr(e2);
            return "string" !== n2 ? [new Pt(r2, e2, "string expected, " + n2 + " found")] : [];
          }
          var xn = { promoteId: function(t2) {
            var e2 = t2.key, r2 = t2.value;
            if ("string" === Dr(r2))
              return gn({ key: e2, value: r2 });
            var n2 = [];
            for (var i2 in r2)
              n2.push.apply(n2, gn({ key: e2 + "." + i2, value: r2[i2] }));
            return n2;
          } };
          function bn(t2) {
            var e2 = t2.value, r2 = t2.key, n2 = t2.styleSpec, i2 = t2.style;
            if (!e2.type)
              return [new Pt(r2, e2, '"type" is required')];
            var a2, o2 = Tt(e2.type);
            switch (o2) {
              case "vector":
              case "raster":
              case "raster-dem":
                return $r({ key: r2, value: e2, valueSpec: n2["source_" + o2.replace("-", "_")], style: t2.style, styleSpec: n2, objectElementValidators: xn });
              case "geojson":
                if (a2 = $r({ key: r2, value: e2, valueSpec: n2.source_geojson, style: i2, styleSpec: n2, objectElementValidators: xn }), e2.cluster)
                  for (var s2 in e2.clusterProperties) {
                    var u2 = e2.clusterProperties[s2], l2 = u2[0], p2 = "string" == typeof l2 ? [l2, ["accumulated"], ["get", s2]] : l2;
                    a2.push.apply(a2, en({ key: r2 + "." + s2 + ".map", value: u2[1], expressionContext: "cluster-map" })), a2.push.apply(a2, en({ key: r2 + "." + s2 + ".reduce", value: p2, expressionContext: "cluster-reduce" }));
                  }
                return a2;
              case "video":
                return $r({ key: r2, value: e2, valueSpec: n2.source_video, style: i2, styleSpec: n2 });
              case "image":
                return $r({ key: r2, value: e2, valueSpec: n2.source_image, style: i2, styleSpec: n2 });
              case "canvas":
                return [new Pt(r2, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
              default:
                return rn({ key: r2 + ".type", value: e2.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: i2, styleSpec: n2 });
            }
          }
          function wn(t2) {
            var e2 = t2.value, r2 = t2.styleSpec, n2 = r2.light, i2 = t2.style, a2 = [], o2 = Dr(e2);
            if (void 0 === e2)
              return a2;
            if ("object" !== o2)
              return a2.concat([new Pt("light", e2, "object expected, " + o2 + " found")]);
            for (var s2 in e2) {
              var u2 = s2.match(/^(.*)-transition$/);
              a2 = a2.concat(u2 && n2[u2[1]] && n2[u2[1]].transition ? An({ key: s2, value: e2[s2], valueSpec: r2.transition, style: i2, styleSpec: r2 }) : n2[s2] ? An({ key: s2, value: e2[s2], valueSpec: n2[s2], style: i2, styleSpec: r2 }) : [new Pt(s2, e2[s2], 'unknown property "' + s2 + '"')]);
            }
            return a2;
          }
          var _n = { "*": function() {
            return [];
          }, array: Wr, boolean: function(t2) {
            var e2 = t2.value, r2 = t2.key, n2 = Dr(e2);
            return "boolean" !== n2 ? [new Pt(r2, e2, "boolean expected, " + n2 + " found")] : [];
          }, number: Qr, color: function(t2) {
            var e2 = t2.key, r2 = t2.value, n2 = Dr(r2);
            return "string" !== n2 ? [new Pt(e2, r2, "color expected, " + n2 + " found")] : null === Qt(r2) ? [new Pt(e2, r2, 'color expected, "' + r2 + '" found')] : [];
          }, constants: Mt, enum: rn, filter: fn, function: tn, layer: vn, object: $r, source: bn, light: wn, string: gn, formatted: function(t2) {
            return 0 === gn(t2).length ? [] : en(t2);
          }, resolvedImage: function(t2) {
            return 0 === gn(t2).length ? [] : en(t2);
          } };
          function An(t2) {
            var e2 = t2.value, r2 = t2.valueSpec, n2 = t2.styleSpec;
            return r2.expression && Lr(Tt(e2)) ? tn(t2) : r2.expression && Gr(Vt(e2)) ? en(t2) : r2.type && _n[r2.type] ? _n[r2.type](t2) : $r(Bt({}, t2, { valueSpec: r2.type ? n2[r2.type] : r2 }));
          }
          function Sn(t2) {
            var e2 = t2.value, r2 = t2.key, n2 = gn(t2);
            return n2.length || (-1 === e2.indexOf("{fontstack}") && n2.push(new Pt(r2, e2, '"glyphs" url must include a "{fontstack}" token')), -1 === e2.indexOf("{range}") && n2.push(new Pt(r2, e2, '"glyphs" url must include a "{range}" token'))), n2;
          }
          function kn(t2, e2) {
            void 0 === e2 && (e2 = Et);
            var r2 = [];
            return r2 = r2.concat(An({ key: "", value: t2, valueSpec: e2.$root, styleSpec: e2, style: t2, objectElementValidators: { glyphs: Sn, "*": function() {
              return [];
            } } })), t2.constants && (r2 = r2.concat(Mt({ key: "constants", value: t2.constants, style: t2, styleSpec: e2 }))), In(r2);
          }
          function In(t2) {
            return [].concat(t2).sort(function(t3, e2) {
              return t3.line - e2.line;
            });
          }
          function zn(t2) {
            return function() {
              for (var e2 = [], r2 = arguments.length; r2--; )
                e2[r2] = arguments[r2];
              return In(t2.apply(this, e2));
            };
          }
          kn.source = zn(bn), kn.light = zn(wn), kn.layer = zn(vn), kn.filter = zn(fn), kn.paintProperty = zn(dn), kn.layoutProperty = zn(mn);
          var Cn = kn, En = Cn.light, Pn = Cn.paintProperty, Mn = Cn.layoutProperty;
          function Bn(t2, e2) {
            var r2 = false;
            if (e2 && e2.length)
              for (var n2 = 0, i2 = e2; n2 < i2.length; n2 += 1)
                t2.fire(new zt(new Error(i2[n2].message))), r2 = true;
            return r2;
          }
          var Tn = Vn;
          function Vn(t2, e2, r2) {
            var n2 = this.cells = [];
            if (t2 instanceof ArrayBuffer) {
              this.arrayBuffer = t2;
              var i2 = new Int32Array(this.arrayBuffer);
              t2 = i2[0], this.d = (e2 = i2[1]) + 2 * (r2 = i2[2]);
              for (var a2 = 0; a2 < this.d * this.d; a2++) {
                var o2 = i2[3 + a2], s2 = i2[3 + a2 + 1];
                n2.push(o2 === s2 ? null : i2.subarray(o2, s2));
              }
              var u2 = i2[3 + n2.length + 1];
              this.keys = i2.subarray(i2[3 + n2.length], u2), this.bboxes = i2.subarray(u2), this.insert = this._insertReadonly;
            } else {
              this.d = e2 + 2 * r2;
              for (var l2 = 0; l2 < this.d * this.d; l2++)
                n2.push([]);
              this.keys = [], this.bboxes = [];
            }
            this.n = e2, this.extent = t2, this.padding = r2, this.scale = e2 / t2, this.uid = 0;
            var p2 = r2 / e2 * t2;
            this.min = -p2, this.max = t2 + p2;
          }
          Vn.prototype.insert = function(t2, e2, r2, n2, i2) {
            this._forEachCell(e2, r2, n2, i2, this._insertCell, this.uid++), this.keys.push(t2), this.bboxes.push(e2), this.bboxes.push(r2), this.bboxes.push(n2), this.bboxes.push(i2);
          }, Vn.prototype._insertReadonly = function() {
            throw "Cannot insert into a GridIndex created from an ArrayBuffer.";
          }, Vn.prototype._insertCell = function(t2, e2, r2, n2, i2, a2) {
            this.cells[i2].push(a2);
          }, Vn.prototype.query = function(t2, e2, r2, n2, i2) {
            var a2 = this.min, o2 = this.max;
            if (t2 <= a2 && e2 <= a2 && o2 <= r2 && o2 <= n2 && !i2)
              return Array.prototype.slice.call(this.keys);
            var s2 = [];
            return this._forEachCell(t2, e2, r2, n2, this._queryCell, s2, {}, i2), s2;
          }, Vn.prototype._queryCell = function(t2, e2, r2, n2, i2, a2, o2, s2) {
            var u2 = this.cells[i2];
            if (null !== u2)
              for (var l2 = this.keys, p2 = this.bboxes, c2 = 0; c2 < u2.length; c2++) {
                var h2 = u2[c2];
                if (void 0 === o2[h2]) {
                  var f2 = 4 * h2;
                  (s2 ? s2(p2[f2 + 0], p2[f2 + 1], p2[f2 + 2], p2[f2 + 3]) : t2 <= p2[f2 + 2] && e2 <= p2[f2 + 3] && r2 >= p2[f2 + 0] && n2 >= p2[f2 + 1]) ? (o2[h2] = true, a2.push(l2[h2])) : o2[h2] = false;
                }
              }
          }, Vn.prototype._forEachCell = function(t2, e2, r2, n2, i2, a2, o2, s2) {
            for (var u2 = this._convertToCellCoord(t2), l2 = this._convertToCellCoord(e2), p2 = this._convertToCellCoord(r2), c2 = this._convertToCellCoord(n2), h2 = u2; h2 <= p2; h2++)
              for (var f2 = l2; f2 <= c2; f2++) {
                var y2 = this.d * f2 + h2;
                if ((!s2 || s2(this._convertFromCellCoord(h2), this._convertFromCellCoord(f2), this._convertFromCellCoord(h2 + 1), this._convertFromCellCoord(f2 + 1))) && i2.call(this, t2, e2, r2, n2, y2, a2, o2, s2))
                  return;
              }
          }, Vn.prototype._convertFromCellCoord = function(t2) {
            return (t2 - this.padding) / this.scale;
          }, Vn.prototype._convertToCellCoord = function(t2) {
            return Math.max(0, Math.min(this.d - 1, Math.floor(t2 * this.scale) + this.padding));
          }, Vn.prototype.toArrayBuffer = function() {
            if (this.arrayBuffer)
              return this.arrayBuffer;
            for (var t2 = this.cells, e2 = 3 + this.cells.length + 1 + 1, r2 = 0, n2 = 0; n2 < this.cells.length; n2++)
              r2 += this.cells[n2].length;
            var i2 = new Int32Array(e2 + r2 + this.keys.length + this.bboxes.length);
            i2[0] = this.extent, i2[1] = this.n, i2[2] = this.padding;
            for (var a2 = e2, o2 = 0; o2 < t2.length; o2++) {
              var s2 = t2[o2];
              i2[3 + o2] = a2, i2.set(s2, a2), a2 += s2.length;
            }
            return i2[3 + t2.length] = a2, i2.set(this.keys, a2), i2[3 + t2.length + 1] = a2 += this.keys.length, i2.set(this.bboxes, a2), a2 += this.bboxes.length, i2.buffer;
          };
          var Fn = o.ImageData, Dn = o.ImageBitmap, Ln = {};
          function On(t2, e2, r2) {
            void 0 === r2 && (r2 = {}), Object.defineProperty(e2, "_classRegistryKey", { value: t2, writeable: false }), Ln[t2] = { klass: e2, omit: r2.omit || [], shallow: r2.shallow || [] };
          }
          for (var Rn in On("Object", Object), Tn.serialize = function(t2, e2) {
            var r2 = t2.toArrayBuffer();
            return e2 && e2.push(r2), { buffer: r2 };
          }, Tn.deserialize = function(t2) {
            return new Tn(t2.buffer);
          }, On("Grid", Tn), On("Color", te), On("Error", Error), On("ResolvedImage", ie), On("StylePropertyFunction", Yr), On("StyleExpression", Kr, { omit: ["_evaluator"] }), On("ZoomDependentExpression", Jr), On("ZoomConstantExpression", Xr), On("CompoundExpression", xe, { omit: ["_evaluate"] }), Ir)
            Ir[Rn]._classRegistryKey || On("Expression_" + Rn, Ir[Rn]);
          function Un(t2) {
            return t2 && "undefined" != typeof ArrayBuffer && (t2 instanceof ArrayBuffer || t2.constructor && "ArrayBuffer" === t2.constructor.name);
          }
          function jn(t2) {
            return Dn && t2 instanceof Dn;
          }
          function qn(t2, e2) {
            if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp)
              return t2;
            if (Un(t2) || jn(t2))
              return e2 && e2.push(t2), t2;
            if (ArrayBuffer.isView(t2)) {
              var r2 = t2;
              return e2 && e2.push(r2.buffer), r2;
            }
            if (t2 instanceof Fn)
              return e2 && e2.push(t2.data.buffer), t2;
            if (Array.isArray(t2)) {
              for (var n2 = [], i2 = 0, a2 = t2; i2 < a2.length; i2 += 1)
                n2.push(qn(a2[i2], e2));
              return n2;
            }
            if ("object" == typeof t2) {
              var o2 = t2.constructor, s2 = o2._classRegistryKey;
              if (!s2)
                throw new Error("can't serialize object of unregistered class");
              var u2 = o2.serialize ? o2.serialize(t2, e2) : {};
              if (!o2.serialize) {
                for (var l2 in t2)
                  if (t2.hasOwnProperty(l2) && !(Ln[s2].omit.indexOf(l2) >= 0)) {
                    var p2 = t2[l2];
                    u2[l2] = Ln[s2].shallow.indexOf(l2) >= 0 ? p2 : qn(p2, e2);
                  }
                t2 instanceof Error && (u2.message = t2.message);
              }
              if (u2.$name)
                throw new Error("$name property is reserved for worker serialization logic.");
              return "Object" !== s2 && (u2.$name = s2), u2;
            }
            throw new Error("can't serialize object of type " + typeof t2);
          }
          function Nn(t2) {
            if (null == t2 || "boolean" == typeof t2 || "number" == typeof t2 || "string" == typeof t2 || t2 instanceof Boolean || t2 instanceof Number || t2 instanceof String || t2 instanceof Date || t2 instanceof RegExp || Un(t2) || jn(t2) || ArrayBuffer.isView(t2) || t2 instanceof Fn)
              return t2;
            if (Array.isArray(t2))
              return t2.map(Nn);
            if ("object" == typeof t2) {
              var e2 = t2.$name || "Object", r2 = Ln[e2].klass;
              if (!r2)
                throw new Error("can't deserialize unregistered class " + e2);
              if (r2.deserialize)
                return r2.deserialize(t2);
              for (var n2 = Object.create(r2.prototype), i2 = 0, a2 = Object.keys(t2); i2 < a2.length; i2 += 1) {
                var o2 = a2[i2];
                if ("$name" !== o2) {
                  var s2 = t2[o2];
                  n2[o2] = Ln[e2].shallow.indexOf(o2) >= 0 ? s2 : Nn(s2);
                }
              }
              return n2;
            }
            throw new Error("can't deserialize object of type " + typeof t2);
          }
          var Kn = function() {
            this.first = true;
          };
          Kn.prototype.update = function(t2, e2) {
            var r2 = Math.floor(t2);
            return this.first ? (this.first = false, this.lastIntegerZoom = r2, this.lastIntegerZoomTime = 0, this.lastZoom = t2, this.lastFloorZoom = r2, true) : (this.lastFloorZoom > r2 ? (this.lastIntegerZoom = r2 + 1, this.lastIntegerZoomTime = e2) : this.lastFloorZoom < r2 && (this.lastIntegerZoom = r2, this.lastIntegerZoomTime = e2), t2 !== this.lastZoom && (this.lastZoom = t2, this.lastFloorZoom = r2, true));
          };
          var Gn = { "Latin-1 Supplement": function(t2) {
            return t2 >= 128 && t2 <= 255;
          }, Arabic: function(t2) {
            return t2 >= 1536 && t2 <= 1791;
          }, "Arabic Supplement": function(t2) {
            return t2 >= 1872 && t2 <= 1919;
          }, "Arabic Extended-A": function(t2) {
            return t2 >= 2208 && t2 <= 2303;
          }, "Hangul Jamo": function(t2) {
            return t2 >= 4352 && t2 <= 4607;
          }, "Unified Canadian Aboriginal Syllabics": function(t2) {
            return t2 >= 5120 && t2 <= 5759;
          }, Khmer: function(t2) {
            return t2 >= 6016 && t2 <= 6143;
          }, "Unified Canadian Aboriginal Syllabics Extended": function(t2) {
            return t2 >= 6320 && t2 <= 6399;
          }, "General Punctuation": function(t2) {
            return t2 >= 8192 && t2 <= 8303;
          }, "Letterlike Symbols": function(t2) {
            return t2 >= 8448 && t2 <= 8527;
          }, "Number Forms": function(t2) {
            return t2 >= 8528 && t2 <= 8591;
          }, "Miscellaneous Technical": function(t2) {
            return t2 >= 8960 && t2 <= 9215;
          }, "Control Pictures": function(t2) {
            return t2 >= 9216 && t2 <= 9279;
          }, "Optical Character Recognition": function(t2) {
            return t2 >= 9280 && t2 <= 9311;
          }, "Enclosed Alphanumerics": function(t2) {
            return t2 >= 9312 && t2 <= 9471;
          }, "Geometric Shapes": function(t2) {
            return t2 >= 9632 && t2 <= 9727;
          }, "Miscellaneous Symbols": function(t2) {
            return t2 >= 9728 && t2 <= 9983;
          }, "Miscellaneous Symbols and Arrows": function(t2) {
            return t2 >= 11008 && t2 <= 11263;
          }, "CJK Radicals Supplement": function(t2) {
            return t2 >= 11904 && t2 <= 12031;
          }, "Kangxi Radicals": function(t2) {
            return t2 >= 12032 && t2 <= 12255;
          }, "Ideographic Description Characters": function(t2) {
            return t2 >= 12272 && t2 <= 12287;
          }, "CJK Symbols and Punctuation": function(t2) {
            return t2 >= 12288 && t2 <= 12351;
          }, Hiragana: function(t2) {
            return t2 >= 12352 && t2 <= 12447;
          }, Katakana: function(t2) {
            return t2 >= 12448 && t2 <= 12543;
          }, Bopomofo: function(t2) {
            return t2 >= 12544 && t2 <= 12591;
          }, "Hangul Compatibility Jamo": function(t2) {
            return t2 >= 12592 && t2 <= 12687;
          }, Kanbun: function(t2) {
            return t2 >= 12688 && t2 <= 12703;
          }, "Bopomofo Extended": function(t2) {
            return t2 >= 12704 && t2 <= 12735;
          }, "CJK Strokes": function(t2) {
            return t2 >= 12736 && t2 <= 12783;
          }, "Katakana Phonetic Extensions": function(t2) {
            return t2 >= 12784 && t2 <= 12799;
          }, "Enclosed CJK Letters and Months": function(t2) {
            return t2 >= 12800 && t2 <= 13055;
          }, "CJK Compatibility": function(t2) {
            return t2 >= 13056 && t2 <= 13311;
          }, "CJK Unified Ideographs Extension A": function(t2) {
            return t2 >= 13312 && t2 <= 19903;
          }, "Yijing Hexagram Symbols": function(t2) {
            return t2 >= 19904 && t2 <= 19967;
          }, "CJK Unified Ideographs": function(t2) {
            return t2 >= 19968 && t2 <= 40959;
          }, "Yi Syllables": function(t2) {
            return t2 >= 40960 && t2 <= 42127;
          }, "Yi Radicals": function(t2) {
            return t2 >= 42128 && t2 <= 42191;
          }, "Hangul Jamo Extended-A": function(t2) {
            return t2 >= 43360 && t2 <= 43391;
          }, "Hangul Syllables": function(t2) {
            return t2 >= 44032 && t2 <= 55215;
          }, "Hangul Jamo Extended-B": function(t2) {
            return t2 >= 55216 && t2 <= 55295;
          }, "Private Use Area": function(t2) {
            return t2 >= 57344 && t2 <= 63743;
          }, "CJK Compatibility Ideographs": function(t2) {
            return t2 >= 63744 && t2 <= 64255;
          }, "Arabic Presentation Forms-A": function(t2) {
            return t2 >= 64336 && t2 <= 65023;
          }, "Vertical Forms": function(t2) {
            return t2 >= 65040 && t2 <= 65055;
          }, "CJK Compatibility Forms": function(t2) {
            return t2 >= 65072 && t2 <= 65103;
          }, "Small Form Variants": function(t2) {
            return t2 >= 65104 && t2 <= 65135;
          }, "Arabic Presentation Forms-B": function(t2) {
            return t2 >= 65136 && t2 <= 65279;
          }, "Halfwidth and Fullwidth Forms": function(t2) {
            return t2 >= 65280 && t2 <= 65519;
          } };
          function Zn(t2) {
            for (var e2 = 0, r2 = t2; e2 < r2.length; e2 += 1)
              if (Xn(r2[e2].charCodeAt(0)))
                return true;
            return false;
          }
          function Xn(t2) {
            return !(746 !== t2 && 747 !== t2 && (t2 < 4352 || !(Gn["Bopomofo Extended"](t2) || Gn.Bopomofo(t2) || Gn["CJK Compatibility Forms"](t2) && !(t2 >= 65097 && t2 <= 65103) || Gn["CJK Compatibility Ideographs"](t2) || Gn["CJK Compatibility"](t2) || Gn["CJK Radicals Supplement"](t2) || Gn["CJK Strokes"](t2) || !(!Gn["CJK Symbols and Punctuation"](t2) || t2 >= 12296 && t2 <= 12305 || t2 >= 12308 && t2 <= 12319 || 12336 === t2) || Gn["CJK Unified Ideographs Extension A"](t2) || Gn["CJK Unified Ideographs"](t2) || Gn["Enclosed CJK Letters and Months"](t2) || Gn["Hangul Compatibility Jamo"](t2) || Gn["Hangul Jamo Extended-A"](t2) || Gn["Hangul Jamo Extended-B"](t2) || Gn["Hangul Jamo"](t2) || Gn["Hangul Syllables"](t2) || Gn.Hiragana(t2) || Gn["Ideographic Description Characters"](t2) || Gn.Kanbun(t2) || Gn["Kangxi Radicals"](t2) || Gn["Katakana Phonetic Extensions"](t2) || Gn.Katakana(t2) && 12540 !== t2 || !(!Gn["Halfwidth and Fullwidth Forms"](t2) || 65288 === t2 || 65289 === t2 || 65293 === t2 || t2 >= 65306 && t2 <= 65310 || 65339 === t2 || 65341 === t2 || 65343 === t2 || t2 >= 65371 && t2 <= 65503 || 65507 === t2 || t2 >= 65512 && t2 <= 65519) || !(!Gn["Small Form Variants"](t2) || t2 >= 65112 && t2 <= 65118 || t2 >= 65123 && t2 <= 65126) || Gn["Unified Canadian Aboriginal Syllabics"](t2) || Gn["Unified Canadian Aboriginal Syllabics Extended"](t2) || Gn["Vertical Forms"](t2) || Gn["Yijing Hexagram Symbols"](t2) || Gn["Yi Syllables"](t2) || Gn["Yi Radicals"](t2))));
          }
          function Jn(t2) {
            return !(Xn(t2) || function(t3) {
              return !!(Gn["Latin-1 Supplement"](t3) && (167 === t3 || 169 === t3 || 174 === t3 || 177 === t3 || 188 === t3 || 189 === t3 || 190 === t3 || 215 === t3 || 247 === t3) || Gn["General Punctuation"](t3) && (8214 === t3 || 8224 === t3 || 8225 === t3 || 8240 === t3 || 8241 === t3 || 8251 === t3 || 8252 === t3 || 8258 === t3 || 8263 === t3 || 8264 === t3 || 8265 === t3 || 8273 === t3) || Gn["Letterlike Symbols"](t3) || Gn["Number Forms"](t3) || Gn["Miscellaneous Technical"](t3) && (t3 >= 8960 && t3 <= 8967 || t3 >= 8972 && t3 <= 8991 || t3 >= 8996 && t3 <= 9e3 || 9003 === t3 || t3 >= 9085 && t3 <= 9114 || t3 >= 9150 && t3 <= 9165 || 9167 === t3 || t3 >= 9169 && t3 <= 9179 || t3 >= 9186 && t3 <= 9215) || Gn["Control Pictures"](t3) && 9251 !== t3 || Gn["Optical Character Recognition"](t3) || Gn["Enclosed Alphanumerics"](t3) || Gn["Geometric Shapes"](t3) || Gn["Miscellaneous Symbols"](t3) && !(t3 >= 9754 && t3 <= 9759) || Gn["Miscellaneous Symbols and Arrows"](t3) && (t3 >= 11026 && t3 <= 11055 || t3 >= 11088 && t3 <= 11097 || t3 >= 11192 && t3 <= 11243) || Gn["CJK Symbols and Punctuation"](t3) || Gn.Katakana(t3) || Gn["Private Use Area"](t3) || Gn["CJK Compatibility Forms"](t3) || Gn["Small Form Variants"](t3) || Gn["Halfwidth and Fullwidth Forms"](t3) || 8734 === t3 || 8756 === t3 || 8757 === t3 || t3 >= 9984 && t3 <= 10087 || t3 >= 10102 && t3 <= 10131 || 65532 === t3 || 65533 === t3);
            }(t2));
          }
          function Hn(t2) {
            return t2 >= 1424 && t2 <= 2303 || Gn["Arabic Presentation Forms-A"](t2) || Gn["Arabic Presentation Forms-B"](t2);
          }
          function Yn(t2, e2) {
            return !(!e2 && Hn(t2) || t2 >= 2304 && t2 <= 3583 || t2 >= 3840 && t2 <= 4255 || Gn.Khmer(t2));
          }
          function $n(t2) {
            for (var e2 = 0, r2 = t2; e2 < r2.length; e2 += 1)
              if (Hn(r2[e2].charCodeAt(0)))
                return true;
            return false;
          }
          var Wn = null, Qn = "unavailable", ti = null, ei = function(t2) {
            t2 && "string" == typeof t2 && t2.indexOf("NetworkError") > -1 && (Qn = "error"), Wn && Wn(t2);
          };
          function ri() {
            ni.fire(new It("pluginStateChange", { pluginStatus: Qn, pluginURL: ti }));
          }
          var ni = new Ct(), ii = function() {
            return Qn;
          }, ai = function() {
            if ("deferred" !== Qn || !ti)
              throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
            Qn = "loading", ri(), ti && bt({ url: ti }, function(t2) {
              t2 ? ei(t2) : (Qn = "loaded", ri());
            });
          }, oi = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: function() {
            return "loaded" === Qn || null != oi.applyArabicShaping;
          }, isLoading: function() {
            return "loading" === Qn;
          }, setState: function(t2) {
            Qn = t2.pluginStatus, ti = t2.pluginURL;
          }, isParsed: function() {
            return null != oi.applyArabicShaping && null != oi.processBidirectionalText && null != oi.processStyledBidirectionalText;
          }, getPluginURL: function() {
            return ti;
          } }, si = function(t2, e2) {
            this.zoom = t2, e2 ? (this.now = e2.now, this.fadeDuration = e2.fadeDuration, this.zoomHistory = e2.zoomHistory, this.transition = e2.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Kn(), this.transition = {});
          };
          si.prototype.isSupportedScript = function(t2) {
            return function(t3, e2) {
              for (var r2 = 0, n2 = t3; r2 < n2.length; r2 += 1)
                if (!Yn(n2[r2].charCodeAt(0), e2))
                  return false;
              return true;
            }(t2, oi.isLoaded());
          }, si.prototype.crossFadingFactor = function() {
            return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
          }, si.prototype.getCrossfadeParameters = function() {
            var t2 = this.zoom, e2 = t2 - Math.floor(t2), r2 = this.crossFadingFactor();
            return t2 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e2 + (1 - e2) * r2 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r2) * e2 };
          };
          var ui = function(t2, e2) {
            this.property = t2, this.value = e2, this.expression = function(t3, e3) {
              if (Lr(t3))
                return new Yr(t3, e3);
              if (Gr(t3)) {
                var r2 = Hr(t3, e3);
                if ("error" === r2.result)
                  throw new Error(r2.value.map(function(t4) {
                    return t4.key + ": " + t4.message;
                  }).join(", "));
                return r2.value;
              }
              var n2 = t3;
              return "string" == typeof t3 && "color" === e3.type && (n2 = te.parse(t3)), { kind: "constant", evaluate: function() {
                return n2;
              } };
            }(void 0 === e2 ? t2.specification.default : e2, t2.specification);
          };
          ui.prototype.isDataDriven = function() {
            return "source" === this.expression.kind || "composite" === this.expression.kind;
          }, ui.prototype.possiblyEvaluate = function(t2, e2, r2) {
            return this.property.possiblyEvaluate(this, t2, e2, r2);
          };
          var li = function(t2) {
            this.property = t2, this.value = new ui(t2, void 0);
          };
          li.prototype.transitioned = function(t2, e2) {
            return new ci(this.property, this.value, e2, h({}, t2.transition, this.transition), t2.now);
          }, li.prototype.untransitioned = function() {
            return new ci(this.property, this.value, null, {}, 0);
          };
          var pi = function(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultTransitionablePropertyValues);
          };
          pi.prototype.getValue = function(t2) {
            return w(this._values[t2].value.value);
          }, pi.prototype.setValue = function(t2, e2) {
            this._values.hasOwnProperty(t2) || (this._values[t2] = new li(this._values[t2].property)), this._values[t2].value = new ui(this._values[t2].property, null === e2 ? void 0 : w(e2));
          }, pi.prototype.getTransition = function(t2) {
            return w(this._values[t2].transition);
          }, pi.prototype.setTransition = function(t2, e2) {
            this._values.hasOwnProperty(t2) || (this._values[t2] = new li(this._values[t2].property)), this._values[t2].transition = w(e2) || void 0;
          }, pi.prototype.serialize = function() {
            for (var t2 = {}, e2 = 0, r2 = Object.keys(this._values); e2 < r2.length; e2 += 1) {
              var n2 = r2[e2], i2 = this.getValue(n2);
              void 0 !== i2 && (t2[n2] = i2);
              var a2 = this.getTransition(n2);
              void 0 !== a2 && (t2[n2 + "-transition"] = a2);
            }
            return t2;
          }, pi.prototype.transitioned = function(t2, e2) {
            for (var r2 = new hi(this._properties), n2 = 0, i2 = Object.keys(this._values); n2 < i2.length; n2 += 1) {
              var a2 = i2[n2];
              r2._values[a2] = this._values[a2].transitioned(t2, e2._values[a2]);
            }
            return r2;
          }, pi.prototype.untransitioned = function() {
            for (var t2 = new hi(this._properties), e2 = 0, r2 = Object.keys(this._values); e2 < r2.length; e2 += 1) {
              var n2 = r2[e2];
              t2._values[n2] = this._values[n2].untransitioned();
            }
            return t2;
          };
          var ci = function(t2, e2, r2, n2, i2) {
            this.property = t2, this.value = e2, this.begin = i2 + n2.delay || 0, this.end = this.begin + n2.duration || 0, t2.specification.transition && (n2.delay || n2.duration) && (this.prior = r2);
          };
          ci.prototype.possiblyEvaluate = function(t2, e2, r2) {
            var n2 = t2.now || 0, i2 = this.value.possiblyEvaluate(t2, e2, r2), a2 = this.prior;
            if (a2) {
              if (n2 > this.end)
                return this.prior = null, i2;
              if (this.value.isDataDriven())
                return this.prior = null, i2;
              if (n2 < this.begin)
                return a2.possiblyEvaluate(t2, e2, r2);
              var o2 = (n2 - this.begin) / (this.end - this.begin);
              return this.property.interpolate(a2.possiblyEvaluate(t2, e2, r2), i2, function(t3) {
                if (t3 <= 0)
                  return 0;
                if (t3 >= 1)
                  return 1;
                var e3 = t3 * t3, r3 = e3 * t3;
                return 4 * (t3 < 0.5 ? r3 : 3 * (t3 - e3) + r3 - 0.75);
              }(o2));
            }
            return i2;
          };
          var hi = function(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultTransitioningPropertyValues);
          };
          hi.prototype.possiblyEvaluate = function(t2, e2, r2) {
            for (var n2 = new di(this._properties), i2 = 0, a2 = Object.keys(this._values); i2 < a2.length; i2 += 1) {
              var o2 = a2[i2];
              n2._values[o2] = this._values[o2].possiblyEvaluate(t2, e2, r2);
            }
            return n2;
          }, hi.prototype.hasTransition = function() {
            for (var t2 = 0, e2 = Object.keys(this._values); t2 < e2.length; t2 += 1)
              if (this._values[e2[t2]].prior)
                return true;
            return false;
          };
          var fi = function(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultPropertyValues);
          };
          fi.prototype.getValue = function(t2) {
            return w(this._values[t2].value);
          }, fi.prototype.setValue = function(t2, e2) {
            this._values[t2] = new ui(this._values[t2].property, null === e2 ? void 0 : w(e2));
          }, fi.prototype.serialize = function() {
            for (var t2 = {}, e2 = 0, r2 = Object.keys(this._values); e2 < r2.length; e2 += 1) {
              var n2 = r2[e2], i2 = this.getValue(n2);
              void 0 !== i2 && (t2[n2] = i2);
            }
            return t2;
          }, fi.prototype.possiblyEvaluate = function(t2, e2, r2) {
            for (var n2 = new di(this._properties), i2 = 0, a2 = Object.keys(this._values); i2 < a2.length; i2 += 1) {
              var o2 = a2[i2];
              n2._values[o2] = this._values[o2].possiblyEvaluate(t2, e2, r2);
            }
            return n2;
          };
          var yi = function(t2, e2, r2) {
            this.property = t2, this.value = e2, this.parameters = r2;
          };
          yi.prototype.isConstant = function() {
            return "constant" === this.value.kind;
          }, yi.prototype.constantOr = function(t2) {
            return "constant" === this.value.kind ? this.value.value : t2;
          }, yi.prototype.evaluate = function(t2, e2, r2, n2) {
            return this.property.evaluate(this.value, this.parameters, t2, e2, r2, n2);
          };
          var di = function(t2) {
            this._properties = t2, this._values = Object.create(t2.defaultPossiblyEvaluatedValues);
          };
          di.prototype.get = function(t2) {
            return this._values[t2];
          };
          var mi = function(t2) {
            this.specification = t2;
          };
          mi.prototype.possiblyEvaluate = function(t2, e2) {
            return t2.expression.evaluate(e2);
          }, mi.prototype.interpolate = function(t2, e2, r2) {
            var n2 = Ge[this.specification.type];
            return n2 ? n2(t2, e2, r2) : t2;
          };
          var vi = function(t2, e2) {
            this.specification = t2, this.overrides = e2;
          };
          vi.prototype.possiblyEvaluate = function(t2, e2, r2, n2) {
            return new yi(this, "constant" === t2.expression.kind || "camera" === t2.expression.kind ? { kind: "constant", value: t2.expression.evaluate(e2, null, {}, r2, n2) } : t2.expression, e2);
          }, vi.prototype.interpolate = function(t2, e2, r2) {
            if ("constant" !== t2.value.kind || "constant" !== e2.value.kind)
              return t2;
            if (void 0 === t2.value.value || void 0 === e2.value.value)
              return new yi(this, { kind: "constant", value: void 0 }, t2.parameters);
            var n2 = Ge[this.specification.type];
            return n2 ? new yi(this, { kind: "constant", value: n2(t2.value.value, e2.value.value, r2) }, t2.parameters) : t2;
          }, vi.prototype.evaluate = function(t2, e2, r2, n2, i2, a2) {
            return "constant" === t2.kind ? t2.value : t2.evaluate(e2, r2, n2, i2, a2);
          };
          var gi = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.possiblyEvaluate = function(t3, e3, r2, n2) {
              if (void 0 === t3.value)
                return new yi(this, { kind: "constant", value: void 0 }, e3);
              if ("constant" === t3.expression.kind) {
                var i2 = t3.expression.evaluate(e3, null, {}, r2, n2), a2 = "resolvedImage" === t3.property.specification.type && "string" != typeof i2 ? i2.name : i2, o2 = this._calculate(a2, a2, a2, e3);
                return new yi(this, { kind: "constant", value: o2 }, e3);
              }
              if ("camera" === t3.expression.kind) {
                var s2 = this._calculate(t3.expression.evaluate({ zoom: e3.zoom - 1 }), t3.expression.evaluate({ zoom: e3.zoom }), t3.expression.evaluate({ zoom: e3.zoom + 1 }), e3);
                return new yi(this, { kind: "constant", value: s2 }, e3);
              }
              return new yi(this, t3.expression, e3);
            }, e2.prototype.evaluate = function(t3, e3, r2, n2, i2, a2) {
              if ("source" === t3.kind) {
                var o2 = t3.evaluate(e3, r2, n2, i2, a2);
                return this._calculate(o2, o2, o2, e3);
              }
              return "composite" === t3.kind ? this._calculate(t3.evaluate({ zoom: Math.floor(e3.zoom) - 1 }, r2, n2), t3.evaluate({ zoom: Math.floor(e3.zoom) }, r2, n2), t3.evaluate({ zoom: Math.floor(e3.zoom) + 1 }, r2, n2), e3) : t3.value;
            }, e2.prototype._calculate = function(t3, e3, r2, n2) {
              return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t3, to: e3 } : { from: r2, to: e3 };
            }, e2.prototype.interpolate = function(t3) {
              return t3;
            }, e2;
          }(vi), xi = function(t2) {
            this.specification = t2;
          };
          xi.prototype.possiblyEvaluate = function(t2, e2, r2, n2) {
            if (void 0 !== t2.value) {
              if ("constant" === t2.expression.kind) {
                var i2 = t2.expression.evaluate(e2, null, {}, r2, n2);
                return this._calculate(i2, i2, i2, e2);
              }
              return this._calculate(t2.expression.evaluate(new si(Math.floor(e2.zoom - 1), e2)), t2.expression.evaluate(new si(Math.floor(e2.zoom), e2)), t2.expression.evaluate(new si(Math.floor(e2.zoom + 1), e2)), e2);
            }
          }, xi.prototype._calculate = function(t2, e2, r2, n2) {
            return n2.zoom > n2.zoomHistory.lastIntegerZoom ? { from: t2, to: e2 } : { from: r2, to: e2 };
          }, xi.prototype.interpolate = function(t2) {
            return t2;
          };
          var bi = function(t2) {
            this.specification = t2;
          };
          bi.prototype.possiblyEvaluate = function(t2, e2, r2, n2) {
            return !!t2.expression.evaluate(e2, null, {}, r2, n2);
          }, bi.prototype.interpolate = function() {
            return false;
          };
          var wi = function(t2) {
            for (var e2 in this.properties = t2, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [], t2) {
              var r2 = t2[e2];
              r2.specification.overridable && this.overridableProperties.push(e2);
              var n2 = this.defaultPropertyValues[e2] = new ui(r2, void 0), i2 = this.defaultTransitionablePropertyValues[e2] = new li(r2);
              this.defaultTransitioningPropertyValues[e2] = i2.untransitioned(), this.defaultPossiblyEvaluatedValues[e2] = n2.possiblyEvaluate({});
            }
          };
          On("DataDrivenProperty", vi), On("DataConstantProperty", mi), On("CrossFadedDataDrivenProperty", gi), On("CrossFadedProperty", xi), On("ColorRampProperty", bi);
          var _i = function(t2) {
            function e2(e3, r2) {
              if (t2.call(this), this.id = e3.id, this.type = e3.type, this._featureFilter = { filter: function() {
                return true;
              }, needGeometry: false }, "custom" !== e3.type && (this.metadata = (e3 = e3).metadata, this.minzoom = e3.minzoom, this.maxzoom = e3.maxzoom, "background" !== e3.type && (this.source = e3.source, this.sourceLayer = e3["source-layer"], this.filter = e3.filter), r2.layout && (this._unevaluatedLayout = new fi(r2.layout)), r2.paint)) {
                for (var n2 in this._transitionablePaint = new pi(r2.paint), e3.paint)
                  this.setPaintProperty(n2, e3.paint[n2], { validate: false });
                for (var i2 in e3.layout)
                  this.setLayoutProperty(i2, e3.layout[i2], { validate: false });
                this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new di(r2.paint);
              }
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getCrossfadeParameters = function() {
              return this._crossfadeParameters;
            }, e2.prototype.getLayoutProperty = function(t3) {
              return "visibility" === t3 ? this.visibility : this._unevaluatedLayout.getValue(t3);
            }, e2.prototype.setLayoutProperty = function(t3, e3, r2) {
              void 0 === r2 && (r2 = {}), null != e3 && this._validate(Mn, "layers." + this.id + ".layout." + t3, t3, e3, r2) || ("visibility" !== t3 ? this._unevaluatedLayout.setValue(t3, e3) : this.visibility = e3);
            }, e2.prototype.getPaintProperty = function(t3) {
              return g(t3, "-transition") ? this._transitionablePaint.getTransition(t3.slice(0, -"-transition".length)) : this._transitionablePaint.getValue(t3);
            }, e2.prototype.setPaintProperty = function(t3, e3, r2) {
              if (void 0 === r2 && (r2 = {}), null != e3 && this._validate(Pn, "layers." + this.id + ".paint." + t3, t3, e3, r2))
                return false;
              if (g(t3, "-transition"))
                return this._transitionablePaint.setTransition(t3.slice(0, -"-transition".length), e3 || void 0), false;
              var n2 = this._transitionablePaint._values[t3], i2 = "cross-faded-data-driven" === n2.property.specification["property-type"], a2 = n2.value.isDataDriven(), o2 = n2.value;
              this._transitionablePaint.setValue(t3, e3), this._handleSpecialPaintPropertyUpdate(t3);
              var s2 = this._transitionablePaint._values[t3].value;
              return s2.isDataDriven() || a2 || i2 || this._handleOverridablePaintPropertyUpdate(t3, o2, s2);
            }, e2.prototype._handleSpecialPaintPropertyUpdate = function(t3) {
            }, e2.prototype._handleOverridablePaintPropertyUpdate = function(t3, e3, r2) {
              return false;
            }, e2.prototype.isHidden = function(t3) {
              return !!(this.minzoom && t3 < this.minzoom) || !!(this.maxzoom && t3 >= this.maxzoom) || "none" === this.visibility;
            }, e2.prototype.updateTransitions = function(t3) {
              this._transitioningPaint = this._transitionablePaint.transitioned(t3, this._transitioningPaint);
            }, e2.prototype.hasTransition = function() {
              return this._transitioningPaint.hasTransition();
            }, e2.prototype.recalculate = function(t3, e3) {
              t3.getCrossfadeParameters && (this._crossfadeParameters = t3.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t3, void 0, e3)), this.paint = this._transitioningPaint.possiblyEvaluate(t3, void 0, e3);
            }, e2.prototype.serialize = function() {
              var t3 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
              return this.visibility && (t3.layout = t3.layout || {}, t3.layout.visibility = this.visibility), b(t3, function(t4, e3) {
                return !(void 0 === t4 || "layout" === e3 && !Object.keys(t4).length || "paint" === e3 && !Object.keys(t4).length);
              });
            }, e2.prototype._validate = function(t3, e3, r2, n2, i2) {
              return void 0 === i2 && (i2 = {}), (!i2 || false !== i2.validate) && Bn(this, t3.call(Cn, { key: e3, layerType: this.type, objectKey: r2, value: n2, styleSpec: Et, style: { glyphs: true, sprite: true } }));
            }, e2.prototype.is3D = function() {
              return false;
            }, e2.prototype.isTileClipped = function() {
              return false;
            }, e2.prototype.hasOffscreenPass = function() {
              return false;
            }, e2.prototype.resize = function() {
            }, e2.prototype.isStateDependent = function() {
              for (var t3 in this.paint._values) {
                var e3 = this.paint.get(t3);
                if (e3 instanceof yi && Tr(e3.property.specification) && ("source" === e3.value.kind || "composite" === e3.value.kind) && e3.value.isStateDependent)
                  return true;
              }
              return false;
            }, e2;
          }(Ct), Ai = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array }, Si = function(t2, e2) {
            this._structArray = t2, this._pos1 = e2 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
          }, ki = function() {
            this.isTransferred = false, this.capacity = -1, this.resize(0);
          };
          function Ii(t2, e2) {
            void 0 === e2 && (e2 = 1);
            var r2 = 0, n2 = 0;
            return { members: t2.map(function(t3) {
              var i2 = Ai[t3.type].BYTES_PER_ELEMENT, a2 = r2 = zi(r2, Math.max(e2, i2)), o2 = t3.components || 1;
              return n2 = Math.max(n2, i2), r2 += i2 * o2, { name: t3.name, type: t3.type, components: o2, offset: a2 };
            }), size: zi(r2, Math.max(n2, e2)), alignment: e2 };
          }
          function zi(t2, e2) {
            return Math.ceil(t2 / e2) * e2;
          }
          ki.serialize = function(t2, e2) {
            return t2._trim(), e2 && (t2.isTransferred = true, e2.push(t2.arrayBuffer)), { length: t2.length, arrayBuffer: t2.arrayBuffer };
          }, ki.deserialize = function(t2) {
            var e2 = Object.create(this.prototype);
            return e2.arrayBuffer = t2.arrayBuffer, e2.length = t2.length, e2.capacity = t2.arrayBuffer.byteLength / e2.bytesPerElement, e2._refreshViews(), e2;
          }, ki.prototype._trim = function() {
            this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
          }, ki.prototype.clear = function() {
            this.length = 0;
          }, ki.prototype.resize = function(t2) {
            this.reserve(t2), this.length = t2;
          }, ki.prototype.reserve = function(t2) {
            if (t2 > this.capacity) {
              this.capacity = Math.max(t2, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
              var e2 = this.uint8;
              this._refreshViews(), e2 && this.uint8.set(e2);
            }
          }, ki.prototype._refreshViews = function() {
            throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
          };
          var Ci = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }, e2.prototype.emplaceBack = function(t3, e3) {
              var r2 = this.length;
              return this.resize(r2 + 1), this.emplace(r2, t3, e3);
            }, e2.prototype.emplace = function(t3, e3, r2) {
              var n2 = 2 * t3;
              return this.int16[n2 + 0] = e3, this.int16[n2 + 1] = r2, t3;
            }, e2;
          }(ki);
          Ci.prototype.bytesPerElement = 4, On("StructArrayLayout2i4", Ci);
          var Ei = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }, e2.prototype.emplaceBack = function(t3, e3, r2, n2) {
              var i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t3, e3, r2, n2);
            }, e2.prototype.emplace = function(t3, e3, r2, n2, i2) {
              var a2 = 4 * t3;
              return this.int16[a2 + 0] = e3, this.int16[a2 + 1] = r2, this.int16[a2 + 2] = n2, this.int16[a2 + 3] = i2, t3;
            }, e2;
          }(ki);
          Ei.prototype.bytesPerElement = 8, On("StructArrayLayout4i8", Ei);
          var Pi = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2, a2) {
              var o2 = this.length;
              return this.resize(o2 + 1), this.emplace(o2, t3, e3, r2, n2, i2, a2);
            }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2, o2) {
              var s2 = 6 * t3;
              return this.int16[s2 + 0] = e3, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, this.int16[s2 + 4] = a2, this.int16[s2 + 5] = o2, t3;
            }, e2;
          }(ki);
          Pi.prototype.bytesPerElement = 12, On("StructArrayLayout2i4i12", Pi);
          var Mi = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2, a2) {
              var o2 = this.length;
              return this.resize(o2 + 1), this.emplace(o2, t3, e3, r2, n2, i2, a2);
            }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2, o2) {
              var s2 = 4 * t3, u2 = 8 * t3;
              return this.int16[s2 + 0] = e3, this.int16[s2 + 1] = r2, this.uint8[u2 + 4] = n2, this.uint8[u2 + 5] = i2, this.uint8[u2 + 6] = a2, this.uint8[u2 + 7] = o2, t3;
            }, e2;
          }(ki);
          Mi.prototype.bytesPerElement = 8, On("StructArrayLayout2i4ub8", Mi);
          var Bi = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }, e2.prototype.emplaceBack = function(t3, e3) {
              var r2 = this.length;
              return this.resize(r2 + 1), this.emplace(r2, t3, e3);
            }, e2.prototype.emplace = function(t3, e3, r2) {
              var n2 = 2 * t3;
              return this.float32[n2 + 0] = e3, this.float32[n2 + 1] = r2, t3;
            }, e2;
          }(ki);
          Bi.prototype.bytesPerElement = 8, On("StructArrayLayout2f8", Bi);
          var Ti = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2) {
              var p2 = this.length;
              return this.resize(p2 + 1), this.emplace(p2, t3, e3, r2, n2, i2, a2, o2, s2, u2, l2);
            }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p2) {
              var c2 = 10 * t3;
              return this.uint16[c2 + 0] = e3, this.uint16[c2 + 1] = r2, this.uint16[c2 + 2] = n2, this.uint16[c2 + 3] = i2, this.uint16[c2 + 4] = a2, this.uint16[c2 + 5] = o2, this.uint16[c2 + 6] = s2, this.uint16[c2 + 7] = u2, this.uint16[c2 + 8] = l2, this.uint16[c2 + 9] = p2, t3;
            }, e2;
          }(ki);
          Ti.prototype.bytesPerElement = 20, On("StructArrayLayout10ui20", Ti);
          var Vi = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p2, c2) {
              var h2 = this.length;
              return this.resize(h2 + 1), this.emplace(h2, t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p2, c2);
            }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p2, c2, h2) {
              var f2 = 12 * t3;
              return this.int16[f2 + 0] = e3, this.int16[f2 + 1] = r2, this.int16[f2 + 2] = n2, this.int16[f2 + 3] = i2, this.uint16[f2 + 4] = a2, this.uint16[f2 + 5] = o2, this.uint16[f2 + 6] = s2, this.uint16[f2 + 7] = u2, this.int16[f2 + 8] = l2, this.int16[f2 + 9] = p2, this.int16[f2 + 10] = c2, this.int16[f2 + 11] = h2, t3;
            }, e2;
          }(ki);
          Vi.prototype.bytesPerElement = 24, On("StructArrayLayout4i4ui4i24", Vi);
          var Fi = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }, e2.prototype.emplaceBack = function(t3, e3, r2) {
              var n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t3, e3, r2);
            }, e2.prototype.emplace = function(t3, e3, r2, n2) {
              var i2 = 3 * t3;
              return this.float32[i2 + 0] = e3, this.float32[i2 + 1] = r2, this.float32[i2 + 2] = n2, t3;
            }, e2;
          }(ki);
          Fi.prototype.bytesPerElement = 12, On("StructArrayLayout3f12", Fi);
          var Di = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }, e2.prototype.emplaceBack = function(t3) {
              var e3 = this.length;
              return this.resize(e3 + 1), this.emplace(e3, t3);
            }, e2.prototype.emplace = function(t3, e3) {
              return this.uint32[1 * t3 + 0] = e3, t3;
            }, e2;
          }(ki);
          Di.prototype.bytesPerElement = 4, On("StructArrayLayout1ul4", Di);
          var Li = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2, a2, o2, s2, u2) {
              var l2 = this.length;
              return this.resize(l2 + 1), this.emplace(l2, t3, e3, r2, n2, i2, a2, o2, s2, u2);
            }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2) {
              var p2 = 10 * t3, c2 = 5 * t3;
              return this.int16[p2 + 0] = e3, this.int16[p2 + 1] = r2, this.int16[p2 + 2] = n2, this.int16[p2 + 3] = i2, this.int16[p2 + 4] = a2, this.int16[p2 + 5] = o2, this.uint32[c2 + 3] = s2, this.uint16[p2 + 8] = u2, this.uint16[p2 + 9] = l2, t3;
            }, e2;
          }(ki);
          Li.prototype.bytesPerElement = 20, On("StructArrayLayout6i1ul2ui20", Li);
          var Oi = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2, a2) {
              var o2 = this.length;
              return this.resize(o2 + 1), this.emplace(o2, t3, e3, r2, n2, i2, a2);
            }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2, o2) {
              var s2 = 6 * t3;
              return this.int16[s2 + 0] = e3, this.int16[s2 + 1] = r2, this.int16[s2 + 2] = n2, this.int16[s2 + 3] = i2, this.int16[s2 + 4] = a2, this.int16[s2 + 5] = o2, t3;
            }, e2;
          }(ki);
          Oi.prototype.bytesPerElement = 12, On("StructArrayLayout2i2i2i12", Oi);
          var Ri = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2) {
              var a2 = this.length;
              return this.resize(a2 + 1), this.emplace(a2, t3, e3, r2, n2, i2);
            }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2) {
              var o2 = 4 * t3, s2 = 8 * t3;
              return this.float32[o2 + 0] = e3, this.float32[o2 + 1] = r2, this.float32[o2 + 2] = n2, this.int16[s2 + 6] = i2, this.int16[s2 + 7] = a2, t3;
            }, e2;
          }(ki);
          Ri.prototype.bytesPerElement = 16, On("StructArrayLayout2f1f2i16", Ri);
          var Ui = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }, e2.prototype.emplaceBack = function(t3, e3, r2, n2) {
              var i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t3, e3, r2, n2);
            }, e2.prototype.emplace = function(t3, e3, r2, n2, i2) {
              var a2 = 12 * t3, o2 = 3 * t3;
              return this.uint8[a2 + 0] = e3, this.uint8[a2 + 1] = r2, this.float32[o2 + 1] = n2, this.float32[o2 + 2] = i2, t3;
            }, e2;
          }(ki);
          Ui.prototype.bytesPerElement = 12, On("StructArrayLayout2ub2f12", Ui);
          var ji = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }, e2.prototype.emplaceBack = function(t3, e3, r2) {
              var n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t3, e3, r2);
            }, e2.prototype.emplace = function(t3, e3, r2, n2) {
              var i2 = 3 * t3;
              return this.uint16[i2 + 0] = e3, this.uint16[i2 + 1] = r2, this.uint16[i2 + 2] = n2, t3;
            }, e2;
          }(ki);
          ji.prototype.bytesPerElement = 6, On("StructArrayLayout3ui6", ji);
          var qi = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2, m2) {
              var v2 = this.length;
              return this.resize(v2 + 1), this.emplace(v2, t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2, m2);
            }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2, m2, v2) {
              var g2 = 24 * t3, x2 = 12 * t3, b2 = 48 * t3;
              return this.int16[g2 + 0] = e3, this.int16[g2 + 1] = r2, this.uint16[g2 + 2] = n2, this.uint16[g2 + 3] = i2, this.uint32[x2 + 2] = a2, this.uint32[x2 + 3] = o2, this.uint32[x2 + 4] = s2, this.uint16[g2 + 10] = u2, this.uint16[g2 + 11] = l2, this.uint16[g2 + 12] = p2, this.float32[x2 + 7] = c2, this.float32[x2 + 8] = h2, this.uint8[b2 + 36] = f2, this.uint8[b2 + 37] = y2, this.uint8[b2 + 38] = d2, this.uint32[x2 + 10] = m2, this.int16[g2 + 22] = v2, t3;
            }, e2;
          }(ki);
          qi.prototype.bytesPerElement = 48, On("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", qi);
          var Ni = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }, e2.prototype.emplaceBack = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2, m2, v2, g2, x2, b2, w2, _2, A2, S2, k2, I2, z2) {
              var C2 = this.length;
              return this.resize(C2 + 1), this.emplace(C2, t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2, m2, v2, g2, x2, b2, w2, _2, A2, S2, k2, I2, z2);
            }, e2.prototype.emplace = function(t3, e3, r2, n2, i2, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2, m2, v2, g2, x2, b2, w2, _2, A2, S2, k2, I2, z2, C2) {
              var E2 = 34 * t3, P2 = 17 * t3;
              return this.int16[E2 + 0] = e3, this.int16[E2 + 1] = r2, this.int16[E2 + 2] = n2, this.int16[E2 + 3] = i2, this.int16[E2 + 4] = a2, this.int16[E2 + 5] = o2, this.int16[E2 + 6] = s2, this.int16[E2 + 7] = u2, this.uint16[E2 + 8] = l2, this.uint16[E2 + 9] = p2, this.uint16[E2 + 10] = c2, this.uint16[E2 + 11] = h2, this.uint16[E2 + 12] = f2, this.uint16[E2 + 13] = y2, this.uint16[E2 + 14] = d2, this.uint16[E2 + 15] = m2, this.uint16[E2 + 16] = v2, this.uint16[E2 + 17] = g2, this.uint16[E2 + 18] = x2, this.uint16[E2 + 19] = b2, this.uint16[E2 + 20] = w2, this.uint16[E2 + 21] = _2, this.uint16[E2 + 22] = A2, this.uint32[P2 + 12] = S2, this.float32[P2 + 13] = k2, this.float32[P2 + 14] = I2, this.float32[P2 + 15] = z2, this.float32[P2 + 16] = C2, t3;
            }, e2;
          }(ki);
          Ni.prototype.bytesPerElement = 68, On("StructArrayLayout8i15ui1ul4f68", Ni);
          var Ki = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }, e2.prototype.emplaceBack = function(t3) {
              var e3 = this.length;
              return this.resize(e3 + 1), this.emplace(e3, t3);
            }, e2.prototype.emplace = function(t3, e3) {
              return this.float32[1 * t3 + 0] = e3, t3;
            }, e2;
          }(ki);
          Ki.prototype.bytesPerElement = 4, On("StructArrayLayout1f4", Ki);
          var Gi = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }, e2.prototype.emplaceBack = function(t3, e3, r2) {
              var n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t3, e3, r2);
            }, e2.prototype.emplace = function(t3, e3, r2, n2) {
              var i2 = 3 * t3;
              return this.int16[i2 + 0] = e3, this.int16[i2 + 1] = r2, this.int16[i2 + 2] = n2, t3;
            }, e2;
          }(ki);
          Gi.prototype.bytesPerElement = 6, On("StructArrayLayout3i6", Gi);
          var Zi = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }, e2.prototype.emplaceBack = function(t3, e3, r2) {
              var n2 = this.length;
              return this.resize(n2 + 1), this.emplace(n2, t3, e3, r2);
            }, e2.prototype.emplace = function(t3, e3, r2, n2) {
              var i2 = 4 * t3;
              return this.uint32[2 * t3 + 0] = e3, this.uint16[i2 + 2] = r2, this.uint16[i2 + 3] = n2, t3;
            }, e2;
          }(ki);
          Zi.prototype.bytesPerElement = 8, On("StructArrayLayout1ul2ui8", Zi);
          var Xi = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }, e2.prototype.emplaceBack = function(t3, e3) {
              var r2 = this.length;
              return this.resize(r2 + 1), this.emplace(r2, t3, e3);
            }, e2.prototype.emplace = function(t3, e3, r2) {
              var n2 = 2 * t3;
              return this.uint16[n2 + 0] = e3, this.uint16[n2 + 1] = r2, t3;
            }, e2;
          }(ki);
          Xi.prototype.bytesPerElement = 4, On("StructArrayLayout2ui4", Xi);
          var Ji = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }, e2.prototype.emplaceBack = function(t3) {
              var e3 = this.length;
              return this.resize(e3 + 1), this.emplace(e3, t3);
            }, e2.prototype.emplace = function(t3, e3) {
              return this.uint16[1 * t3 + 0] = e3, t3;
            }, e2;
          }(ki);
          Ji.prototype.bytesPerElement = 2, On("StructArrayLayout1ui2", Ji);
          var Hi = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._refreshViews = function() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }, e2.prototype.emplaceBack = function(t3, e3, r2, n2) {
              var i2 = this.length;
              return this.resize(i2 + 1), this.emplace(i2, t3, e3, r2, n2);
            }, e2.prototype.emplace = function(t3, e3, r2, n2, i2) {
              var a2 = 4 * t3;
              return this.float32[a2 + 0] = e3, this.float32[a2 + 1] = r2, this.float32[a2 + 2] = n2, this.float32[a2 + 3] = i2, t3;
            }, e2;
          }(ki);
          Hi.prototype.bytesPerElement = 16, On("StructArrayLayout4f16", Hi);
          var Yi = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2;
            var r2 = { anchorPointX: { configurable: true }, anchorPointY: { configurable: true }, x1: { configurable: true }, y1: { configurable: true }, x2: { configurable: true }, y2: { configurable: true }, featureIndex: { configurable: true }, sourceLayerIndex: { configurable: true }, bucketIndex: { configurable: true }, anchorPoint: { configurable: true } };
            return r2.anchorPointX.get = function() {
              return this._structArray.int16[this._pos2 + 0];
            }, r2.anchorPointY.get = function() {
              return this._structArray.int16[this._pos2 + 1];
            }, r2.x1.get = function() {
              return this._structArray.int16[this._pos2 + 2];
            }, r2.y1.get = function() {
              return this._structArray.int16[this._pos2 + 3];
            }, r2.x2.get = function() {
              return this._structArray.int16[this._pos2 + 4];
            }, r2.y2.get = function() {
              return this._structArray.int16[this._pos2 + 5];
            }, r2.featureIndex.get = function() {
              return this._structArray.uint32[this._pos4 + 3];
            }, r2.sourceLayerIndex.get = function() {
              return this._structArray.uint16[this._pos2 + 8];
            }, r2.bucketIndex.get = function() {
              return this._structArray.uint16[this._pos2 + 9];
            }, r2.anchorPoint.get = function() {
              return new i(this.anchorPointX, this.anchorPointY);
            }, Object.defineProperties(e2.prototype, r2), e2;
          }(Si);
          Yi.prototype.size = 20;
          var $i = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.get = function(t3) {
              return new Yi(this, t3);
            }, e2;
          }(Li);
          On("CollisionBoxArray", $i);
          var Wi = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2;
            var r2 = { anchorX: { configurable: true }, anchorY: { configurable: true }, glyphStartIndex: { configurable: true }, numGlyphs: { configurable: true }, vertexStartIndex: { configurable: true }, lineStartIndex: { configurable: true }, lineLength: { configurable: true }, segment: { configurable: true }, lowerSize: { configurable: true }, upperSize: { configurable: true }, lineOffsetX: { configurable: true }, lineOffsetY: { configurable: true }, writingMode: { configurable: true }, placedOrientation: { configurable: true }, hidden: { configurable: true }, crossTileID: { configurable: true }, associatedIconIndex: { configurable: true } };
            return r2.anchorX.get = function() {
              return this._structArray.int16[this._pos2 + 0];
            }, r2.anchorY.get = function() {
              return this._structArray.int16[this._pos2 + 1];
            }, r2.glyphStartIndex.get = function() {
              return this._structArray.uint16[this._pos2 + 2];
            }, r2.numGlyphs.get = function() {
              return this._structArray.uint16[this._pos2 + 3];
            }, r2.vertexStartIndex.get = function() {
              return this._structArray.uint32[this._pos4 + 2];
            }, r2.lineStartIndex.get = function() {
              return this._structArray.uint32[this._pos4 + 3];
            }, r2.lineLength.get = function() {
              return this._structArray.uint32[this._pos4 + 4];
            }, r2.segment.get = function() {
              return this._structArray.uint16[this._pos2 + 10];
            }, r2.lowerSize.get = function() {
              return this._structArray.uint16[this._pos2 + 11];
            }, r2.upperSize.get = function() {
              return this._structArray.uint16[this._pos2 + 12];
            }, r2.lineOffsetX.get = function() {
              return this._structArray.float32[this._pos4 + 7];
            }, r2.lineOffsetY.get = function() {
              return this._structArray.float32[this._pos4 + 8];
            }, r2.writingMode.get = function() {
              return this._structArray.uint8[this._pos1 + 36];
            }, r2.placedOrientation.get = function() {
              return this._structArray.uint8[this._pos1 + 37];
            }, r2.placedOrientation.set = function(t3) {
              this._structArray.uint8[this._pos1 + 37] = t3;
            }, r2.hidden.get = function() {
              return this._structArray.uint8[this._pos1 + 38];
            }, r2.hidden.set = function(t3) {
              this._structArray.uint8[this._pos1 + 38] = t3;
            }, r2.crossTileID.get = function() {
              return this._structArray.uint32[this._pos4 + 10];
            }, r2.crossTileID.set = function(t3) {
              this._structArray.uint32[this._pos4 + 10] = t3;
            }, r2.associatedIconIndex.get = function() {
              return this._structArray.int16[this._pos2 + 22];
            }, Object.defineProperties(e2.prototype, r2), e2;
          }(Si);
          Wi.prototype.size = 48;
          var Qi = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.get = function(t3) {
              return new Wi(this, t3);
            }, e2;
          }(qi);
          On("PlacedSymbolArray", Qi);
          var ta = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2;
            var r2 = { anchorX: { configurable: true }, anchorY: { configurable: true }, rightJustifiedTextSymbolIndex: { configurable: true }, centerJustifiedTextSymbolIndex: { configurable: true }, leftJustifiedTextSymbolIndex: { configurable: true }, verticalPlacedTextSymbolIndex: { configurable: true }, placedIconSymbolIndex: { configurable: true }, verticalPlacedIconSymbolIndex: { configurable: true }, key: { configurable: true }, textBoxStartIndex: { configurable: true }, textBoxEndIndex: { configurable: true }, verticalTextBoxStartIndex: { configurable: true }, verticalTextBoxEndIndex: { configurable: true }, iconBoxStartIndex: { configurable: true }, iconBoxEndIndex: { configurable: true }, verticalIconBoxStartIndex: { configurable: true }, verticalIconBoxEndIndex: { configurable: true }, featureIndex: { configurable: true }, numHorizontalGlyphVertices: { configurable: true }, numVerticalGlyphVertices: { configurable: true }, numIconVertices: { configurable: true }, numVerticalIconVertices: { configurable: true }, useRuntimeCollisionCircles: { configurable: true }, crossTileID: { configurable: true }, textBoxScale: { configurable: true }, textOffset0: { configurable: true }, textOffset1: { configurable: true }, collisionCircleDiameter: { configurable: true } };
            return r2.anchorX.get = function() {
              return this._structArray.int16[this._pos2 + 0];
            }, r2.anchorY.get = function() {
              return this._structArray.int16[this._pos2 + 1];
            }, r2.rightJustifiedTextSymbolIndex.get = function() {
              return this._structArray.int16[this._pos2 + 2];
            }, r2.centerJustifiedTextSymbolIndex.get = function() {
              return this._structArray.int16[this._pos2 + 3];
            }, r2.leftJustifiedTextSymbolIndex.get = function() {
              return this._structArray.int16[this._pos2 + 4];
            }, r2.verticalPlacedTextSymbolIndex.get = function() {
              return this._structArray.int16[this._pos2 + 5];
            }, r2.placedIconSymbolIndex.get = function() {
              return this._structArray.int16[this._pos2 + 6];
            }, r2.verticalPlacedIconSymbolIndex.get = function() {
              return this._structArray.int16[this._pos2 + 7];
            }, r2.key.get = function() {
              return this._structArray.uint16[this._pos2 + 8];
            }, r2.textBoxStartIndex.get = function() {
              return this._structArray.uint16[this._pos2 + 9];
            }, r2.textBoxEndIndex.get = function() {
              return this._structArray.uint16[this._pos2 + 10];
            }, r2.verticalTextBoxStartIndex.get = function() {
              return this._structArray.uint16[this._pos2 + 11];
            }, r2.verticalTextBoxEndIndex.get = function() {
              return this._structArray.uint16[this._pos2 + 12];
            }, r2.iconBoxStartIndex.get = function() {
              return this._structArray.uint16[this._pos2 + 13];
            }, r2.iconBoxEndIndex.get = function() {
              return this._structArray.uint16[this._pos2 + 14];
            }, r2.verticalIconBoxStartIndex.get = function() {
              return this._structArray.uint16[this._pos2 + 15];
            }, r2.verticalIconBoxEndIndex.get = function() {
              return this._structArray.uint16[this._pos2 + 16];
            }, r2.featureIndex.get = function() {
              return this._structArray.uint16[this._pos2 + 17];
            }, r2.numHorizontalGlyphVertices.get = function() {
              return this._structArray.uint16[this._pos2 + 18];
            }, r2.numVerticalGlyphVertices.get = function() {
              return this._structArray.uint16[this._pos2 + 19];
            }, r2.numIconVertices.get = function() {
              return this._structArray.uint16[this._pos2 + 20];
            }, r2.numVerticalIconVertices.get = function() {
              return this._structArray.uint16[this._pos2 + 21];
            }, r2.useRuntimeCollisionCircles.get = function() {
              return this._structArray.uint16[this._pos2 + 22];
            }, r2.crossTileID.get = function() {
              return this._structArray.uint32[this._pos4 + 12];
            }, r2.crossTileID.set = function(t3) {
              this._structArray.uint32[this._pos4 + 12] = t3;
            }, r2.textBoxScale.get = function() {
              return this._structArray.float32[this._pos4 + 13];
            }, r2.textOffset0.get = function() {
              return this._structArray.float32[this._pos4 + 14];
            }, r2.textOffset1.get = function() {
              return this._structArray.float32[this._pos4 + 15];
            }, r2.collisionCircleDiameter.get = function() {
              return this._structArray.float32[this._pos4 + 16];
            }, Object.defineProperties(e2.prototype, r2), e2;
          }(Si);
          ta.prototype.size = 68;
          var ea = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.get = function(t3) {
              return new ta(this, t3);
            }, e2;
          }(Ni);
          On("SymbolInstanceArray", ea);
          var ra = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getoffsetX = function(t3) {
              return this.float32[1 * t3 + 0];
            }, e2;
          }(Ki);
          On("GlyphOffsetArray", ra);
          var na = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getx = function(t3) {
              return this.int16[3 * t3 + 0];
            }, e2.prototype.gety = function(t3) {
              return this.int16[3 * t3 + 1];
            }, e2.prototype.gettileUnitDistanceFromAnchor = function(t3) {
              return this.int16[3 * t3 + 2];
            }, e2;
          }(Gi);
          On("SymbolLineVertexArray", na);
          var ia = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2;
            var r2 = { featureIndex: { configurable: true }, sourceLayerIndex: { configurable: true }, bucketIndex: { configurable: true } };
            return r2.featureIndex.get = function() {
              return this._structArray.uint32[this._pos4 + 0];
            }, r2.sourceLayerIndex.get = function() {
              return this._structArray.uint16[this._pos2 + 2];
            }, r2.bucketIndex.get = function() {
              return this._structArray.uint16[this._pos2 + 3];
            }, Object.defineProperties(e2.prototype, r2), e2;
          }(Si);
          ia.prototype.size = 8;
          var aa = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.get = function(t3) {
              return new ia(this, t3);
            }, e2;
          }(Zi);
          On("FeatureIndexArray", aa);
          var oa = Ii([{ name: "a_pos", components: 2, type: "Int16" }], 4).members, sa = function(t2) {
            void 0 === t2 && (t2 = []), this.segments = t2;
          };
          function ua(t2, e2) {
            return 256 * (t2 = p(Math.floor(t2), 0, 255)) + p(Math.floor(e2), 0, 255);
          }
          sa.prototype.prepareSegment = function(t2, e2, r2, n2) {
            var i2 = this.segments[this.segments.length - 1];
            return t2 > sa.MAX_VERTEX_ARRAY_LENGTH && A("Max vertices per segment is " + sa.MAX_VERTEX_ARRAY_LENGTH + ": bucket requested " + t2), (!i2 || i2.vertexLength + t2 > sa.MAX_VERTEX_ARRAY_LENGTH || i2.sortKey !== n2) && (i2 = { vertexOffset: e2.length, primitiveOffset: r2.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== n2 && (i2.sortKey = n2), this.segments.push(i2)), i2;
          }, sa.prototype.get = function() {
            return this.segments;
          }, sa.prototype.destroy = function() {
            for (var t2 = 0, e2 = this.segments; t2 < e2.length; t2 += 1) {
              var r2 = e2[t2];
              for (var n2 in r2.vaos)
                r2.vaos[n2].destroy();
            }
          }, sa.simpleSegment = function(t2, e2, r2, n2) {
            return new sa([{ vertexOffset: t2, primitiveOffset: e2, vertexLength: r2, primitiveLength: n2, vaos: {}, sortKey: 0 }]);
          }, sa.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, On("SegmentVector", sa);
          var la = Ii([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]), pa = e(function(t2) {
            t2.exports = function(t3, e2) {
              var r2, n2, i2, a2, o2, s2, u2, l2;
              for (n2 = t3.length - (r2 = 3 & t3.length), i2 = e2, o2 = 3432918353, s2 = 461845907, l2 = 0; l2 < n2; )
                u2 = 255 & t3.charCodeAt(l2) | (255 & t3.charCodeAt(++l2)) << 8 | (255 & t3.charCodeAt(++l2)) << 16 | (255 & t3.charCodeAt(++l2)) << 24, ++l2, i2 = 27492 + (65535 & (a2 = 5 * (65535 & (i2 = (i2 ^= u2 = (65535 & (u2 = (u2 = (65535 & u2) * o2 + (((u2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 15 | u2 >>> 17)) * s2 + (((u2 >>> 16) * s2 & 65535) << 16) & 4294967295) << 13 | i2 >>> 19)) + ((5 * (i2 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (a2 >>> 16) & 65535) << 16);
              switch (u2 = 0, r2) {
                case 3:
                  u2 ^= (255 & t3.charCodeAt(l2 + 2)) << 16;
                case 2:
                  u2 ^= (255 & t3.charCodeAt(l2 + 1)) << 8;
                case 1:
                  i2 ^= u2 = (65535 & (u2 = (u2 = (65535 & (u2 ^= 255 & t3.charCodeAt(l2))) * o2 + (((u2 >>> 16) * o2 & 65535) << 16) & 4294967295) << 15 | u2 >>> 17)) * s2 + (((u2 >>> 16) * s2 & 65535) << 16) & 4294967295;
              }
              return i2 ^= t3.length, i2 = 2246822507 * (65535 & (i2 ^= i2 >>> 16)) + ((2246822507 * (i2 >>> 16) & 65535) << 16) & 4294967295, i2 = 3266489909 * (65535 & (i2 ^= i2 >>> 13)) + ((3266489909 * (i2 >>> 16) & 65535) << 16) & 4294967295, (i2 ^= i2 >>> 16) >>> 0;
            };
          }), ca = e(function(t2) {
            t2.exports = function(t3, e2) {
              for (var r2, n2 = t3.length, i2 = e2 ^ n2, a2 = 0; n2 >= 4; )
                r2 = 1540483477 * (65535 & (r2 = 255 & t3.charCodeAt(a2) | (255 & t3.charCodeAt(++a2)) << 8 | (255 & t3.charCodeAt(++a2)) << 16 | (255 & t3.charCodeAt(++a2)) << 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16), i2 = 1540483477 * (65535 & i2) + ((1540483477 * (i2 >>> 16) & 65535) << 16) ^ (r2 = 1540483477 * (65535 & (r2 ^= r2 >>> 24)) + ((1540483477 * (r2 >>> 16) & 65535) << 16)), n2 -= 4, ++a2;
              switch (n2) {
                case 3:
                  i2 ^= (255 & t3.charCodeAt(a2 + 2)) << 16;
                case 2:
                  i2 ^= (255 & t3.charCodeAt(a2 + 1)) << 8;
                case 1:
                  i2 = 1540483477 * (65535 & (i2 ^= 255 & t3.charCodeAt(a2))) + ((1540483477 * (i2 >>> 16) & 65535) << 16);
              }
              return i2 = 1540483477 * (65535 & (i2 ^= i2 >>> 13)) + ((1540483477 * (i2 >>> 16) & 65535) << 16), (i2 ^= i2 >>> 15) >>> 0;
            };
          }), ha = pa, fa = ca;
          ha.murmur3 = pa, ha.murmur2 = fa;
          var ya = function() {
            this.ids = [], this.positions = [], this.indexed = false;
          };
          ya.prototype.add = function(t2, e2, r2, n2) {
            this.ids.push(ma(t2)), this.positions.push(e2, r2, n2);
          }, ya.prototype.getPositions = function(t2) {
            for (var e2 = ma(t2), r2 = 0, n2 = this.ids.length - 1; r2 < n2; ) {
              var i2 = r2 + n2 >> 1;
              this.ids[i2] >= e2 ? n2 = i2 : r2 = i2 + 1;
            }
            for (var a2 = []; this.ids[r2] === e2; )
              a2.push({ index: this.positions[3 * r2], start: this.positions[3 * r2 + 1], end: this.positions[3 * r2 + 2] }), r2++;
            return a2;
          }, ya.serialize = function(t2, e2) {
            var r2 = new Float64Array(t2.ids), n2 = new Uint32Array(t2.positions);
            return function t3(e3, r3, n3, i2) {
              for (; n3 < i2; ) {
                for (var a2 = e3[n3 + i2 >> 1], o2 = n3 - 1, s2 = i2 + 1; ; ) {
                  do {
                    o2++;
                  } while (e3[o2] < a2);
                  do {
                    s2--;
                  } while (e3[s2] > a2);
                  if (o2 >= s2)
                    break;
                  va(e3, o2, s2), va(r3, 3 * o2, 3 * s2), va(r3, 3 * o2 + 1, 3 * s2 + 1), va(r3, 3 * o2 + 2, 3 * s2 + 2);
                }
                s2 - n3 < i2 - s2 ? (t3(e3, r3, n3, s2), n3 = s2 + 1) : (t3(e3, r3, s2 + 1, i2), i2 = s2);
              }
            }(r2, n2, 0, r2.length - 1), e2 && e2.push(r2.buffer, n2.buffer), { ids: r2, positions: n2 };
          }, ya.deserialize = function(t2) {
            var e2 = new ya();
            return e2.ids = t2.ids, e2.positions = t2.positions, e2.indexed = true, e2;
          };
          var da = Math.pow(2, 53) - 1;
          function ma(t2) {
            var e2 = +t2;
            return !isNaN(e2) && e2 <= da ? e2 : ha(String(t2));
          }
          function va(t2, e2, r2) {
            var n2 = t2[e2];
            t2[e2] = t2[r2], t2[r2] = n2;
          }
          On("FeaturePositionMap", ya);
          var ga = function(t2, e2) {
            this.gl = t2.gl, this.location = e2;
          }, xa = function(t2) {
            function e2(e3, r2) {
              t2.call(this, e3, r2), this.current = 0;
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.set = function(t3) {
              this.current !== t3 && (this.current = t3, this.gl.uniform1i(this.location, t3));
            }, e2;
          }(ga), ba = function(t2) {
            function e2(e3, r2) {
              t2.call(this, e3, r2), this.current = 0;
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.set = function(t3) {
              this.current !== t3 && (this.current = t3, this.gl.uniform1f(this.location, t3));
            }, e2;
          }(ga), wa = function(t2) {
            function e2(e3, r2) {
              t2.call(this, e3, r2), this.current = [0, 0];
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.set = function(t3) {
              t3[0] === this.current[0] && t3[1] === this.current[1] || (this.current = t3, this.gl.uniform2f(this.location, t3[0], t3[1]));
            }, e2;
          }(ga), _a = function(t2) {
            function e2(e3, r2) {
              t2.call(this, e3, r2), this.current = [0, 0, 0];
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.set = function(t3) {
              t3[0] === this.current[0] && t3[1] === this.current[1] && t3[2] === this.current[2] || (this.current = t3, this.gl.uniform3f(this.location, t3[0], t3[1], t3[2]));
            }, e2;
          }(ga), Aa = function(t2) {
            function e2(e3, r2) {
              t2.call(this, e3, r2), this.current = [0, 0, 0, 0];
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.set = function(t3) {
              t3[0] === this.current[0] && t3[1] === this.current[1] && t3[2] === this.current[2] && t3[3] === this.current[3] || (this.current = t3, this.gl.uniform4f(this.location, t3[0], t3[1], t3[2], t3[3]));
            }, e2;
          }(ga), Sa = function(t2) {
            function e2(e3, r2) {
              t2.call(this, e3, r2), this.current = te.transparent;
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.set = function(t3) {
              t3.r === this.current.r && t3.g === this.current.g && t3.b === this.current.b && t3.a === this.current.a || (this.current = t3, this.gl.uniform4f(this.location, t3.r, t3.g, t3.b, t3.a));
            }, e2;
          }(ga), ka = new Float32Array(16), Ia = function(t2) {
            function e2(e3, r2) {
              t2.call(this, e3, r2), this.current = ka;
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.set = function(t3) {
              if (t3[12] !== this.current[12] || t3[0] !== this.current[0])
                return this.current = t3, void this.gl.uniformMatrix4fv(this.location, false, t3);
              for (var e3 = 1; e3 < 16; e3++)
                if (t3[e3] !== this.current[e3]) {
                  this.current = t3, this.gl.uniformMatrix4fv(this.location, false, t3);
                  break;
                }
            }, e2;
          }(ga);
          function za(t2) {
            return [ua(255 * t2.r, 255 * t2.g), ua(255 * t2.b, 255 * t2.a)];
          }
          var Ca = function(t2, e2, r2) {
            this.value = t2, this.uniformNames = e2.map(function(t3) {
              return "u_" + t3;
            }), this.type = r2;
          };
          Ca.prototype.setUniform = function(t2, e2, r2) {
            t2.set(r2.constantOr(this.value));
          }, Ca.prototype.getBinding = function(t2, e2, r2) {
            return "color" === this.type ? new Sa(t2, e2) : new ba(t2, e2);
          };
          var Ea = function(t2, e2) {
            this.uniformNames = e2.map(function(t3) {
              return "u_" + t3;
            }), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
          };
          Ea.prototype.setConstantPatternPositions = function(t2, e2) {
            this.pixelRatioFrom = e2.pixelRatio, this.pixelRatioTo = t2.pixelRatio, this.patternFrom = e2.tlbr, this.patternTo = t2.tlbr;
          }, Ea.prototype.setUniform = function(t2, e2, r2, n2) {
            var i2 = "u_pattern_to" === n2 ? this.patternTo : "u_pattern_from" === n2 ? this.patternFrom : "u_pixel_ratio_to" === n2 ? this.pixelRatioTo : "u_pixel_ratio_from" === n2 ? this.pixelRatioFrom : null;
            i2 && t2.set(i2);
          }, Ea.prototype.getBinding = function(t2, e2, r2) {
            return "u_pattern" === r2.substr(0, 9) ? new Aa(t2, e2) : new ba(t2, e2);
          };
          var Pa = function(t2, e2, r2, n2) {
            this.expression = t2, this.type = r2, this.maxValue = 0, this.paintVertexAttributes = e2.map(function(t3) {
              return { name: "a_" + t3, type: "Float32", components: "color" === r2 ? 2 : 1, offset: 0 };
            }), this.paintVertexArray = new n2();
          };
          Pa.prototype.populatePaintArray = function(t2, e2, r2, n2, i2) {
            var a2 = this.paintVertexArray.length, o2 = this.expression.evaluate(new si(0), e2, {}, n2, [], i2);
            this.paintVertexArray.resize(t2), this._setPaintValue(a2, t2, o2);
          }, Pa.prototype.updatePaintArray = function(t2, e2, r2, n2) {
            var i2 = this.expression.evaluate({ zoom: 0 }, r2, n2);
            this._setPaintValue(t2, e2, i2);
          }, Pa.prototype._setPaintValue = function(t2, e2, r2) {
            if ("color" === this.type)
              for (var n2 = za(r2), i2 = t2; i2 < e2; i2++)
                this.paintVertexArray.emplace(i2, n2[0], n2[1]);
            else {
              for (var a2 = t2; a2 < e2; a2++)
                this.paintVertexArray.emplace(a2, r2);
              this.maxValue = Math.max(this.maxValue, Math.abs(r2));
            }
          }, Pa.prototype.upload = function(t2) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }, Pa.prototype.destroy = function() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          };
          var Ma = function(t2, e2, r2, n2, i2, a2) {
            this.expression = t2, this.uniformNames = e2.map(function(t3) {
              return "u_" + t3 + "_t";
            }), this.type = r2, this.useIntegerZoom = n2, this.zoom = i2, this.maxValue = 0, this.paintVertexAttributes = e2.map(function(t3) {
              return { name: "a_" + t3, type: "Float32", components: "color" === r2 ? 4 : 2, offset: 0 };
            }), this.paintVertexArray = new a2();
          };
          Ma.prototype.populatePaintArray = function(t2, e2, r2, n2, i2) {
            var a2 = this.expression.evaluate(new si(this.zoom), e2, {}, n2, [], i2), o2 = this.expression.evaluate(new si(this.zoom + 1), e2, {}, n2, [], i2), s2 = this.paintVertexArray.length;
            this.paintVertexArray.resize(t2), this._setPaintValue(s2, t2, a2, o2);
          }, Ma.prototype.updatePaintArray = function(t2, e2, r2, n2) {
            var i2 = this.expression.evaluate({ zoom: this.zoom }, r2, n2), a2 = this.expression.evaluate({ zoom: this.zoom + 1 }, r2, n2);
            this._setPaintValue(t2, e2, i2, a2);
          }, Ma.prototype._setPaintValue = function(t2, e2, r2, n2) {
            if ("color" === this.type)
              for (var i2 = za(r2), a2 = za(n2), o2 = t2; o2 < e2; o2++)
                this.paintVertexArray.emplace(o2, i2[0], i2[1], a2[0], a2[1]);
            else {
              for (var s2 = t2; s2 < e2; s2++)
                this.paintVertexArray.emplace(s2, r2, n2);
              this.maxValue = Math.max(this.maxValue, Math.abs(r2), Math.abs(n2));
            }
          }, Ma.prototype.upload = function(t2) {
            this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t2.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
          }, Ma.prototype.destroy = function() {
            this.paintVertexBuffer && this.paintVertexBuffer.destroy();
          }, Ma.prototype.setUniform = function(t2, e2) {
            var r2 = this.useIntegerZoom ? Math.floor(e2.zoom) : e2.zoom, n2 = p(this.expression.interpolationFactor(r2, this.zoom, this.zoom + 1), 0, 1);
            t2.set(n2);
          }, Ma.prototype.getBinding = function(t2, e2, r2) {
            return new ba(t2, e2);
          };
          var Ba = function(t2, e2, r2, n2, i2, a2) {
            this.expression = t2, this.type = e2, this.useIntegerZoom = r2, this.zoom = n2, this.layerId = a2, this.zoomInPaintVertexArray = new i2(), this.zoomOutPaintVertexArray = new i2();
          };
          Ba.prototype.populatePaintArray = function(t2, e2, r2) {
            var n2 = this.zoomInPaintVertexArray.length;
            this.zoomInPaintVertexArray.resize(t2), this.zoomOutPaintVertexArray.resize(t2), this._setPaintValues(n2, t2, e2.patterns && e2.patterns[this.layerId], r2);
          }, Ba.prototype.updatePaintArray = function(t2, e2, r2, n2, i2) {
            this._setPaintValues(t2, e2, r2.patterns && r2.patterns[this.layerId], i2);
          }, Ba.prototype._setPaintValues = function(t2, e2, r2, n2) {
            if (n2 && r2) {
              var i2 = n2[r2.min], a2 = n2[r2.mid], o2 = n2[r2.max];
              if (i2 && a2 && o2)
                for (var s2 = t2; s2 < e2; s2++)
                  this.zoomInPaintVertexArray.emplace(s2, a2.tl[0], a2.tl[1], a2.br[0], a2.br[1], i2.tl[0], i2.tl[1], i2.br[0], i2.br[1], a2.pixelRatio, i2.pixelRatio), this.zoomOutPaintVertexArray.emplace(s2, a2.tl[0], a2.tl[1], a2.br[0], a2.br[1], o2.tl[0], o2.tl[1], o2.br[0], o2.br[1], a2.pixelRatio, o2.pixelRatio);
            }
          }, Ba.prototype.upload = function(t2) {
            this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t2.createVertexBuffer(this.zoomInPaintVertexArray, la.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t2.createVertexBuffer(this.zoomOutPaintVertexArray, la.members, this.expression.isStateDependent));
          }, Ba.prototype.destroy = function() {
            this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
          };
          var Ta = function(t2, e2, r2) {
            this.binders = {}, this._buffers = [];
            var n2 = [];
            for (var i2 in t2.paint._values)
              if (r2(i2)) {
                var a2 = t2.paint.get(i2);
                if (a2 instanceof yi && Tr(a2.property.specification)) {
                  var o2 = Fa(i2, t2.type), s2 = a2.value, u2 = a2.property.specification.type, l2 = a2.property.useIntegerZoom, p2 = a2.property.specification["property-type"], c2 = "cross-faded" === p2 || "cross-faded-data-driven" === p2;
                  if ("constant" === s2.kind)
                    this.binders[i2] = c2 ? new Ea(s2.value, o2) : new Ca(s2.value, o2, u2), n2.push("/u_" + i2);
                  else if ("source" === s2.kind || c2) {
                    var h2 = Da(i2, u2, "source");
                    this.binders[i2] = c2 ? new Ba(s2, u2, l2, e2, h2, t2.id) : new Pa(s2, o2, u2, h2), n2.push("/a_" + i2);
                  } else {
                    var f2 = Da(i2, u2, "composite");
                    this.binders[i2] = new Ma(s2, o2, u2, l2, e2, f2), n2.push("/z_" + i2);
                  }
                }
              }
            this.cacheKey = n2.sort().join("");
          };
          Ta.prototype.getMaxValue = function(t2) {
            var e2 = this.binders[t2];
            return e2 instanceof Pa || e2 instanceof Ma ? e2.maxValue : 0;
          }, Ta.prototype.populatePaintArrays = function(t2, e2, r2, n2, i2) {
            for (var a2 in this.binders) {
              var o2 = this.binders[a2];
              (o2 instanceof Pa || o2 instanceof Ma || o2 instanceof Ba) && o2.populatePaintArray(t2, e2, r2, n2, i2);
            }
          }, Ta.prototype.setConstantPatternPositions = function(t2, e2) {
            for (var r2 in this.binders) {
              var n2 = this.binders[r2];
              n2 instanceof Ea && n2.setConstantPatternPositions(t2, e2);
            }
          }, Ta.prototype.updatePaintArrays = function(t2, e2, r2, n2, i2) {
            var a2 = false;
            for (var o2 in t2)
              for (var s2 = 0, u2 = e2.getPositions(o2); s2 < u2.length; s2 += 1) {
                var l2 = u2[s2], p2 = r2.feature(l2.index);
                for (var c2 in this.binders) {
                  var h2 = this.binders[c2];
                  if ((h2 instanceof Pa || h2 instanceof Ma || h2 instanceof Ba) && true === h2.expression.isStateDependent) {
                    var f2 = n2.paint.get(c2);
                    h2.expression = f2.value, h2.updatePaintArray(l2.start, l2.end, p2, t2[o2], i2), a2 = true;
                  }
                }
              }
            return a2;
          }, Ta.prototype.defines = function() {
            var t2 = [];
            for (var e2 in this.binders) {
              var r2 = this.binders[e2];
              (r2 instanceof Ca || r2 instanceof Ea) && t2.push.apply(t2, r2.uniformNames.map(function(t3) {
                return "#define HAS_UNIFORM_" + t3;
              }));
            }
            return t2;
          }, Ta.prototype.getBinderAttributes = function() {
            var t2 = [];
            for (var e2 in this.binders) {
              var r2 = this.binders[e2];
              if (r2 instanceof Pa || r2 instanceof Ma)
                for (var n2 = 0; n2 < r2.paintVertexAttributes.length; n2++)
                  t2.push(r2.paintVertexAttributes[n2].name);
              else if (r2 instanceof Ba)
                for (var i2 = 0; i2 < la.members.length; i2++)
                  t2.push(la.members[i2].name);
            }
            return t2;
          }, Ta.prototype.getBinderUniforms = function() {
            var t2 = [];
            for (var e2 in this.binders) {
              var r2 = this.binders[e2];
              if (r2 instanceof Ca || r2 instanceof Ea || r2 instanceof Ma)
                for (var n2 = 0, i2 = r2.uniformNames; n2 < i2.length; n2 += 1)
                  t2.push(i2[n2]);
            }
            return t2;
          }, Ta.prototype.getPaintVertexBuffers = function() {
            return this._buffers;
          }, Ta.prototype.getUniforms = function(t2, e2) {
            var r2 = [];
            for (var n2 in this.binders) {
              var i2 = this.binders[n2];
              if (i2 instanceof Ca || i2 instanceof Ea || i2 instanceof Ma)
                for (var a2 = 0, o2 = i2.uniformNames; a2 < o2.length; a2 += 1) {
                  var s2 = o2[a2];
                  if (e2[s2]) {
                    var u2 = i2.getBinding(t2, e2[s2], s2);
                    r2.push({ name: s2, property: n2, binding: u2 });
                  }
                }
            }
            return r2;
          }, Ta.prototype.setUniforms = function(t2, e2, r2, n2) {
            for (var i2 = 0, a2 = e2; i2 < a2.length; i2 += 1) {
              var o2 = a2[i2], s2 = o2.name, u2 = o2.property;
              this.binders[u2].setUniform(o2.binding, n2, r2.get(u2), s2);
            }
          }, Ta.prototype.updatePaintBuffers = function(t2) {
            for (var e2 in this._buffers = [], this.binders) {
              var r2 = this.binders[e2];
              if (t2 && r2 instanceof Ba) {
                var n2 = 2 === t2.fromScale ? r2.zoomInPaintVertexBuffer : r2.zoomOutPaintVertexBuffer;
                n2 && this._buffers.push(n2);
              } else
                (r2 instanceof Pa || r2 instanceof Ma) && r2.paintVertexBuffer && this._buffers.push(r2.paintVertexBuffer);
            }
          }, Ta.prototype.upload = function(t2) {
            for (var e2 in this.binders) {
              var r2 = this.binders[e2];
              (r2 instanceof Pa || r2 instanceof Ma || r2 instanceof Ba) && r2.upload(t2);
            }
            this.updatePaintBuffers();
          }, Ta.prototype.destroy = function() {
            for (var t2 in this.binders) {
              var e2 = this.binders[t2];
              (e2 instanceof Pa || e2 instanceof Ma || e2 instanceof Ba) && e2.destroy();
            }
          };
          var Va = function(t2, e2, r2) {
            void 0 === r2 && (r2 = function() {
              return true;
            }), this.programConfigurations = {};
            for (var n2 = 0, i2 = t2; n2 < i2.length; n2 += 1) {
              var a2 = i2[n2];
              this.programConfigurations[a2.id] = new Ta(a2, e2, r2);
            }
            this.needsUpload = false, this._featureMap = new ya(), this._bufferOffset = 0;
          };
          function Fa(t2, e2) {
            return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t2] || [t2.replace(e2 + "-", "").replace(/-/g, "_")];
          }
          function Da(t2, e2, r2) {
            var n2 = { color: { source: Bi, composite: Hi }, number: { source: Ki, composite: Bi } }, i2 = function(t3) {
              return { "line-pattern": { source: Ti, composite: Ti }, "fill-pattern": { source: Ti, composite: Ti }, "fill-extrusion-pattern": { source: Ti, composite: Ti } }[t3];
            }(t2);
            return i2 && i2[r2] || n2[e2][r2];
          }
          Va.prototype.populatePaintArrays = function(t2, e2, r2, n2, i2, a2) {
            for (var o2 in this.programConfigurations)
              this.programConfigurations[o2].populatePaintArrays(t2, e2, n2, i2, a2);
            void 0 !== e2.id && this._featureMap.add(e2.id, r2, this._bufferOffset, t2), this._bufferOffset = t2, this.needsUpload = true;
          }, Va.prototype.updatePaintArrays = function(t2, e2, r2, n2) {
            for (var i2 = 0, a2 = r2; i2 < a2.length; i2 += 1) {
              var o2 = a2[i2];
              this.needsUpload = this.programConfigurations[o2.id].updatePaintArrays(t2, this._featureMap, e2, o2, n2) || this.needsUpload;
            }
          }, Va.prototype.get = function(t2) {
            return this.programConfigurations[t2];
          }, Va.prototype.upload = function(t2) {
            if (this.needsUpload) {
              for (var e2 in this.programConfigurations)
                this.programConfigurations[e2].upload(t2);
              this.needsUpload = false;
            }
          }, Va.prototype.destroy = function() {
            for (var t2 in this.programConfigurations)
              this.programConfigurations[t2].destroy();
          }, On("ConstantBinder", Ca), On("CrossFadedConstantBinder", Ea), On("SourceExpressionBinder", Pa), On("CrossFadedCompositeBinder", Ba), On("CompositeExpressionBinder", Ma), On("ProgramConfiguration", Ta, { omit: ["_buffers"] }), On("ProgramConfigurationSet", Va);
          var La = Math.pow(2, 14) - 1, Oa = -La - 1;
          function Ra(t2) {
            for (var e2 = 8192 / t2.extent, r2 = t2.loadGeometry(), n2 = 0; n2 < r2.length; n2++)
              for (var i2 = r2[n2], a2 = 0; a2 < i2.length; a2++) {
                var o2 = i2[a2], s2 = Math.round(o2.x * e2), u2 = Math.round(o2.y * e2);
                o2.x = p(s2, Oa, La), o2.y = p(u2, Oa, La), (s2 < o2.x || s2 > o2.x + 1 || u2 < o2.y || u2 > o2.y + 1) && A("Geometry exceeds allowed extent, reduce your vector tile buffer size");
              }
            return r2;
          }
          function Ua(t2, e2) {
            return { type: t2.type, id: t2.id, properties: t2.properties, geometry: e2 ? Ra(t2) : [] };
          }
          function ja(t2, e2, r2, n2, i2) {
            t2.emplaceBack(2 * e2 + (n2 + 1) / 2, 2 * r2 + (i2 + 1) / 2);
          }
          var qa = function(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map(function(t3) {
              return t3.id;
            }), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new Ci(), this.indexArray = new ji(), this.segments = new sa(), this.programConfigurations = new Va(t2.layers, t2.zoom), this.stateDependentLayerIds = this.layers.filter(function(t3) {
              return t3.isStateDependent();
            }).map(function(t3) {
              return t3.id;
            });
          };
          function Na(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              if (Wa(e2, t2[r2]))
                return true;
            for (var n2 = 0; n2 < e2.length; n2++)
              if (Wa(t2, e2[n2]))
                return true;
            return !!Xa(t2, e2);
          }
          function Ka(t2, e2, r2) {
            return !!Wa(t2, e2) || !!Ha(e2, t2, r2);
          }
          function Ga(t2, e2) {
            if (1 === t2.length)
              return $a(e2, t2[0]);
            for (var r2 = 0; r2 < e2.length; r2++)
              for (var n2 = e2[r2], i2 = 0; i2 < n2.length; i2++)
                if (Wa(t2, n2[i2]))
                  return true;
            for (var a2 = 0; a2 < t2.length; a2++)
              if ($a(e2, t2[a2]))
                return true;
            for (var o2 = 0; o2 < e2.length; o2++)
              if (Xa(t2, e2[o2]))
                return true;
            return false;
          }
          function Za(t2, e2, r2) {
            if (t2.length > 1) {
              if (Xa(t2, e2))
                return true;
              for (var n2 = 0; n2 < e2.length; n2++)
                if (Ha(e2[n2], t2, r2))
                  return true;
            }
            for (var i2 = 0; i2 < t2.length; i2++)
              if (Ha(t2[i2], e2, r2))
                return true;
            return false;
          }
          function Xa(t2, e2) {
            if (0 === t2.length || 0 === e2.length)
              return false;
            for (var r2 = 0; r2 < t2.length - 1; r2++)
              for (var n2 = t2[r2], i2 = t2[r2 + 1], a2 = 0; a2 < e2.length - 1; a2++)
                if (Ja(n2, i2, e2[a2], e2[a2 + 1]))
                  return true;
            return false;
          }
          function Ja(t2, e2, r2, n2) {
            return S(t2, r2, n2) !== S(e2, r2, n2) && S(t2, e2, r2) !== S(t2, e2, n2);
          }
          function Ha(t2, e2, r2) {
            var n2 = r2 * r2;
            if (1 === e2.length)
              return t2.distSqr(e2[0]) < n2;
            for (var i2 = 1; i2 < e2.length; i2++)
              if (Ya(t2, e2[i2 - 1], e2[i2]) < n2)
                return true;
            return false;
          }
          function Ya(t2, e2, r2) {
            var n2 = e2.distSqr(r2);
            if (0 === n2)
              return t2.distSqr(e2);
            var i2 = ((t2.x - e2.x) * (r2.x - e2.x) + (t2.y - e2.y) * (r2.y - e2.y)) / n2;
            return t2.distSqr(i2 < 0 ? e2 : i2 > 1 ? r2 : r2.sub(e2)._mult(i2)._add(e2));
          }
          function $a(t2, e2) {
            for (var r2, n2, i2, a2 = false, o2 = 0; o2 < t2.length; o2++)
              for (var s2 = 0, u2 = (r2 = t2[o2]).length - 1; s2 < r2.length; u2 = s2++)
                (n2 = r2[s2]).y > e2.y != (i2 = r2[u2]).y > e2.y && e2.x < (i2.x - n2.x) * (e2.y - n2.y) / (i2.y - n2.y) + n2.x && (a2 = !a2);
            return a2;
          }
          function Wa(t2, e2) {
            for (var r2 = false, n2 = 0, i2 = t2.length - 1; n2 < t2.length; i2 = n2++) {
              var a2 = t2[n2], o2 = t2[i2];
              a2.y > e2.y != o2.y > e2.y && e2.x < (o2.x - a2.x) * (e2.y - a2.y) / (o2.y - a2.y) + a2.x && (r2 = !r2);
            }
            return r2;
          }
          function Qa(t2, e2, r2) {
            var n2 = r2[0], i2 = r2[2];
            if (t2.x < n2.x && e2.x < n2.x || t2.x > i2.x && e2.x > i2.x || t2.y < n2.y && e2.y < n2.y || t2.y > i2.y && e2.y > i2.y)
              return false;
            var a2 = S(t2, e2, r2[0]);
            return a2 !== S(t2, e2, r2[1]) || a2 !== S(t2, e2, r2[2]) || a2 !== S(t2, e2, r2[3]);
          }
          function to(t2, e2, r2) {
            var n2 = e2.paint.get(t2).value;
            return "constant" === n2.kind ? n2.value : r2.programConfigurations.get(e2.id).getMaxValue(t2);
          }
          function eo(t2) {
            return Math.sqrt(t2[0] * t2[0] + t2[1] * t2[1]);
          }
          function ro(t2, e2, r2, n2, a2) {
            if (!e2[0] && !e2[1])
              return t2;
            var o2 = i.convert(e2)._mult(a2);
            "viewport" === r2 && o2._rotate(-n2);
            for (var s2 = [], u2 = 0; u2 < t2.length; u2++)
              s2.push(t2[u2].sub(o2));
            return s2;
          }
          qa.prototype.populate = function(t2, e2, r2) {
            var n2 = this.layers[0], i2 = [], a2 = null;
            "circle" === n2.type && (a2 = n2.layout.get("circle-sort-key"));
            for (var o2 = 0, s2 = t2; o2 < s2.length; o2 += 1) {
              var u2 = s2[o2], l2 = u2.feature, p2 = u2.id, c2 = u2.index, h2 = u2.sourceLayerIndex, f2 = this.layers[0]._featureFilter.needGeometry, y2 = Ua(l2, f2);
              if (this.layers[0]._featureFilter.filter(new si(this.zoom), y2, r2)) {
                var d2 = a2 ? a2.evaluate(y2, {}, r2) : void 0, m2 = { id: p2, properties: l2.properties, type: l2.type, sourceLayerIndex: h2, index: c2, geometry: f2 ? y2.geometry : Ra(l2), patterns: {}, sortKey: d2 };
                i2.push(m2);
              }
            }
            a2 && i2.sort(function(t3, e3) {
              return t3.sortKey - e3.sortKey;
            });
            for (var v2 = 0, g2 = i2; v2 < g2.length; v2 += 1) {
              var x2 = g2[v2], b2 = x2.geometry, w2 = x2.index, _2 = x2.sourceLayerIndex, A2 = t2[w2].feature;
              this.addFeature(x2, b2, w2, r2), e2.featureIndex.insert(A2, b2, w2, _2, this.index);
            }
          }, qa.prototype.update = function(t2, e2, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
          }, qa.prototype.isEmpty = function() {
            return 0 === this.layoutVertexArray.length;
          }, qa.prototype.uploadPending = function() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }, qa.prototype.upload = function(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, oa), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
          }, qa.prototype.destroy = function() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }, qa.prototype.addFeature = function(t2, e2, r2, n2) {
            for (var i2 = 0, a2 = e2; i2 < a2.length; i2 += 1)
              for (var o2 = 0, s2 = a2[i2]; o2 < s2.length; o2 += 1) {
                var u2 = s2[o2], l2 = u2.x, p2 = u2.y;
                if (!(l2 < 0 || l2 >= 8192 || p2 < 0 || p2 >= 8192)) {
                  var c2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t2.sortKey), h2 = c2.vertexLength;
                  ja(this.layoutVertexArray, l2, p2, -1, -1), ja(this.layoutVertexArray, l2, p2, 1, -1), ja(this.layoutVertexArray, l2, p2, 1, 1), ja(this.layoutVertexArray, l2, p2, -1, 1), this.indexArray.emplaceBack(h2, h2 + 1, h2 + 2), this.indexArray.emplaceBack(h2, h2 + 3, h2 + 2), c2.vertexLength += 4, c2.primitiveLength += 2;
                }
              }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, {}, n2);
          }, On("CircleBucket", qa, { omit: ["layers"] });
          var no = new wi({ "circle-sort-key": new vi(Et.layout_circle["circle-sort-key"]) }), io = { paint: new wi({ "circle-radius": new vi(Et.paint_circle["circle-radius"]), "circle-color": new vi(Et.paint_circle["circle-color"]), "circle-blur": new vi(Et.paint_circle["circle-blur"]), "circle-opacity": new vi(Et.paint_circle["circle-opacity"]), "circle-translate": new mi(Et.paint_circle["circle-translate"]), "circle-translate-anchor": new mi(Et.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new mi(Et.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new mi(Et.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new vi(Et.paint_circle["circle-stroke-width"]), "circle-stroke-color": new vi(Et.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new vi(Et.paint_circle["circle-stroke-opacity"]) }), layout: no }, ao = "undefined" != typeof Float32Array ? Float32Array : Array;
          function oo(t2) {
            return t2[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = 1, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 1, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0, t2[15] = 1, t2;
          }
          function so(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], a2 = e2[2], o2 = e2[3], s2 = e2[4], u2 = e2[5], l2 = e2[6], p2 = e2[7], c2 = e2[8], h2 = e2[9], f2 = e2[10], y2 = e2[11], d2 = e2[12], m2 = e2[13], v2 = e2[14], g2 = e2[15], x2 = r2[0], b2 = r2[1], w2 = r2[2], _2 = r2[3];
            return t2[0] = x2 * n2 + b2 * s2 + w2 * c2 + _2 * d2, t2[1] = x2 * i2 + b2 * u2 + w2 * h2 + _2 * m2, t2[2] = x2 * a2 + b2 * l2 + w2 * f2 + _2 * v2, t2[3] = x2 * o2 + b2 * p2 + w2 * y2 + _2 * g2, t2[4] = (x2 = r2[4]) * n2 + (b2 = r2[5]) * s2 + (w2 = r2[6]) * c2 + (_2 = r2[7]) * d2, t2[5] = x2 * i2 + b2 * u2 + w2 * h2 + _2 * m2, t2[6] = x2 * a2 + b2 * l2 + w2 * f2 + _2 * v2, t2[7] = x2 * o2 + b2 * p2 + w2 * y2 + _2 * g2, t2[8] = (x2 = r2[8]) * n2 + (b2 = r2[9]) * s2 + (w2 = r2[10]) * c2 + (_2 = r2[11]) * d2, t2[9] = x2 * i2 + b2 * u2 + w2 * h2 + _2 * m2, t2[10] = x2 * a2 + b2 * l2 + w2 * f2 + _2 * v2, t2[11] = x2 * o2 + b2 * p2 + w2 * y2 + _2 * g2, t2[12] = (x2 = r2[12]) * n2 + (b2 = r2[13]) * s2 + (w2 = r2[14]) * c2 + (_2 = r2[15]) * d2, t2[13] = x2 * i2 + b2 * u2 + w2 * h2 + _2 * m2, t2[14] = x2 * a2 + b2 * l2 + w2 * f2 + _2 * v2, t2[15] = x2 * o2 + b2 * p2 + w2 * y2 + _2 * g2, t2;
          }
          Math.hypot || (Math.hypot = function() {
            for (var t2 = arguments, e2 = 0, r2 = arguments.length; r2--; )
              e2 += t2[r2] * t2[r2];
            return Math.sqrt(e2);
          });
          var uo, lo = so;
          function po(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], a2 = e2[2], o2 = e2[3];
            return t2[0] = r2[0] * n2 + r2[4] * i2 + r2[8] * a2 + r2[12] * o2, t2[1] = r2[1] * n2 + r2[5] * i2 + r2[9] * a2 + r2[13] * o2, t2[2] = r2[2] * n2 + r2[6] * i2 + r2[10] * a2 + r2[14] * o2, t2[3] = r2[3] * n2 + r2[7] * i2 + r2[11] * a2 + r2[15] * o2, t2;
          }
          uo = new ao(3), ao != Float32Array && (uo[0] = 0, uo[1] = 0, uo[2] = 0), function() {
            var t2 = new ao(4);
            ao != Float32Array && (t2[0] = 0, t2[1] = 0, t2[2] = 0, t2[3] = 0);
          }();
          var co = (function() {
            var t2 = new ao(2);
            ao != Float32Array && (t2[0] = 0, t2[1] = 0);
          }(), function(t2) {
            function e2(e3) {
              t2.call(this, e3, io);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.createBucket = function(t3) {
              return new qa(t3);
            }, e2.prototype.queryRadius = function(t3) {
              var e3 = t3;
              return to("circle-radius", this, e3) + to("circle-stroke-width", this, e3) + eo(this.paint.get("circle-translate"));
            }, e2.prototype.queryIntersectsFeature = function(t3, e3, r2, n2, i2, a2, o2, s2) {
              for (var u2 = ro(t3, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), a2.angle, o2), l2 = this.paint.get("circle-radius").evaluate(e3, r2) + this.paint.get("circle-stroke-width").evaluate(e3, r2), p2 = "map" === this.paint.get("circle-pitch-alignment"), c2 = p2 ? u2 : function(t4, e4) {
                return t4.map(function(t5) {
                  return ho(t5, e4);
                });
              }(u2, s2), h2 = p2 ? l2 * o2 : l2, f2 = 0, y2 = n2; f2 < y2.length; f2 += 1)
                for (var d2 = 0, m2 = y2[f2]; d2 < m2.length; d2 += 1) {
                  var v2 = m2[d2], g2 = p2 ? v2 : ho(v2, s2), x2 = h2, b2 = po([], [v2.x, v2.y, 0, 1], s2);
                  if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? x2 *= b2[3] / a2.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (x2 *= a2.cameraToCenterDistance / b2[3]), Ka(c2, g2, x2))
                    return true;
                }
              return false;
            }, e2;
          }(_i));
          function ho(t2, e2) {
            var r2 = po([], [t2.x, t2.y, 0, 1], e2);
            return new i(r2[0] / r2[3], r2[1] / r2[3]);
          }
          var fo = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2;
          }(qa);
          function yo(t2, e2, r2, n2) {
            var i2 = e2.width, a2 = e2.height;
            if (n2) {
              if (n2 instanceof Uint8ClampedArray)
                n2 = new Uint8Array(n2.buffer);
              else if (n2.length !== i2 * a2 * r2)
                throw new RangeError("mismatched image size");
            } else
              n2 = new Uint8Array(i2 * a2 * r2);
            return t2.width = i2, t2.height = a2, t2.data = n2, t2;
          }
          function mo(t2, e2, r2) {
            var n2 = e2.width, i2 = e2.height;
            if (n2 !== t2.width || i2 !== t2.height) {
              var a2 = yo({}, { width: n2, height: i2 }, r2);
              vo(t2, a2, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t2.width, n2), height: Math.min(t2.height, i2) }, r2), t2.width = n2, t2.height = i2, t2.data = a2.data;
            }
          }
          function vo(t2, e2, r2, n2, i2, a2) {
            if (0 === i2.width || 0 === i2.height)
              return e2;
            if (i2.width > t2.width || i2.height > t2.height || r2.x > t2.width - i2.width || r2.y > t2.height - i2.height)
              throw new RangeError("out of range source coordinates for image copy");
            if (i2.width > e2.width || i2.height > e2.height || n2.x > e2.width - i2.width || n2.y > e2.height - i2.height)
              throw new RangeError("out of range destination coordinates for image copy");
            for (var o2 = t2.data, s2 = e2.data, u2 = 0; u2 < i2.height; u2++)
              for (var l2 = ((r2.y + u2) * t2.width + r2.x) * a2, p2 = ((n2.y + u2) * e2.width + n2.x) * a2, c2 = 0; c2 < i2.width * a2; c2++)
                s2[p2 + c2] = o2[l2 + c2];
            return e2;
          }
          On("HeatmapBucket", fo, { omit: ["layers"] });
          var go2 = function(t2, e2) {
            yo(this, t2, 1, e2);
          };
          go2.prototype.resize = function(t2) {
            mo(this, t2, 1);
          }, go2.prototype.clone = function() {
            return new go2({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }, go2.copy = function(t2, e2, r2, n2, i2) {
            vo(t2, e2, r2, n2, i2, 1);
          };
          var xo = function(t2, e2) {
            yo(this, t2, 4, e2);
          };
          xo.prototype.resize = function(t2) {
            mo(this, t2, 4);
          }, xo.prototype.replace = function(t2, e2) {
            e2 ? this.data.set(t2) : this.data = t2 instanceof Uint8ClampedArray ? new Uint8Array(t2.buffer) : t2;
          }, xo.prototype.clone = function() {
            return new xo({ width: this.width, height: this.height }, new Uint8Array(this.data));
          }, xo.copy = function(t2, e2, r2, n2, i2) {
            vo(t2, e2, r2, n2, i2, 4);
          }, On("AlphaImage", go2), On("RGBAImage", xo);
          var bo = { paint: new wi({ "heatmap-radius": new vi(Et.paint_heatmap["heatmap-radius"]), "heatmap-weight": new vi(Et.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new mi(Et.paint_heatmap["heatmap-intensity"]), "heatmap-color": new bi(Et.paint_heatmap["heatmap-color"]), "heatmap-opacity": new mi(Et.paint_heatmap["heatmap-opacity"]) }) };
          function wo(t2) {
            var e2 = {}, r2 = t2.resolution || 256, n2 = t2.clips ? t2.clips.length : 1, i2 = t2.image || new xo({ width: r2, height: n2 }), a2 = function(r3, n3, a3) {
              e2[t2.evaluationKey] = a3;
              var o3 = t2.expression.evaluate(e2);
              i2.data[r3 + n3 + 0] = Math.floor(255 * o3.r / o3.a), i2.data[r3 + n3 + 1] = Math.floor(255 * o3.g / o3.a), i2.data[r3 + n3 + 2] = Math.floor(255 * o3.b / o3.a), i2.data[r3 + n3 + 3] = Math.floor(255 * o3.a);
            };
            if (t2.clips)
              for (var o2 = 0, s2 = 0; o2 < n2; ++o2, s2 += 4 * r2)
                for (var u2 = 0, l2 = 0; u2 < r2; u2++, l2 += 4) {
                  var p2 = u2 / (r2 - 1), c2 = t2.clips[o2];
                  a2(s2, l2, c2.start * (1 - p2) + c2.end * p2);
                }
            else
              for (var h2 = 0, f2 = 0; h2 < r2; h2++, f2 += 4)
                a2(0, f2, h2 / (r2 - 1));
            return i2;
          }
          var _o = function(t2) {
            function e2(e3) {
              t2.call(this, e3, bo), this._updateColorRamp();
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.createBucket = function(t3) {
              return new fo(t3);
            }, e2.prototype._handleSpecialPaintPropertyUpdate = function(t3) {
              "heatmap-color" === t3 && this._updateColorRamp();
            }, e2.prototype._updateColorRamp = function() {
              this.colorRamp = wo({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
            }, e2.prototype.resize = function() {
              this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
            }, e2.prototype.queryRadius = function() {
              return 0;
            }, e2.prototype.queryIntersectsFeature = function() {
              return false;
            }, e2.prototype.hasOffscreenPass = function() {
              return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
            }, e2;
          }(_i), Ao = { paint: new wi({ "hillshade-illumination-direction": new mi(Et.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new mi(Et.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new mi(Et.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new mi(Et.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new mi(Et.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new mi(Et.paint_hillshade["hillshade-accent-color"]) }) }, So = function(t2) {
            function e2(e3) {
              t2.call(this, e3, Ao);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.hasOffscreenPass = function() {
              return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
            }, e2;
          }(_i), ko = Ii([{ name: "a_pos", components: 2, type: "Int16" }], 4).members, Io = Co, zo = Co;
          function Co(t2, e2, r2) {
            r2 = r2 || 2;
            var n2, i2, a2, o2, s2, u2, l2, p2 = e2 && e2.length, c2 = p2 ? e2[0] * r2 : t2.length, h2 = Eo(t2, 0, c2, r2, true), f2 = [];
            if (!h2 || h2.next === h2.prev)
              return f2;
            if (p2 && (h2 = function(t3, e3, r3, n3) {
              var i3, a3, o3, s3 = [];
              for (i3 = 0, a3 = e3.length; i3 < a3; i3++)
                (o3 = Eo(t3, e3[i3] * n3, i3 < a3 - 1 ? e3[i3 + 1] * n3 : t3.length, n3, false)) === o3.next && (o3.steiner = true), s3.push(Uo(o3));
              for (s3.sort(Do), i3 = 0; i3 < s3.length; i3++)
                Lo(s3[i3], r3), r3 = Po(r3, r3.next);
              return r3;
            }(t2, e2, h2, r2)), t2.length > 80 * r2) {
              n2 = a2 = t2[0], i2 = o2 = t2[1];
              for (var y2 = r2; y2 < c2; y2 += r2)
                (s2 = t2[y2]) < n2 && (n2 = s2), (u2 = t2[y2 + 1]) < i2 && (i2 = u2), s2 > a2 && (a2 = s2), u2 > o2 && (o2 = u2);
              l2 = 0 !== (l2 = Math.max(a2 - n2, o2 - i2)) ? 1 / l2 : 0;
            }
            return Mo(h2, f2, r2, n2, i2, l2), f2;
          }
          function Eo(t2, e2, r2, n2, i2) {
            var a2, o2;
            if (i2 === Qo(t2, e2, r2, n2) > 0)
              for (a2 = e2; a2 < r2; a2 += n2)
                o2 = Yo(a2, t2[a2], t2[a2 + 1], o2);
            else
              for (a2 = r2 - n2; a2 >= e2; a2 -= n2)
                o2 = Yo(a2, t2[a2], t2[a2 + 1], o2);
            return o2 && Ko(o2, o2.next) && ($o(o2), o2 = o2.next), o2;
          }
          function Po(t2, e2) {
            if (!t2)
              return t2;
            e2 || (e2 = t2);
            var r2, n2 = t2;
            do {
              if (r2 = false, n2.steiner || !Ko(n2, n2.next) && 0 !== No(n2.prev, n2, n2.next))
                n2 = n2.next;
              else {
                if ($o(n2), (n2 = e2 = n2.prev) === n2.next)
                  break;
                r2 = true;
              }
            } while (r2 || n2 !== e2);
            return e2;
          }
          function Mo(t2, e2, r2, n2, i2, a2, o2) {
            if (t2) {
              !o2 && a2 && function(t3, e3, r3, n3) {
                var i3 = t3;
                do {
                  null === i3.z && (i3.z = Ro(i3.x, i3.y, e3, r3, n3)), i3.prevZ = i3.prev, i3.nextZ = i3.next, i3 = i3.next;
                } while (i3 !== t3);
                i3.prevZ.nextZ = null, i3.prevZ = null, function(t4) {
                  var e4, r4, n4, i4, a3, o3, s3, u3, l3 = 1;
                  do {
                    for (r4 = t4, t4 = null, a3 = null, o3 = 0; r4; ) {
                      for (o3++, n4 = r4, s3 = 0, e4 = 0; e4 < l3 && (s3++, n4 = n4.nextZ); e4++)
                        ;
                      for (u3 = l3; s3 > 0 || u3 > 0 && n4; )
                        0 !== s3 && (0 === u3 || !n4 || r4.z <= n4.z) ? (i4 = r4, r4 = r4.nextZ, s3--) : (i4 = n4, n4 = n4.nextZ, u3--), a3 ? a3.nextZ = i4 : t4 = i4, i4.prevZ = a3, a3 = i4;
                      r4 = n4;
                    }
                    a3.nextZ = null, l3 *= 2;
                  } while (o3 > 1);
                }(i3);
              }(t2, n2, i2, a2);
              for (var s2, u2, l2 = t2; t2.prev !== t2.next; )
                if (s2 = t2.prev, u2 = t2.next, a2 ? To(t2, n2, i2, a2) : Bo(t2))
                  e2.push(s2.i / r2), e2.push(t2.i / r2), e2.push(u2.i / r2), $o(t2), t2 = u2.next, l2 = u2.next;
                else if ((t2 = u2) === l2) {
                  o2 ? 1 === o2 ? Mo(t2 = Vo(Po(t2), e2, r2), e2, r2, n2, i2, a2, 2) : 2 === o2 && Fo(t2, e2, r2, n2, i2, a2) : Mo(Po(t2), e2, r2, n2, i2, a2, 1);
                  break;
                }
            }
          }
          function Bo(t2) {
            var e2 = t2.prev, r2 = t2, n2 = t2.next;
            if (No(e2, r2, n2) >= 0)
              return false;
            for (var i2 = t2.next.next; i2 !== t2.prev; ) {
              if (jo(e2.x, e2.y, r2.x, r2.y, n2.x, n2.y, i2.x, i2.y) && No(i2.prev, i2, i2.next) >= 0)
                return false;
              i2 = i2.next;
            }
            return true;
          }
          function To(t2, e2, r2, n2) {
            var i2 = t2.prev, a2 = t2, o2 = t2.next;
            if (No(i2, a2, o2) >= 0)
              return false;
            for (var s2 = i2.x > a2.x ? i2.x > o2.x ? i2.x : o2.x : a2.x > o2.x ? a2.x : o2.x, u2 = i2.y > a2.y ? i2.y > o2.y ? i2.y : o2.y : a2.y > o2.y ? a2.y : o2.y, l2 = Ro(i2.x < a2.x ? i2.x < o2.x ? i2.x : o2.x : a2.x < o2.x ? a2.x : o2.x, i2.y < a2.y ? i2.y < o2.y ? i2.y : o2.y : a2.y < o2.y ? a2.y : o2.y, e2, r2, n2), p2 = Ro(s2, u2, e2, r2, n2), c2 = t2.prevZ, h2 = t2.nextZ; c2 && c2.z >= l2 && h2 && h2.z <= p2; ) {
              if (c2 !== t2.prev && c2 !== t2.next && jo(i2.x, i2.y, a2.x, a2.y, o2.x, o2.y, c2.x, c2.y) && No(c2.prev, c2, c2.next) >= 0)
                return false;
              if (c2 = c2.prevZ, h2 !== t2.prev && h2 !== t2.next && jo(i2.x, i2.y, a2.x, a2.y, o2.x, o2.y, h2.x, h2.y) && No(h2.prev, h2, h2.next) >= 0)
                return false;
              h2 = h2.nextZ;
            }
            for (; c2 && c2.z >= l2; ) {
              if (c2 !== t2.prev && c2 !== t2.next && jo(i2.x, i2.y, a2.x, a2.y, o2.x, o2.y, c2.x, c2.y) && No(c2.prev, c2, c2.next) >= 0)
                return false;
              c2 = c2.prevZ;
            }
            for (; h2 && h2.z <= p2; ) {
              if (h2 !== t2.prev && h2 !== t2.next && jo(i2.x, i2.y, a2.x, a2.y, o2.x, o2.y, h2.x, h2.y) && No(h2.prev, h2, h2.next) >= 0)
                return false;
              h2 = h2.nextZ;
            }
            return true;
          }
          function Vo(t2, e2, r2) {
            var n2 = t2;
            do {
              var i2 = n2.prev, a2 = n2.next.next;
              !Ko(i2, a2) && Go(i2, n2, n2.next, a2) && Jo(i2, a2) && Jo(a2, i2) && (e2.push(i2.i / r2), e2.push(n2.i / r2), e2.push(a2.i / r2), $o(n2), $o(n2.next), n2 = t2 = a2), n2 = n2.next;
            } while (n2 !== t2);
            return Po(n2);
          }
          function Fo(t2, e2, r2, n2, i2, a2) {
            var o2 = t2;
            do {
              for (var s2 = o2.next.next; s2 !== o2.prev; ) {
                if (o2.i !== s2.i && qo(o2, s2)) {
                  var u2 = Ho(o2, s2);
                  return o2 = Po(o2, o2.next), u2 = Po(u2, u2.next), Mo(o2, e2, r2, n2, i2, a2), void Mo(u2, e2, r2, n2, i2, a2);
                }
                s2 = s2.next;
              }
              o2 = o2.next;
            } while (o2 !== t2);
          }
          function Do(t2, e2) {
            return t2.x - e2.x;
          }
          function Lo(t2, e2) {
            if (e2 = function(t3, e3) {
              var r3, n2 = e3, i2 = t3.x, a2 = t3.y, o2 = -1 / 0;
              do {
                if (a2 <= n2.y && a2 >= n2.next.y && n2.next.y !== n2.y) {
                  var s2 = n2.x + (a2 - n2.y) * (n2.next.x - n2.x) / (n2.next.y - n2.y);
                  if (s2 <= i2 && s2 > o2) {
                    if (o2 = s2, s2 === i2) {
                      if (a2 === n2.y)
                        return n2;
                      if (a2 === n2.next.y)
                        return n2.next;
                    }
                    r3 = n2.x < n2.next.x ? n2 : n2.next;
                  }
                }
                n2 = n2.next;
              } while (n2 !== e3);
              if (!r3)
                return null;
              if (i2 === o2)
                return r3;
              var u2, l2 = r3, p2 = r3.x, c2 = r3.y, h2 = 1 / 0;
              n2 = r3;
              do {
                i2 >= n2.x && n2.x >= p2 && i2 !== n2.x && jo(a2 < c2 ? i2 : o2, a2, p2, c2, a2 < c2 ? o2 : i2, a2, n2.x, n2.y) && (u2 = Math.abs(a2 - n2.y) / (i2 - n2.x), Jo(n2, t3) && (u2 < h2 || u2 === h2 && (n2.x > r3.x || n2.x === r3.x && Oo(r3, n2))) && (r3 = n2, h2 = u2)), n2 = n2.next;
              } while (n2 !== l2);
              return r3;
            }(t2, e2)) {
              var r2 = Ho(e2, t2);
              Po(e2, e2.next), Po(r2, r2.next);
            }
          }
          function Oo(t2, e2) {
            return No(t2.prev, t2, e2.prev) < 0 && No(e2.next, t2, t2.next) < 0;
          }
          function Ro(t2, e2, r2, n2, i2) {
            return (t2 = 1431655765 & ((t2 = 858993459 & ((t2 = 252645135 & ((t2 = 16711935 & ((t2 = 32767 * (t2 - r2) * i2) | t2 << 8)) | t2 << 4)) | t2 << 2)) | t2 << 1)) | (e2 = 1431655765 & ((e2 = 858993459 & ((e2 = 252645135 & ((e2 = 16711935 & ((e2 = 32767 * (e2 - n2) * i2) | e2 << 8)) | e2 << 4)) | e2 << 2)) | e2 << 1)) << 1;
          }
          function Uo(t2) {
            var e2 = t2, r2 = t2;
            do {
              (e2.x < r2.x || e2.x === r2.x && e2.y < r2.y) && (r2 = e2), e2 = e2.next;
            } while (e2 !== t2);
            return r2;
          }
          function jo(t2, e2, r2, n2, i2, a2, o2, s2) {
            return (i2 - o2) * (e2 - s2) - (t2 - o2) * (a2 - s2) >= 0 && (t2 - o2) * (n2 - s2) - (r2 - o2) * (e2 - s2) >= 0 && (r2 - o2) * (a2 - s2) - (i2 - o2) * (n2 - s2) >= 0;
          }
          function qo(t2, e2) {
            return t2.next.i !== e2.i && t2.prev.i !== e2.i && !function(t3, e3) {
              var r2 = t3;
              do {
                if (r2.i !== t3.i && r2.next.i !== t3.i && r2.i !== e3.i && r2.next.i !== e3.i && Go(r2, r2.next, t3, e3))
                  return true;
                r2 = r2.next;
              } while (r2 !== t3);
              return false;
            }(t2, e2) && (Jo(t2, e2) && Jo(e2, t2) && function(t3, e3) {
              var r2 = t3, n2 = false, i2 = (t3.x + e3.x) / 2, a2 = (t3.y + e3.y) / 2;
              do {
                r2.y > a2 != r2.next.y > a2 && r2.next.y !== r2.y && i2 < (r2.next.x - r2.x) * (a2 - r2.y) / (r2.next.y - r2.y) + r2.x && (n2 = !n2), r2 = r2.next;
              } while (r2 !== t3);
              return n2;
            }(t2, e2) && (No(t2.prev, t2, e2.prev) || No(t2, e2.prev, e2)) || Ko(t2, e2) && No(t2.prev, t2, t2.next) > 0 && No(e2.prev, e2, e2.next) > 0);
          }
          function No(t2, e2, r2) {
            return (e2.y - t2.y) * (r2.x - e2.x) - (e2.x - t2.x) * (r2.y - e2.y);
          }
          function Ko(t2, e2) {
            return t2.x === e2.x && t2.y === e2.y;
          }
          function Go(t2, e2, r2, n2) {
            var i2 = Xo(No(t2, e2, r2)), a2 = Xo(No(t2, e2, n2)), o2 = Xo(No(r2, n2, t2)), s2 = Xo(No(r2, n2, e2));
            return i2 !== a2 && o2 !== s2 || !(0 !== i2 || !Zo(t2, r2, e2)) || !(0 !== a2 || !Zo(t2, n2, e2)) || !(0 !== o2 || !Zo(r2, t2, n2)) || !(0 !== s2 || !Zo(r2, e2, n2));
          }
          function Zo(t2, e2, r2) {
            return e2.x <= Math.max(t2.x, r2.x) && e2.x >= Math.min(t2.x, r2.x) && e2.y <= Math.max(t2.y, r2.y) && e2.y >= Math.min(t2.y, r2.y);
          }
          function Xo(t2) {
            return t2 > 0 ? 1 : t2 < 0 ? -1 : 0;
          }
          function Jo(t2, e2) {
            return No(t2.prev, t2, t2.next) < 0 ? No(t2, e2, t2.next) >= 0 && No(t2, t2.prev, e2) >= 0 : No(t2, e2, t2.prev) < 0 || No(t2, t2.next, e2) < 0;
          }
          function Ho(t2, e2) {
            var r2 = new Wo(t2.i, t2.x, t2.y), n2 = new Wo(e2.i, e2.x, e2.y), i2 = t2.next, a2 = e2.prev;
            return t2.next = e2, e2.prev = t2, r2.next = i2, i2.prev = r2, n2.next = r2, r2.prev = n2, a2.next = n2, n2.prev = a2, n2;
          }
          function Yo(t2, e2, r2, n2) {
            var i2 = new Wo(t2, e2, r2);
            return n2 ? (i2.next = n2.next, i2.prev = n2, n2.next.prev = i2, n2.next = i2) : (i2.prev = i2, i2.next = i2), i2;
          }
          function $o(t2) {
            t2.next.prev = t2.prev, t2.prev.next = t2.next, t2.prevZ && (t2.prevZ.nextZ = t2.nextZ), t2.nextZ && (t2.nextZ.prevZ = t2.prevZ);
          }
          function Wo(t2, e2, r2) {
            this.i = t2, this.x = e2, this.y = r2, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = false;
          }
          function Qo(t2, e2, r2, n2) {
            for (var i2 = 0, a2 = e2, o2 = r2 - n2; a2 < r2; a2 += n2)
              i2 += (t2[o2] - t2[a2]) * (t2[a2 + 1] + t2[o2 + 1]), o2 = a2;
            return i2;
          }
          function ts(t2, e2, r2, n2, i2) {
            !function t3(e3, r3, n3, i3, a2) {
              for (; i3 > n3; ) {
                if (i3 - n3 > 600) {
                  var o2 = i3 - n3 + 1, s2 = r3 - n3 + 1, u2 = Math.log(o2), l2 = 0.5 * Math.exp(2 * u2 / 3), p2 = 0.5 * Math.sqrt(u2 * l2 * (o2 - l2) / o2) * (s2 - o2 / 2 < 0 ? -1 : 1);
                  t3(e3, r3, Math.max(n3, Math.floor(r3 - s2 * l2 / o2 + p2)), Math.min(i3, Math.floor(r3 + (o2 - s2) * l2 / o2 + p2)), a2);
                }
                var c2 = e3[r3], h2 = n3, f2 = i3;
                for (es(e3, n3, r3), a2(e3[i3], c2) > 0 && es(e3, n3, i3); h2 < f2; ) {
                  for (es(e3, h2, f2), h2++, f2--; a2(e3[h2], c2) < 0; )
                    h2++;
                  for (; a2(e3[f2], c2) > 0; )
                    f2--;
                }
                0 === a2(e3[n3], c2) ? es(e3, n3, f2) : es(e3, ++f2, i3), f2 <= r3 && (n3 = f2 + 1), r3 <= f2 && (i3 = f2 - 1);
              }
            }(t2, e2, r2 || 0, n2 || t2.length - 1, i2 || rs);
          }
          function es(t2, e2, r2) {
            var n2 = t2[e2];
            t2[e2] = t2[r2], t2[r2] = n2;
          }
          function rs(t2, e2) {
            return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
          }
          function ns(t2, e2) {
            var r2 = t2.length;
            if (r2 <= 1)
              return [t2];
            for (var n2, i2, a2 = [], o2 = 0; o2 < r2; o2++) {
              var s2 = k(t2[o2]);
              0 !== s2 && (t2[o2].area = Math.abs(s2), void 0 === i2 && (i2 = s2 < 0), i2 === s2 < 0 ? (n2 && a2.push(n2), n2 = [t2[o2]]) : n2.push(t2[o2]));
            }
            if (n2 && a2.push(n2), e2 > 1)
              for (var u2 = 0; u2 < a2.length; u2++)
                a2[u2].length <= e2 || (ts(a2[u2], e2, 1, a2[u2].length - 1, is), a2[u2] = a2[u2].slice(0, e2));
            return a2;
          }
          function is(t2, e2) {
            return e2.area - t2.area;
          }
          function as(t2, e2, r2) {
            for (var n2 = r2.patternDependencies, i2 = false, a2 = 0, o2 = e2; a2 < o2.length; a2 += 1) {
              var s2 = o2[a2].paint.get(t2 + "-pattern");
              s2.isConstant() || (i2 = true);
              var u2 = s2.constantOr(null);
              u2 && (i2 = true, n2[u2.to] = true, n2[u2.from] = true);
            }
            return i2;
          }
          function os(t2, e2, r2, n2, i2) {
            for (var a2 = i2.patternDependencies, o2 = 0, s2 = e2; o2 < s2.length; o2 += 1) {
              var u2 = s2[o2], l2 = u2.paint.get(t2 + "-pattern").value;
              if ("constant" !== l2.kind) {
                var p2 = l2.evaluate({ zoom: n2 - 1 }, r2, {}, i2.availableImages), c2 = l2.evaluate({ zoom: n2 }, r2, {}, i2.availableImages), h2 = l2.evaluate({ zoom: n2 + 1 }, r2, {}, i2.availableImages);
                c2 = c2 && c2.name ? c2.name : c2, h2 = h2 && h2.name ? h2.name : h2, a2[p2 = p2 && p2.name ? p2.name : p2] = true, a2[c2] = true, a2[h2] = true, r2.patterns[u2.id] = { min: p2, mid: c2, max: h2 };
              }
            }
            return r2;
          }
          Co.deviation = function(t2, e2, r2, n2) {
            var i2 = e2 && e2.length, a2 = Math.abs(Qo(t2, 0, i2 ? e2[0] * r2 : t2.length, r2));
            if (i2)
              for (var o2 = 0, s2 = e2.length; o2 < s2; o2++)
                a2 -= Math.abs(Qo(t2, e2[o2] * r2, o2 < s2 - 1 ? e2[o2 + 1] * r2 : t2.length, r2));
            var u2 = 0;
            for (o2 = 0; o2 < n2.length; o2 += 3) {
              var l2 = n2[o2] * r2, p2 = n2[o2 + 1] * r2, c2 = n2[o2 + 2] * r2;
              u2 += Math.abs((t2[l2] - t2[c2]) * (t2[p2 + 1] - t2[l2 + 1]) - (t2[l2] - t2[p2]) * (t2[c2 + 1] - t2[l2 + 1]));
            }
            return 0 === a2 && 0 === u2 ? 0 : Math.abs((u2 - a2) / a2);
          }, Co.flatten = function(t2) {
            for (var e2 = t2[0][0].length, r2 = { vertices: [], holes: [], dimensions: e2 }, n2 = 0, i2 = 0; i2 < t2.length; i2++) {
              for (var a2 = 0; a2 < t2[i2].length; a2++)
                for (var o2 = 0; o2 < e2; o2++)
                  r2.vertices.push(t2[i2][a2][o2]);
              i2 > 0 && r2.holes.push(n2 += t2[i2 - 1].length);
            }
            return r2;
          }, Io.default = zo;
          var ss = function(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map(function(t3) {
              return t3.id;
            }), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new Ci(), this.indexArray = new ji(), this.indexArray2 = new Xi(), this.programConfigurations = new Va(t2.layers, t2.zoom), this.segments = new sa(), this.segments2 = new sa(), this.stateDependentLayerIds = this.layers.filter(function(t3) {
              return t3.isStateDependent();
            }).map(function(t3) {
              return t3.id;
            });
          };
          ss.prototype.populate = function(t2, e2, r2) {
            this.hasPattern = as("fill", this.layers, e2);
            for (var n2 = this.layers[0].layout.get("fill-sort-key"), i2 = [], a2 = 0, o2 = t2; a2 < o2.length; a2 += 1) {
              var s2 = o2[a2], u2 = s2.feature, l2 = s2.id, p2 = s2.index, c2 = s2.sourceLayerIndex, h2 = this.layers[0]._featureFilter.needGeometry, f2 = Ua(u2, h2);
              if (this.layers[0]._featureFilter.filter(new si(this.zoom), f2, r2)) {
                var y2 = n2 ? n2.evaluate(f2, {}, r2, e2.availableImages) : void 0, d2 = { id: l2, properties: u2.properties, type: u2.type, sourceLayerIndex: c2, index: p2, geometry: h2 ? f2.geometry : Ra(u2), patterns: {}, sortKey: y2 };
                i2.push(d2);
              }
            }
            n2 && i2.sort(function(t3, e3) {
              return t3.sortKey - e3.sortKey;
            });
            for (var m2 = 0, v2 = i2; m2 < v2.length; m2 += 1) {
              var g2 = v2[m2], x2 = g2.geometry, b2 = g2.index, w2 = g2.sourceLayerIndex;
              if (this.hasPattern) {
                var _2 = os("fill", this.layers, g2, this.zoom, e2);
                this.patternFeatures.push(_2);
              } else
                this.addFeature(g2, x2, b2, r2, {});
              e2.featureIndex.insert(t2[b2].feature, x2, b2, w2, this.index);
            }
          }, ss.prototype.update = function(t2, e2, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
          }, ss.prototype.addFeatures = function(t2, e2, r2) {
            for (var n2 = 0, i2 = this.patternFeatures; n2 < i2.length; n2 += 1) {
              var a2 = i2[n2];
              this.addFeature(a2, a2.geometry, a2.index, e2, r2);
            }
          }, ss.prototype.isEmpty = function() {
            return 0 === this.layoutVertexArray.length;
          }, ss.prototype.uploadPending = function() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }, ss.prototype.upload = function(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, ko), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.indexBuffer2 = t2.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t2), this.uploaded = true;
          }, ss.prototype.destroy = function() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
          }, ss.prototype.addFeature = function(t2, e2, r2, n2, i2) {
            for (var a2 = 0, o2 = ns(e2, 500); a2 < o2.length; a2 += 1) {
              for (var s2 = o2[a2], u2 = 0, l2 = 0, p2 = s2; l2 < p2.length; l2 += 1)
                u2 += p2[l2].length;
              for (var c2 = this.segments.prepareSegment(u2, this.layoutVertexArray, this.indexArray), h2 = c2.vertexLength, f2 = [], y2 = [], d2 = 0, m2 = s2; d2 < m2.length; d2 += 1) {
                var v2 = m2[d2];
                if (0 !== v2.length) {
                  v2 !== s2[0] && y2.push(f2.length / 2);
                  var g2 = this.segments2.prepareSegment(v2.length, this.layoutVertexArray, this.indexArray2), x2 = g2.vertexLength;
                  this.layoutVertexArray.emplaceBack(v2[0].x, v2[0].y), this.indexArray2.emplaceBack(x2 + v2.length - 1, x2), f2.push(v2[0].x), f2.push(v2[0].y);
                  for (var b2 = 1; b2 < v2.length; b2++)
                    this.layoutVertexArray.emplaceBack(v2[b2].x, v2[b2].y), this.indexArray2.emplaceBack(x2 + b2 - 1, x2 + b2), f2.push(v2[b2].x), f2.push(v2[b2].y);
                  g2.vertexLength += v2.length, g2.primitiveLength += v2.length;
                }
              }
              for (var w2 = Io(f2, y2), _2 = 0; _2 < w2.length; _2 += 3)
                this.indexArray.emplaceBack(h2 + w2[_2], h2 + w2[_2 + 1], h2 + w2[_2 + 2]);
              c2.vertexLength += u2, c2.primitiveLength += w2.length / 3;
            }
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
          }, On("FillBucket", ss, { omit: ["layers", "patternFeatures"] });
          var us = new wi({ "fill-sort-key": new vi(Et.layout_fill["fill-sort-key"]) }), ls = { paint: new wi({ "fill-antialias": new mi(Et.paint_fill["fill-antialias"]), "fill-opacity": new vi(Et.paint_fill["fill-opacity"]), "fill-color": new vi(Et.paint_fill["fill-color"]), "fill-outline-color": new vi(Et.paint_fill["fill-outline-color"]), "fill-translate": new mi(Et.paint_fill["fill-translate"]), "fill-translate-anchor": new mi(Et.paint_fill["fill-translate-anchor"]), "fill-pattern": new gi(Et.paint_fill["fill-pattern"]) }), layout: us }, ps = function(t2) {
            function e2(e3) {
              t2.call(this, e3, ls);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.recalculate = function(e3, r2) {
              t2.prototype.recalculate.call(this, e3, r2);
              var n2 = this.paint._values["fill-outline-color"];
              "constant" === n2.value.kind && void 0 === n2.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
            }, e2.prototype.createBucket = function(t3) {
              return new ss(t3);
            }, e2.prototype.queryRadius = function() {
              return eo(this.paint.get("fill-translate"));
            }, e2.prototype.queryIntersectsFeature = function(t3, e3, r2, n2, i2, a2, o2) {
              return Ga(ro(t3, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), a2.angle, o2), n2);
            }, e2.prototype.isTileClipped = function() {
              return true;
            }, e2;
          }(_i), cs = Ii([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4).members, hs = fs4;
          function fs4(t2, e2, r2, n2, i2) {
            this.properties = {}, this.extent = r2, this.type = 0, this._pbf = t2, this._geometry = -1, this._keys = n2, this._values = i2, t2.readFields(ys, this, e2);
          }
          function ys(t2, e2, r2) {
            1 == t2 ? e2.id = r2.readVarint() : 2 == t2 ? function(t3, e3) {
              for (var r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
                var n2 = e3._keys[t3.readVarint()], i2 = e3._values[t3.readVarint()];
                e3.properties[n2] = i2;
              }
            }(r2, e2) : 3 == t2 ? e2.type = r2.readVarint() : 4 == t2 && (e2._geometry = r2.pos);
          }
          function ds(t2) {
            for (var e2, r2, n2 = 0, i2 = 0, a2 = t2.length, o2 = a2 - 1; i2 < a2; o2 = i2++)
              n2 += ((r2 = t2[o2]).x - (e2 = t2[i2]).x) * (e2.y + r2.y);
            return n2;
          }
          fs4.types = ["Unknown", "Point", "LineString", "Polygon"], fs4.prototype.loadGeometry = function() {
            var t2 = this._pbf;
            t2.pos = this._geometry;
            for (var e2, r2 = t2.readVarint() + t2.pos, n2 = 1, a2 = 0, o2 = 0, s2 = 0, u2 = []; t2.pos < r2; ) {
              if (a2 <= 0) {
                var l2 = t2.readVarint();
                n2 = 7 & l2, a2 = l2 >> 3;
              }
              if (a2--, 1 === n2 || 2 === n2)
                o2 += t2.readSVarint(), s2 += t2.readSVarint(), 1 === n2 && (e2 && u2.push(e2), e2 = []), e2.push(new i(o2, s2));
              else {
                if (7 !== n2)
                  throw new Error("unknown command " + n2);
                e2 && e2.push(e2[0].clone());
              }
            }
            return e2 && u2.push(e2), u2;
          }, fs4.prototype.bbox = function() {
            var t2 = this._pbf;
            t2.pos = this._geometry;
            for (var e2 = t2.readVarint() + t2.pos, r2 = 1, n2 = 0, i2 = 0, a2 = 0, o2 = 1 / 0, s2 = -1 / 0, u2 = 1 / 0, l2 = -1 / 0; t2.pos < e2; ) {
              if (n2 <= 0) {
                var p2 = t2.readVarint();
                r2 = 7 & p2, n2 = p2 >> 3;
              }
              if (n2--, 1 === r2 || 2 === r2)
                (i2 += t2.readSVarint()) < o2 && (o2 = i2), i2 > s2 && (s2 = i2), (a2 += t2.readSVarint()) < u2 && (u2 = a2), a2 > l2 && (l2 = a2);
              else if (7 !== r2)
                throw new Error("unknown command " + r2);
            }
            return [o2, u2, s2, l2];
          }, fs4.prototype.toGeoJSON = function(t2, e2, r2) {
            var n2, i2, a2 = this.extent * Math.pow(2, r2), o2 = this.extent * t2, s2 = this.extent * e2, u2 = this.loadGeometry(), l2 = fs4.types[this.type];
            function p2(t3) {
              for (var e3 = 0; e3 < t3.length; e3++) {
                var r3 = t3[e3];
                t3[e3] = [360 * (r3.x + o2) / a2 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r3.y + s2) / a2) * Math.PI / 180)) - 90];
              }
            }
            switch (this.type) {
              case 1:
                var c2 = [];
                for (n2 = 0; n2 < u2.length; n2++)
                  c2[n2] = u2[n2][0];
                p2(u2 = c2);
                break;
              case 2:
                for (n2 = 0; n2 < u2.length; n2++)
                  p2(u2[n2]);
                break;
              case 3:
                for (u2 = function(t3) {
                  var e3 = t3.length;
                  if (e3 <= 1)
                    return [t3];
                  for (var r3, n3, i3 = [], a3 = 0; a3 < e3; a3++) {
                    var o3 = ds(t3[a3]);
                    0 !== o3 && (void 0 === n3 && (n3 = o3 < 0), n3 === o3 < 0 ? (r3 && i3.push(r3), r3 = [t3[a3]]) : r3.push(t3[a3]));
                  }
                  return r3 && i3.push(r3), i3;
                }(u2), n2 = 0; n2 < u2.length; n2++)
                  for (i2 = 0; i2 < u2[n2].length; i2++)
                    p2(u2[n2][i2]);
            }
            1 === u2.length ? u2 = u2[0] : l2 = "Multi" + l2;
            var h2 = { type: "Feature", geometry: { type: l2, coordinates: u2 }, properties: this.properties };
            return "id" in this && (h2.id = this.id), h2;
          };
          var ms = vs7;
          function vs7(t2, e2) {
            this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t2, this._keys = [], this._values = [], this._features = [], t2.readFields(gs, this, e2), this.length = this._features.length;
          }
          function gs(t2, e2, r2) {
            15 === t2 ? e2.version = r2.readVarint() : 1 === t2 ? e2.name = r2.readString() : 5 === t2 ? e2.extent = r2.readVarint() : 2 === t2 ? e2._features.push(r2.pos) : 3 === t2 ? e2._keys.push(r2.readString()) : 4 === t2 && e2._values.push(function(t3) {
              for (var e3 = null, r3 = t3.readVarint() + t3.pos; t3.pos < r3; ) {
                var n2 = t3.readVarint() >> 3;
                e3 = 1 === n2 ? t3.readString() : 2 === n2 ? t3.readFloat() : 3 === n2 ? t3.readDouble() : 4 === n2 ? t3.readVarint64() : 5 === n2 ? t3.readVarint() : 6 === n2 ? t3.readSVarint() : 7 === n2 ? t3.readBoolean() : null;
              }
              return e3;
            }(r2));
          }
          function xs(t2, e2, r2) {
            if (3 === t2) {
              var n2 = new ms(r2, r2.readVarint() + r2.pos);
              n2.length && (e2[n2.name] = n2);
            }
          }
          vs7.prototype.feature = function(t2) {
            if (t2 < 0 || t2 >= this._features.length)
              throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t2];
            var e2 = this._pbf.readVarint() + this._pbf.pos;
            return new hs(this._pbf, e2, this.extent, this._keys, this._values);
          };
          var bs = { VectorTile: function(t2, e2) {
            this.layers = t2.readFields(xs, {}, e2);
          }, VectorTileFeature: hs, VectorTileLayer: ms }, ws = bs.VectorTileFeature.types, _s = Math.pow(2, 13);
          function As(t2, e2, r2, n2, i2, a2, o2, s2) {
            t2.emplaceBack(e2, r2, 2 * Math.floor(n2 * _s) + o2, i2 * _s * 2, a2 * _s * 2, Math.round(s2));
          }
          var Ss = function(t2) {
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map(function(t3) {
              return t3.id;
            }), this.index = t2.index, this.hasPattern = false, this.layoutVertexArray = new Pi(), this.indexArray = new ji(), this.programConfigurations = new Va(t2.layers, t2.zoom), this.segments = new sa(), this.stateDependentLayerIds = this.layers.filter(function(t3) {
              return t3.isStateDependent();
            }).map(function(t3) {
              return t3.id;
            });
          };
          function ks(t2, e2) {
            return t2.x === e2.x && (t2.x < 0 || t2.x > 8192) || t2.y === e2.y && (t2.y < 0 || t2.y > 8192);
          }
          Ss.prototype.populate = function(t2, e2, r2) {
            this.features = [], this.hasPattern = as("fill-extrusion", this.layers, e2);
            for (var n2 = 0, i2 = t2; n2 < i2.length; n2 += 1) {
              var a2 = i2[n2], o2 = a2.feature, s2 = a2.id, u2 = a2.index, l2 = a2.sourceLayerIndex, p2 = this.layers[0]._featureFilter.needGeometry, c2 = Ua(o2, p2);
              if (this.layers[0]._featureFilter.filter(new si(this.zoom), c2, r2)) {
                var h2 = { id: s2, sourceLayerIndex: l2, index: u2, geometry: p2 ? c2.geometry : Ra(o2), properties: o2.properties, type: o2.type, patterns: {} };
                this.hasPattern ? this.features.push(os("fill-extrusion", this.layers, h2, this.zoom, e2)) : this.addFeature(h2, h2.geometry, u2, r2, {}), e2.featureIndex.insert(o2, h2.geometry, u2, l2, this.index, true);
              }
            }
          }, Ss.prototype.addFeatures = function(t2, e2, r2) {
            for (var n2 = 0, i2 = this.features; n2 < i2.length; n2 += 1) {
              var a2 = i2[n2];
              this.addFeature(a2, a2.geometry, a2.index, e2, r2);
            }
          }, Ss.prototype.update = function(t2, e2, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
          }, Ss.prototype.isEmpty = function() {
            return 0 === this.layoutVertexArray.length;
          }, Ss.prototype.uploadPending = function() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }, Ss.prototype.upload = function(t2) {
            this.uploaded || (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, cs), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
          }, Ss.prototype.destroy = function() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }, Ss.prototype.addFeature = function(t2, e2, r2, n2, i2) {
            for (var a2 = 0, o2 = ns(e2, 500); a2 < o2.length; a2 += 1) {
              for (var s2 = o2[a2], u2 = 0, l2 = 0, p2 = s2; l2 < p2.length; l2 += 1)
                u2 += p2[l2].length;
              for (var c2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray), h2 = 0, f2 = s2; h2 < f2.length; h2 += 1) {
                var y2 = f2[h2];
                if (0 !== y2.length && !((B2 = y2).every(function(t3) {
                  return t3.x < 0;
                }) || B2.every(function(t3) {
                  return t3.x > 8192;
                }) || B2.every(function(t3) {
                  return t3.y < 0;
                }) || B2.every(function(t3) {
                  return t3.y > 8192;
                })))
                  for (var d2 = 0, m2 = 0; m2 < y2.length; m2++) {
                    var v2 = y2[m2];
                    if (m2 >= 1) {
                      var g2 = y2[m2 - 1];
                      if (!ks(v2, g2)) {
                        c2.vertexLength + 4 > sa.MAX_VERTEX_ARRAY_LENGTH && (c2 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                        var x2 = v2.sub(g2)._perp()._unit(), b2 = g2.dist(v2);
                        d2 + b2 > 32768 && (d2 = 0), As(this.layoutVertexArray, v2.x, v2.y, x2.x, x2.y, 0, 0, d2), As(this.layoutVertexArray, v2.x, v2.y, x2.x, x2.y, 0, 1, d2), As(this.layoutVertexArray, g2.x, g2.y, x2.x, x2.y, 0, 0, d2 += b2), As(this.layoutVertexArray, g2.x, g2.y, x2.x, x2.y, 0, 1, d2);
                        var w2 = c2.vertexLength;
                        this.indexArray.emplaceBack(w2, w2 + 2, w2 + 1), this.indexArray.emplaceBack(w2 + 1, w2 + 2, w2 + 3), c2.vertexLength += 4, c2.primitiveLength += 2;
                      }
                    }
                  }
              }
              if (c2.vertexLength + u2 > sa.MAX_VERTEX_ARRAY_LENGTH && (c2 = this.segments.prepareSegment(u2, this.layoutVertexArray, this.indexArray)), "Polygon" === ws[t2.type]) {
                for (var _2 = [], A2 = [], S2 = c2.vertexLength, k2 = 0, I2 = s2; k2 < I2.length; k2 += 1) {
                  var z2 = I2[k2];
                  if (0 !== z2.length) {
                    z2 !== s2[0] && A2.push(_2.length / 2);
                    for (var C2 = 0; C2 < z2.length; C2++) {
                      var E2 = z2[C2];
                      As(this.layoutVertexArray, E2.x, E2.y, 0, 0, 1, 1, 0), _2.push(E2.x), _2.push(E2.y);
                    }
                  }
                }
                for (var P2 = Io(_2, A2), M2 = 0; M2 < P2.length; M2 += 3)
                  this.indexArray.emplaceBack(S2 + P2[M2], S2 + P2[M2 + 2], S2 + P2[M2 + 1]);
                c2.primitiveLength += P2.length / 3, c2.vertexLength += u2;
              }
            }
            var B2;
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
          }, On("FillExtrusionBucket", Ss, { omit: ["layers", "features"] });
          var Is = { paint: new wi({ "fill-extrusion-opacity": new mi(Et["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new vi(Et["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new mi(Et["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new mi(Et["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new gi(Et["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new vi(Et["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new vi(Et["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new mi(Et["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) }) }, zs = function(t2) {
            function e2(e3) {
              t2.call(this, e3, Is);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.createBucket = function(t3) {
              return new Ss(t3);
            }, e2.prototype.queryRadius = function() {
              return eo(this.paint.get("fill-extrusion-translate"));
            }, e2.prototype.is3D = function() {
              return true;
            }, e2.prototype.queryIntersectsFeature = function(t3, e3, r2, n2, a2, o2, s2, u2) {
              var l2 = ro(t3, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), o2.angle, s2), p2 = this.paint.get("fill-extrusion-height").evaluate(e3, r2), c2 = this.paint.get("fill-extrusion-base").evaluate(e3, r2), h2 = function(t4, e4, r3, n3) {
                for (var a3 = [], o3 = 0, s3 = t4; o3 < s3.length; o3 += 1) {
                  var u3 = s3[o3], l3 = [u3.x, u3.y, 0, 1];
                  po(l3, l3, e4), a3.push(new i(l3[0] / l3[3], l3[1] / l3[3]));
                }
                return a3;
              }(l2, u2), f2 = function(t4, e4, r3, n3) {
                for (var a3 = [], o3 = [], s3 = n3[8] * e4, u3 = n3[9] * e4, l3 = n3[10] * e4, p3 = n3[11] * e4, c3 = n3[8] * r3, h3 = n3[9] * r3, f3 = n3[10] * r3, y2 = n3[11] * r3, d2 = 0, m2 = t4; d2 < m2.length; d2 += 1) {
                  for (var v2 = [], g2 = [], x2 = 0, b2 = m2[d2]; x2 < b2.length; x2 += 1) {
                    var w2 = b2[x2], _2 = w2.x, A2 = w2.y, S2 = n3[0] * _2 + n3[4] * A2 + n3[12], k2 = n3[1] * _2 + n3[5] * A2 + n3[13], I2 = n3[2] * _2 + n3[6] * A2 + n3[14], z2 = n3[3] * _2 + n3[7] * A2 + n3[15], C2 = I2 + l3, E2 = z2 + p3, P2 = S2 + c3, M2 = k2 + h3, B2 = I2 + f3, T2 = z2 + y2, V2 = new i((S2 + s3) / E2, (k2 + u3) / E2);
                    V2.z = C2 / E2, v2.push(V2);
                    var F2 = new i(P2 / T2, M2 / T2);
                    F2.z = B2 / T2, g2.push(F2);
                  }
                  a3.push(v2), o3.push(g2);
                }
                return [a3, o3];
              }(n2, c2, p2, u2);
              return function(t4, e4, r3) {
                var n3 = 1 / 0;
                Ga(r3, e4) && (n3 = Es(r3, e4[0]));
                for (var i2 = 0; i2 < e4.length; i2++)
                  for (var a3 = e4[i2], o3 = t4[i2], s3 = 0; s3 < a3.length - 1; s3++) {
                    var u3 = a3[s3], l3 = [u3, a3[s3 + 1], o3[s3 + 1], o3[s3], u3];
                    Na(r3, l3) && (n3 = Math.min(n3, Es(r3, l3)));
                  }
                return n3 !== 1 / 0 && n3;
              }(f2[0], f2[1], h2);
            }, e2;
          }(_i);
          function Cs(t2, e2) {
            return t2.x * e2.x + t2.y * e2.y;
          }
          function Es(t2, e2) {
            if (1 === t2.length) {
              for (var r2, n2 = 0, i2 = e2[n2++]; !r2 || i2.equals(r2); )
                if (!(r2 = e2[n2++]))
                  return 1 / 0;
              for (; n2 < e2.length; n2++) {
                var a2 = e2[n2], o2 = t2[0], s2 = r2.sub(i2), u2 = a2.sub(i2), l2 = o2.sub(i2), p2 = Cs(s2, s2), c2 = Cs(s2, u2), h2 = Cs(u2, u2), f2 = Cs(l2, s2), y2 = Cs(l2, u2), d2 = p2 * h2 - c2 * c2, m2 = (h2 * f2 - c2 * y2) / d2, v2 = (p2 * y2 - c2 * f2) / d2, g2 = i2.z * (1 - m2 - v2) + r2.z * m2 + a2.z * v2;
                if (isFinite(g2))
                  return g2;
              }
              return 1 / 0;
            }
            for (var x2 = 1 / 0, b2 = 0, w2 = e2; b2 < w2.length; b2 += 1)
              x2 = Math.min(x2, w2[b2].z);
            return x2;
          }
          var Ps = Ii([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4).members, Ms = Ii([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]).members, Bs = bs.VectorTileFeature.types, Ts = Math.cos(Math.PI / 180 * 37.5), Vs = Math.pow(2, 14) / 0.5, Fs = function(t2) {
            var e2 = this;
            this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map(function(t3) {
              return t3.id;
            }), this.index = t2.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach(function(t3) {
              e2.gradients[t3.id] = {};
            }), this.layoutVertexArray = new Mi(), this.layoutVertexArray2 = new Bi(), this.indexArray = new ji(), this.programConfigurations = new Va(t2.layers, t2.zoom), this.segments = new sa(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter(function(t3) {
              return t3.isStateDependent();
            }).map(function(t3) {
              return t3.id;
            });
          };
          Fs.prototype.populate = function(t2, e2, r2) {
            this.hasPattern = as("line", this.layers, e2);
            for (var n2 = this.layers[0].layout.get("line-sort-key"), i2 = [], a2 = 0, o2 = t2; a2 < o2.length; a2 += 1) {
              var s2 = o2[a2], u2 = s2.feature, l2 = s2.id, p2 = s2.index, c2 = s2.sourceLayerIndex, h2 = this.layers[0]._featureFilter.needGeometry, f2 = Ua(u2, h2);
              if (this.layers[0]._featureFilter.filter(new si(this.zoom), f2, r2)) {
                var y2 = n2 ? n2.evaluate(f2, {}, r2) : void 0, d2 = { id: l2, properties: u2.properties, type: u2.type, sourceLayerIndex: c2, index: p2, geometry: h2 ? f2.geometry : Ra(u2), patterns: {}, sortKey: y2 };
                i2.push(d2);
              }
            }
            n2 && i2.sort(function(t3, e3) {
              return t3.sortKey - e3.sortKey;
            });
            for (var m2 = 0, v2 = i2; m2 < v2.length; m2 += 1) {
              var g2 = v2[m2], x2 = g2.geometry, b2 = g2.index, w2 = g2.sourceLayerIndex;
              if (this.hasPattern) {
                var _2 = os("line", this.layers, g2, this.zoom, e2);
                this.patternFeatures.push(_2);
              } else
                this.addFeature(g2, x2, b2, r2, {});
              e2.featureIndex.insert(t2[b2].feature, x2, b2, w2, this.index);
            }
          }, Fs.prototype.update = function(t2, e2, r2) {
            this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t2, e2, this.stateDependentLayers, r2);
          }, Fs.prototype.addFeatures = function(t2, e2, r2) {
            for (var n2 = 0, i2 = this.patternFeatures; n2 < i2.length; n2 += 1) {
              var a2 = i2[n2];
              this.addFeature(a2, a2.geometry, a2.index, e2, r2);
            }
          }, Fs.prototype.isEmpty = function() {
            return 0 === this.layoutVertexArray.length;
          }, Fs.prototype.uploadPending = function() {
            return !this.uploaded || this.programConfigurations.needsUpload;
          }, Fs.prototype.upload = function(t2) {
            this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t2.createVertexBuffer(this.layoutVertexArray2, Ms)), this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, Ps), this.indexBuffer = t2.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t2), this.uploaded = true;
          }, Fs.prototype.destroy = function() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
          }, Fs.prototype.lineFeatureClips = function(t2) {
            if (t2.properties && t2.properties.hasOwnProperty("mapbox_clip_start") && t2.properties.hasOwnProperty("mapbox_clip_end"))
              return { start: +t2.properties.mapbox_clip_start, end: +t2.properties.mapbox_clip_end };
          }, Fs.prototype.addFeature = function(t2, e2, r2, n2, i2) {
            var a2 = this.layers[0].layout, o2 = a2.get("line-join").evaluate(t2, {}), s2 = a2.get("line-cap"), u2 = a2.get("line-miter-limit"), l2 = a2.get("line-round-limit");
            this.lineClips = this.lineFeatureClips(t2);
            for (var p2 = 0, c2 = e2; p2 < c2.length; p2 += 1)
              this.addLine(c2[p2], t2, o2, s2, u2, l2);
            this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t2, r2, i2, n2);
          }, Fs.prototype.addLine = function(t2, e2, r2, n2, i2, a2) {
            if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
              this.lineClipsArray.push(this.lineClips);
              for (var o2 = 0; o2 < t2.length - 1; o2++)
                this.totalDistance += t2[o2].dist(t2[o2 + 1]);
              this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
            }
            for (var s2 = "Polygon" === Bs[e2.type], u2 = t2.length; u2 >= 2 && t2[u2 - 1].equals(t2[u2 - 2]); )
              u2--;
            for (var l2 = 0; l2 < u2 - 1 && t2[l2].equals(t2[l2 + 1]); )
              l2++;
            if (!(u2 < (s2 ? 3 : 2))) {
              "bevel" === r2 && (i2 = 1.05);
              var p2, c2 = this.overscaling <= 16 ? 122880 / (512 * this.overscaling) : 0, h2 = this.segments.prepareSegment(10 * u2, this.layoutVertexArray, this.indexArray), f2 = void 0, y2 = void 0, d2 = void 0, m2 = void 0;
              this.e1 = this.e2 = -1, s2 && (m2 = t2[l2].sub(p2 = t2[u2 - 2])._unit()._perp());
              for (var v2 = l2; v2 < u2; v2++)
                if (!(y2 = v2 === u2 - 1 ? s2 ? t2[l2 + 1] : void 0 : t2[v2 + 1]) || !t2[v2].equals(y2)) {
                  m2 && (d2 = m2), p2 && (f2 = p2), p2 = t2[v2], m2 = y2 ? y2.sub(p2)._unit()._perp() : d2;
                  var g2 = (d2 = d2 || m2).add(m2);
                  0 === g2.x && 0 === g2.y || g2._unit();
                  var x2 = d2.x * m2.x + d2.y * m2.y, b2 = g2.x * m2.x + g2.y * m2.y, w2 = 0 !== b2 ? 1 / b2 : 1 / 0, _2 = 2 * Math.sqrt(2 - 2 * b2), A2 = b2 < Ts && f2 && y2, S2 = d2.x * m2.y - d2.y * m2.x > 0;
                  if (A2 && v2 > l2) {
                    var k2 = p2.dist(f2);
                    if (k2 > 2 * c2) {
                      var I2 = p2.sub(p2.sub(f2)._mult(c2 / k2)._round());
                      this.updateDistance(f2, I2), this.addCurrentVertex(I2, d2, 0, 0, h2), f2 = I2;
                    }
                  }
                  var z2 = f2 && y2, C2 = z2 ? r2 : s2 ? "butt" : n2;
                  if (z2 && "round" === C2 && (w2 < a2 ? C2 = "miter" : w2 <= 2 && (C2 = "fakeround")), "miter" === C2 && w2 > i2 && (C2 = "bevel"), "bevel" === C2 && (w2 > 2 && (C2 = "flipbevel"), w2 < i2 && (C2 = "miter")), f2 && this.updateDistance(f2, p2), "miter" === C2)
                    g2._mult(w2), this.addCurrentVertex(p2, g2, 0, 0, h2);
                  else if ("flipbevel" === C2) {
                    if (w2 > 100)
                      g2 = m2.mult(-1);
                    else {
                      var E2 = w2 * d2.add(m2).mag() / d2.sub(m2).mag();
                      g2._perp()._mult(E2 * (S2 ? -1 : 1));
                    }
                    this.addCurrentVertex(p2, g2, 0, 0, h2), this.addCurrentVertex(p2, g2.mult(-1), 0, 0, h2);
                  } else if ("bevel" === C2 || "fakeround" === C2) {
                    var P2 = -Math.sqrt(w2 * w2 - 1), M2 = S2 ? P2 : 0, B2 = S2 ? 0 : P2;
                    if (f2 && this.addCurrentVertex(p2, d2, M2, B2, h2), "fakeround" === C2)
                      for (var T2 = Math.round(180 * _2 / Math.PI / 20), V2 = 1; V2 < T2; V2++) {
                        var F2 = V2 / T2;
                        if (0.5 !== F2) {
                          var D2 = F2 - 0.5;
                          F2 += F2 * D2 * (F2 - 1) * ((1.0904 + x2 * (x2 * (3.55645 - 1.43519 * x2) - 3.2452)) * D2 * D2 + (0.848013 + x2 * (0.215638 * x2 - 1.06021)));
                        }
                        var L2 = m2.sub(d2)._mult(F2)._add(d2)._unit()._mult(S2 ? -1 : 1);
                        this.addHalfVertex(p2, L2.x, L2.y, false, S2, 0, h2);
                      }
                    y2 && this.addCurrentVertex(p2, m2, -M2, -B2, h2);
                  } else if ("butt" === C2)
                    this.addCurrentVertex(p2, g2, 0, 0, h2);
                  else if ("square" === C2) {
                    var O2 = f2 ? 1 : -1;
                    this.addCurrentVertex(p2, g2, O2, O2, h2);
                  } else
                    "round" === C2 && (f2 && (this.addCurrentVertex(p2, d2, 0, 0, h2), this.addCurrentVertex(p2, d2, 1, 1, h2, true)), y2 && (this.addCurrentVertex(p2, m2, -1, -1, h2, true), this.addCurrentVertex(p2, m2, 0, 0, h2)));
                  if (A2 && v2 < u2 - 1) {
                    var R2 = p2.dist(y2);
                    if (R2 > 2 * c2) {
                      var U2 = p2.add(y2.sub(p2)._mult(c2 / R2)._round());
                      this.updateDistance(p2, U2), this.addCurrentVertex(U2, m2, 0, 0, h2), p2 = U2;
                    }
                  }
                }
            }
          }, Fs.prototype.addCurrentVertex = function(t2, e2, r2, n2, i2, a2) {
            void 0 === a2 && (a2 = false);
            var o2 = e2.y * n2 - e2.x, s2 = -e2.y - e2.x * n2;
            this.addHalfVertex(t2, e2.x + e2.y * r2, e2.y - e2.x * r2, a2, false, r2, i2), this.addHalfVertex(t2, o2, s2, a2, true, -n2, i2), this.distance > Vs / 2 && 0 === this.totalDistance && (this.distance = 0, this.addCurrentVertex(t2, e2, r2, n2, i2, a2));
          }, Fs.prototype.addHalfVertex = function(t2, e2, r2, n2, i2, a2, o2) {
            var s2 = 0.5 * (this.lineClips ? this.scaledDistance * (Vs - 1) : this.scaledDistance);
            this.layoutVertexArray.emplaceBack((t2.x << 1) + (n2 ? 1 : 0), (t2.y << 1) + (i2 ? 1 : 0), Math.round(63 * e2) + 128, Math.round(63 * r2) + 128, 1 + (0 === a2 ? 0 : a2 < 0 ? -1 : 1) | (63 & s2) << 2, s2 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
            var u2 = o2.vertexLength++;
            this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u2), o2.primitiveLength++), i2 ? this.e2 = u2 : this.e1 = u2;
          }, Fs.prototype.updateScaledDistance = function() {
            this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
          }, Fs.prototype.updateDistance = function(t2, e2) {
            this.distance += t2.dist(e2), this.updateScaledDistance();
          }, On("LineBucket", Fs, { omit: ["layers", "patternFeatures"] });
          var Ds = new wi({ "line-cap": new mi(Et.layout_line["line-cap"]), "line-join": new vi(Et.layout_line["line-join"]), "line-miter-limit": new mi(Et.layout_line["line-miter-limit"]), "line-round-limit": new mi(Et.layout_line["line-round-limit"]), "line-sort-key": new vi(Et.layout_line["line-sort-key"]) }), Ls = { paint: new wi({ "line-opacity": new vi(Et.paint_line["line-opacity"]), "line-color": new vi(Et.paint_line["line-color"]), "line-translate": new mi(Et.paint_line["line-translate"]), "line-translate-anchor": new mi(Et.paint_line["line-translate-anchor"]), "line-width": new vi(Et.paint_line["line-width"]), "line-gap-width": new vi(Et.paint_line["line-gap-width"]), "line-offset": new vi(Et.paint_line["line-offset"]), "line-blur": new vi(Et.paint_line["line-blur"]), "line-dasharray": new xi(Et.paint_line["line-dasharray"]), "line-pattern": new gi(Et.paint_line["line-pattern"]), "line-gradient": new bi(Et.paint_line["line-gradient"]) }), layout: Ds }, Os = new (function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.possiblyEvaluate = function(e3, r2) {
              return r2 = new si(Math.floor(r2.zoom), { now: r2.now, fadeDuration: r2.fadeDuration, zoomHistory: r2.zoomHistory, transition: r2.transition }), t2.prototype.possiblyEvaluate.call(this, e3, r2);
            }, e2.prototype.evaluate = function(e3, r2, n2, i2) {
              return r2 = h({}, r2, { zoom: Math.floor(r2.zoom) }), t2.prototype.evaluate.call(this, e3, r2, n2, i2);
            }, e2;
          }(vi))(Ls.paint.properties["line-width"].specification);
          Os.useIntegerZoom = true;
          var Rs = function(t2) {
            function e2(e3) {
              t2.call(this, e3, Ls), this.gradientVersion = 0;
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._handleSpecialPaintPropertyUpdate = function(t3) {
              "line-gradient" === t3 && (this.stepInterpolant = this._transitionablePaint._values["line-gradient"].value.expression._styleExpression.expression instanceof Ne, this.gradientVersion = (this.gradientVersion + 1) % s);
            }, e2.prototype.gradientExpression = function() {
              return this._transitionablePaint._values["line-gradient"].value.expression;
            }, e2.prototype.recalculate = function(e3, r2) {
              t2.prototype.recalculate.call(this, e3, r2), this.paint._values["line-floorwidth"] = Os.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, e3);
            }, e2.prototype.createBucket = function(t3) {
              return new Fs(t3);
            }, e2.prototype.queryRadius = function(t3) {
              var e3 = t3, r2 = Us(to("line-width", this, e3), to("line-gap-width", this, e3)), n2 = to("line-offset", this, e3);
              return r2 / 2 + Math.abs(n2) + eo(this.paint.get("line-translate"));
            }, e2.prototype.queryIntersectsFeature = function(t3, e3, r2, n2, a2, o2, s2) {
              var u2 = ro(t3, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), o2.angle, s2), l2 = s2 / 2 * Us(this.paint.get("line-width").evaluate(e3, r2), this.paint.get("line-gap-width").evaluate(e3, r2)), p2 = this.paint.get("line-offset").evaluate(e3, r2);
              return p2 && (n2 = function(t4, e4) {
                for (var r3 = [], n3 = new i(0, 0), a3 = 0; a3 < t4.length; a3++) {
                  for (var o3 = t4[a3], s3 = [], u3 = 0; u3 < o3.length; u3++) {
                    var l3 = o3[u3], p3 = o3[u3 + 1], c2 = 0 === u3 ? n3 : l3.sub(o3[u3 - 1])._unit()._perp(), h2 = u3 === o3.length - 1 ? n3 : p3.sub(l3)._unit()._perp(), f2 = c2._add(h2)._unit();
                    f2._mult(1 / (f2.x * h2.x + f2.y * h2.y)), s3.push(f2._mult(e4)._add(l3));
                  }
                  r3.push(s3);
                }
                return r3;
              }(n2, p2 * s2)), function(t4, e4, r3) {
                for (var n3 = 0; n3 < e4.length; n3++) {
                  var i2 = e4[n3];
                  if (t4.length >= 3) {
                    for (var a3 = 0; a3 < i2.length; a3++)
                      if (Wa(t4, i2[a3]))
                        return true;
                  }
                  if (Za(t4, i2, r3))
                    return true;
                }
                return false;
              }(u2, n2, l2);
            }, e2.prototype.isTileClipped = function() {
              return true;
            }, e2;
          }(_i);
          function Us(t2, e2) {
            return e2 > 0 ? e2 + 2 * t2 : t2;
          }
          var js = Ii([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), qs = Ii([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4), Ns = (Ii([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4), Ii([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }])), Ks = (Ii([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]), Ii([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4)), Gs = Ii([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
          function Zs(t2, e2, r2) {
            return t2.sections.forEach(function(t3) {
              t3.text = function(t4, e3, r3) {
                var n2 = e3.layout.get("text-transform").evaluate(r3, {});
                return "uppercase" === n2 ? t4 = t4.toLocaleUpperCase() : "lowercase" === n2 && (t4 = t4.toLocaleLowerCase()), oi.applyArabicShaping && (t4 = oi.applyArabicShaping(t4)), t4;
              }(t3.text, e2, r2);
            }), t2;
          }
          Ii([{ name: "triangle", components: 3, type: "Uint16" }]), Ii([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Ii([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", components: 2, name: "textOffset" }, { type: "Float32", name: "collisionCircleDiameter" }]), Ii([{ type: "Float32", name: "offsetX" }]), Ii([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]);
          var Xs = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" }, Js = function(t2, e2, r2, n2, i2) {
            var a2, o2, s2 = 8 * i2 - n2 - 1, u2 = (1 << s2) - 1, l2 = u2 >> 1, p2 = -7, c2 = r2 ? i2 - 1 : 0, h2 = r2 ? -1 : 1, f2 = t2[e2 + c2];
            for (c2 += h2, a2 = f2 & (1 << -p2) - 1, f2 >>= -p2, p2 += s2; p2 > 0; a2 = 256 * a2 + t2[e2 + c2], c2 += h2, p2 -= 8)
              ;
            for (o2 = a2 & (1 << -p2) - 1, a2 >>= -p2, p2 += n2; p2 > 0; o2 = 256 * o2 + t2[e2 + c2], c2 += h2, p2 -= 8)
              ;
            if (0 === a2)
              a2 = 1 - l2;
            else {
              if (a2 === u2)
                return o2 ? NaN : 1 / 0 * (f2 ? -1 : 1);
              o2 += Math.pow(2, n2), a2 -= l2;
            }
            return (f2 ? -1 : 1) * o2 * Math.pow(2, a2 - n2);
          }, Hs = function(t2, e2, r2, n2, i2, a2) {
            var o2, s2, u2, l2 = 8 * a2 - i2 - 1, p2 = (1 << l2) - 1, c2 = p2 >> 1, h2 = 23 === i2 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n2 ? 0 : a2 - 1, y2 = n2 ? 1 : -1, d2 = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0;
            for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (s2 = isNaN(e2) ? 1 : 0, o2 = p2) : (o2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (u2 = Math.pow(2, -o2)) < 1 && (o2--, u2 *= 2), (e2 += o2 + c2 >= 1 ? h2 / u2 : h2 * Math.pow(2, 1 - c2)) * u2 >= 2 && (o2++, u2 /= 2), o2 + c2 >= p2 ? (s2 = 0, o2 = p2) : o2 + c2 >= 1 ? (s2 = (e2 * u2 - 1) * Math.pow(2, i2), o2 += c2) : (s2 = e2 * Math.pow(2, c2 - 1) * Math.pow(2, i2), o2 = 0)); i2 >= 8; t2[r2 + f2] = 255 & s2, f2 += y2, s2 /= 256, i2 -= 8)
              ;
            for (o2 = o2 << i2 | s2, l2 += i2; l2 > 0; t2[r2 + f2] = 255 & o2, f2 += y2, o2 /= 256, l2 -= 8)
              ;
            t2[r2 + f2 - y2] |= 128 * d2;
          }, Ys = $s;
          function $s(t2) {
            this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t2) ? t2 : new Uint8Array(t2 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          $s.Varint = 0, $s.Fixed64 = 1, $s.Bytes = 2, $s.Fixed32 = 5;
          var Ws = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
          function Qs(t2) {
            return t2.type === $s.Bytes ? t2.readVarint() + t2.pos : t2.pos + 1;
          }
          function tu(t2, e2, r2) {
            return r2 ? 4294967296 * e2 + (t2 >>> 0) : 4294967296 * (e2 >>> 0) + (t2 >>> 0);
          }
          function eu(t2, e2, r2) {
            var n2 = e2 <= 16383 ? 1 : e2 <= 2097151 ? 2 : e2 <= 268435455 ? 3 : Math.floor(Math.log(e2) / (7 * Math.LN2));
            r2.realloc(n2);
            for (var i2 = r2.pos - 1; i2 >= t2; i2--)
              r2.buf[i2 + n2] = r2.buf[i2];
          }
          function ru(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeVarint(t2[r2]);
          }
          function nu(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeSVarint(t2[r2]);
          }
          function iu(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeFloat(t2[r2]);
          }
          function au(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeDouble(t2[r2]);
          }
          function ou(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeBoolean(t2[r2]);
          }
          function su(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeFixed32(t2[r2]);
          }
          function uu(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeSFixed32(t2[r2]);
          }
          function lu(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeFixed64(t2[r2]);
          }
          function pu(t2, e2) {
            for (var r2 = 0; r2 < t2.length; r2++)
              e2.writeSFixed64(t2[r2]);
          }
          function cu(t2, e2) {
            return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + 16777216 * t2[e2 + 3];
          }
          function hu(t2, e2, r2) {
            t2[r2] = e2, t2[r2 + 1] = e2 >>> 8, t2[r2 + 2] = e2 >>> 16, t2[r2 + 3] = e2 >>> 24;
          }
          function fu(t2, e2) {
            return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16) + (t2[e2 + 3] << 24);
          }
          function yu(t2, e2, r2) {
            1 === t2 && r2.readMessage(du, e2);
          }
          function du(t2, e2, r2) {
            if (3 === t2) {
              var n2 = r2.readMessage(mu, {}), i2 = n2.width, a2 = n2.height, o2 = n2.left, s2 = n2.top, u2 = n2.advance;
              e2.push({ id: n2.id, bitmap: new go2({ width: i2 + 6, height: a2 + 6 }, n2.bitmap), metrics: { width: i2, height: a2, left: o2, top: s2, advance: u2 } });
            }
          }
          function mu(t2, e2, r2) {
            1 === t2 ? e2.id = r2.readVarint() : 2 === t2 ? e2.bitmap = r2.readBytes() : 3 === t2 ? e2.width = r2.readVarint() : 4 === t2 ? e2.height = r2.readVarint() : 5 === t2 ? e2.left = r2.readSVarint() : 6 === t2 ? e2.top = r2.readSVarint() : 7 === t2 && (e2.advance = r2.readVarint());
          }
          function vu(t2) {
            for (var e2 = 0, r2 = 0, n2 = 0, i2 = t2; n2 < i2.length; n2 += 1) {
              var a2 = i2[n2];
              e2 += a2.w * a2.h, r2 = Math.max(r2, a2.w);
            }
            t2.sort(function(t3, e3) {
              return e3.h - t3.h;
            });
            for (var o2 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e2 / 0.95)), r2), h: 1 / 0 }], s2 = 0, u2 = 0, l2 = 0, p2 = t2; l2 < p2.length; l2 += 1)
              for (var c2 = p2[l2], h2 = o2.length - 1; h2 >= 0; h2--) {
                var f2 = o2[h2];
                if (!(c2.w > f2.w || c2.h > f2.h)) {
                  if (c2.x = f2.x, c2.y = f2.y, u2 = Math.max(u2, c2.y + c2.h), s2 = Math.max(s2, c2.x + c2.w), c2.w === f2.w && c2.h === f2.h) {
                    var y2 = o2.pop();
                    h2 < o2.length && (o2[h2] = y2);
                  } else
                    c2.h === f2.h ? (f2.x += c2.w, f2.w -= c2.w) : c2.w === f2.w ? (f2.y += c2.h, f2.h -= c2.h) : (o2.push({ x: f2.x + c2.w, y: f2.y, w: f2.w - c2.w, h: c2.h }), f2.y += c2.h, f2.h -= c2.h);
                  break;
                }
              }
            return { w: s2, h: u2, fill: e2 / (s2 * u2) || 0 };
          }
          $s.prototype = { destroy: function() {
            this.buf = null;
          }, readFields: function(t2, e2, r2) {
            for (r2 = r2 || this.length; this.pos < r2; ) {
              var n2 = this.readVarint(), i2 = n2 >> 3, a2 = this.pos;
              this.type = 7 & n2, t2(i2, e2, this), this.pos === a2 && this.skip(n2);
            }
            return e2;
          }, readMessage: function(t2, e2) {
            return this.readFields(t2, e2, this.readVarint() + this.pos);
          }, readFixed32: function() {
            var t2 = cu(this.buf, this.pos);
            return this.pos += 4, t2;
          }, readSFixed32: function() {
            var t2 = fu(this.buf, this.pos);
            return this.pos += 4, t2;
          }, readFixed64: function() {
            var t2 = cu(this.buf, this.pos) + 4294967296 * cu(this.buf, this.pos + 4);
            return this.pos += 8, t2;
          }, readSFixed64: function() {
            var t2 = cu(this.buf, this.pos) + 4294967296 * fu(this.buf, this.pos + 4);
            return this.pos += 8, t2;
          }, readFloat: function() {
            var t2 = Js(this.buf, this.pos, true, 23, 4);
            return this.pos += 4, t2;
          }, readDouble: function() {
            var t2 = Js(this.buf, this.pos, true, 52, 8);
            return this.pos += 8, t2;
          }, readVarint: function(t2) {
            var e2, r2, n2 = this.buf;
            return e2 = 127 & (r2 = n2[this.pos++]), r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 7, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 14, r2 < 128 ? e2 : (e2 |= (127 & (r2 = n2[this.pos++])) << 21, r2 < 128 ? e2 : function(t3, e3, r3) {
              var n3, i2, a2 = r3.buf;
              if (n3 = (112 & (i2 = a2[r3.pos++])) >> 4, i2 < 128)
                return tu(t3, n3, e3);
              if (n3 |= (127 & (i2 = a2[r3.pos++])) << 3, i2 < 128)
                return tu(t3, n3, e3);
              if (n3 |= (127 & (i2 = a2[r3.pos++])) << 10, i2 < 128)
                return tu(t3, n3, e3);
              if (n3 |= (127 & (i2 = a2[r3.pos++])) << 17, i2 < 128)
                return tu(t3, n3, e3);
              if (n3 |= (127 & (i2 = a2[r3.pos++])) << 24, i2 < 128)
                return tu(t3, n3, e3);
              if (n3 |= (1 & (i2 = a2[r3.pos++])) << 31, i2 < 128)
                return tu(t3, n3, e3);
              throw new Error("Expected varint not more than 10 bytes");
            }(e2 |= (15 & (r2 = n2[this.pos])) << 28, t2, this))));
          }, readVarint64: function() {
            return this.readVarint(true);
          }, readSVarint: function() {
            var t2 = this.readVarint();
            return t2 % 2 == 1 ? (t2 + 1) / -2 : t2 / 2;
          }, readBoolean: function() {
            return Boolean(this.readVarint());
          }, readString: function() {
            var t2 = this.readVarint() + this.pos, e2 = this.pos;
            return this.pos = t2, t2 - e2 >= 12 && Ws ? function(t3, e3, r2) {
              return Ws.decode(t3.subarray(e3, r2));
            }(this.buf, e2, t2) : function(t3, e3, r2) {
              for (var n2 = "", i2 = e3; i2 < r2; ) {
                var a2, o2, s2, u2 = t3[i2], l2 = null, p2 = u2 > 239 ? 4 : u2 > 223 ? 3 : u2 > 191 ? 2 : 1;
                if (i2 + p2 > r2)
                  break;
                1 === p2 ? u2 < 128 && (l2 = u2) : 2 === p2 ? 128 == (192 & (a2 = t3[i2 + 1])) && (l2 = (31 & u2) << 6 | 63 & a2) <= 127 && (l2 = null) : 3 === p2 ? (o2 = t3[i2 + 2], 128 == (192 & (a2 = t3[i2 + 1])) && 128 == (192 & o2) && ((l2 = (15 & u2) << 12 | (63 & a2) << 6 | 63 & o2) <= 2047 || l2 >= 55296 && l2 <= 57343) && (l2 = null)) : 4 === p2 && (o2 = t3[i2 + 2], s2 = t3[i2 + 3], 128 == (192 & (a2 = t3[i2 + 1])) && 128 == (192 & o2) && 128 == (192 & s2) && ((l2 = (15 & u2) << 18 | (63 & a2) << 12 | (63 & o2) << 6 | 63 & s2) <= 65535 || l2 >= 1114112) && (l2 = null)), null === l2 ? (l2 = 65533, p2 = 1) : l2 > 65535 && (l2 -= 65536, n2 += String.fromCharCode(l2 >>> 10 & 1023 | 55296), l2 = 56320 | 1023 & l2), n2 += String.fromCharCode(l2), i2 += p2;
              }
              return n2;
            }(this.buf, e2, t2);
          }, readBytes: function() {
            var t2 = this.readVarint() + this.pos, e2 = this.buf.subarray(this.pos, t2);
            return this.pos = t2, e2;
          }, readPackedVarint: function(t2, e2) {
            if (this.type !== $s.Bytes)
              return t2.push(this.readVarint(e2));
            var r2 = Qs(this);
            for (t2 = t2 || []; this.pos < r2; )
              t2.push(this.readVarint(e2));
            return t2;
          }, readPackedSVarint: function(t2) {
            if (this.type !== $s.Bytes)
              return t2.push(this.readSVarint());
            var e2 = Qs(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readSVarint());
            return t2;
          }, readPackedBoolean: function(t2) {
            if (this.type !== $s.Bytes)
              return t2.push(this.readBoolean());
            var e2 = Qs(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readBoolean());
            return t2;
          }, readPackedFloat: function(t2) {
            if (this.type !== $s.Bytes)
              return t2.push(this.readFloat());
            var e2 = Qs(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readFloat());
            return t2;
          }, readPackedDouble: function(t2) {
            if (this.type !== $s.Bytes)
              return t2.push(this.readDouble());
            var e2 = Qs(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readDouble());
            return t2;
          }, readPackedFixed32: function(t2) {
            if (this.type !== $s.Bytes)
              return t2.push(this.readFixed32());
            var e2 = Qs(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readFixed32());
            return t2;
          }, readPackedSFixed32: function(t2) {
            if (this.type !== $s.Bytes)
              return t2.push(this.readSFixed32());
            var e2 = Qs(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readSFixed32());
            return t2;
          }, readPackedFixed64: function(t2) {
            if (this.type !== $s.Bytes)
              return t2.push(this.readFixed64());
            var e2 = Qs(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readFixed64());
            return t2;
          }, readPackedSFixed64: function(t2) {
            if (this.type !== $s.Bytes)
              return t2.push(this.readSFixed64());
            var e2 = Qs(this);
            for (t2 = t2 || []; this.pos < e2; )
              t2.push(this.readSFixed64());
            return t2;
          }, skip: function(t2) {
            var e2 = 7 & t2;
            if (e2 === $s.Varint)
              for (; this.buf[this.pos++] > 127; )
                ;
            else if (e2 === $s.Bytes)
              this.pos = this.readVarint() + this.pos;
            else if (e2 === $s.Fixed32)
              this.pos += 4;
            else {
              if (e2 !== $s.Fixed64)
                throw new Error("Unimplemented type: " + e2);
              this.pos += 8;
            }
          }, writeTag: function(t2, e2) {
            this.writeVarint(t2 << 3 | e2);
          }, realloc: function(t2) {
            for (var e2 = this.length || 16; e2 < this.pos + t2; )
              e2 *= 2;
            if (e2 !== this.length) {
              var r2 = new Uint8Array(e2);
              r2.set(this.buf), this.buf = r2, this.length = e2;
            }
          }, finish: function() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }, writeFixed32: function(t2) {
            this.realloc(4), hu(this.buf, t2, this.pos), this.pos += 4;
          }, writeSFixed32: function(t2) {
            this.realloc(4), hu(this.buf, t2, this.pos), this.pos += 4;
          }, writeFixed64: function(t2) {
            this.realloc(8), hu(this.buf, -1 & t2, this.pos), hu(this.buf, Math.floor(t2 * (1 / 4294967296)), this.pos + 4), this.pos += 8;
          }, writeSFixed64: function(t2) {
            this.realloc(8), hu(this.buf, -1 & t2, this.pos), hu(this.buf, Math.floor(t2 * (1 / 4294967296)), this.pos + 4), this.pos += 8;
          }, writeVarint: function(t2) {
            (t2 = +t2 || 0) > 268435455 || t2 < 0 ? function(t3, e2) {
              var r2, n2;
              if (t3 >= 0 ? (r2 = t3 % 4294967296 | 0, n2 = t3 / 4294967296 | 0) : (n2 = ~(-t3 / 4294967296), 4294967295 ^ (r2 = ~(-t3 % 4294967296)) ? r2 = r2 + 1 | 0 : (r2 = 0, n2 = n2 + 1 | 0)), t3 >= 18446744073709552e3 || t3 < -18446744073709552e3)
                throw new Error("Given varint doesn't fit into 10 bytes");
              e2.realloc(10), function(t4, e3, r3) {
                r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, t4 >>>= 7, r3.buf[r3.pos++] = 127 & t4 | 128, r3.buf[r3.pos] = 127 & (t4 >>>= 7);
              }(r2, 0, e2), function(t4, e3) {
                var r3 = (7 & t4) << 4;
                e3.buf[e3.pos++] |= r3 | ((t4 >>>= 3) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4 | ((t4 >>>= 7) ? 128 : 0), t4 && (e3.buf[e3.pos++] = 127 & t4)))));
              }(n2, e2);
            }(t2, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t2 | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = 127 & (t2 >>>= 7) | (t2 > 127 ? 128 : 0), t2 <= 127 || (this.buf[this.pos++] = t2 >>> 7 & 127))));
          }, writeSVarint: function(t2) {
            this.writeVarint(t2 < 0 ? 2 * -t2 - 1 : 2 * t2);
          }, writeBoolean: function(t2) {
            this.writeVarint(Boolean(t2));
          }, writeString: function(t2) {
            t2 = String(t2), this.realloc(4 * t2.length), this.pos++;
            var e2 = this.pos;
            this.pos = function(t3, e3, r3) {
              for (var n2, i2, a2 = 0; a2 < e3.length; a2++) {
                if ((n2 = e3.charCodeAt(a2)) > 55295 && n2 < 57344) {
                  if (!i2) {
                    n2 > 56319 || a2 + 1 === e3.length ? (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189) : i2 = n2;
                    continue;
                  }
                  if (n2 < 56320) {
                    t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = n2;
                    continue;
                  }
                  n2 = i2 - 55296 << 10 | n2 - 56320 | 65536, i2 = null;
                } else
                  i2 && (t3[r3++] = 239, t3[r3++] = 191, t3[r3++] = 189, i2 = null);
                n2 < 128 ? t3[r3++] = n2 : (n2 < 2048 ? t3[r3++] = n2 >> 6 | 192 : (n2 < 65536 ? t3[r3++] = n2 >> 12 | 224 : (t3[r3++] = n2 >> 18 | 240, t3[r3++] = n2 >> 12 & 63 | 128), t3[r3++] = n2 >> 6 & 63 | 128), t3[r3++] = 63 & n2 | 128);
              }
              return r3;
            }(this.buf, t2, this.pos);
            var r2 = this.pos - e2;
            r2 >= 128 && eu(e2, r2, this), this.pos = e2 - 1, this.writeVarint(r2), this.pos += r2;
          }, writeFloat: function(t2) {
            this.realloc(4), Hs(this.buf, t2, this.pos, true, 23, 4), this.pos += 4;
          }, writeDouble: function(t2) {
            this.realloc(8), Hs(this.buf, t2, this.pos, true, 52, 8), this.pos += 8;
          }, writeBytes: function(t2) {
            var e2 = t2.length;
            this.writeVarint(e2), this.realloc(e2);
            for (var r2 = 0; r2 < e2; r2++)
              this.buf[this.pos++] = t2[r2];
          }, writeRawMessage: function(t2, e2) {
            this.pos++;
            var r2 = this.pos;
            t2(e2, this);
            var n2 = this.pos - r2;
            n2 >= 128 && eu(r2, n2, this), this.pos = r2 - 1, this.writeVarint(n2), this.pos += n2;
          }, writeMessage: function(t2, e2, r2) {
            this.writeTag(t2, $s.Bytes), this.writeRawMessage(e2, r2);
          }, writePackedVarint: function(t2, e2) {
            e2.length && this.writeMessage(t2, ru, e2);
          }, writePackedSVarint: function(t2, e2) {
            e2.length && this.writeMessage(t2, nu, e2);
          }, writePackedBoolean: function(t2, e2) {
            e2.length && this.writeMessage(t2, ou, e2);
          }, writePackedFloat: function(t2, e2) {
            e2.length && this.writeMessage(t2, iu, e2);
          }, writePackedDouble: function(t2, e2) {
            e2.length && this.writeMessage(t2, au, e2);
          }, writePackedFixed32: function(t2, e2) {
            e2.length && this.writeMessage(t2, su, e2);
          }, writePackedSFixed32: function(t2, e2) {
            e2.length && this.writeMessage(t2, uu, e2);
          }, writePackedFixed64: function(t2, e2) {
            e2.length && this.writeMessage(t2, lu, e2);
          }, writePackedSFixed64: function(t2, e2) {
            e2.length && this.writeMessage(t2, pu, e2);
          }, writeBytesField: function(t2, e2) {
            this.writeTag(t2, $s.Bytes), this.writeBytes(e2);
          }, writeFixed32Field: function(t2, e2) {
            this.writeTag(t2, $s.Fixed32), this.writeFixed32(e2);
          }, writeSFixed32Field: function(t2, e2) {
            this.writeTag(t2, $s.Fixed32), this.writeSFixed32(e2);
          }, writeFixed64Field: function(t2, e2) {
            this.writeTag(t2, $s.Fixed64), this.writeFixed64(e2);
          }, writeSFixed64Field: function(t2, e2) {
            this.writeTag(t2, $s.Fixed64), this.writeSFixed64(e2);
          }, writeVarintField: function(t2, e2) {
            this.writeTag(t2, $s.Varint), this.writeVarint(e2);
          }, writeSVarintField: function(t2, e2) {
            this.writeTag(t2, $s.Varint), this.writeSVarint(e2);
          }, writeStringField: function(t2, e2) {
            this.writeTag(t2, $s.Bytes), this.writeString(e2);
          }, writeFloatField: function(t2, e2) {
            this.writeTag(t2, $s.Fixed32), this.writeFloat(e2);
          }, writeDoubleField: function(t2, e2) {
            this.writeTag(t2, $s.Fixed64), this.writeDouble(e2);
          }, writeBooleanField: function(t2, e2) {
            this.writeVarintField(t2, Boolean(e2));
          } };
          var gu = function(t2, e2) {
            var r2 = e2.pixelRatio, n2 = e2.version, i2 = e2.stretchX, a2 = e2.stretchY, o2 = e2.content;
            this.paddedRect = t2, this.pixelRatio = r2, this.stretchX = i2, this.stretchY = a2, this.content = o2, this.version = n2;
          }, xu = { tl: { configurable: true }, br: { configurable: true }, tlbr: { configurable: true }, displaySize: { configurable: true } };
          xu.tl.get = function() {
            return [this.paddedRect.x + 1, this.paddedRect.y + 1];
          }, xu.br.get = function() {
            return [this.paddedRect.x + this.paddedRect.w - 1, this.paddedRect.y + this.paddedRect.h - 1];
          }, xu.tlbr.get = function() {
            return this.tl.concat(this.br);
          }, xu.displaySize.get = function() {
            return [(this.paddedRect.w - 2) / this.pixelRatio, (this.paddedRect.h - 2) / this.pixelRatio];
          }, Object.defineProperties(gu.prototype, xu);
          var bu = function(t2, e2) {
            var r2 = {}, n2 = {};
            this.haveRenderCallbacks = [];
            var i2 = [];
            this.addImages(t2, r2, i2), this.addImages(e2, n2, i2);
            var a2 = vu(i2), o2 = new xo({ width: a2.w || 1, height: a2.h || 1 });
            for (var s2 in t2) {
              var u2 = t2[s2], l2 = r2[s2].paddedRect;
              xo.copy(u2.data, o2, { x: 0, y: 0 }, { x: l2.x + 1, y: l2.y + 1 }, u2.data);
            }
            for (var p2 in e2) {
              var c2 = e2[p2], h2 = n2[p2].paddedRect, f2 = h2.x + 1, y2 = h2.y + 1, d2 = c2.data.width, m2 = c2.data.height;
              xo.copy(c2.data, o2, { x: 0, y: 0 }, { x: f2, y: y2 }, c2.data), xo.copy(c2.data, o2, { x: 0, y: m2 - 1 }, { x: f2, y: y2 - 1 }, { width: d2, height: 1 }), xo.copy(c2.data, o2, { x: 0, y: 0 }, { x: f2, y: y2 + m2 }, { width: d2, height: 1 }), xo.copy(c2.data, o2, { x: d2 - 1, y: 0 }, { x: f2 - 1, y: y2 }, { width: 1, height: m2 }), xo.copy(c2.data, o2, { x: 0, y: 0 }, { x: f2 + d2, y: y2 }, { width: 1, height: m2 });
            }
            this.image = o2, this.iconPositions = r2, this.patternPositions = n2;
          };
          bu.prototype.addImages = function(t2, e2, r2) {
            for (var n2 in t2) {
              var i2 = t2[n2], a2 = { x: 0, y: 0, w: i2.data.width + 2, h: i2.data.height + 2 };
              r2.push(a2), e2[n2] = new gu(a2, i2), i2.hasRenderCallback && this.haveRenderCallbacks.push(n2);
            }
          }, bu.prototype.patchUpdatedImages = function(t2, e2) {
            for (var r2 in t2.dispatchRenderCallbacks(this.haveRenderCallbacks), t2.updatedImages)
              this.patchUpdatedImage(this.iconPositions[r2], t2.getImage(r2), e2), this.patchUpdatedImage(this.patternPositions[r2], t2.getImage(r2), e2);
          }, bu.prototype.patchUpdatedImage = function(t2, e2, r2) {
            if (t2 && e2 && t2.version !== e2.version) {
              t2.version = e2.version;
              var n2 = t2.tl;
              r2.update(e2.data, void 0, { x: n2[0], y: n2[1] });
            }
          }, On("ImagePosition", gu), On("ImageAtlas", bu);
          var wu = { horizontal: 1, vertical: 2, horizontalOnly: 3 }, _u = function() {
            this.scale = 1, this.fontStack = "", this.imageName = null;
          };
          _u.forText = function(t2, e2) {
            var r2 = new _u();
            return r2.scale = t2 || 1, r2.fontStack = e2, r2;
          }, _u.forImage = function(t2) {
            var e2 = new _u();
            return e2.imageName = t2, e2;
          };
          var Au = function() {
            this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
          };
          function Su(t2, e2, r2, n2, i2, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2) {
            var m2, v2 = Au.fromFeature(t2, i2);
            c2 === wu.vertical && v2.verticalizePunctuation();
            var g2 = oi.processBidirectionalText, x2 = oi.processStyledBidirectionalText;
            if (g2 && 1 === v2.sections.length) {
              m2 = [];
              for (var b2 = 0, w2 = g2(v2.toString(), Mu(v2, l2, a2, e2, n2, f2, y2)); b2 < w2.length; b2 += 1) {
                var _2 = w2[b2], A2 = new Au();
                A2.text = _2, A2.sections = v2.sections;
                for (var S2 = 0; S2 < _2.length; S2++)
                  A2.sectionIndex.push(0);
                m2.push(A2);
              }
            } else if (x2) {
              m2 = [];
              for (var k2 = 0, I2 = x2(v2.text, v2.sectionIndex, Mu(v2, l2, a2, e2, n2, f2, y2)); k2 < I2.length; k2 += 1) {
                var z2 = I2[k2], C2 = new Au();
                C2.text = z2[0], C2.sectionIndex = z2[1], C2.sections = v2.sections, m2.push(C2);
              }
            } else
              m2 = function(t3, e3) {
                for (var r3 = [], n3 = t3.text, i3 = 0, a3 = 0, o3 = e3; a3 < o3.length; a3 += 1) {
                  var s3 = o3[a3];
                  r3.push(t3.substring(i3, s3)), i3 = s3;
                }
                return i3 < n3.length && r3.push(t3.substring(i3, n3.length)), r3;
              }(v2, Mu(v2, l2, a2, e2, n2, f2, y2));
            var E2 = [], P2 = { positionedLines: E2, text: v2.toString(), top: p2[1], bottom: p2[1], left: p2[0], right: p2[0], writingMode: c2, iconsInText: false, verticalizable: false };
            return function(t3, e3, r3, n3, i3, a3, o3, s3, u3, l3, p3, c3) {
              for (var h3 = 0, f3 = -17, y3 = 0, d3 = 0, m3 = "right" === s3 ? 1 : "left" === s3 ? 0 : 0.5, v3 = 0, g3 = 0, x3 = i3; g3 < x3.length; g3 += 1) {
                var b3 = x3[g3];
                b3.trim();
                var w3 = b3.getMaxScale(), _3 = 24 * (w3 - 1), A3 = { positionedGlyphs: [], lineOffset: 0 };
                t3.positionedLines[v3] = A3;
                var S3 = A3.positionedGlyphs, k3 = 0;
                if (b3.length()) {
                  for (var I3 = 0; I3 < b3.length(); I3++) {
                    var z3 = b3.getSection(I3), C3 = b3.getSectionIndex(I3), E3 = b3.getCharCode(I3), P3 = 0, M2 = null, B2 = null, T2 = null, V2 = 24, F2 = !(u3 === wu.horizontal || !p3 && !Xn(E3) || p3 && (ku[E3] || (K2 = E3, Gn.Arabic(K2) || Gn["Arabic Supplement"](K2) || Gn["Arabic Extended-A"](K2) || Gn["Arabic Presentation Forms-A"](K2) || Gn["Arabic Presentation Forms-B"](K2))));
                    if (z3.imageName) {
                      var D2 = n3[z3.imageName];
                      if (!D2)
                        continue;
                      T2 = z3.imageName, t3.iconsInText = t3.iconsInText || true, B2 = D2.paddedRect;
                      var L2 = D2.displaySize;
                      z3.scale = 24 * z3.scale / c3, P3 = _3 + (24 - L2[1] * z3.scale), V2 = (M2 = { width: L2[0], height: L2[1], left: 1, top: -3, advance: F2 ? L2[1] : L2[0] }).advance;
                      var O2 = F2 ? L2[0] * z3.scale - 24 * w3 : L2[1] * z3.scale - 24 * w3;
                      O2 > 0 && O2 > k3 && (k3 = O2);
                    } else {
                      var R2 = r3[z3.fontStack], U2 = R2 && R2[E3];
                      if (U2 && U2.rect)
                        B2 = U2.rect, M2 = U2.metrics;
                      else {
                        var j2 = e3[z3.fontStack], q2 = j2 && j2[E3];
                        if (!q2)
                          continue;
                        M2 = q2.metrics;
                      }
                      P3 = 24 * (w3 - z3.scale);
                    }
                    F2 ? (t3.verticalizable = true, S3.push({ glyph: E3, imageName: T2, x: h3, y: f3 + P3, vertical: F2, scale: z3.scale, fontStack: z3.fontStack, sectionIndex: C3, metrics: M2, rect: B2 }), h3 += V2 * z3.scale + l3) : (S3.push({ glyph: E3, imageName: T2, x: h3, y: f3 + P3, vertical: F2, scale: z3.scale, fontStack: z3.fontStack, sectionIndex: C3, metrics: M2, rect: B2 }), h3 += M2.advance * z3.scale + l3);
                  }
                  0 !== S3.length && (y3 = Math.max(h3 - l3, y3), Tu(S3, 0, S3.length - 1, m3, k3)), h3 = 0;
                  var N2 = a3 * w3 + k3;
                  A3.lineOffset = Math.max(k3, _3), f3 += N2, d3 = Math.max(N2, d3), ++v3;
                } else
                  f3 += a3, ++v3;
              }
              var K2, G2 = f3 - -17, Z2 = Bu(o3), X2 = Z2.horizontalAlign, J2 = Z2.verticalAlign;
              (function(t4, e4, r4, n4, i4, a4, o4, s4, u4) {
                var l4, p4 = (e4 - r4) * i4;
                l4 = a4 !== o4 ? -s4 * n4 - -17 : (-n4 * u4 + 0.5) * o4;
                for (var c4 = 0, h4 = t4; c4 < h4.length; c4 += 1)
                  for (var f4 = 0, y4 = h4[c4].positionedGlyphs; f4 < y4.length; f4 += 1) {
                    var d4 = y4[f4];
                    d4.x += p4, d4.y += l4;
                  }
              })(t3.positionedLines, m3, X2, J2, y3, d3, a3, G2, i3.length), t3.top += -J2 * G2, t3.bottom = t3.top + G2, t3.left += -X2 * y3, t3.right = t3.left + y3;
            }(P2, e2, r2, n2, m2, o2, s2, u2, c2, l2, h2, d2), !function(t3) {
              for (var e3 = 0, r3 = t3; e3 < r3.length; e3 += 1)
                if (0 !== r3[e3].positionedGlyphs.length)
                  return false;
              return true;
            }(E2) && P2;
          }
          Au.fromFeature = function(t2, e2) {
            for (var r2 = new Au(), n2 = 0; n2 < t2.sections.length; n2++) {
              var i2 = t2.sections[n2];
              i2.image ? r2.addImageSection(i2) : r2.addTextSection(i2, e2);
            }
            return r2;
          }, Au.prototype.length = function() {
            return this.text.length;
          }, Au.prototype.getSection = function(t2) {
            return this.sections[this.sectionIndex[t2]];
          }, Au.prototype.getSectionIndex = function(t2) {
            return this.sectionIndex[t2];
          }, Au.prototype.getCharCode = function(t2) {
            return this.text.charCodeAt(t2);
          }, Au.prototype.verticalizePunctuation = function() {
            this.text = function(t2) {
              for (var e2 = "", r2 = 0; r2 < t2.length; r2++) {
                var n2 = t2.charCodeAt(r2 + 1) || null, i2 = t2.charCodeAt(r2 - 1) || null;
                e2 += n2 && Jn(n2) && !Xs[t2[r2 + 1]] || i2 && Jn(i2) && !Xs[t2[r2 - 1]] || !Xs[t2[r2]] ? t2[r2] : Xs[t2[r2]];
              }
              return e2;
            }(this.text);
          }, Au.prototype.trim = function() {
            for (var t2 = 0, e2 = 0; e2 < this.text.length && ku[this.text.charCodeAt(e2)]; e2++)
              t2++;
            for (var r2 = this.text.length, n2 = this.text.length - 1; n2 >= 0 && n2 >= t2 && ku[this.text.charCodeAt(n2)]; n2--)
              r2--;
            this.text = this.text.substring(t2, r2), this.sectionIndex = this.sectionIndex.slice(t2, r2);
          }, Au.prototype.substring = function(t2, e2) {
            var r2 = new Au();
            return r2.text = this.text.substring(t2, e2), r2.sectionIndex = this.sectionIndex.slice(t2, e2), r2.sections = this.sections, r2;
          }, Au.prototype.toString = function() {
            return this.text;
          }, Au.prototype.getMaxScale = function() {
            var t2 = this;
            return this.sectionIndex.reduce(function(e2, r2) {
              return Math.max(e2, t2.sections[r2].scale);
            }, 0);
          }, Au.prototype.addTextSection = function(t2, e2) {
            this.text += t2.text, this.sections.push(_u.forText(t2.scale, t2.fontStack || e2));
            for (var r2 = this.sections.length - 1, n2 = 0; n2 < t2.text.length; ++n2)
              this.sectionIndex.push(r2);
          }, Au.prototype.addImageSection = function(t2) {
            var e2 = t2.image ? t2.image.name : "";
            if (0 !== e2.length) {
              var r2 = this.getNextImageSectionCharCode();
              r2 ? (this.text += String.fromCharCode(r2), this.sections.push(_u.forImage(e2)), this.sectionIndex.push(this.sections.length - 1)) : A("Reached maximum number of images 6401");
            } else
              A("Can't add FormattedSection with an empty image.");
          }, Au.prototype.getNextImageSectionCharCode = function() {
            return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
          };
          var ku = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, Iu = {};
          function zu(t2, e2, r2, n2, i2, a2) {
            if (e2.imageName) {
              var o2 = n2[e2.imageName];
              return o2 ? o2.displaySize[0] * e2.scale * 24 / a2 + i2 : 0;
            }
            var s2 = r2[e2.fontStack], u2 = s2 && s2[t2];
            return u2 ? u2.metrics.advance * e2.scale + i2 : 0;
          }
          function Cu(t2, e2, r2, n2) {
            var i2 = Math.pow(t2 - e2, 2);
            return n2 ? t2 < e2 ? i2 / 2 : 2 * i2 : i2 + Math.abs(r2) * r2;
          }
          function Eu(t2, e2, r2) {
            var n2 = 0;
            return 10 === t2 && (n2 -= 1e4), r2 && (n2 += 150), 40 !== t2 && 65288 !== t2 || (n2 += 50), 41 !== e2 && 65289 !== e2 || (n2 += 50), n2;
          }
          function Pu(t2, e2, r2, n2, i2, a2) {
            for (var o2 = null, s2 = Cu(e2, r2, i2, a2), u2 = 0, l2 = n2; u2 < l2.length; u2 += 1) {
              var p2 = l2[u2], c2 = Cu(e2 - p2.x, r2, i2, a2) + p2.badness;
              c2 <= s2 && (o2 = p2, s2 = c2);
            }
            return { index: t2, x: e2, priorBreak: o2, badness: s2 };
          }
          function Mu(t2, e2, r2, n2, i2, a2, o2) {
            if ("point" !== a2)
              return [];
            if (!t2)
              return [];
            for (var s2, u2 = [], l2 = function(t3, e3, r3, n3, i3, a3) {
              for (var o3 = 0, s3 = 0; s3 < t3.length(); s3++) {
                var u3 = t3.getSection(s3);
                o3 += zu(t3.getCharCode(s3), u3, n3, i3, e3, a3);
              }
              return o3 / Math.max(1, Math.ceil(o3 / r3));
            }(t2, e2, r2, n2, i2, o2), p2 = t2.text.indexOf("\u200B") >= 0, c2 = 0, h2 = 0; h2 < t2.length(); h2++) {
              var f2 = t2.getSection(h2), y2 = t2.getCharCode(h2);
              if (ku[y2] || (c2 += zu(y2, f2, n2, i2, e2, o2)), h2 < t2.length() - 1) {
                var d2 = !((s2 = y2) < 11904 || !(Gn["Bopomofo Extended"](s2) || Gn.Bopomofo(s2) || Gn["CJK Compatibility Forms"](s2) || Gn["CJK Compatibility Ideographs"](s2) || Gn["CJK Compatibility"](s2) || Gn["CJK Radicals Supplement"](s2) || Gn["CJK Strokes"](s2) || Gn["CJK Symbols and Punctuation"](s2) || Gn["CJK Unified Ideographs Extension A"](s2) || Gn["CJK Unified Ideographs"](s2) || Gn["Enclosed CJK Letters and Months"](s2) || Gn["Halfwidth and Fullwidth Forms"](s2) || Gn.Hiragana(s2) || Gn["Ideographic Description Characters"](s2) || Gn["Kangxi Radicals"](s2) || Gn["Katakana Phonetic Extensions"](s2) || Gn.Katakana(s2) || Gn["Vertical Forms"](s2) || Gn["Yi Radicals"](s2) || Gn["Yi Syllables"](s2)));
                (Iu[y2] || d2 || f2.imageName) && u2.push(Pu(h2 + 1, c2, l2, u2, Eu(y2, t2.getCharCode(h2 + 1), d2 && p2), false));
              }
            }
            return function t3(e3) {
              return e3 ? t3(e3.priorBreak).concat(e3.index) : [];
            }(Pu(t2.length(), c2, l2, u2, 0, true));
          }
          function Bu(t2) {
            var e2 = 0.5, r2 = 0.5;
            switch (t2) {
              case "right":
              case "top-right":
              case "bottom-right":
                e2 = 1;
                break;
              case "left":
              case "top-left":
              case "bottom-left":
                e2 = 0;
            }
            switch (t2) {
              case "bottom":
              case "bottom-right":
              case "bottom-left":
                r2 = 1;
                break;
              case "top":
              case "top-right":
              case "top-left":
                r2 = 0;
            }
            return { horizontalAlign: e2, verticalAlign: r2 };
          }
          function Tu(t2, e2, r2, n2, i2) {
            if (n2 || i2)
              for (var a2 = t2[r2], o2 = (t2[r2].x + a2.metrics.advance * a2.scale) * n2, s2 = e2; s2 <= r2; s2++)
                t2[s2].x -= o2, t2[s2].y += i2;
          }
          function Vu(t2, e2, r2, n2, i2, a2) {
            var o2, s2 = t2.image;
            if (s2.content) {
              var u2 = s2.content, l2 = s2.pixelRatio || 1;
              o2 = [u2[0] / l2, u2[1] / l2, s2.displaySize[0] - u2[2] / l2, s2.displaySize[1] - u2[3] / l2];
            }
            var p2, c2, h2, f2, y2 = e2.left * a2, d2 = e2.right * a2;
            "width" === r2 || "both" === r2 ? (f2 = i2[0] + y2 - n2[3], c2 = i2[0] + d2 + n2[1]) : c2 = (f2 = i2[0] + (y2 + d2 - s2.displaySize[0]) / 2) + s2.displaySize[0];
            var m2 = e2.top * a2, v2 = e2.bottom * a2;
            return "height" === r2 || "both" === r2 ? (p2 = i2[1] + m2 - n2[0], h2 = i2[1] + v2 + n2[2]) : h2 = (p2 = i2[1] + (m2 + v2 - s2.displaySize[1]) / 2) + s2.displaySize[1], { image: s2, top: p2, right: c2, bottom: h2, left: f2, collisionPadding: o2 };
          }
          Iu[10] = true, Iu[32] = true, Iu[38] = true, Iu[40] = true, Iu[41] = true, Iu[43] = true, Iu[45] = true, Iu[47] = true, Iu[173] = true, Iu[183] = true, Iu[8203] = true, Iu[8208] = true, Iu[8211] = true, Iu[8231] = true;
          var Fu = function(t2) {
            function e2(e3, r2, n2, i2) {
              t2.call(this, e3, r2), this.angle = n2, void 0 !== i2 && (this.segment = i2);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.clone = function() {
              return new e2(this.x, this.y, this.angle, this.segment);
            }, e2;
          }(i);
          function Du(t2, e2) {
            var r2 = e2.expression;
            if ("constant" === r2.kind)
              return { kind: "constant", layoutSize: r2.evaluate(new si(t2 + 1)) };
            if ("source" === r2.kind)
              return { kind: "source" };
            for (var n2 = r2.zoomStops, i2 = r2.interpolationType, a2 = 0; a2 < n2.length && n2[a2] <= t2; )
              a2++;
            for (var o2 = a2 = Math.max(0, a2 - 1); o2 < n2.length && n2[o2] < t2 + 1; )
              o2++;
            o2 = Math.min(n2.length - 1, o2);
            var s2 = n2[a2], u2 = n2[o2];
            return "composite" === r2.kind ? { kind: "composite", minZoom: s2, maxZoom: u2, interpolationType: i2 } : { kind: "camera", minZoom: s2, maxZoom: u2, minSize: r2.evaluate(new si(s2)), maxSize: r2.evaluate(new si(u2)), interpolationType: i2 };
          }
          function Lu(t2, e2, r2) {
            var n2 = e2.uSize, i2 = r2.lowerSize;
            return "source" === t2.kind ? i2 / 128 : "composite" === t2.kind ? Ke(i2 / 128, r2.upperSize / 128, e2.uSizeT) : n2;
          }
          function Ou(t2, e2) {
            var r2 = 0, n2 = 0;
            if ("constant" === t2.kind)
              n2 = t2.layoutSize;
            else if ("source" !== t2.kind) {
              var i2 = t2.interpolationType, a2 = i2 ? p(ar.interpolationFactor(i2, e2, t2.minZoom, t2.maxZoom), 0, 1) : 0;
              "camera" === t2.kind ? n2 = Ke(t2.minSize, t2.maxSize, a2) : r2 = a2;
            }
            return { uSizeT: r2, uSize: n2 };
          }
          On("Anchor", Fu);
          var Ru = Object.freeze({ __proto__: null, getSizeData: Du, evaluateSizeForFeature: Lu, evaluateSizeForZoom: Ou, SIZE_PACK_FACTOR: 128 });
          function Uu(t2, e2, r2, n2, i2) {
            if (void 0 === e2.segment)
              return true;
            for (var a2 = e2, o2 = e2.segment + 1, s2 = 0; s2 > -r2 / 2; ) {
              if (--o2 < 0)
                return false;
              s2 -= t2[o2].dist(a2), a2 = t2[o2];
            }
            s2 += t2[o2].dist(t2[o2 + 1]), o2++;
            for (var u2 = [], l2 = 0; s2 < r2 / 2; ) {
              var p2 = t2[o2], c2 = t2[o2 + 1];
              if (!c2)
                return false;
              var h2 = t2[o2 - 1].angleTo(p2) - p2.angleTo(c2);
              for (h2 = Math.abs((h2 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), u2.push({ distance: s2, angleDelta: h2 }), l2 += h2; s2 - u2[0].distance > n2; )
                l2 -= u2.shift().angleDelta;
              if (l2 > i2)
                return false;
              o2++, s2 += p2.dist(c2);
            }
            return true;
          }
          function ju(t2) {
            for (var e2 = 0, r2 = 0; r2 < t2.length - 1; r2++)
              e2 += t2[r2].dist(t2[r2 + 1]);
            return e2;
          }
          function qu(t2, e2, r2) {
            return t2 ? 0.6 * e2 * r2 : 0;
          }
          function Nu(t2, e2) {
            return Math.max(t2 ? t2.right - t2.left : 0, e2 ? e2.right - e2.left : 0);
          }
          function Ku(t2, e2, r2, n2, i2, a2) {
            for (var o2 = qu(r2, i2, a2), s2 = Nu(r2, n2) * a2, u2 = 0, l2 = ju(t2) / 2, p2 = 0; p2 < t2.length - 1; p2++) {
              var c2 = t2[p2], h2 = t2[p2 + 1], f2 = c2.dist(h2);
              if (u2 + f2 > l2) {
                var y2 = (l2 - u2) / f2, d2 = Ke(c2.x, h2.x, y2), m2 = Ke(c2.y, h2.y, y2), v2 = new Fu(d2, m2, h2.angleTo(c2), p2);
                return v2._round(), !o2 || Uu(t2, v2, s2, o2, e2) ? v2 : void 0;
              }
              u2 += f2;
            }
          }
          function Gu(t2, e2, r2, n2, i2, a2, o2, s2, u2) {
            var l2 = qu(n2, a2, o2), p2 = Nu(n2, i2), c2 = p2 * o2, h2 = 0 === t2[0].x || t2[0].x === u2 || 0 === t2[0].y || t2[0].y === u2;
            return e2 - c2 < e2 / 4 && (e2 = c2 + e2 / 4), function t3(e3, r3, n3, i3, a3, o3, s3, u3, l3) {
              for (var p3 = o3 / 2, c3 = ju(e3), h3 = 0, f2 = r3 - n3, y2 = [], d2 = 0; d2 < e3.length - 1; d2++) {
                for (var m2 = e3[d2], v2 = e3[d2 + 1], g2 = m2.dist(v2), x2 = v2.angleTo(m2); f2 + n3 < h3 + g2; ) {
                  var b2 = ((f2 += n3) - h3) / g2, w2 = Ke(m2.x, v2.x, b2), _2 = Ke(m2.y, v2.y, b2);
                  if (w2 >= 0 && w2 < l3 && _2 >= 0 && _2 < l3 && f2 - p3 >= 0 && f2 + p3 <= c3) {
                    var A2 = new Fu(w2, _2, x2, d2);
                    A2._round(), i3 && !Uu(e3, A2, o3, i3, a3) || y2.push(A2);
                  }
                }
                h3 += g2;
              }
              return u3 || y2.length || s3 || (y2 = t3(e3, h3 / 2, n3, i3, a3, o3, s3, true, l3)), y2;
            }(t2, h2 ? e2 / 2 * s2 % e2 : (p2 / 2 + 2 * a2) * o2 * s2 % e2, e2, l2, r2, c2, h2, false, u2);
          }
          function Zu(t2, e2, r2, n2, a2) {
            for (var o2 = [], s2 = 0; s2 < t2.length; s2++)
              for (var u2 = t2[s2], l2 = void 0, p2 = 0; p2 < u2.length - 1; p2++) {
                var c2 = u2[p2], h2 = u2[p2 + 1];
                c2.x < e2 && h2.x < e2 || (c2.x < e2 ? c2 = new i(e2, c2.y + (e2 - c2.x) / (h2.x - c2.x) * (h2.y - c2.y))._round() : h2.x < e2 && (h2 = new i(e2, c2.y + (e2 - c2.x) / (h2.x - c2.x) * (h2.y - c2.y))._round()), c2.y < r2 && h2.y < r2 || (c2.y < r2 ? c2 = new i(c2.x + (r2 - c2.y) / (h2.y - c2.y) * (h2.x - c2.x), r2)._round() : h2.y < r2 && (h2 = new i(c2.x + (r2 - c2.y) / (h2.y - c2.y) * (h2.x - c2.x), r2)._round()), c2.x >= n2 && h2.x >= n2 || (c2.x >= n2 ? c2 = new i(n2, c2.y + (n2 - c2.x) / (h2.x - c2.x) * (h2.y - c2.y))._round() : h2.x >= n2 && (h2 = new i(n2, c2.y + (n2 - c2.x) / (h2.x - c2.x) * (h2.y - c2.y))._round()), c2.y >= a2 && h2.y >= a2 || (c2.y >= a2 ? c2 = new i(c2.x + (a2 - c2.y) / (h2.y - c2.y) * (h2.x - c2.x), a2)._round() : h2.y >= a2 && (h2 = new i(c2.x + (a2 - c2.y) / (h2.y - c2.y) * (h2.x - c2.x), a2)._round()), l2 && c2.equals(l2[l2.length - 1]) || o2.push(l2 = [c2]), l2.push(h2)))));
              }
            return o2;
          }
          function Xu(t2, e2, r2, n2) {
            var a2 = [], o2 = t2.image, s2 = o2.pixelRatio, u2 = o2.paddedRect.w - 2, l2 = o2.paddedRect.h - 2, p2 = t2.right - t2.left, c2 = t2.bottom - t2.top, h2 = o2.stretchX || [[0, u2]], f2 = o2.stretchY || [[0, l2]], y2 = function(t3, e3) {
              return t3 + e3[1] - e3[0];
            }, d2 = h2.reduce(y2, 0), m2 = f2.reduce(y2, 0), v2 = u2 - d2, g2 = l2 - m2, x2 = 0, b2 = d2, w2 = 0, _2 = m2, A2 = 0, S2 = v2, k2 = 0, I2 = g2;
            if (o2.content && n2) {
              var z2 = o2.content;
              x2 = Ju(h2, 0, z2[0]), w2 = Ju(f2, 0, z2[1]), b2 = Ju(h2, z2[0], z2[2]), _2 = Ju(f2, z2[1], z2[3]), A2 = z2[0] - x2, k2 = z2[1] - w2, S2 = z2[2] - z2[0] - b2, I2 = z2[3] - z2[1] - _2;
            }
            var C2 = function(n3, a3, u3, l3) {
              var h3 = Yu(n3.stretch - x2, b2, p2, t2.left), f3 = $u(n3.fixed - A2, S2, n3.stretch, d2), y3 = Yu(a3.stretch - w2, _2, c2, t2.top), v3 = $u(a3.fixed - k2, I2, a3.stretch, m2), g3 = Yu(u3.stretch - x2, b2, p2, t2.left), z3 = $u(u3.fixed - A2, S2, u3.stretch, d2), C3 = Yu(l3.stretch - w2, _2, c2, t2.top), E3 = $u(l3.fixed - k2, I2, l3.stretch, m2), P3 = new i(h3, y3), M3 = new i(g3, y3), B3 = new i(g3, C3), T3 = new i(h3, C3), V3 = new i(f3 / s2, v3 / s2), F2 = new i(z3 / s2, E3 / s2), D2 = e2 * Math.PI / 180;
              if (D2) {
                var L2 = Math.sin(D2), O2 = Math.cos(D2), R2 = [O2, -L2, L2, O2];
                P3._matMult(R2), M3._matMult(R2), T3._matMult(R2), B3._matMult(R2);
              }
              var U2 = n3.stretch + n3.fixed, j2 = a3.stretch + a3.fixed;
              return { tl: P3, tr: M3, bl: T3, br: B3, tex: { x: o2.paddedRect.x + 1 + U2, y: o2.paddedRect.y + 1 + j2, w: u3.stretch + u3.fixed - U2, h: l3.stretch + l3.fixed - j2 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: V3, pixelOffsetBR: F2, minFontScaleX: S2 / s2 / p2, minFontScaleY: I2 / s2 / c2, isSDF: r2 };
            };
            if (n2 && (o2.stretchX || o2.stretchY))
              for (var E2 = Hu(h2, v2, d2), P2 = Hu(f2, g2, m2), M2 = 0; M2 < E2.length - 1; M2++)
                for (var B2 = E2[M2], T2 = E2[M2 + 1], V2 = 0; V2 < P2.length - 1; V2++)
                  a2.push(C2(B2, P2[V2], T2, P2[V2 + 1]));
            else
              a2.push(C2({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: u2 + 1 }, { fixed: 0, stretch: l2 + 1 }));
            return a2;
          }
          function Ju(t2, e2, r2) {
            for (var n2 = 0, i2 = 0, a2 = t2; i2 < a2.length; i2 += 1) {
              var o2 = a2[i2];
              n2 += Math.max(e2, Math.min(r2, o2[1])) - Math.max(e2, Math.min(r2, o2[0]));
            }
            return n2;
          }
          function Hu(t2, e2, r2) {
            for (var n2 = [{ fixed: -1, stretch: 0 }], i2 = 0, a2 = t2; i2 < a2.length; i2 += 1) {
              var o2 = a2[i2], s2 = o2[0], u2 = o2[1], l2 = n2[n2.length - 1];
              n2.push({ fixed: s2 - l2.stretch, stretch: l2.stretch }), n2.push({ fixed: s2 - l2.stretch, stretch: l2.stretch + (u2 - s2) });
            }
            return n2.push({ fixed: e2 + 1, stretch: r2 }), n2;
          }
          function Yu(t2, e2, r2, n2) {
            return t2 / e2 * r2 + n2;
          }
          function $u(t2, e2, r2, n2) {
            return t2 - e2 * r2 / n2;
          }
          var Wu = function(t2, e2, r2, n2, a2, o2, s2, u2, l2, p2) {
            if (this.boxStartIndex = t2.length, l2) {
              var c2 = o2.top, h2 = o2.bottom, f2 = o2.collisionPadding;
              f2 && (c2 -= f2[1], h2 += f2[3]);
              var y2 = h2 - c2;
              y2 > 0 && (y2 = Math.max(10, y2), this.circleDiameter = y2);
            } else {
              var d2 = o2.top * s2 - u2, m2 = o2.bottom * s2 + u2, v2 = o2.left * s2 - u2, g2 = o2.right * s2 + u2, x2 = o2.collisionPadding;
              if (x2 && (v2 -= x2[0] * s2, d2 -= x2[1] * s2, g2 += x2[2] * s2, m2 += x2[3] * s2), p2) {
                var b2 = new i(v2, d2), w2 = new i(g2, d2), _2 = new i(v2, m2), A2 = new i(g2, m2), S2 = p2 * Math.PI / 180;
                b2._rotate(S2), w2._rotate(S2), _2._rotate(S2), A2._rotate(S2), v2 = Math.min(b2.x, w2.x, _2.x, A2.x), g2 = Math.max(b2.x, w2.x, _2.x, A2.x), d2 = Math.min(b2.y, w2.y, _2.y, A2.y), m2 = Math.max(b2.y, w2.y, _2.y, A2.y);
              }
              t2.emplaceBack(e2.x, e2.y, v2, d2, g2, m2, r2, n2, a2);
            }
            this.boxEndIndex = t2.length;
          }, Qu = function(t2, e2) {
            if (void 0 === t2 && (t2 = []), void 0 === e2 && (e2 = tl), this.data = t2, this.length = this.data.length, this.compare = e2, this.length > 0)
              for (var r2 = (this.length >> 1) - 1; r2 >= 0; r2--)
                this._down(r2);
          };
          function tl(t2, e2) {
            return t2 < e2 ? -1 : t2 > e2 ? 1 : 0;
          }
          function el(t2, e2, r2) {
            void 0 === e2 && (e2 = 1), void 0 === r2 && (r2 = false);
            for (var n2 = 1 / 0, a2 = 1 / 0, o2 = -1 / 0, s2 = -1 / 0, u2 = t2[0], l2 = 0; l2 < u2.length; l2++) {
              var p2 = u2[l2];
              (!l2 || p2.x < n2) && (n2 = p2.x), (!l2 || p2.y < a2) && (a2 = p2.y), (!l2 || p2.x > o2) && (o2 = p2.x), (!l2 || p2.y > s2) && (s2 = p2.y);
            }
            var c2 = Math.min(o2 - n2, s2 - a2), h2 = c2 / 2, f2 = new Qu([], rl);
            if (0 === c2)
              return new i(n2, a2);
            for (var y2 = n2; y2 < o2; y2 += c2)
              for (var d2 = a2; d2 < s2; d2 += c2)
                f2.push(new nl(y2 + h2, d2 + h2, h2, t2));
            for (var m2 = function(t3) {
              for (var e3 = 0, r3 = 0, n3 = 0, i2 = t3[0], a3 = 0, o3 = i2.length, s3 = o3 - 1; a3 < o3; s3 = a3++) {
                var u3 = i2[a3], l3 = i2[s3], p3 = u3.x * l3.y - l3.x * u3.y;
                r3 += (u3.x + l3.x) * p3, n3 += (u3.y + l3.y) * p3, e3 += 3 * p3;
              }
              return new nl(r3 / e3, n3 / e3, 0, t3);
            }(t2), v2 = f2.length; f2.length; ) {
              var g2 = f2.pop();
              (g2.d > m2.d || !m2.d) && (m2 = g2, r2 && console.log("found best %d after %d probes", Math.round(1e4 * g2.d) / 1e4, v2)), g2.max - m2.d <= e2 || (f2.push(new nl(g2.p.x - (h2 = g2.h / 2), g2.p.y - h2, h2, t2)), f2.push(new nl(g2.p.x + h2, g2.p.y - h2, h2, t2)), f2.push(new nl(g2.p.x - h2, g2.p.y + h2, h2, t2)), f2.push(new nl(g2.p.x + h2, g2.p.y + h2, h2, t2)), v2 += 4);
            }
            return r2 && (console.log("num probes: " + v2), console.log("best distance: " + m2.d)), m2.p;
          }
          function rl(t2, e2) {
            return e2.max - t2.max;
          }
          function nl(t2, e2, r2, n2) {
            this.p = new i(t2, e2), this.h = r2, this.d = function(t3, e3) {
              for (var r3 = false, n3 = 1 / 0, i2 = 0; i2 < e3.length; i2++)
                for (var a2 = e3[i2], o2 = 0, s2 = a2.length, u2 = s2 - 1; o2 < s2; u2 = o2++) {
                  var l2 = a2[o2], p2 = a2[u2];
                  l2.y > t3.y != p2.y > t3.y && t3.x < (p2.x - l2.x) * (t3.y - l2.y) / (p2.y - l2.y) + l2.x && (r3 = !r3), n3 = Math.min(n3, Ya(t3, l2, p2));
                }
              return (r3 ? 1 : -1) * Math.sqrt(n3);
            }(this.p, n2), this.max = this.d + this.h * Math.SQRT2;
          }
          Qu.prototype.push = function(t2) {
            this.data.push(t2), this.length++, this._up(this.length - 1);
          }, Qu.prototype.pop = function() {
            if (0 !== this.length) {
              var t2 = this.data[0], e2 = this.data.pop();
              return this.length--, this.length > 0 && (this.data[0] = e2, this._down(0)), t2;
            }
          }, Qu.prototype.peek = function() {
            return this.data[0];
          }, Qu.prototype._up = function(t2) {
            for (var e2 = this.data, r2 = this.compare, n2 = e2[t2]; t2 > 0; ) {
              var i2 = t2 - 1 >> 1, a2 = e2[i2];
              if (r2(n2, a2) >= 0)
                break;
              e2[t2] = a2, t2 = i2;
            }
            e2[t2] = n2;
          }, Qu.prototype._down = function(t2) {
            for (var e2 = this.data, r2 = this.compare, n2 = this.length >> 1, i2 = e2[t2]; t2 < n2; ) {
              var a2 = 1 + (t2 << 1), o2 = e2[a2], s2 = a2 + 1;
              if (s2 < this.length && r2(e2[s2], o2) < 0 && (a2 = s2, o2 = e2[s2]), r2(o2, i2) >= 0)
                break;
              e2[t2] = o2, t2 = a2;
            }
            e2[t2] = i2;
          };
          var il = Number.POSITIVE_INFINITY;
          function al(t2, e2) {
            return e2[1] !== il ? function(t3, e3, r2) {
              var n2 = 0, i2 = 0;
              switch (e3 = Math.abs(e3), r2 = Math.abs(r2), t3) {
                case "top-right":
                case "top-left":
                case "top":
                  i2 = r2 - 7;
                  break;
                case "bottom-right":
                case "bottom-left":
                case "bottom":
                  i2 = 7 - r2;
              }
              switch (t3) {
                case "top-right":
                case "bottom-right":
                case "right":
                  n2 = -e3;
                  break;
                case "top-left":
                case "bottom-left":
                case "left":
                  n2 = e3;
              }
              return [n2, i2];
            }(t2, e2[0], e2[1]) : function(t3, e3) {
              var r2 = 0, n2 = 0;
              e3 < 0 && (e3 = 0);
              var i2 = e3 / Math.sqrt(2);
              switch (t3) {
                case "top-right":
                case "top-left":
                  n2 = i2 - 7;
                  break;
                case "bottom-right":
                case "bottom-left":
                  n2 = 7 - i2;
                  break;
                case "bottom":
                  n2 = 7 - e3;
                  break;
                case "top":
                  n2 = e3 - 7;
              }
              switch (t3) {
                case "top-right":
                case "bottom-right":
                  r2 = -i2;
                  break;
                case "top-left":
                case "bottom-left":
                  r2 = i2;
                  break;
                case "left":
                  r2 = e3;
                  break;
                case "right":
                  r2 = -e3;
              }
              return [r2, n2];
            }(t2, e2[0]);
          }
          function ol(t2) {
            switch (t2) {
              case "right":
              case "top-right":
              case "bottom-right":
                return "right";
              case "left":
              case "top-left":
              case "bottom-left":
                return "left";
            }
            return "center";
          }
          function sl(t2, e2, r2, n2, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2) {
            var m2 = function(t3, e3, r3, n3, a3, o3, s3, u3) {
              for (var l3 = n3.layout.get("text-rotate").evaluate(o3, {}) * Math.PI / 180, p3 = [], c3 = 0, h3 = e3.positionedLines; c3 < h3.length; c3 += 1)
                for (var f3 = h3[c3], y3 = 0, d3 = f3.positionedGlyphs; y3 < d3.length; y3 += 1) {
                  var m3 = d3[y3];
                  if (m3.rect) {
                    var v3 = m3.rect || {}, g3 = 4, x3 = true, b3 = 1, w2 = 0, _2 = (a3 || u3) && m3.vertical, A2 = m3.metrics.advance * m3.scale / 2;
                    if (u3 && e3.verticalizable && (w2 = f3.lineOffset / 2 - (m3.imageName ? -(24 - m3.metrics.width * m3.scale) / 2 : 24 * (m3.scale - 1))), m3.imageName) {
                      var S2 = s3[m3.imageName];
                      x3 = S2.sdf, g3 = 1 / (b3 = S2.pixelRatio);
                    }
                    var k2 = a3 ? [m3.x + A2, m3.y] : [0, 0], I2 = a3 ? [0, 0] : [m3.x + A2 + r3[0], m3.y + r3[1] - w2], z2 = [0, 0];
                    _2 && (z2 = I2, I2 = [0, 0]);
                    var C2 = (m3.metrics.left - g3) * m3.scale - A2 + I2[0], E2 = (-m3.metrics.top - g3) * m3.scale + I2[1], P2 = C2 + v3.w * m3.scale / b3, M2 = E2 + v3.h * m3.scale / b3, B2 = new i(C2, E2), T2 = new i(P2, E2), V2 = new i(C2, M2), F2 = new i(P2, M2);
                    if (_2) {
                      var D2 = new i(-A2, A2 - -17), L2 = -Math.PI / 2, O2 = 12 - A2, R2 = new i(22 - O2, -(m3.imageName ? O2 : 0)), U2 = new (Function.prototype.bind.apply(i, [null].concat(z2)))();
                      B2._rotateAround(L2, D2)._add(R2)._add(U2), T2._rotateAround(L2, D2)._add(R2)._add(U2), V2._rotateAround(L2, D2)._add(R2)._add(U2), F2._rotateAround(L2, D2)._add(R2)._add(U2);
                    }
                    if (l3) {
                      var j2 = Math.sin(l3), q2 = Math.cos(l3), N2 = [q2, -j2, j2, q2];
                      B2._matMult(N2), T2._matMult(N2), V2._matMult(N2), F2._matMult(N2);
                    }
                    var K2 = new i(0, 0), G2 = new i(0, 0);
                    p3.push({ tl: B2, tr: T2, bl: V2, br: F2, tex: v3, writingMode: e3.writingMode, glyphOffset: k2, sectionIndex: m3.sectionIndex, isSDF: x3, pixelOffsetTL: K2, pixelOffsetBR: G2, minFontScaleX: 0, minFontScaleY: 0 });
                  }
                }
              return p3;
            }(0, r2, u2, a2, o2, s2, n2, t2.allowVerticalPlacement), v2 = t2.textSizeData, g2 = null;
            "source" === v2.kind ? (g2 = [128 * a2.layout.get("text-size").evaluate(s2, {})])[0] > 32640 && A(t2.layerIds[0] + ': Value for "text-size" is >= 255. Reduce your "text-size".') : "composite" === v2.kind && ((g2 = [128 * y2.compositeTextSizes[0].evaluate(s2, {}, d2), 128 * y2.compositeTextSizes[1].evaluate(s2, {}, d2)])[0] > 32640 || g2[1] > 32640) && A(t2.layerIds[0] + ': Value for "text-size" is >= 255. Reduce your "text-size".'), t2.addSymbols(t2.text, m2, g2, u2, o2, s2, p2, e2, l2.lineStartIndex, l2.lineLength, f2, d2);
            for (var x2 = 0, b2 = c2; x2 < b2.length; x2 += 1)
              h2[b2[x2]] = t2.text.placedSymbolArray.length - 1;
            return 4 * m2.length;
          }
          function ul(t2) {
            for (var e2 in t2)
              return t2[e2];
            return null;
          }
          function ll(t2, e2, r2, n2) {
            var i2 = t2.compareText;
            if (e2 in i2) {
              for (var a2 = i2[e2], o2 = a2.length - 1; o2 >= 0; o2--)
                if (n2.dist(a2[o2]) < r2)
                  return true;
            } else
              i2[e2] = [];
            return i2[e2].push(n2), false;
          }
          var pl = bs.VectorTileFeature.types, cl = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
          function hl(t2, e2, r2, n2, i2, a2, o2, s2, u2, l2, p2, c2, h2) {
            var f2 = s2 ? Math.min(32640, Math.round(s2[0])) : 0, y2 = s2 ? Math.min(32640, Math.round(s2[1])) : 0;
            t2.emplaceBack(e2, r2, Math.round(32 * n2), Math.round(32 * i2), a2, o2, (f2 << 1) + (u2 ? 1 : 0), y2, 16 * l2, 16 * p2, 256 * c2, 256 * h2);
          }
          function fl(t2, e2, r2) {
            t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2), t2.emplaceBack(e2.x, e2.y, r2);
          }
          function yl(t2) {
            for (var e2 = 0, r2 = t2.sections; e2 < r2.length; e2 += 1)
              if ($n(r2[e2].text))
                return true;
            return false;
          }
          var dl = function(t2) {
            this.layoutVertexArray = new Vi(), this.indexArray = new ji(), this.programConfigurations = t2, this.segments = new sa(), this.dynamicLayoutVertexArray = new Fi(), this.opacityVertexArray = new Di(), this.placedSymbolArray = new Qi();
          };
          dl.prototype.isEmpty = function() {
            return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
          }, dl.prototype.upload = function(t2, e2, r2, n2) {
            this.isEmpty() || (r2 && (this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, js.members), this.indexBuffer = t2.createIndexBuffer(this.indexArray, e2), this.dynamicLayoutVertexBuffer = t2.createVertexBuffer(this.dynamicLayoutVertexArray, qs.members, true), this.opacityVertexBuffer = t2.createVertexBuffer(this.opacityVertexArray, cl, true), this.opacityVertexBuffer.itemSize = 1), (r2 || n2) && this.programConfigurations.upload(t2));
          }, dl.prototype.destroy = function() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
          }, On("SymbolBuffers", dl);
          var ml = function(t2, e2, r2) {
            this.layoutVertexArray = new t2(), this.layoutAttributes = e2, this.indexArray = new r2(), this.segments = new sa(), this.collisionVertexArray = new Ui();
          };
          ml.prototype.upload = function(t2) {
            this.layoutVertexBuffer = t2.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t2.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t2.createVertexBuffer(this.collisionVertexArray, Ns.members, true);
          }, ml.prototype.destroy = function() {
            this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
          }, On("CollisionBuffers", ml);
          var vl = function(t2) {
            this.collisionBoxArray = t2.collisionBoxArray, this.zoom = t2.zoom, this.overscaling = t2.overscaling, this.layers = t2.layers, this.layerIds = this.layers.map(function(t3) {
              return t3.id;
            }), this.index = t2.index, this.pixelRatio = t2.pixelRatio, this.sourceLayerIndex = t2.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = oo([]), this.placementViewportMatrix = oo([]);
            var e2 = this.layers[0]._unevaluatedLayout._values;
            this.textSizeData = Du(this.zoom, e2["text-size"]), this.iconSizeData = Du(this.zoom, e2["icon-size"]);
            var r2 = this.layers[0].layout, n2 = r2.get("symbol-sort-key"), i2 = r2.get("symbol-z-order");
            this.canOverlap = r2.get("text-allow-overlap") || r2.get("icon-allow-overlap") || r2.get("text-ignore-placement") || r2.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== i2 && void 0 !== n2.constantOr(1), this.sortFeaturesByY = ("viewport-y" === i2 || "auto" === i2 && !this.sortFeaturesByKey) && this.canOverlap, "point" === r2.get("symbol-placement") && (this.writingModes = r2.get("text-writing-mode").map(function(t3) {
              return wu[t3];
            })), this.stateDependentLayerIds = this.layers.filter(function(t3) {
              return t3.isStateDependent();
            }).map(function(t3) {
              return t3.id;
            }), this.sourceID = t2.sourceID;
          };
          vl.prototype.createArrays = function() {
            this.text = new dl(new Va(this.layers, this.zoom, function(t2) {
              return /^text/.test(t2);
            })), this.icon = new dl(new Va(this.layers, this.zoom, function(t2) {
              return /^icon/.test(t2);
            })), this.glyphOffsetArray = new ra(), this.lineVertexArray = new na(), this.symbolInstances = new ea();
          }, vl.prototype.calculateGlyphDependencies = function(t2, e2, r2, n2, i2) {
            for (var a2 = 0; a2 < t2.length; a2++)
              if (e2[t2.charCodeAt(a2)] = true, (r2 || n2) && i2) {
                var o2 = Xs[t2.charAt(a2)];
                o2 && (e2[o2.charCodeAt(0)] = true);
              }
          }, vl.prototype.populate = function(t2, e2, r2) {
            var n2 = this.layers[0], i2 = n2.layout, a2 = i2.get("text-font"), o2 = i2.get("text-field"), s2 = i2.get("icon-image"), u2 = ("constant" !== o2.value.kind || o2.value.value instanceof ne && !o2.value.value.isEmpty() || o2.value.value.toString().length > 0) && ("constant" !== a2.value.kind || a2.value.value.length > 0), l2 = "constant" !== s2.value.kind || !!s2.value.value || Object.keys(s2.parameters).length > 0, p2 = i2.get("symbol-sort-key");
            if (this.features = [], u2 || l2) {
              for (var c2 = e2.iconDependencies, h2 = e2.glyphDependencies, f2 = e2.availableImages, y2 = new si(this.zoom), d2 = 0, m2 = t2; d2 < m2.length; d2 += 1) {
                var v2 = m2[d2], g2 = v2.feature, x2 = v2.id, b2 = v2.index, w2 = v2.sourceLayerIndex, _2 = n2._featureFilter.needGeometry, A2 = Ua(g2, _2);
                if (n2._featureFilter.filter(y2, A2, r2)) {
                  _2 || (A2.geometry = Ra(g2));
                  var S2 = void 0;
                  if (u2) {
                    var k2 = n2.getValueAndResolveTokens("text-field", A2, r2, f2), I2 = ne.factory(k2);
                    yl(I2) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === ii() || this.hasRTLText && oi.isParsed()) && (S2 = Zs(I2, n2, A2));
                  }
                  var z2 = void 0;
                  if (l2) {
                    var C2 = n2.getValueAndResolveTokens("icon-image", A2, r2, f2);
                    z2 = C2 instanceof ie ? C2 : ie.fromString(C2);
                  }
                  if (S2 || z2) {
                    var E2 = this.sortFeaturesByKey ? p2.evaluate(A2, {}, r2) : void 0;
                    if (this.features.push({ id: x2, text: S2, icon: z2, index: b2, sourceLayerIndex: w2, geometry: A2.geometry, properties: g2.properties, type: pl[g2.type], sortKey: E2 }), z2 && (c2[z2.name] = true), S2) {
                      var P2 = a2.evaluate(A2, {}, r2).join(","), M2 = "map" === i2.get("text-rotation-alignment") && "point" !== i2.get("symbol-placement");
                      this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(wu.vertical) >= 0;
                      for (var B2 = 0, T2 = S2.sections; B2 < T2.length; B2 += 1) {
                        var V2 = T2[B2];
                        if (V2.image)
                          c2[V2.image.name] = true;
                        else {
                          var F2 = Zn(S2.toString()), D2 = V2.fontStack || P2, L2 = h2[D2] = h2[D2] || {};
                          this.calculateGlyphDependencies(V2.text, L2, M2, this.allowVerticalPlacement, F2);
                        }
                      }
                    }
                  }
                }
              }
              "line" === i2.get("symbol-placement") && (this.features = function(t3) {
                var e3 = {}, r3 = {}, n3 = [], i3 = 0;
                function a3(e4) {
                  n3.push(t3[e4]), i3++;
                }
                function o3(t4, e4, i4) {
                  var a4 = r3[t4];
                  return delete r3[t4], r3[e4] = a4, n3[a4].geometry[0].pop(), n3[a4].geometry[0] = n3[a4].geometry[0].concat(i4[0]), a4;
                }
                function s3(t4, r4, i4) {
                  var a4 = e3[r4];
                  return delete e3[r4], e3[t4] = a4, n3[a4].geometry[0].shift(), n3[a4].geometry[0] = i4[0].concat(n3[a4].geometry[0]), a4;
                }
                function u3(t4, e4, r4) {
                  var n4 = r4 ? e4[0][e4[0].length - 1] : e4[0][0];
                  return t4 + ":" + n4.x + ":" + n4.y;
                }
                for (var l3 = 0; l3 < t3.length; l3++) {
                  var p3 = t3[l3], c3 = p3.geometry, h3 = p3.text ? p3.text.toString() : null;
                  if (h3) {
                    var f3 = u3(h3, c3), y3 = u3(h3, c3, true);
                    if (f3 in r3 && y3 in e3 && r3[f3] !== e3[y3]) {
                      var d3 = s3(f3, y3, c3), m3 = o3(f3, y3, n3[d3].geometry);
                      delete e3[f3], delete r3[y3], r3[u3(h3, n3[m3].geometry, true)] = m3, n3[d3].geometry = null;
                    } else
                      f3 in r3 ? o3(f3, y3, c3) : y3 in e3 ? s3(f3, y3, c3) : (a3(l3), e3[f3] = i3 - 1, r3[y3] = i3 - 1);
                  } else
                    a3(l3);
                }
                return n3.filter(function(t4) {
                  return t4.geometry;
                });
              }(this.features)), this.sortFeaturesByKey && this.features.sort(function(t3, e3) {
                return t3.sortKey - e3.sortKey;
              });
            }
          }, vl.prototype.update = function(t2, e2, r2) {
            this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2), this.icon.programConfigurations.updatePaintArrays(t2, e2, this.layers, r2));
          }, vl.prototype.isEmpty = function() {
            return 0 === this.symbolInstances.length && !this.hasRTLText;
          }, vl.prototype.uploadPending = function() {
            return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
          }, vl.prototype.upload = function(t2) {
            !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t2), this.iconCollisionBox.upload(t2)), this.text.upload(t2, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t2, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
          }, vl.prototype.destroyDebugData = function() {
            this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
          }, vl.prototype.destroy = function() {
            this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
          }, vl.prototype.addToLineVertexArray = function(t2, e2) {
            var r2 = this.lineVertexArray.length;
            if (void 0 !== t2.segment) {
              for (var n2 = t2.dist(e2[t2.segment + 1]), i2 = t2.dist(e2[t2.segment]), a2 = {}, o2 = t2.segment + 1; o2 < e2.length; o2++)
                a2[o2] = { x: e2[o2].x, y: e2[o2].y, tileUnitDistanceFromAnchor: n2 }, o2 < e2.length - 1 && (n2 += e2[o2 + 1].dist(e2[o2]));
              for (var s2 = t2.segment || 0; s2 >= 0; s2--)
                a2[s2] = { x: e2[s2].x, y: e2[s2].y, tileUnitDistanceFromAnchor: i2 }, s2 > 0 && (i2 += e2[s2 - 1].dist(e2[s2]));
              for (var u2 = 0; u2 < e2.length; u2++) {
                var l2 = a2[u2];
                this.lineVertexArray.emplaceBack(l2.x, l2.y, l2.tileUnitDistanceFromAnchor);
              }
            }
            return { lineStartIndex: r2, lineLength: this.lineVertexArray.length - r2 };
          }, vl.prototype.addSymbols = function(t2, e2, r2, n2, i2, a2, o2, s2, u2, l2, p2, c2) {
            for (var h2 = t2.indexArray, f2 = t2.layoutVertexArray, y2 = t2.segments.prepareSegment(4 * e2.length, f2, h2, this.canOverlap ? a2.sortKey : void 0), d2 = this.glyphOffsetArray.length, m2 = y2.vertexLength, v2 = this.allowVerticalPlacement && o2 === wu.vertical ? Math.PI / 2 : 0, g2 = a2.text && a2.text.sections, x2 = 0; x2 < e2.length; x2++) {
              var b2 = e2[x2], w2 = b2.tl, _2 = b2.tr, A2 = b2.bl, S2 = b2.br, k2 = b2.tex, I2 = b2.pixelOffsetTL, z2 = b2.pixelOffsetBR, C2 = b2.minFontScaleX, E2 = b2.minFontScaleY, P2 = b2.glyphOffset, M2 = b2.isSDF, B2 = b2.sectionIndex, T2 = y2.vertexLength, V2 = P2[1];
              hl(f2, s2.x, s2.y, w2.x, V2 + w2.y, k2.x, k2.y, r2, M2, I2.x, I2.y, C2, E2), hl(f2, s2.x, s2.y, _2.x, V2 + _2.y, k2.x + k2.w, k2.y, r2, M2, z2.x, I2.y, C2, E2), hl(f2, s2.x, s2.y, A2.x, V2 + A2.y, k2.x, k2.y + k2.h, r2, M2, I2.x, z2.y, C2, E2), hl(f2, s2.x, s2.y, S2.x, V2 + S2.y, k2.x + k2.w, k2.y + k2.h, r2, M2, z2.x, z2.y, C2, E2), fl(t2.dynamicLayoutVertexArray, s2, v2), h2.emplaceBack(T2, T2 + 1, T2 + 2), h2.emplaceBack(T2 + 1, T2 + 2, T2 + 3), y2.vertexLength += 4, y2.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(P2[0]), x2 !== e2.length - 1 && B2 === e2[x2 + 1].sectionIndex || t2.programConfigurations.populatePaintArrays(f2.length, a2, a2.index, {}, c2, g2 && g2[B2]);
            }
            t2.placedSymbolArray.emplaceBack(s2.x, s2.y, d2, this.glyphOffsetArray.length - d2, m2, u2, l2, s2.segment, r2 ? r2[0] : 0, r2 ? r2[1] : 0, n2[0], n2[1], o2, 0, false, 0, p2);
          }, vl.prototype._addCollisionDebugVertex = function(t2, e2, r2, n2, i2, a2) {
            return e2.emplaceBack(0, 0), t2.emplaceBack(r2.x, r2.y, n2, i2, Math.round(a2.x), Math.round(a2.y));
          }, vl.prototype.addCollisionDebugVertices = function(t2, e2, r2, n2, a2, o2, s2) {
            var u2 = a2.segments.prepareSegment(4, a2.layoutVertexArray, a2.indexArray), l2 = u2.vertexLength, p2 = a2.layoutVertexArray, c2 = a2.collisionVertexArray, h2 = s2.anchorX, f2 = s2.anchorY;
            this._addCollisionDebugVertex(p2, c2, o2, h2, f2, new i(t2, e2)), this._addCollisionDebugVertex(p2, c2, o2, h2, f2, new i(r2, e2)), this._addCollisionDebugVertex(p2, c2, o2, h2, f2, new i(r2, n2)), this._addCollisionDebugVertex(p2, c2, o2, h2, f2, new i(t2, n2)), u2.vertexLength += 4;
            var y2 = a2.indexArray;
            y2.emplaceBack(l2, l2 + 1), y2.emplaceBack(l2 + 1, l2 + 2), y2.emplaceBack(l2 + 2, l2 + 3), y2.emplaceBack(l2 + 3, l2), u2.primitiveLength += 4;
          }, vl.prototype.addDebugCollisionBoxes = function(t2, e2, r2, n2) {
            for (var i2 = t2; i2 < e2; i2++) {
              var a2 = this.collisionBoxArray.get(i2);
              this.addCollisionDebugVertices(a2.x1, a2.y1, a2.x2, a2.y2, n2 ? this.textCollisionBox : this.iconCollisionBox, a2.anchorPoint, r2);
            }
          }, vl.prototype.generateCollisionDebugBuffers = function() {
            this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new ml(Oi, Ks.members, Xi), this.iconCollisionBox = new ml(Oi, Ks.members, Xi);
            for (var t2 = 0; t2 < this.symbolInstances.length; t2++) {
              var e2 = this.symbolInstances.get(t2);
              this.addDebugCollisionBoxes(e2.textBoxStartIndex, e2.textBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.verticalTextBoxStartIndex, e2.verticalTextBoxEndIndex, e2, true), this.addDebugCollisionBoxes(e2.iconBoxStartIndex, e2.iconBoxEndIndex, e2, false), this.addDebugCollisionBoxes(e2.verticalIconBoxStartIndex, e2.verticalIconBoxEndIndex, e2, false);
            }
          }, vl.prototype._deserializeCollisionBoxesForSymbol = function(t2, e2, r2, n2, i2, a2, o2, s2, u2) {
            for (var l2 = {}, p2 = e2; p2 < r2; p2++) {
              var c2 = t2.get(p2);
              l2.textBox = { x1: c2.x1, y1: c2.y1, x2: c2.x2, y2: c2.y2, anchorPointX: c2.anchorPointX, anchorPointY: c2.anchorPointY }, l2.textFeatureIndex = c2.featureIndex;
              break;
            }
            for (var h2 = n2; h2 < i2; h2++) {
              var f2 = t2.get(h2);
              l2.verticalTextBox = { x1: f2.x1, y1: f2.y1, x2: f2.x2, y2: f2.y2, anchorPointX: f2.anchorPointX, anchorPointY: f2.anchorPointY }, l2.verticalTextFeatureIndex = f2.featureIndex;
              break;
            }
            for (var y2 = a2; y2 < o2; y2++) {
              var d2 = t2.get(y2);
              l2.iconBox = { x1: d2.x1, y1: d2.y1, x2: d2.x2, y2: d2.y2, anchorPointX: d2.anchorPointX, anchorPointY: d2.anchorPointY }, l2.iconFeatureIndex = d2.featureIndex;
              break;
            }
            for (var m2 = s2; m2 < u2; m2++) {
              var v2 = t2.get(m2);
              l2.verticalIconBox = { x1: v2.x1, y1: v2.y1, x2: v2.x2, y2: v2.y2, anchorPointX: v2.anchorPointX, anchorPointY: v2.anchorPointY }, l2.verticalIconFeatureIndex = v2.featureIndex;
              break;
            }
            return l2;
          }, vl.prototype.deserializeCollisionBoxes = function(t2) {
            this.collisionArrays = [];
            for (var e2 = 0; e2 < this.symbolInstances.length; e2++) {
              var r2 = this.symbolInstances.get(e2);
              this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t2, r2.textBoxStartIndex, r2.textBoxEndIndex, r2.verticalTextBoxStartIndex, r2.verticalTextBoxEndIndex, r2.iconBoxStartIndex, r2.iconBoxEndIndex, r2.verticalIconBoxStartIndex, r2.verticalIconBoxEndIndex));
            }
          }, vl.prototype.hasTextData = function() {
            return this.text.segments.get().length > 0;
          }, vl.prototype.hasIconData = function() {
            return this.icon.segments.get().length > 0;
          }, vl.prototype.hasDebugData = function() {
            return this.textCollisionBox && this.iconCollisionBox;
          }, vl.prototype.hasTextCollisionBoxData = function() {
            return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
          }, vl.prototype.hasIconCollisionBoxData = function() {
            return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
          }, vl.prototype.addIndicesForPlacedSymbol = function(t2, e2) {
            for (var r2 = t2.placedSymbolArray.get(e2), n2 = r2.vertexStartIndex + 4 * r2.numGlyphs, i2 = r2.vertexStartIndex; i2 < n2; i2 += 4)
              t2.indexArray.emplaceBack(i2, i2 + 1, i2 + 2), t2.indexArray.emplaceBack(i2 + 1, i2 + 2, i2 + 3);
          }, vl.prototype.getSortedSymbolIndexes = function(t2) {
            if (this.sortedAngle === t2 && void 0 !== this.symbolInstanceIndexes)
              return this.symbolInstanceIndexes;
            for (var e2 = Math.sin(t2), r2 = Math.cos(t2), n2 = [], i2 = [], a2 = [], o2 = 0; o2 < this.symbolInstances.length; ++o2) {
              a2.push(o2);
              var s2 = this.symbolInstances.get(o2);
              n2.push(0 | Math.round(e2 * s2.anchorX + r2 * s2.anchorY)), i2.push(s2.featureIndex);
            }
            return a2.sort(function(t3, e3) {
              return n2[t3] - n2[e3] || i2[e3] - i2[t3];
            }), a2;
          }, vl.prototype.addToSortKeyRanges = function(t2, e2) {
            var r2 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
            r2 && r2.sortKey === e2 ? r2.symbolInstanceEnd = t2 + 1 : this.sortKeyRanges.push({ sortKey: e2, symbolInstanceStart: t2, symbolInstanceEnd: t2 + 1 });
          }, vl.prototype.sortFeatures = function(t2) {
            var e2 = this;
            if (this.sortFeaturesByY && this.sortedAngle !== t2 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
              this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t2), this.sortedAngle = t2, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
              for (var r2 = 0, n2 = this.symbolInstanceIndexes; r2 < n2.length; r2 += 1) {
                var i2 = this.symbolInstances.get(n2[r2]);
                this.featureSortOrder.push(i2.featureIndex), [i2.rightJustifiedTextSymbolIndex, i2.centerJustifiedTextSymbolIndex, i2.leftJustifiedTextSymbolIndex].forEach(function(t3, r3, n3) {
                  t3 >= 0 && n3.indexOf(t3) === r3 && e2.addIndicesForPlacedSymbol(e2.text, t3);
                }), i2.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, i2.verticalPlacedTextSymbolIndex), i2.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, i2.placedIconSymbolIndex), i2.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, i2.verticalPlacedIconSymbolIndex);
              }
              this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
            }
          }, On("SymbolBucket", vl, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), vl.MAX_GLYPHS = 65535, vl.addDynamicAttributes = fl;
          var gl = new wi({ "symbol-placement": new mi(Et.layout_symbol["symbol-placement"]), "symbol-spacing": new mi(Et.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new mi(Et.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new vi(Et.layout_symbol["symbol-sort-key"]), "symbol-z-order": new mi(Et.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new mi(Et.layout_symbol["icon-allow-overlap"]), "icon-ignore-placement": new mi(Et.layout_symbol["icon-ignore-placement"]), "icon-optional": new mi(Et.layout_symbol["icon-optional"]), "icon-rotation-alignment": new mi(Et.layout_symbol["icon-rotation-alignment"]), "icon-size": new vi(Et.layout_symbol["icon-size"]), "icon-text-fit": new mi(Et.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new mi(Et.layout_symbol["icon-text-fit-padding"]), "icon-image": new vi(Et.layout_symbol["icon-image"]), "icon-rotate": new vi(Et.layout_symbol["icon-rotate"]), "icon-padding": new mi(Et.layout_symbol["icon-padding"]), "icon-keep-upright": new mi(Et.layout_symbol["icon-keep-upright"]), "icon-offset": new vi(Et.layout_symbol["icon-offset"]), "icon-anchor": new vi(Et.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new mi(Et.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new mi(Et.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new mi(Et.layout_symbol["text-rotation-alignment"]), "text-field": new vi(Et.layout_symbol["text-field"]), "text-font": new vi(Et.layout_symbol["text-font"]), "text-size": new vi(Et.layout_symbol["text-size"]), "text-max-width": new vi(Et.layout_symbol["text-max-width"]), "text-line-height": new mi(Et.layout_symbol["text-line-height"]), "text-letter-spacing": new vi(Et.layout_symbol["text-letter-spacing"]), "text-justify": new vi(Et.layout_symbol["text-justify"]), "text-radial-offset": new vi(Et.layout_symbol["text-radial-offset"]), "text-variable-anchor": new mi(Et.layout_symbol["text-variable-anchor"]), "text-anchor": new vi(Et.layout_symbol["text-anchor"]), "text-max-angle": new mi(Et.layout_symbol["text-max-angle"]), "text-writing-mode": new mi(Et.layout_symbol["text-writing-mode"]), "text-rotate": new vi(Et.layout_symbol["text-rotate"]), "text-padding": new mi(Et.layout_symbol["text-padding"]), "text-keep-upright": new mi(Et.layout_symbol["text-keep-upright"]), "text-transform": new vi(Et.layout_symbol["text-transform"]), "text-offset": new vi(Et.layout_symbol["text-offset"]), "text-allow-overlap": new mi(Et.layout_symbol["text-allow-overlap"]), "text-ignore-placement": new mi(Et.layout_symbol["text-ignore-placement"]), "text-optional": new mi(Et.layout_symbol["text-optional"]) }), xl = { paint: new wi({ "icon-opacity": new vi(Et.paint_symbol["icon-opacity"]), "icon-color": new vi(Et.paint_symbol["icon-color"]), "icon-halo-color": new vi(Et.paint_symbol["icon-halo-color"]), "icon-halo-width": new vi(Et.paint_symbol["icon-halo-width"]), "icon-halo-blur": new vi(Et.paint_symbol["icon-halo-blur"]), "icon-translate": new mi(Et.paint_symbol["icon-translate"]), "icon-translate-anchor": new mi(Et.paint_symbol["icon-translate-anchor"]), "text-opacity": new vi(Et.paint_symbol["text-opacity"]), "text-color": new vi(Et.paint_symbol["text-color"], { runtimeType: jt, getOverride: function(t2) {
            return t2.textColor;
          }, hasOverride: function(t2) {
            return !!t2.textColor;
          } }), "text-halo-color": new vi(Et.paint_symbol["text-halo-color"]), "text-halo-width": new vi(Et.paint_symbol["text-halo-width"]), "text-halo-blur": new vi(Et.paint_symbol["text-halo-blur"]), "text-translate": new mi(Et.paint_symbol["text-translate"]), "text-translate-anchor": new mi(Et.paint_symbol["text-translate-anchor"]) }), layout: gl }, bl = function(t2) {
            this.type = t2.property.overrides ? t2.property.overrides.runtimeType : Lt, this.defaultValue = t2;
          };
          bl.prototype.evaluate = function(t2) {
            if (t2.formattedSection) {
              var e2 = this.defaultValue.property.overrides;
              if (e2 && e2.hasOverride(t2.formattedSection))
                return e2.getOverride(t2.formattedSection);
            }
            return t2.feature && t2.featureState ? this.defaultValue.evaluate(t2.feature, t2.featureState) : this.defaultValue.property.specification.default;
          }, bl.prototype.eachChild = function(t2) {
            this.defaultValue.isConstant() || t2(this.defaultValue.value._styleExpression.expression);
          }, bl.prototype.outputDefined = function() {
            return false;
          }, bl.prototype.serialize = function() {
            return null;
          }, On("FormatSectionOverride", bl, { omit: ["defaultValue"] });
          var wl = function(t2) {
            function e2(e3) {
              t2.call(this, e3, xl);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.recalculate = function(e3, r2) {
              if (t2.prototype.recalculate.call(this, e3, r2), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment")), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
                var n2 = this.layout.get("text-writing-mode");
                if (n2) {
                  for (var i2 = [], a2 = 0, o2 = n2; a2 < o2.length; a2 += 1) {
                    var s2 = o2[a2];
                    i2.indexOf(s2) < 0 && i2.push(s2);
                  }
                  this.layout._values["text-writing-mode"] = i2;
                } else
                  this.layout._values["text-writing-mode"] = ["horizontal"];
              }
              this._setPaintOverrides();
            }, e2.prototype.getValueAndResolveTokens = function(t3, e3, r2, n2) {
              var i2 = this.layout.get(t3).evaluate(e3, {}, r2, n2), a2 = this._unevaluatedLayout._values[t3];
              return a2.isDataDriven() || Gr(a2.value) || !i2 ? i2 : function(t4, e4) {
                return e4.replace(/{([^{}]+)}/g, function(e5, r3) {
                  return r3 in t4 ? String(t4[r3]) : "";
                });
              }(e3.properties, i2);
            }, e2.prototype.createBucket = function(t3) {
              return new vl(t3);
            }, e2.prototype.queryRadius = function() {
              return 0;
            }, e2.prototype.queryIntersectsFeature = function() {
              return false;
            }, e2.prototype._setPaintOverrides = function() {
              for (var t3 = 0, r2 = xl.paint.overridableProperties; t3 < r2.length; t3 += 1) {
                var n2 = r2[t3];
                if (e2.hasPaintOverride(this.layout, n2)) {
                  var i2, a2 = this.paint.get(n2), o2 = new bl(a2), s2 = new Kr(o2, a2.property.specification);
                  i2 = "constant" === a2.value.kind || "source" === a2.value.kind ? new Xr("source", s2) : new Jr("composite", s2, a2.value.zoomStops, a2.value._interpolationType), this.paint._values[n2] = new yi(a2.property, i2, a2.parameters);
                }
              }
            }, e2.prototype._handleOverridablePaintPropertyUpdate = function(t3, r2, n2) {
              return !(!this.layout || r2.isDataDriven() || n2.isDataDriven()) && e2.hasPaintOverride(this.layout, t3);
            }, e2.hasPaintOverride = function(t3, e3) {
              var r2 = t3.get("text-field"), n2 = xl.paint.properties[e3], i2 = false, a2 = function(t4) {
                for (var e4 = 0, r3 = t4; e4 < r3.length; e4 += 1)
                  if (n2.overrides && n2.overrides.hasOverride(r3[e4]))
                    return void (i2 = true);
              };
              if ("constant" === r2.value.kind && r2.value.value instanceof ne)
                a2(r2.value.value.sections);
              else if ("source" === r2.value.kind) {
                var o2 = function(t4) {
                  i2 || (t4 instanceof le && se(t4.value) === Gt ? a2(t4.value.sections) : t4 instanceof fe ? a2(t4.sections) : t4.eachChild(o2));
                }, s2 = r2.value;
                s2._styleExpression && o2(s2._styleExpression.expression);
              }
              return i2;
            }, e2;
          }(_i), _l = { paint: new wi({ "background-color": new mi(Et.paint_background["background-color"]), "background-pattern": new xi(Et.paint_background["background-pattern"]), "background-opacity": new mi(Et.paint_background["background-opacity"]) }) }, Al = function(t2) {
            function e2(e3) {
              t2.call(this, e3, _l);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2;
          }(_i), Sl = { paint: new wi({ "raster-opacity": new mi(Et.paint_raster["raster-opacity"]), "raster-hue-rotate": new mi(Et.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new mi(Et.paint_raster["raster-brightness-min"]), "raster-brightness-max": new mi(Et.paint_raster["raster-brightness-max"]), "raster-saturation": new mi(Et.paint_raster["raster-saturation"]), "raster-contrast": new mi(Et.paint_raster["raster-contrast"]), "raster-resampling": new mi(Et.paint_raster["raster-resampling"]), "raster-fade-duration": new mi(Et.paint_raster["raster-fade-duration"]) }) }, kl = function(t2) {
            function e2(e3) {
              t2.call(this, e3, Sl);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2;
          }(_i), Il = function(t2) {
            function e2(e3) {
              t2.call(this, e3, {}), this.implementation = e3;
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.is3D = function() {
              return "3d" === this.implementation.renderingMode;
            }, e2.prototype.hasOffscreenPass = function() {
              return void 0 !== this.implementation.prerender;
            }, e2.prototype.recalculate = function() {
            }, e2.prototype.updateTransitions = function() {
            }, e2.prototype.hasTransition = function() {
            }, e2.prototype.serialize = function() {
            }, e2.prototype.onAdd = function(t3) {
              this.implementation.onAdd && this.implementation.onAdd(t3, t3.painter.context.gl);
            }, e2.prototype.onRemove = function(t3) {
              this.implementation.onRemove && this.implementation.onRemove(t3, t3.painter.context.gl);
            }, e2;
          }(_i), zl = { circle: co, heatmap: _o, hillshade: So, fill: ps, "fill-extrusion": zs, line: Rs, symbol: wl, background: Al, raster: kl }, Cl = o.HTMLImageElement, El = o.HTMLCanvasElement, Pl = o.HTMLVideoElement, Ml = o.ImageData, Bl = o.ImageBitmap, Tl = function(t2, e2, r2, n2) {
            this.context = t2, this.format = r2, this.texture = t2.gl.createTexture(), this.update(e2, n2);
          };
          Tl.prototype.update = function(t2, e2, r2) {
            var n2 = t2.width, i2 = t2.height, a2 = !(this.size && this.size[0] === n2 && this.size[1] === i2 || r2), o2 = this.context, s2 = o2.gl;
            if (this.useMipmap = Boolean(e2 && e2.useMipmap), s2.bindTexture(s2.TEXTURE_2D, this.texture), o2.pixelStoreUnpackFlipY.set(false), o2.pixelStoreUnpack.set(1), o2.pixelStoreUnpackPremultiplyAlpha.set(this.format === s2.RGBA && (!e2 || false !== e2.premultiply)), a2)
              this.size = [n2, i2], t2 instanceof Cl || t2 instanceof El || t2 instanceof Pl || t2 instanceof Ml || Bl && t2 instanceof Bl ? s2.texImage2D(s2.TEXTURE_2D, 0, this.format, this.format, s2.UNSIGNED_BYTE, t2) : s2.texImage2D(s2.TEXTURE_2D, 0, this.format, n2, i2, 0, this.format, s2.UNSIGNED_BYTE, t2.data);
            else {
              var u2 = r2 || { x: 0, y: 0 }, l2 = u2.x, p2 = u2.y;
              t2 instanceof Cl || t2 instanceof El || t2 instanceof Pl || t2 instanceof Ml || Bl && t2 instanceof Bl ? s2.texSubImage2D(s2.TEXTURE_2D, 0, l2, p2, s2.RGBA, s2.UNSIGNED_BYTE, t2) : s2.texSubImage2D(s2.TEXTURE_2D, 0, l2, p2, n2, i2, s2.RGBA, s2.UNSIGNED_BYTE, t2.data);
            }
            this.useMipmap && this.isSizePowerOfTwo() && s2.generateMipmap(s2.TEXTURE_2D);
          }, Tl.prototype.bind = function(t2, e2, r2) {
            var n2 = this.context.gl;
            n2.bindTexture(n2.TEXTURE_2D, this.texture), r2 !== n2.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (r2 = n2.LINEAR), t2 !== this.filter && (n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MAG_FILTER, t2), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_MIN_FILTER, r2 || t2), this.filter = t2), e2 !== this.wrap && (n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_S, e2), n2.texParameteri(n2.TEXTURE_2D, n2.TEXTURE_WRAP_T, e2), this.wrap = e2);
          }, Tl.prototype.isSizePowerOfTwo = function() {
            return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
          }, Tl.prototype.destroy = function() {
            this.context.gl.deleteTexture(this.texture), this.texture = null;
          };
          var Vl = function(t2) {
            var e2 = this;
            this._callback = t2, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = function() {
              e2._triggered = false, e2._callback();
            });
          };
          Vl.prototype.trigger = function() {
            var t2 = this;
            this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(function() {
              t2._triggered = false, t2._callback();
            }, 0));
          }, Vl.prototype.remove = function() {
            delete this._channel, this._callback = function() {
            };
          };
          var Fl = function(t2, e2, r2) {
            this.target = t2, this.parent = e2, this.mapId = r2, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, v(["receive", "process"], this), this.invoker = new Vl(this.process), this.target.addEventListener("message", this.receive, false), this.globalScope = I() ? t2 : o;
          };
          function Dl(t2, e2, r2) {
            var n2 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r2);
            return [t2 * n2 - 2 * Math.PI * 6378137 / 2, e2 * n2 - 2 * Math.PI * 6378137 / 2];
          }
          Fl.prototype.send = function(t2, e2, r2, n2, i2) {
            var a2 = this;
            void 0 === i2 && (i2 = false);
            var o2 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
            r2 && (this.callbacks[o2] = r2);
            var s2 = E(this.globalScope) ? void 0 : [];
            return this.target.postMessage({ id: o2, type: t2, hasCallback: !!r2, targetMapId: n2, mustQueue: i2, sourceMapId: this.mapId, data: qn(e2, s2) }, s2), { cancel: function() {
              r2 && delete a2.callbacks[o2], a2.target.postMessage({ id: o2, type: "<cancel>", targetMapId: n2, sourceMapId: a2.mapId });
            } };
          }, Fl.prototype.receive = function(t2) {
            var e2 = t2.data, r2 = e2.id;
            if (r2 && (!e2.targetMapId || this.mapId === e2.targetMapId))
              if ("<cancel>" === e2.type) {
                delete this.tasks[r2];
                var n2 = this.cancelCallbacks[r2];
                delete this.cancelCallbacks[r2], n2 && n2();
              } else
                I() || e2.mustQueue ? (this.tasks[r2] = e2, this.taskQueue.push(r2), this.invoker.trigger()) : this.processTask(r2, e2);
          }, Fl.prototype.process = function() {
            if (this.taskQueue.length) {
              var t2 = this.taskQueue.shift(), e2 = this.tasks[t2];
              delete this.tasks[t2], this.taskQueue.length && this.invoker.trigger(), e2 && this.processTask(t2, e2);
            }
          }, Fl.prototype.processTask = function(t2, e2) {
            var r2 = this;
            if ("<response>" === e2.type) {
              var n2 = this.callbacks[t2];
              delete this.callbacks[t2], n2 && (e2.error ? n2(Nn(e2.error)) : n2(null, Nn(e2.data)));
            } else {
              var i2 = false, a2 = E(this.globalScope) ? void 0 : [], o2 = e2.hasCallback ? function(e3, n3) {
                i2 = true, delete r2.cancelCallbacks[t2], r2.target.postMessage({ id: t2, type: "<response>", sourceMapId: r2.mapId, error: e3 ? qn(e3) : null, data: qn(n3, a2) }, a2);
              } : function(t3) {
                i2 = true;
              }, s2 = null, u2 = Nn(e2.data);
              if (this.parent[e2.type])
                s2 = this.parent[e2.type](e2.sourceMapId, u2, o2);
              else if (this.parent.getWorkerSource) {
                var l2 = e2.type.split(".");
                s2 = this.parent.getWorkerSource(e2.sourceMapId, l2[0], u2.source)[l2[1]](u2, o2);
              } else
                o2(new Error("Could not find function " + e2.type));
              !i2 && s2 && s2.cancel && (this.cancelCallbacks[t2] = s2.cancel);
            }
          }, Fl.prototype.remove = function() {
            this.invoker.remove(), this.target.removeEventListener("message", this.receive, false);
          };
          var Ll = function(t2, e2) {
            t2 && (e2 ? this.setSouthWest(t2).setNorthEast(e2) : 4 === t2.length ? this.setSouthWest([t2[0], t2[1]]).setNorthEast([t2[2], t2[3]]) : this.setSouthWest(t2[0]).setNorthEast(t2[1]));
          };
          Ll.prototype.setNorthEast = function(t2) {
            return this._ne = t2 instanceof Ol ? new Ol(t2.lng, t2.lat) : Ol.convert(t2), this;
          }, Ll.prototype.setSouthWest = function(t2) {
            return this._sw = t2 instanceof Ol ? new Ol(t2.lng, t2.lat) : Ol.convert(t2), this;
          }, Ll.prototype.extend = function(t2) {
            var e2, r2, n2 = this._sw, i2 = this._ne;
            if (t2 instanceof Ol)
              e2 = t2, r2 = t2;
            else {
              if (!(t2 instanceof Ll))
                return Array.isArray(t2) ? 4 === t2.length || t2.every(Array.isArray) ? this.extend(Ll.convert(t2)) : this.extend(Ol.convert(t2)) : this;
              if (r2 = t2._ne, !(e2 = t2._sw) || !r2)
                return this;
            }
            return n2 || i2 ? (n2.lng = Math.min(e2.lng, n2.lng), n2.lat = Math.min(e2.lat, n2.lat), i2.lng = Math.max(r2.lng, i2.lng), i2.lat = Math.max(r2.lat, i2.lat)) : (this._sw = new Ol(e2.lng, e2.lat), this._ne = new Ol(r2.lng, r2.lat)), this;
          }, Ll.prototype.getCenter = function() {
            return new Ol((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
          }, Ll.prototype.getSouthWest = function() {
            return this._sw;
          }, Ll.prototype.getNorthEast = function() {
            return this._ne;
          }, Ll.prototype.getNorthWest = function() {
            return new Ol(this.getWest(), this.getNorth());
          }, Ll.prototype.getSouthEast = function() {
            return new Ol(this.getEast(), this.getSouth());
          }, Ll.prototype.getWest = function() {
            return this._sw.lng;
          }, Ll.prototype.getSouth = function() {
            return this._sw.lat;
          }, Ll.prototype.getEast = function() {
            return this._ne.lng;
          }, Ll.prototype.getNorth = function() {
            return this._ne.lat;
          }, Ll.prototype.toArray = function() {
            return [this._sw.toArray(), this._ne.toArray()];
          }, Ll.prototype.toString = function() {
            return "LngLatBounds(" + this._sw.toString() + ", " + this._ne.toString() + ")";
          }, Ll.prototype.isEmpty = function() {
            return !(this._sw && this._ne);
          }, Ll.prototype.contains = function(t2) {
            var e2 = Ol.convert(t2), r2 = e2.lng, n2 = e2.lat, i2 = this._sw.lng <= r2 && r2 <= this._ne.lng;
            return this._sw.lng > this._ne.lng && (i2 = this._sw.lng >= r2 && r2 >= this._ne.lng), this._sw.lat <= n2 && n2 <= this._ne.lat && i2;
          }, Ll.convert = function(t2) {
            return !t2 || t2 instanceof Ll ? t2 : new Ll(t2);
          };
          var Ol = function(t2, e2) {
            if (isNaN(t2) || isNaN(e2))
              throw new Error("Invalid LngLat object: (" + t2 + ", " + e2 + ")");
            if (this.lng = +t2, this.lat = +e2, this.lat > 90 || this.lat < -90)
              throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
          };
          Ol.prototype.wrap = function() {
            return new Ol(c(this.lng, -180, 180), this.lat);
          }, Ol.prototype.toArray = function() {
            return [this.lng, this.lat];
          }, Ol.prototype.toString = function() {
            return "LngLat(" + this.lng + ", " + this.lat + ")";
          }, Ol.prototype.distanceTo = function(t2) {
            var e2 = Math.PI / 180, r2 = this.lat * e2, n2 = t2.lat * e2, i2 = Math.sin(r2) * Math.sin(n2) + Math.cos(r2) * Math.cos(n2) * Math.cos((t2.lng - this.lng) * e2);
            return 63710088e-1 * Math.acos(Math.min(i2, 1));
          }, Ol.prototype.toBounds = function(t2) {
            void 0 === t2 && (t2 = 0);
            var e2 = 360 * t2 / 40075017, r2 = e2 / Math.cos(Math.PI / 180 * this.lat);
            return new Ll(new Ol(this.lng - r2, this.lat - e2), new Ol(this.lng + r2, this.lat + e2));
          }, Ol.convert = function(t2) {
            if (t2 instanceof Ol)
              return t2;
            if (Array.isArray(t2) && (2 === t2.length || 3 === t2.length))
              return new Ol(Number(t2[0]), Number(t2[1]));
            if (!Array.isArray(t2) && "object" == typeof t2 && null !== t2)
              return new Ol(Number("lng" in t2 ? t2.lng : t2.lon), Number(t2.lat));
            throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
          };
          var Rl = 2 * Math.PI * 63710088e-1;
          function Ul(t2) {
            return Rl * Math.cos(t2 * Math.PI / 180);
          }
          function jl(t2) {
            return (180 + t2) / 360;
          }
          function ql(t2) {
            return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t2 * Math.PI / 360))) / 360;
          }
          function Nl(t2, e2) {
            return t2 / Ul(e2);
          }
          function Kl(t2) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t2) * Math.PI / 180)) - 90;
          }
          var Gl = function(t2, e2, r2) {
            void 0 === r2 && (r2 = 0), this.x = +t2, this.y = +e2, this.z = +r2;
          };
          Gl.fromLngLat = function(t2, e2) {
            void 0 === e2 && (e2 = 0);
            var r2 = Ol.convert(t2);
            return new Gl(jl(r2.lng), ql(r2.lat), Nl(e2, r2.lat));
          }, Gl.prototype.toLngLat = function() {
            return new Ol(360 * this.x - 180, Kl(this.y));
          }, Gl.prototype.toAltitude = function() {
            return this.z * Ul(Kl(this.y));
          }, Gl.prototype.meterInMercatorCoordinateUnits = function() {
            return 1 / Rl * (t2 = Kl(this.y), 1 / Math.cos(t2 * Math.PI / 180));
            var t2;
          };
          var Zl = function(t2, e2, r2) {
            this.z = t2, this.x = e2, this.y = r2, this.key = Hl(0, t2, t2, e2, r2);
          };
          Zl.prototype.equals = function(t2) {
            return this.z === t2.z && this.x === t2.x && this.y === t2.y;
          }, Zl.prototype.url = function(t2, e2) {
            var r2, n2, i2, a2, o2, s2 = (n2 = this.y, i2 = this.z, a2 = Dl(256 * (r2 = this.x), 256 * (n2 = Math.pow(2, i2) - n2 - 1), i2), o2 = Dl(256 * (r2 + 1), 256 * (n2 + 1), i2), a2[0] + "," + a2[1] + "," + o2[0] + "," + o2[1]), u2 = function(t3, e3, r3) {
              for (var n3, i3 = "", a3 = t3; a3 > 0; a3--)
                i3 += (e3 & (n3 = 1 << a3 - 1) ? 1 : 0) + (r3 & n3 ? 2 : 0);
              return i3;
            }(this.z, this.x, this.y);
            return t2[(this.x + this.y) % t2.length].replace("{prefix}", (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace("{z}", String(this.z)).replace("{x}", String(this.x)).replace("{y}", String("tms" === e2 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace("{quadkey}", u2).replace("{bbox-epsg-3857}", s2);
          }, Zl.prototype.getTilePoint = function(t2) {
            var e2 = Math.pow(2, this.z);
            return new i(8192 * (t2.x * e2 - this.x), 8192 * (t2.y * e2 - this.y));
          }, Zl.prototype.toString = function() {
            return this.z + "/" + this.x + "/" + this.y;
          };
          var Xl = function(t2, e2) {
            this.wrap = t2, this.canonical = e2, this.key = Hl(t2, e2.z, e2.z, e2.x, e2.y);
          }, Jl = function(t2, e2, r2, n2, i2) {
            this.overscaledZ = t2, this.wrap = e2, this.canonical = new Zl(r2, +n2, +i2), this.key = Hl(e2, t2, r2, n2, i2);
          };
          function Hl(t2, e2, r2, n2, i2) {
            (t2 *= 2) < 0 && (t2 = -1 * t2 - 1);
            var a2 = 1 << r2;
            return (a2 * a2 * t2 + a2 * i2 + n2).toString(36) + r2.toString(36) + e2.toString(36);
          }
          Jl.prototype.equals = function(t2) {
            return this.overscaledZ === t2.overscaledZ && this.wrap === t2.wrap && this.canonical.equals(t2.canonical);
          }, Jl.prototype.scaledTo = function(t2) {
            var e2 = this.canonical.z - t2;
            return t2 > this.canonical.z ? new Jl(t2, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new Jl(t2, this.wrap, t2, this.canonical.x >> e2, this.canonical.y >> e2);
          }, Jl.prototype.calculateScaledKey = function(t2, e2) {
            var r2 = this.canonical.z - t2;
            return t2 > this.canonical.z ? Hl(this.wrap * +e2, t2, this.canonical.z, this.canonical.x, this.canonical.y) : Hl(this.wrap * +e2, t2, t2, this.canonical.x >> r2, this.canonical.y >> r2);
          }, Jl.prototype.isChildOf = function(t2) {
            if (t2.wrap !== this.wrap)
              return false;
            var e2 = this.canonical.z - t2.canonical.z;
            return 0 === t2.overscaledZ || t2.overscaledZ < this.overscaledZ && t2.canonical.x === this.canonical.x >> e2 && t2.canonical.y === this.canonical.y >> e2;
          }, Jl.prototype.children = function(t2) {
            if (this.overscaledZ >= t2)
              return [new Jl(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
            var e2 = this.canonical.z + 1, r2 = 2 * this.canonical.x, n2 = 2 * this.canonical.y;
            return [new Jl(e2, this.wrap, e2, r2, n2), new Jl(e2, this.wrap, e2, r2 + 1, n2), new Jl(e2, this.wrap, e2, r2, n2 + 1), new Jl(e2, this.wrap, e2, r2 + 1, n2 + 1)];
          }, Jl.prototype.isLessThan = function(t2) {
            return this.wrap < t2.wrap || !(this.wrap > t2.wrap) && (this.overscaledZ < t2.overscaledZ || !(this.overscaledZ > t2.overscaledZ) && (this.canonical.x < t2.canonical.x || !(this.canonical.x > t2.canonical.x) && this.canonical.y < t2.canonical.y));
          }, Jl.prototype.wrapped = function() {
            return new Jl(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
          }, Jl.prototype.unwrapTo = function(t2) {
            return new Jl(this.overscaledZ, t2, this.canonical.z, this.canonical.x, this.canonical.y);
          }, Jl.prototype.overscaleFactor = function() {
            return Math.pow(2, this.overscaledZ - this.canonical.z);
          }, Jl.prototype.toUnwrapped = function() {
            return new Xl(this.wrap, this.canonical);
          }, Jl.prototype.toString = function() {
            return this.overscaledZ + "/" + this.canonical.x + "/" + this.canonical.y;
          }, Jl.prototype.getTilePoint = function(t2) {
            return this.canonical.getTilePoint(new Gl(t2.x - this.wrap, t2.y));
          }, On("CanonicalTileID", Zl), On("OverscaledTileID", Jl, { omit: ["posMatrix"] });
          var Yl = function(t2, e2, r2) {
            if (this.uid = t2, e2.height !== e2.width)
              throw new RangeError("DEM tiles must be square");
            if (r2 && "mapbox" !== r2 && "terrarium" !== r2)
              return A('"' + r2 + '" is not a valid encoding type. Valid types include "mapbox" and "terrarium".');
            this.stride = e2.height;
            var n2 = this.dim = e2.height - 2;
            this.data = new Uint32Array(e2.data.buffer), this.encoding = r2 || "mapbox";
            for (var i2 = 0; i2 < n2; i2++)
              this.data[this._idx(-1, i2)] = this.data[this._idx(0, i2)], this.data[this._idx(n2, i2)] = this.data[this._idx(n2 - 1, i2)], this.data[this._idx(i2, -1)] = this.data[this._idx(i2, 0)], this.data[this._idx(i2, n2)] = this.data[this._idx(i2, n2 - 1)];
            this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(n2, -1)] = this.data[this._idx(n2 - 1, 0)], this.data[this._idx(-1, n2)] = this.data[this._idx(0, n2 - 1)], this.data[this._idx(n2, n2)] = this.data[this._idx(n2 - 1, n2 - 1)];
          };
          Yl.prototype.get = function(t2, e2) {
            var r2 = new Uint8Array(this.data.buffer), n2 = 4 * this._idx(t2, e2);
            return ("terrarium" === this.encoding ? this._unpackTerrarium : this._unpackMapbox)(r2[n2], r2[n2 + 1], r2[n2 + 2]);
          }, Yl.prototype.getUnpackVector = function() {
            return "terrarium" === this.encoding ? [256, 1, 1 / 256, 32768] : [6553.6, 25.6, 0.1, 1e4];
          }, Yl.prototype._idx = function(t2, e2) {
            if (t2 < -1 || t2 >= this.dim + 1 || e2 < -1 || e2 >= this.dim + 1)
              throw new RangeError("out of range source coordinates for DEM data");
            return (e2 + 1) * this.stride + (t2 + 1);
          }, Yl.prototype._unpackMapbox = function(t2, e2, r2) {
            return (256 * t2 * 256 + 256 * e2 + r2) / 10 - 1e4;
          }, Yl.prototype._unpackTerrarium = function(t2, e2, r2) {
            return 256 * t2 + e2 + r2 / 256 - 32768;
          }, Yl.prototype.getPixels = function() {
            return new xo({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
          }, Yl.prototype.backfillBorder = function(t2, e2, r2) {
            if (this.dim !== t2.dim)
              throw new Error("dem dimension mismatch");
            var n2 = e2 * this.dim, i2 = e2 * this.dim + this.dim, a2 = r2 * this.dim, o2 = r2 * this.dim + this.dim;
            switch (e2) {
              case -1:
                n2 = i2 - 1;
                break;
              case 1:
                i2 = n2 + 1;
            }
            switch (r2) {
              case -1:
                a2 = o2 - 1;
                break;
              case 1:
                o2 = a2 + 1;
            }
            for (var s2 = -e2 * this.dim, u2 = -r2 * this.dim, l2 = a2; l2 < o2; l2++)
              for (var p2 = n2; p2 < i2; p2++)
                this.data[this._idx(p2, l2)] = t2.data[this._idx(p2 + s2, l2 + u2)];
          }, On("DEMData", Yl);
          var $l = function(t2) {
            this._stringToNumber = {}, this._numberToString = [];
            for (var e2 = 0; e2 < t2.length; e2++) {
              var r2 = t2[e2];
              this._stringToNumber[r2] = e2, this._numberToString[e2] = r2;
            }
          };
          $l.prototype.encode = function(t2) {
            return this._stringToNumber[t2];
          }, $l.prototype.decode = function(t2) {
            return this._numberToString[t2];
          };
          var Wl = function(t2, e2, r2, n2, i2) {
            this.type = "Feature", this._vectorTileFeature = t2, t2._z = e2, t2._x = r2, t2._y = n2, this.properties = t2.properties, this.id = i2;
          }, Ql = { geometry: { configurable: true } };
          Ql.geometry.get = function() {
            return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
          }, Ql.geometry.set = function(t2) {
            this._geometry = t2;
          }, Wl.prototype.toJSON = function() {
            var t2 = { geometry: this.geometry };
            for (var e2 in this)
              "_geometry" !== e2 && "_vectorTileFeature" !== e2 && (t2[e2] = this[e2]);
            return t2;
          }, Object.defineProperties(Wl.prototype, Ql);
          var tp = function() {
            this.state = {}, this.stateChanges = {}, this.deletedStates = {};
          };
          tp.prototype.updateState = function(t2, e2, r2) {
            var n2 = String(e2);
            if (this.stateChanges[t2] = this.stateChanges[t2] || {}, this.stateChanges[t2][n2] = this.stateChanges[t2][n2] || {}, h(this.stateChanges[t2][n2], r2), null === this.deletedStates[t2])
              for (var i2 in this.deletedStates[t2] = {}, this.state[t2])
                i2 !== n2 && (this.deletedStates[t2][i2] = null);
            else if (this.deletedStates[t2] && null === this.deletedStates[t2][n2])
              for (var a2 in this.deletedStates[t2][n2] = {}, this.state[t2][n2])
                r2[a2] || (this.deletedStates[t2][n2][a2] = null);
            else
              for (var o2 in r2)
                this.deletedStates[t2] && this.deletedStates[t2][n2] && null === this.deletedStates[t2][n2][o2] && delete this.deletedStates[t2][n2][o2];
          }, tp.prototype.removeFeatureState = function(t2, e2, r2) {
            if (null !== this.deletedStates[t2]) {
              var n2 = String(e2);
              if (this.deletedStates[t2] = this.deletedStates[t2] || {}, r2 && void 0 !== e2)
                null !== this.deletedStates[t2][n2] && (this.deletedStates[t2][n2] = this.deletedStates[t2][n2] || {}, this.deletedStates[t2][n2][r2] = null);
              else if (void 0 !== e2)
                if (this.stateChanges[t2] && this.stateChanges[t2][n2])
                  for (r2 in this.deletedStates[t2][n2] = {}, this.stateChanges[t2][n2])
                    this.deletedStates[t2][n2][r2] = null;
                else
                  this.deletedStates[t2][n2] = null;
              else
                this.deletedStates[t2] = null;
            }
          }, tp.prototype.getState = function(t2, e2) {
            var r2 = String(e2), n2 = h({}, (this.state[t2] || {})[r2], (this.stateChanges[t2] || {})[r2]);
            if (null === this.deletedStates[t2])
              return {};
            if (this.deletedStates[t2]) {
              var i2 = this.deletedStates[t2][e2];
              if (null === i2)
                return {};
              for (var a2 in i2)
                delete n2[a2];
            }
            return n2;
          }, tp.prototype.initializeTileState = function(t2, e2) {
            t2.setFeatureState(this.state, e2);
          }, tp.prototype.coalesceChanges = function(t2, e2) {
            var r2 = {};
            for (var n2 in this.stateChanges) {
              this.state[n2] = this.state[n2] || {};
              var i2 = {};
              for (var a2 in this.stateChanges[n2])
                this.state[n2][a2] || (this.state[n2][a2] = {}), h(this.state[n2][a2], this.stateChanges[n2][a2]), i2[a2] = this.state[n2][a2];
              r2[n2] = i2;
            }
            for (var o2 in this.deletedStates) {
              this.state[o2] = this.state[o2] || {};
              var s2 = {};
              if (null === this.deletedStates[o2])
                for (var u2 in this.state[o2])
                  s2[u2] = {}, this.state[o2][u2] = {};
              else
                for (var l2 in this.deletedStates[o2]) {
                  if (null === this.deletedStates[o2][l2])
                    this.state[o2][l2] = {};
                  else
                    for (var p2 = 0, c2 = Object.keys(this.deletedStates[o2][l2]); p2 < c2.length; p2 += 1)
                      delete this.state[o2][l2][c2[p2]];
                  s2[l2] = this.state[o2][l2];
                }
              r2[o2] = r2[o2] || {}, h(r2[o2], s2);
            }
            if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(r2).length)
              for (var f2 in t2)
                t2[f2].setFeatureState(r2, e2);
          };
          var ep = function(t2, e2) {
            this.tileID = t2, this.x = t2.canonical.x, this.y = t2.canonical.y, this.z = t2.canonical.z, this.grid = new Tn(8192, 16, 0), this.grid3D = new Tn(8192, 16, 0), this.featureIndexArray = new aa(), this.promoteId = e2;
          };
          function rp(t2, e2, r2, n2, i2) {
            return x(t2, function(t3, a2) {
              var o2 = e2 instanceof di ? e2.get(a2) : null;
              return o2 && o2.evaluate ? o2.evaluate(r2, n2, i2) : o2;
            });
          }
          function np(t2) {
            for (var e2 = 1 / 0, r2 = 1 / 0, n2 = -1 / 0, i2 = -1 / 0, a2 = 0, o2 = t2; a2 < o2.length; a2 += 1) {
              var s2 = o2[a2];
              e2 = Math.min(e2, s2.x), r2 = Math.min(r2, s2.y), n2 = Math.max(n2, s2.x), i2 = Math.max(i2, s2.y);
            }
            return { minX: e2, minY: r2, maxX: n2, maxY: i2 };
          }
          function ip(t2, e2) {
            return e2 - t2;
          }
          ep.prototype.insert = function(t2, e2, r2, n2, i2, a2) {
            var o2 = this.featureIndexArray.length;
            this.featureIndexArray.emplaceBack(r2, n2, i2);
            for (var s2 = a2 ? this.grid3D : this.grid, u2 = 0; u2 < e2.length; u2++) {
              for (var l2 = e2[u2], p2 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], c2 = 0; c2 < l2.length; c2++) {
                var h2 = l2[c2];
                p2[0] = Math.min(p2[0], h2.x), p2[1] = Math.min(p2[1], h2.y), p2[2] = Math.max(p2[2], h2.x), p2[3] = Math.max(p2[3], h2.y);
              }
              p2[0] < 8192 && p2[1] < 8192 && p2[2] >= 0 && p2[3] >= 0 && s2.insert(o2, p2[0], p2[1], p2[2], p2[3]);
            }
          }, ep.prototype.loadVTLayers = function() {
            return this.vtLayers || (this.vtLayers = new bs.VectorTile(new Ys(this.rawTileData)).layers, this.sourceLayerCoder = new $l(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
          }, ep.prototype.query = function(t2, e2, r2, n2) {
            var a2 = this;
            this.loadVTLayers();
            for (var o2 = t2.params || {}, s2 = 8192 / t2.tileSize / t2.scale, u2 = on2(o2.filter), l2 = t2.queryGeometry, p2 = t2.queryPadding * s2, c2 = np(l2), h2 = this.grid.query(c2.minX - p2, c2.minY - p2, c2.maxX + p2, c2.maxY + p2), f2 = np(t2.cameraQueryGeometry), y2 = this.grid3D.query(f2.minX - p2, f2.minY - p2, f2.maxX + p2, f2.maxY + p2, function(e3, r3, n3, a3) {
              return function(t3, e4, r4, n4, a4) {
                for (var o3 = 0, s3 = t3; o3 < s3.length; o3 += 1) {
                  var u3 = s3[o3];
                  if (e4 <= u3.x && r4 <= u3.y && n4 >= u3.x && a4 >= u3.y)
                    return true;
                }
                var l3 = [new i(e4, r4), new i(e4, a4), new i(n4, a4), new i(n4, r4)];
                if (t3.length > 2) {
                  for (var p3 = 0, c3 = l3; p3 < c3.length; p3 += 1)
                    if (Wa(t3, c3[p3]))
                      return true;
                }
                for (var h3 = 0; h3 < t3.length - 1; h3++)
                  if (Qa(t3[h3], t3[h3 + 1], l3))
                    return true;
                return false;
              }(t2.cameraQueryGeometry, e3 - p2, r3 - p2, n3 + p2, a3 + p2);
            }), d2 = 0, m2 = y2; d2 < m2.length; d2 += 1)
              h2.push(m2[d2]);
            h2.sort(ip);
            for (var v2, g2 = {}, x2 = function(i2) {
              var p3 = h2[i2];
              if (p3 !== v2) {
                v2 = p3;
                var c3 = a2.featureIndexArray.get(p3), f3 = null;
                a2.loadMatchingFeature(g2, c3.bucketIndex, c3.sourceLayerIndex, c3.featureIndex, u2, o2.layers, o2.availableImages, e2, r2, n2, function(e3, r3, n3) {
                  return f3 || (f3 = Ra(e3)), r3.queryIntersectsFeature(l2, e3, n3, f3, a2.z, t2.transform, s2, t2.pixelPosMatrix);
                });
              }
            }, b2 = 0; b2 < h2.length; b2++)
              x2(b2);
            return g2;
          }, ep.prototype.loadMatchingFeature = function(t2, e2, r2, n2, i2, a2, o2, s2, u2, l2, p2) {
            var c2 = this.bucketLayerIDs[e2];
            if (!a2 || function(t3, e3) {
              for (var r3 = 0; r3 < t3.length; r3++)
                if (e3.indexOf(t3[r3]) >= 0)
                  return true;
              return false;
            }(a2, c2)) {
              var f2 = this.sourceLayerCoder.decode(r2), y2 = this.vtLayers[f2].feature(n2);
              if (i2.needGeometry) {
                var d2 = Ua(y2, true);
                if (!i2.filter(new si(this.tileID.overscaledZ), d2, this.tileID.canonical))
                  return;
              } else if (!i2.filter(new si(this.tileID.overscaledZ), y2))
                return;
              for (var m2 = this.getId(y2, f2), v2 = 0; v2 < c2.length; v2++) {
                var g2 = c2[v2];
                if (!(a2 && a2.indexOf(g2) < 0)) {
                  var x2 = s2[g2];
                  if (x2) {
                    var b2 = {};
                    void 0 !== m2 && l2 && (b2 = l2.getState(x2.sourceLayer || "_geojsonTileLayer", m2));
                    var w2 = h({}, u2[g2]);
                    w2.paint = rp(w2.paint, x2.paint, y2, b2, o2), w2.layout = rp(w2.layout, x2.layout, y2, b2, o2);
                    var _2 = !p2 || p2(y2, x2, b2);
                    if (_2) {
                      var A2 = new Wl(y2, this.z, this.x, this.y, m2);
                      A2.layer = w2;
                      var S2 = t2[g2];
                      void 0 === S2 && (S2 = t2[g2] = []), S2.push({ featureIndex: n2, feature: A2, intersectionZ: _2 });
                    }
                  }
                }
              }
            }
          }, ep.prototype.lookupSymbolFeatures = function(t2, e2, r2, n2, i2, a2, o2, s2) {
            var u2 = {};
            this.loadVTLayers();
            for (var l2 = on2(i2), p2 = 0, c2 = t2; p2 < c2.length; p2 += 1)
              this.loadMatchingFeature(u2, r2, n2, c2[p2], l2, a2, o2, s2, e2);
            return u2;
          }, ep.prototype.hasLayer = function(t2) {
            for (var e2 = 0, r2 = this.bucketLayerIDs; e2 < r2.length; e2 += 1)
              for (var n2 = 0, i2 = r2[e2]; n2 < i2.length; n2 += 1)
                if (t2 === i2[n2])
                  return true;
            return false;
          }, ep.prototype.getId = function(t2, e2) {
            var r2 = t2.id;
            return this.promoteId && "boolean" == typeof (r2 = t2.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e2]]) && (r2 = Number(r2)), r2;
          }, On("FeatureIndex", ep, { omit: ["rawTileData", "sourceLayerCoder"] });
          var ap2 = function(t2, e2) {
            this.tileID = t2, this.uid = y(), this.uses = 0, this.tileSize = e2, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.expiredRequestCount = 0, this.state = "loading";
          };
          ap2.prototype.registerFadeDuration = function(t2) {
            var e2 = t2 + this.timeAdded;
            e2 < O.now() || this.fadeEndTime && e2 < this.fadeEndTime || (this.fadeEndTime = e2);
          }, ap2.prototype.wasRequested = function() {
            return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
          }, ap2.prototype.loadVectorData = function(t2, e2, r2) {
            if (this.hasData() && this.unloadVectorData(), this.state = "loaded", t2) {
              for (var n2 in t2.featureIndex && (this.latestFeatureIndex = t2.featureIndex, t2.rawTileData ? (this.latestRawTileData = t2.rawTileData, this.latestFeatureIndex.rawTileData = t2.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = t2.collisionBoxArray, this.buckets = function(t3, e3) {
                var r3 = {};
                if (!e3)
                  return r3;
                for (var n3 = function() {
                  var t4 = a3[i3], n4 = t4.layerIds.map(function(t5) {
                    return e3.getLayer(t5);
                  }).filter(Boolean);
                  if (0 !== n4.length) {
                    t4.layers = n4, t4.stateDependentLayerIds && (t4.stateDependentLayers = t4.stateDependentLayerIds.map(function(t5) {
                      return n4.filter(function(e4) {
                        return e4.id === t5;
                      })[0];
                    }));
                    for (var o3 = 0, s3 = n4; o3 < s3.length; o3 += 1)
                      r3[s3[o3].id] = t4;
                  }
                }, i3 = 0, a3 = t3; i3 < a3.length; i3 += 1)
                  n3();
                return r3;
              }(t2.buckets, e2.style), this.hasSymbolBuckets = false, this.buckets) {
                var i2 = this.buckets[n2];
                if (i2 instanceof vl) {
                  if (this.hasSymbolBuckets = true, !r2)
                    break;
                  i2.justReloaded = true;
                }
              }
              if (this.hasRTLText = false, this.hasSymbolBuckets)
                for (var a2 in this.buckets) {
                  var o2 = this.buckets[a2];
                  if (o2 instanceof vl && o2.hasRTLText) {
                    this.hasRTLText = true, oi.isLoading() || oi.isLoaded() || "deferred" !== ii() || ai();
                    break;
                  }
                }
              for (var s2 in this.queryPadding = 0, this.buckets) {
                var u2 = this.buckets[s2];
                this.queryPadding = Math.max(this.queryPadding, e2.style.getLayer(s2).queryRadius(u2));
              }
              t2.imageAtlas && (this.imageAtlas = t2.imageAtlas), t2.glyphAtlasImage && (this.glyphAtlasImage = t2.glyphAtlasImage);
            } else
              this.collisionBoxArray = new $i();
          }, ap2.prototype.unloadVectorData = function() {
            for (var t2 in this.buckets)
              this.buckets[t2].destroy();
            this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
          }, ap2.prototype.getBucket = function(t2) {
            return this.buckets[t2.id];
          }, ap2.prototype.upload = function(t2) {
            for (var e2 in this.buckets) {
              var r2 = this.buckets[e2];
              r2.uploadPending() && r2.upload(t2);
            }
            var n2 = t2.gl;
            this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new Tl(t2, this.imageAtlas.image, n2.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new Tl(t2, this.glyphAtlasImage, n2.ALPHA), this.glyphAtlasImage = null);
          }, ap2.prototype.prepare = function(t2) {
            this.imageAtlas && this.imageAtlas.patchUpdatedImages(t2, this.imageAtlasTexture);
          }, ap2.prototype.queryRenderedFeatures = function(t2, e2, r2, n2, i2, a2, o2, s2, u2, l2) {
            return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: n2, cameraQueryGeometry: i2, scale: a2, tileSize: this.tileSize, pixelPosMatrix: l2, transform: s2, params: o2, queryPadding: this.queryPadding * u2 }, t2, e2, r2) : {};
          }, ap2.prototype.querySourceFeatures = function(t2, e2) {
            var r2 = this.latestFeatureIndex;
            if (r2 && r2.rawTileData) {
              var n2 = r2.loadVTLayers(), i2 = e2 ? e2.sourceLayer : "", a2 = n2._geojsonTileLayer || n2[i2];
              if (a2)
                for (var o2 = on2(e2 && e2.filter), s2 = this.tileID.canonical, u2 = s2.z, l2 = s2.x, p2 = s2.y, c2 = { z: u2, x: l2, y: p2 }, h2 = 0; h2 < a2.length; h2++) {
                  var f2 = a2.feature(h2);
                  if (o2.needGeometry) {
                    var y2 = Ua(f2, true);
                    if (!o2.filter(new si(this.tileID.overscaledZ), y2, this.tileID.canonical))
                      continue;
                  } else if (!o2.filter(new si(this.tileID.overscaledZ), f2))
                    continue;
                  var d2 = r2.getId(f2, i2), m2 = new Wl(f2, u2, l2, p2, d2);
                  m2.tile = c2, t2.push(m2);
                }
            }
          }, ap2.prototype.hasData = function() {
            return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
          }, ap2.prototype.patternsLoaded = function() {
            return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
          }, ap2.prototype.setExpiryData = function(t2) {
            var e2 = this.expirationTime;
            if (t2.cacheControl) {
              var r2 = z(t2.cacheControl);
              r2["max-age"] && (this.expirationTime = Date.now() + 1e3 * r2["max-age"]);
            } else
              t2.expires && (this.expirationTime = new Date(t2.expires).getTime());
            if (this.expirationTime) {
              var n2 = Date.now(), i2 = false;
              if (this.expirationTime > n2)
                i2 = false;
              else if (e2)
                if (this.expirationTime < e2)
                  i2 = true;
                else {
                  var a2 = this.expirationTime - e2;
                  a2 ? this.expirationTime = n2 + Math.max(a2, 3e4) : i2 = true;
                }
              else
                i2 = true;
              i2 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
            }
          }, ap2.prototype.getExpiryTimeout = function() {
            if (this.expirationTime)
              return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1);
          }, ap2.prototype.setFeatureState = function(t2, e2) {
            if (this.latestFeatureIndex && this.latestFeatureIndex.rawTileData && 0 !== Object.keys(t2).length) {
              var r2 = this.latestFeatureIndex.loadVTLayers();
              for (var n2 in this.buckets)
                if (e2.style.hasLayer(n2)) {
                  var i2 = this.buckets[n2], a2 = i2.layers[0].sourceLayer || "_geojsonTileLayer", o2 = r2[a2], s2 = t2[a2];
                  if (o2 && s2 && 0 !== Object.keys(s2).length) {
                    i2.update(s2, o2, this.imageAtlas && this.imageAtlas.patternPositions || {});
                    var u2 = e2 && e2.style && e2.style.getLayer(n2);
                    u2 && (this.queryPadding = Math.max(this.queryPadding, u2.queryRadius(i2)));
                  }
                }
            }
          }, ap2.prototype.holdingForFade = function() {
            return void 0 !== this.symbolFadeHoldUntil;
          }, ap2.prototype.symbolFadeFinished = function() {
            return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < O.now();
          }, ap2.prototype.clearFadeHold = function() {
            this.symbolFadeHoldUntil = void 0;
          }, ap2.prototype.setHoldDuration = function(t2) {
            this.symbolFadeHoldUntil = O.now() + t2;
          }, ap2.prototype.setDependencies = function(t2, e2) {
            for (var r2 = {}, n2 = 0, i2 = e2; n2 < i2.length; n2 += 1)
              r2[i2[n2]] = true;
            this.dependencies[t2] = r2;
          }, ap2.prototype.hasDependency = function(t2, e2) {
            for (var r2 = 0, n2 = t2; r2 < n2.length; r2 += 1) {
              var i2 = this.dependencies[n2[r2]];
              if (i2) {
                for (var a2 = 0, o2 = e2; a2 < o2.length; a2 += 1)
                  if (i2[o2[a2]])
                    return true;
              }
            }
            return false;
          };
          var op = o.performance, sp = function(t2) {
            this._marks = { start: [t2.url, "start"].join("#"), end: [t2.url, "end"].join("#"), measure: t2.url.toString() }, op.mark(this._marks.start);
          };
          sp.prototype.finish = function() {
            op.mark(this._marks.end);
            var t2 = op.getEntriesByName(this._marks.measure);
            return 0 === t2.length && (op.measure(this._marks.measure, this._marks.start, this._marks.end), t2 = op.getEntriesByName(this._marks.measure), op.clearMarks(this._marks.start), op.clearMarks(this._marks.end), op.clearMeasures(this._marks.measure)), t2;
          }, t.Actor = Fl, t.AlphaImage = go2, t.CanonicalTileID = Zl, t.CollisionBoxArray = $i, t.Color = te, t.DEMData = Yl, t.DataConstantProperty = mi, t.DictionaryCoder = $l, t.EXTENT = 8192, t.ErrorEvent = zt, t.EvaluationParameters = si, t.Event = It, t.Evented = Ct, t.FeatureIndex = ep, t.FillBucket = ss, t.FillExtrusionBucket = Ss, t.ImageAtlas = bu, t.ImagePosition = gu, t.LineBucket = Fs, t.LngLat = Ol, t.LngLatBounds = Ll, t.MercatorCoordinate = Gl, t.ONE_EM = 24, t.OverscaledTileID = Jl, t.Point = i, t.Point$1 = i, t.Properties = wi, t.Protobuf = Ys, t.RGBAImage = xo, t.RequestManager = G, t.RequestPerformance = sp, t.ResourceType = yt, t.SegmentVector = sa, t.SourceFeatureState = tp, t.StructArrayLayout1ui2 = Ji, t.StructArrayLayout2f1f2i16 = Ri, t.StructArrayLayout2i4 = Ci, t.StructArrayLayout3ui6 = ji, t.StructArrayLayout4i8 = Ei, t.SymbolBucket = vl, t.Texture = Tl, t.Tile = ap2, t.Transitionable = pi, t.Uniform1f = ba, t.Uniform1i = xa, t.Uniform2f = wa, t.Uniform3f = _a, t.Uniform4f = Aa, t.UniformColor = Sa, t.UniformMatrix4f = Ia, t.UnwrappedTileID = Xl, t.ValidationError = Pt, t.WritingMode = wu, t.ZoomHistory = Kn, t.add = function(t2, e2, r2) {
            return t2[0] = e2[0] + r2[0], t2[1] = e2[1] + r2[1], t2[2] = e2[2] + r2[2], t2;
          }, t.addDynamicAttributes = fl, t.asyncAll = function(t2, e2, r2) {
            if (!t2.length)
              return r2(null, []);
            var n2 = t2.length, i2 = new Array(t2.length), a2 = null;
            t2.forEach(function(t3, o2) {
              e2(t3, function(t4, e3) {
                t4 && (a2 = t4), i2[o2] = e3, 0 == --n2 && r2(a2, i2);
              });
            });
          }, t.bezier = u, t.bindAll = v, t.browser = O, t.cacheEntryPossiblyAdded = function(t2) {
            ++ht > ut && (t2.getActor().send("enforceCacheSizeLimit", st), ht = 0);
          }, t.clamp = p, t.clearTileCache = function(t2) {
            var e2 = o.caches.delete("mapbox-tiles");
            t2 && e2.catch(t2).then(function() {
              return t2();
            });
          }, t.clipLine = Zu, t.clone = function(t2) {
            var e2 = new ao(16);
            return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2[3] = t2[3], e2[4] = t2[4], e2[5] = t2[5], e2[6] = t2[6], e2[7] = t2[7], e2[8] = t2[8], e2[9] = t2[9], e2[10] = t2[10], e2[11] = t2[11], e2[12] = t2[12], e2[13] = t2[13], e2[14] = t2[14], e2[15] = t2[15], e2;
          }, t.clone$1 = w, t.clone$2 = function(t2) {
            var e2 = new ao(3);
            return e2[0] = t2[0], e2[1] = t2[1], e2[2] = t2[2], e2;
          }, t.collisionCircleLayout = Gs, t.config = R, t.create = function() {
            var t2 = new ao(16);
            return ao != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
          }, t.create$1 = function() {
            var t2 = new ao(9);
            return ao != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[0] = 1, t2[4] = 1, t2[8] = 1, t2;
          }, t.create$2 = function() {
            var t2 = new ao(4);
            return ao != Float32Array && (t2[1] = 0, t2[2] = 0), t2[0] = 1, t2[3] = 1, t2;
          }, t.createCommonjsModule = e, t.createExpression = Zr, t.createLayout = Ii, t.createStyleLayer = function(t2) {
            return "custom" === t2.type ? new Il(t2) : new zl[t2.type](t2);
          }, t.cross = function(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], a2 = e2[2], o2 = r2[0], s2 = r2[1], u2 = r2[2];
            return t2[0] = i2 * u2 - a2 * s2, t2[1] = a2 * o2 - n2 * u2, t2[2] = n2 * s2 - i2 * o2, t2;
          }, t.deepEqual = function t2(e2, r2) {
            if (Array.isArray(e2)) {
              if (!Array.isArray(r2) || e2.length !== r2.length)
                return false;
              for (var n2 = 0; n2 < e2.length; n2++)
                if (!t2(e2[n2], r2[n2]))
                  return false;
              return true;
            }
            if ("object" == typeof e2 && null !== e2 && null !== r2) {
              if ("object" != typeof r2)
                return false;
              if (Object.keys(e2).length !== Object.keys(r2).length)
                return false;
              for (var i2 in e2)
                if (!t2(e2[i2], r2[i2]))
                  return false;
              return true;
            }
            return e2 === r2;
          }, t.dot = function(t2, e2) {
            return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2];
          }, t.dot$1 = function(t2, e2) {
            return t2[0] * e2[0] + t2[1] * e2[1] + t2[2] * e2[2] + t2[3] * e2[3];
          }, t.ease = l, t.emitValidationErrors = Bn, t.endsWith = g, t.enforceCacheSizeLimit = function(t2) {
            lt(), tt2 && tt2.then(function(e2) {
              e2.keys().then(function(r2) {
                for (var n2 = 0; n2 < r2.length - t2; n2++)
                  e2.delete(r2[n2]);
              });
            });
          }, t.evaluateSizeForFeature = Lu, t.evaluateSizeForZoom = Ou, t.evaluateVariableOffset = al, t.evented = ni, t.extend = h, t.featureFilter = on2, t.filterObject = b, t.fromRotation = function(t2, e2) {
            var r2 = Math.sin(e2), n2 = Math.cos(e2);
            return t2[0] = n2, t2[1] = r2, t2[2] = 0, t2[3] = -r2, t2[4] = n2, t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
          }, t.getAnchorAlignment = Bu, t.getAnchorJustification = ol, t.getArrayBuffer = bt, t.getImage = At, t.getJSON = function(t2, e2) {
            return xt(h(t2, { type: "json" }), e2);
          }, t.getRTLTextPluginStatus = ii, t.getReferrer = mt, t.getVideo = function(t2, e2) {
            var r2, n2, i2 = o.document.createElement("video");
            i2.muted = true, i2.onloadstart = function() {
              e2(null, i2);
            };
            for (var a2 = 0; a2 < t2.length; a2++) {
              var s2 = o.document.createElement("source");
              r2 = t2[a2], n2 = void 0, (n2 = o.document.createElement("a")).href = r2, (n2.protocol !== o.document.location.protocol || n2.host !== o.document.location.host) && (i2.crossOrigin = "Anonymous"), s2.src = t2[a2], i2.appendChild(s2);
            }
            return { cancel: function() {
            } };
          }, t.identity = oo, t.invert = function(t2, e2) {
            var r2 = e2[0], n2 = e2[1], i2 = e2[2], a2 = e2[3], o2 = e2[4], s2 = e2[5], u2 = e2[6], l2 = e2[7], p2 = e2[8], c2 = e2[9], h2 = e2[10], f2 = e2[11], y2 = e2[12], d2 = e2[13], m2 = e2[14], v2 = e2[15], g2 = r2 * s2 - n2 * o2, x2 = r2 * u2 - i2 * o2, b2 = r2 * l2 - a2 * o2, w2 = n2 * u2 - i2 * s2, _2 = n2 * l2 - a2 * s2, A2 = i2 * l2 - a2 * u2, S2 = p2 * d2 - c2 * y2, k2 = p2 * m2 - h2 * y2, I2 = p2 * v2 - f2 * y2, z2 = c2 * m2 - h2 * d2, C2 = c2 * v2 - f2 * d2, E2 = h2 * v2 - f2 * m2, P2 = g2 * E2 - x2 * C2 + b2 * z2 + w2 * I2 - _2 * k2 + A2 * S2;
            return P2 ? (t2[0] = (s2 * E2 - u2 * C2 + l2 * z2) * (P2 = 1 / P2), t2[1] = (i2 * C2 - n2 * E2 - a2 * z2) * P2, t2[2] = (d2 * A2 - m2 * _2 + v2 * w2) * P2, t2[3] = (h2 * _2 - c2 * A2 - f2 * w2) * P2, t2[4] = (u2 * I2 - o2 * E2 - l2 * k2) * P2, t2[5] = (r2 * E2 - i2 * I2 + a2 * k2) * P2, t2[6] = (m2 * b2 - y2 * A2 - v2 * x2) * P2, t2[7] = (p2 * A2 - h2 * b2 + f2 * x2) * P2, t2[8] = (o2 * C2 - s2 * I2 + l2 * S2) * P2, t2[9] = (n2 * I2 - r2 * C2 - a2 * S2) * P2, t2[10] = (y2 * _2 - d2 * b2 + v2 * g2) * P2, t2[11] = (c2 * b2 - p2 * _2 - f2 * g2) * P2, t2[12] = (s2 * k2 - o2 * z2 - u2 * S2) * P2, t2[13] = (r2 * z2 - n2 * k2 + i2 * S2) * P2, t2[14] = (d2 * x2 - y2 * w2 - m2 * g2) * P2, t2[15] = (p2 * w2 - c2 * x2 + h2 * g2) * P2, t2) : null;
          }, t.isChar = Gn, t.isMapboxURL = Z, t.keysDifference = function(t2, e2) {
            var r2 = [];
            for (var n2 in t2)
              n2 in e2 || r2.push(n2);
            return r2;
          }, t.makeRequest = xt, t.mapObject = x, t.mercatorXfromLng = jl, t.mercatorYfromLat = ql, t.mercatorZfromAltitude = Nl, t.mul = lo, t.multiply = so, t.mvt = bs, t.nextPowerOfTwo = function(t2) {
            return t2 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t2) / Math.LN2));
          }, t.normalize = function(t2, e2) {
            var r2 = e2[0], n2 = e2[1], i2 = e2[2], a2 = r2 * r2 + n2 * n2 + i2 * i2;
            return a2 > 0 && (a2 = 1 / Math.sqrt(a2)), t2[0] = e2[0] * a2, t2[1] = e2[1] * a2, t2[2] = e2[2] * a2, t2;
          }, t.number = Ke, t.offscreenCanvasSupported = ft, t.ortho = function(t2, e2, r2, n2, i2, a2, o2) {
            var s2 = 1 / (e2 - r2), u2 = 1 / (n2 - i2), l2 = 1 / (a2 - o2);
            return t2[0] = -2 * s2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = -2 * u2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[10] = 2 * l2, t2[11] = 0, t2[12] = (e2 + r2) * s2, t2[13] = (i2 + n2) * u2, t2[14] = (o2 + a2) * l2, t2[15] = 1, t2;
          }, t.parseGlyphPBF = function(t2) {
            return new Ys(t2).readFields(yu, []);
          }, t.pbf = Ys, t.performSymbolLayout = function(t2, e2, r2, n2, i2, a2, o2) {
            t2.createArrays(), t2.tilePixelRatio = 8192 / (512 * t2.overscaling), t2.compareText = {}, t2.iconsNeedLinear = false;
            var s2 = t2.layers[0].layout, u2 = t2.layers[0]._unevaluatedLayout._values, l2 = {};
            if ("composite" === t2.textSizeData.kind) {
              var p2 = t2.textSizeData, c2 = p2.maxZoom;
              l2.compositeTextSizes = [u2["text-size"].possiblyEvaluate(new si(p2.minZoom), o2), u2["text-size"].possiblyEvaluate(new si(c2), o2)];
            }
            if ("composite" === t2.iconSizeData.kind) {
              var h2 = t2.iconSizeData, f2 = h2.maxZoom;
              l2.compositeIconSizes = [u2["icon-size"].possiblyEvaluate(new si(h2.minZoom), o2), u2["icon-size"].possiblyEvaluate(new si(f2), o2)];
            }
            l2.layoutTextSize = u2["text-size"].possiblyEvaluate(new si(t2.zoom + 1), o2), l2.layoutIconSize = u2["icon-size"].possiblyEvaluate(new si(t2.zoom + 1), o2), l2.textMaxSize = u2["text-size"].possiblyEvaluate(new si(18));
            for (var y2 = 24 * s2.get("text-line-height"), d2 = "map" === s2.get("text-rotation-alignment") && "point" !== s2.get("symbol-placement"), m2 = s2.get("text-keep-upright"), v2 = s2.get("text-size"), g2 = function() {
              var a3 = b2[x2], u3 = s2.get("text-font").evaluate(a3, {}, o2).join(","), p3 = v2.evaluate(a3, {}, o2), c3 = l2.layoutTextSize.evaluate(a3, {}, o2), h3 = l2.layoutIconSize.evaluate(a3, {}, o2), f3 = { horizontal: {}, vertical: void 0 }, g3 = a3.text, w2 = [0, 0];
              if (g3) {
                var _2 = g3.toString(), S2 = 24 * s2.get("text-letter-spacing").evaluate(a3, {}, o2), k2 = function(t3) {
                  for (var e3 = 0, r3 = t3; e3 < r3.length; e3 += 1)
                    if (n3 = r3[e3].charCodeAt(0), Gn.Arabic(n3) || Gn["Arabic Supplement"](n3) || Gn["Arabic Extended-A"](n3) || Gn["Arabic Presentation Forms-A"](n3) || Gn["Arabic Presentation Forms-B"](n3))
                      return false;
                  var n3;
                  return true;
                }(_2) ? S2 : 0, I2 = s2.get("text-anchor").evaluate(a3, {}, o2), z2 = s2.get("text-variable-anchor");
                if (!z2) {
                  var C2 = s2.get("text-radial-offset").evaluate(a3, {}, o2);
                  w2 = C2 ? al(I2, [24 * C2, il]) : s2.get("text-offset").evaluate(a3, {}, o2).map(function(t3) {
                    return 24 * t3;
                  });
                }
                var E2 = d2 ? "center" : s2.get("text-justify").evaluate(a3, {}, o2), P2 = s2.get("symbol-placement"), M2 = "point" === P2 ? 24 * s2.get("text-max-width").evaluate(a3, {}, o2) : 0, B2 = function() {
                  t2.allowVerticalPlacement && Zn(_2) && (f3.vertical = Su(g3, e2, r2, i2, u3, M2, y2, I2, "left", k2, w2, wu.vertical, true, P2, c3, p3));
                };
                if (!d2 && z2) {
                  for (var T2 = "auto" === E2 ? z2.map(function(t3) {
                    return ol(t3);
                  }) : [E2], V2 = false, F2 = 0; F2 < T2.length; F2++) {
                    var D2 = T2[F2];
                    if (!f3.horizontal[D2])
                      if (V2)
                        f3.horizontal[D2] = f3.horizontal[0];
                      else {
                        var L2 = Su(g3, e2, r2, i2, u3, M2, y2, "center", D2, k2, w2, wu.horizontal, false, P2, c3, p3);
                        L2 && (f3.horizontal[D2] = L2, V2 = 1 === L2.positionedLines.length);
                      }
                  }
                  B2();
                } else {
                  "auto" === E2 && (E2 = ol(I2));
                  var O2 = Su(g3, e2, r2, i2, u3, M2, y2, I2, E2, k2, w2, wu.horizontal, false, P2, c3, p3);
                  O2 && (f3.horizontal[E2] = O2), B2(), Zn(_2) && d2 && m2 && (f3.vertical = Su(g3, e2, r2, i2, u3, M2, y2, I2, E2, k2, w2, wu.vertical, false, P2, c3, p3));
                }
              }
              var R2 = void 0, U2 = false;
              if (a3.icon && a3.icon.name) {
                var j2 = n2[a3.icon.name];
                j2 && (R2 = function(t3, e3, r3) {
                  var n3 = Bu(r3), i3 = e3[0] - t3.displaySize[0] * n3.horizontalAlign, a4 = e3[1] - t3.displaySize[1] * n3.verticalAlign;
                  return { image: t3, top: a4, bottom: a4 + t3.displaySize[1], left: i3, right: i3 + t3.displaySize[0] };
                }(i2[a3.icon.name], s2.get("icon-offset").evaluate(a3, {}, o2), s2.get("icon-anchor").evaluate(a3, {}, o2)), U2 = j2.sdf, void 0 === t2.sdfIcons ? t2.sdfIcons = j2.sdf : t2.sdfIcons !== j2.sdf && A("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (j2.pixelRatio !== t2.pixelRatio || 0 !== s2.get("icon-rotate").constantOr(1)) && (t2.iconsNeedLinear = true));
              }
              var q2 = ul(f3.horizontal) || f3.vertical;
              t2.iconsInText = !!q2 && q2.iconsInText, (q2 || R2) && function(t3, e3, r3, n3, i3, a4, o3, s3, u4, l3, p4) {
                var c4 = a4.textMaxSize.evaluate(e3, {});
                void 0 === c4 && (c4 = o3);
                var h4, f4 = t3.layers[0].layout, y3 = f4.get("icon-offset").evaluate(e3, {}, p4), d3 = ul(r3.horizontal), m3 = o3 / 24, v3 = t3.tilePixelRatio * m3, g4 = t3.tilePixelRatio * c4 / 24, x3 = t3.tilePixelRatio * s3, b3 = t3.tilePixelRatio * f4.get("symbol-spacing"), w3 = f4.get("text-padding") * t3.tilePixelRatio, _3 = f4.get("icon-padding") * t3.tilePixelRatio, S3 = f4.get("text-max-angle") / 180 * Math.PI, k3 = "map" === f4.get("text-rotation-alignment") && "point" !== f4.get("symbol-placement"), I3 = "map" === f4.get("icon-rotation-alignment") && "point" !== f4.get("symbol-placement"), z3 = f4.get("symbol-placement"), C3 = b3 / 2, E3 = f4.get("icon-text-fit");
                n3 && "none" !== E3 && (t3.allowVerticalPlacement && r3.vertical && (h4 = Vu(n3, r3.vertical, E3, f4.get("icon-text-fit-padding"), y3, m3)), d3 && (n3 = Vu(n3, d3, E3, f4.get("icon-text-fit-padding"), y3, m3)));
                var P3 = function(s4, c5) {
                  c5.x < 0 || c5.x >= 8192 || c5.y < 0 || c5.y >= 8192 || function(t4, e4, r4, n4, i4, a5, o4, s5, u5, l4, p5, c6, h5, f5, y4, d4, m4, v4, g5, x4, b4, w4, _4, S4, k4) {
                    var I4, z4, C4, E4, P4, M4 = t4.addToLineVertexArray(e4, r4), B4 = 0, T4 = 0, V4 = 0, F4 = 0, D4 = -1, L4 = -1, O4 = {}, R4 = ha(""), U4 = 0, j4 = 0;
                    if (void 0 === s5._unevaluatedLayout.getValue("text-radial-offset") ? (U4 = (I4 = s5.layout.get("text-offset").evaluate(b4, {}, S4).map(function(t5) {
                      return 24 * t5;
                    }))[0], j4 = I4[1]) : (U4 = 24 * s5.layout.get("text-radial-offset").evaluate(b4, {}, S4), j4 = il), t4.allowVerticalPlacement && n4.vertical) {
                      var q4 = s5.layout.get("text-rotate").evaluate(b4, {}, S4) + 90;
                      E4 = new Wu(u5, e4, l4, p5, c6, n4.vertical, h5, f5, y4, q4), o4 && (P4 = new Wu(u5, e4, l4, p5, c6, o4, m4, v4, y4, q4));
                    }
                    if (i4) {
                      var N3 = s5.layout.get("icon-rotate").evaluate(b4, {}), K3 = "none" !== s5.layout.get("icon-text-fit"), G3 = Xu(i4, N3, _4, K3), Z3 = o4 ? Xu(o4, N3, _4, K3) : void 0;
                      C4 = new Wu(u5, e4, l4, p5, c6, i4, m4, v4, false, N3), B4 = 4 * G3.length;
                      var X3 = t4.iconSizeData, J3 = null;
                      "source" === X3.kind ? (J3 = [128 * s5.layout.get("icon-size").evaluate(b4, {})])[0] > 32640 && A(t4.layerIds[0] + ': Value for "icon-size" is >= 255. Reduce your "icon-size".') : "composite" === X3.kind && ((J3 = [128 * w4.compositeIconSizes[0].evaluate(b4, {}, S4), 128 * w4.compositeIconSizes[1].evaluate(b4, {}, S4)])[0] > 32640 || J3[1] > 32640) && A(t4.layerIds[0] + ': Value for "icon-size" is >= 255. Reduce your "icon-size".'), t4.addSymbols(t4.icon, G3, J3, x4, g5, b4, false, e4, M4.lineStartIndex, M4.lineLength, -1, S4), D4 = t4.icon.placedSymbolArray.length - 1, Z3 && (T4 = 4 * Z3.length, t4.addSymbols(t4.icon, Z3, J3, x4, g5, b4, wu.vertical, e4, M4.lineStartIndex, M4.lineLength, -1, S4), L4 = t4.icon.placedSymbolArray.length - 1);
                    }
                    for (var H3 in n4.horizontal) {
                      var Y3 = n4.horizontal[H3];
                      if (!z4) {
                        R4 = ha(Y3.text);
                        var $3 = s5.layout.get("text-rotate").evaluate(b4, {}, S4);
                        z4 = new Wu(u5, e4, l4, p5, c6, Y3, h5, f5, y4, $3);
                      }
                      var W3 = 1 === Y3.positionedLines.length;
                      if (V4 += sl(t4, e4, Y3, a5, s5, y4, b4, d4, M4, n4.vertical ? wu.horizontal : wu.horizontalOnly, W3 ? Object.keys(n4.horizontal) : [H3], O4, D4, w4, S4), W3)
                        break;
                    }
                    n4.vertical && (F4 += sl(t4, e4, n4.vertical, a5, s5, y4, b4, d4, M4, wu.vertical, ["vertical"], O4, L4, w4, S4));
                    var Q2 = z4 ? z4.boxStartIndex : t4.collisionBoxArray.length, tt3 = z4 ? z4.boxEndIndex : t4.collisionBoxArray.length, et2 = E4 ? E4.boxStartIndex : t4.collisionBoxArray.length, rt2 = E4 ? E4.boxEndIndex : t4.collisionBoxArray.length, nt2 = C4 ? C4.boxStartIndex : t4.collisionBoxArray.length, it2 = C4 ? C4.boxEndIndex : t4.collisionBoxArray.length, at2 = P4 ? P4.boxStartIndex : t4.collisionBoxArray.length, ot2 = P4 ? P4.boxEndIndex : t4.collisionBoxArray.length, st2 = -1, ut2 = function(t5, e5) {
                      return t5 && t5.circleDiameter ? Math.max(t5.circleDiameter, e5) : e5;
                    };
                    st2 = ut2(z4, st2), st2 = ut2(E4, st2), st2 = ut2(C4, st2);
                    var lt2 = (st2 = ut2(P4, st2)) > -1 ? 1 : 0;
                    lt2 && (st2 *= k4 / 24), t4.glyphOffsetArray.length >= vl.MAX_GLYPHS && A("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== b4.sortKey && t4.addToSortKeyRanges(t4.symbolInstances.length, b4.sortKey), t4.symbolInstances.emplaceBack(e4.x, e4.y, O4.right >= 0 ? O4.right : -1, O4.center >= 0 ? O4.center : -1, O4.left >= 0 ? O4.left : -1, O4.vertical || -1, D4, L4, R4, Q2, tt3, et2, rt2, nt2, it2, at2, ot2, l4, V4, F4, B4, T4, lt2, 0, h5, U4, j4, st2);
                  }(t3, c5, s4, r3, n3, i3, h4, t3.layers[0], t3.collisionBoxArray, e3.index, e3.sourceLayerIndex, t3.index, v3, w3, k3, u4, x3, _3, I3, y3, e3, a4, l3, p4, o3);
                };
                if ("line" === z3)
                  for (var M3 = 0, B3 = Zu(e3.geometry, 0, 0, 8192, 8192); M3 < B3.length; M3 += 1)
                    for (var T3 = B3[M3], V3 = 0, F3 = Gu(T3, b3, S3, r3.vertical || d3, n3, 24, g4, t3.overscaling, 8192); V3 < F3.length; V3 += 1) {
                      var D3 = F3[V3];
                      d3 && ll(t3, d3.text, C3, D3) || P3(T3, D3);
                    }
                else if ("line-center" === z3)
                  for (var L3 = 0, O3 = e3.geometry; L3 < O3.length; L3 += 1) {
                    var R3 = O3[L3];
                    if (R3.length > 1) {
                      var U3 = Ku(R3, S3, r3.vertical || d3, n3, 24, g4);
                      U3 && P3(R3, U3);
                    }
                  }
                else if ("Polygon" === e3.type)
                  for (var j3 = 0, q3 = ns(e3.geometry, 0); j3 < q3.length; j3 += 1) {
                    var N2 = q3[j3], K2 = el(N2, 16);
                    P3(N2[0], new Fu(K2.x, K2.y, 0));
                  }
                else if ("LineString" === e3.type)
                  for (var G2 = 0, Z2 = e3.geometry; G2 < Z2.length; G2 += 1) {
                    var X2 = Z2[G2];
                    P3(X2, new Fu(X2[0].x, X2[0].y, 0));
                  }
                else if ("Point" === e3.type)
                  for (var J2 = 0, H2 = e3.geometry; J2 < H2.length; J2 += 1)
                    for (var Y2 = 0, $2 = H2[J2]; Y2 < $2.length; Y2 += 1) {
                      var W2 = $2[Y2];
                      P3([W2], new Fu(W2.x, W2.y, 0));
                    }
              }(t2, a3, f3, R2, n2, l2, c3, h3, w2, U2, o2);
            }, x2 = 0, b2 = t2.features; x2 < b2.length; x2 += 1)
              g2();
            a2 && t2.generateCollisionDebugBuffers();
          }, t.perspective = function(t2, e2, r2, n2, i2) {
            var a2, o2 = 1 / Math.tan(e2 / 2);
            return t2[0] = o2 / r2, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[5] = o2, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = -1, t2[12] = 0, t2[13] = 0, t2[15] = 0, null != i2 && i2 !== 1 / 0 ? (t2[10] = (i2 + n2) * (a2 = 1 / (n2 - i2)), t2[14] = 2 * i2 * n2 * a2) : (t2[10] = -1, t2[14] = -2 * n2), t2;
          }, t.pick = function(t2, e2) {
            for (var r2 = {}, n2 = 0; n2 < e2.length; n2++) {
              var i2 = e2[n2];
              i2 in t2 && (r2[i2] = t2[i2]);
            }
            return r2;
          }, t.plugin = oi, t.polygonIntersectsPolygon = Na, t.postMapLoadEvent = ot, t.postTurnstileEvent = it, t.potpack = vu, t.refProperties = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"], t.register = On, t.registerForPluginStateChange = function(t2) {
            return t2({ pluginStatus: Qn, pluginURL: ti }), ni.on("pluginStateChange", t2), t2;
          }, t.renderColorRamp = wo, t.rotate = function(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], a2 = e2[2], o2 = e2[3], s2 = Math.sin(r2), u2 = Math.cos(r2);
            return t2[0] = n2 * u2 + a2 * s2, t2[1] = i2 * u2 + o2 * s2, t2[2] = n2 * -s2 + a2 * u2, t2[3] = i2 * -s2 + o2 * u2, t2;
          }, t.rotateX = function(t2, e2, r2) {
            var n2 = Math.sin(r2), i2 = Math.cos(r2), a2 = e2[4], o2 = e2[5], s2 = e2[6], u2 = e2[7], l2 = e2[8], p2 = e2[9], c2 = e2[10], h2 = e2[11];
            return e2 !== t2 && (t2[0] = e2[0], t2[1] = e2[1], t2[2] = e2[2], t2[3] = e2[3], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[4] = a2 * i2 + l2 * n2, t2[5] = o2 * i2 + p2 * n2, t2[6] = s2 * i2 + c2 * n2, t2[7] = u2 * i2 + h2 * n2, t2[8] = l2 * i2 - a2 * n2, t2[9] = p2 * i2 - o2 * n2, t2[10] = c2 * i2 - s2 * n2, t2[11] = h2 * i2 - u2 * n2, t2;
          }, t.rotateZ = function(t2, e2, r2) {
            var n2 = Math.sin(r2), i2 = Math.cos(r2), a2 = e2[0], o2 = e2[1], s2 = e2[2], u2 = e2[3], l2 = e2[4], p2 = e2[5], c2 = e2[6], h2 = e2[7];
            return e2 !== t2 && (t2[8] = e2[8], t2[9] = e2[9], t2[10] = e2[10], t2[11] = e2[11], t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15]), t2[0] = a2 * i2 + l2 * n2, t2[1] = o2 * i2 + p2 * n2, t2[2] = s2 * i2 + c2 * n2, t2[3] = u2 * i2 + h2 * n2, t2[4] = l2 * i2 - a2 * n2, t2[5] = p2 * i2 - o2 * n2, t2[6] = c2 * i2 - s2 * n2, t2[7] = h2 * i2 - u2 * n2, t2;
          }, t.scale = function(t2, e2, r2) {
            var n2 = r2[0], i2 = r2[1], a2 = r2[2];
            return t2[0] = e2[0] * n2, t2[1] = e2[1] * n2, t2[2] = e2[2] * n2, t2[3] = e2[3] * n2, t2[4] = e2[4] * i2, t2[5] = e2[5] * i2, t2[6] = e2[6] * i2, t2[7] = e2[7] * i2, t2[8] = e2[8] * a2, t2[9] = e2[9] * a2, t2[10] = e2[10] * a2, t2[11] = e2[11] * a2, t2[12] = e2[12], t2[13] = e2[13], t2[14] = e2[14], t2[15] = e2[15], t2;
          }, t.scale$1 = function(t2, e2, r2) {
            return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2[2] = e2[2] * r2, t2[3] = e2[3] * r2, t2;
          }, t.scale$2 = function(t2, e2, r2) {
            return t2[0] = e2[0] * r2, t2[1] = e2[1] * r2, t2[2] = e2[2] * r2, t2;
          }, t.setCacheLimits = function(t2, e2) {
            st = t2, ut = e2;
          }, t.setRTLTextPlugin = function(t2, e2, r2) {
            if (void 0 === r2 && (r2 = false), "deferred" === Qn || "loading" === Qn || "loaded" === Qn)
              throw new Error("setRTLTextPlugin cannot be called multiple times.");
            ti = O.resolveURL(t2), Qn = "deferred", Wn = e2, ri(), r2 || ai();
          }, t.sphericalToCartesian = function(t2) {
            var e2 = t2[0], r2 = t2[1], n2 = t2[2];
            return r2 += 90, r2 *= Math.PI / 180, n2 *= Math.PI / 180, { x: e2 * Math.cos(r2) * Math.sin(n2), y: e2 * Math.sin(r2) * Math.sin(n2), z: e2 * Math.cos(n2) };
          }, t.sqrLen = function(t2) {
            var e2 = t2[0], r2 = t2[1];
            return e2 * e2 + r2 * r2;
          }, t.styleSpec = Et, t.sub = function(t2, e2, r2) {
            return t2[0] = e2[0] - r2[0], t2[1] = e2[1] - r2[1], t2[2] = e2[2] - r2[2], t2;
          }, t.symbolSize = Ru, t.transformMat3 = function(t2, e2, r2) {
            var n2 = e2[0], i2 = e2[1], a2 = e2[2];
            return t2[0] = n2 * r2[0] + i2 * r2[3] + a2 * r2[6], t2[1] = n2 * r2[1] + i2 * r2[4] + a2 * r2[7], t2[2] = n2 * r2[2] + i2 * r2[5] + a2 * r2[8], t2;
          }, t.transformMat4 = po, t.translate = function(t2, e2, r2) {
            var n2, i2, a2, o2, s2, u2, l2, p2, c2, h2, f2, y2, d2 = r2[0], m2 = r2[1], v2 = r2[2];
            return e2 === t2 ? (t2[12] = e2[0] * d2 + e2[4] * m2 + e2[8] * v2 + e2[12], t2[13] = e2[1] * d2 + e2[5] * m2 + e2[9] * v2 + e2[13], t2[14] = e2[2] * d2 + e2[6] * m2 + e2[10] * v2 + e2[14], t2[15] = e2[3] * d2 + e2[7] * m2 + e2[11] * v2 + e2[15]) : (i2 = e2[1], a2 = e2[2], o2 = e2[3], s2 = e2[4], u2 = e2[5], l2 = e2[6], p2 = e2[7], c2 = e2[8], h2 = e2[9], f2 = e2[10], y2 = e2[11], t2[0] = n2 = e2[0], t2[1] = i2, t2[2] = a2, t2[3] = o2, t2[4] = s2, t2[5] = u2, t2[6] = l2, t2[7] = p2, t2[8] = c2, t2[9] = h2, t2[10] = f2, t2[11] = y2, t2[12] = n2 * d2 + s2 * m2 + c2 * v2 + e2[12], t2[13] = i2 * d2 + u2 * m2 + h2 * v2 + e2[13], t2[14] = a2 * d2 + l2 * m2 + f2 * v2 + e2[14], t2[15] = o2 * d2 + p2 * m2 + y2 * v2 + e2[15]), t2;
          }, t.triggerPluginCompletionEvent = ei, t.uniqueId = y, t.validateCustomStyleLayer = function(t2) {
            var e2 = [], r2 = t2.id;
            return void 0 === r2 && e2.push({ message: "layers." + r2 + ': missing required property "id"' }), void 0 === t2.render && e2.push({ message: "layers." + r2 + ': missing required method "render"' }), t2.renderingMode && "2d" !== t2.renderingMode && "3d" !== t2.renderingMode && e2.push({ message: "layers." + r2 + ': property "renderingMode" must be either "2d" or "3d"' }), e2;
          }, t.validateLight = En, t.validateStyle = Cn, t.values = function(t2) {
            var e2 = [];
            for (var r2 in t2)
              e2.push(t2[r2]);
            return e2;
          }, t.vectorTile = bs, t.version = "1.13.3", t.warnOnce = A, t.webpSupported = U, t.window = o, t.wrap = c;
        });
        define2(["./shared"], function(e) {
          "use strict";
          function t(e2) {
            var r2 = typeof e2;
            if ("number" === r2 || "boolean" === r2 || "string" === r2 || null == e2)
              return JSON.stringify(e2);
            if (Array.isArray(e2)) {
              for (var i2 = "[", o2 = 0, n2 = e2; o2 < n2.length; o2 += 1)
                i2 += t(n2[o2]) + ",";
              return i2 + "]";
            }
            for (var a2 = Object.keys(e2).sort(), s2 = "{", l2 = 0; l2 < a2.length; l2++)
              s2 += JSON.stringify(a2[l2]) + ":" + t(e2[a2[l2]]) + ",";
            return s2 + "}";
          }
          function r(r2) {
            for (var i2 = "", o2 = 0, n2 = e.refProperties; o2 < n2.length; o2 += 1)
              i2 += "/" + t(r2[n2[o2]]);
            return i2;
          }
          var i = function(e2) {
            this.keyCache = {}, e2 && this.replace(e2);
          };
          i.prototype.replace = function(e2) {
            this._layerConfigs = {}, this._layers = {}, this.update(e2, []);
          }, i.prototype.update = function(t2, i2) {
            for (var o2 = this, n2 = 0, a2 = t2; n2 < a2.length; n2 += 1) {
              var s2 = a2[n2];
              this._layerConfigs[s2.id] = s2;
              var l2 = this._layers[s2.id] = e.createStyleLayer(s2);
              l2._featureFilter = e.featureFilter(l2.filter), this.keyCache[s2.id] && delete this.keyCache[s2.id];
            }
            for (var u2 = 0, h2 = i2; u2 < h2.length; u2 += 1) {
              var c2 = h2[u2];
              delete this.keyCache[c2], delete this._layerConfigs[c2], delete this._layers[c2];
            }
            this.familiesBySource = {};
            for (var p2 = 0, f2 = function(e2, t3) {
              for (var i3 = {}, o3 = 0; o3 < e2.length; o3++) {
                var n3 = t3 && t3[e2[o3].id] || r(e2[o3]);
                t3 && (t3[e2[o3].id] = n3);
                var a3 = i3[n3];
                a3 || (a3 = i3[n3] = []), a3.push(e2[o3]);
              }
              var s3 = [];
              for (var l3 in i3)
                s3.push(i3[l3]);
              return s3;
            }(e.values(this._layerConfigs), this.keyCache); p2 < f2.length; p2 += 1) {
              var d2 = f2[p2].map(function(e2) {
                return o2._layers[e2.id];
              }), g2 = d2[0];
              if ("none" !== g2.visibility) {
                var v2 = g2.source || "", m2 = this.familiesBySource[v2];
                m2 || (m2 = this.familiesBySource[v2] = {});
                var y2 = g2.sourceLayer || "_geojsonTileLayer", x2 = m2[y2];
                x2 || (x2 = m2[y2] = []), x2.push(d2);
              }
            }
          };
          var o = function(t2) {
            var r2 = {}, i2 = [];
            for (var o2 in t2) {
              var n2 = t2[o2], a2 = r2[o2] = {};
              for (var s2 in n2) {
                var l2 = n2[+s2];
                if (l2 && 0 !== l2.bitmap.width && 0 !== l2.bitmap.height) {
                  var u2 = { x: 0, y: 0, w: l2.bitmap.width + 2, h: l2.bitmap.height + 2 };
                  i2.push(u2), a2[s2] = { rect: u2, metrics: l2.metrics };
                }
              }
            }
            var h2 = e.potpack(i2), c2 = new e.AlphaImage({ width: h2.w || 1, height: h2.h || 1 });
            for (var p2 in t2) {
              var f2 = t2[p2];
              for (var d2 in f2) {
                var g2 = f2[+d2];
                if (g2 && 0 !== g2.bitmap.width && 0 !== g2.bitmap.height) {
                  var v2 = r2[p2][d2].rect;
                  e.AlphaImage.copy(g2.bitmap, c2, { x: 0, y: 0 }, { x: v2.x + 1, y: v2.y + 1 }, g2.bitmap);
                }
              }
            }
            this.image = c2, this.positions = r2;
          };
          e.register("GlyphAtlas", o);
          var n = function(t2) {
            this.tileID = new e.OverscaledTileID(t2.tileID.overscaledZ, t2.tileID.wrap, t2.tileID.canonical.z, t2.tileID.canonical.x, t2.tileID.canonical.y), this.uid = t2.uid, this.zoom = t2.zoom, this.pixelRatio = t2.pixelRatio, this.tileSize = t2.tileSize, this.source = t2.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t2.showCollisionBoxes, this.collectResourceTiming = !!t2.collectResourceTiming, this.returnDependencies = !!t2.returnDependencies, this.promoteId = t2.promoteId;
          };
          function a(t2, r2, i2) {
            for (var o2 = new e.EvaluationParameters(r2), n2 = 0, a2 = t2; n2 < a2.length; n2 += 1)
              a2[n2].recalculate(o2, i2);
          }
          function s(t2, r2) {
            var i2 = e.getArrayBuffer(t2.request, function(t3, i3, o2, n2) {
              t3 ? r2(t3) : i3 && r2(null, { vectorTile: new e.vectorTile.VectorTile(new e.pbf(i3)), rawData: i3, cacheControl: o2, expires: n2 });
            });
            return function() {
              i2.cancel(), r2();
            };
          }
          n.prototype.parse = function(t2, r2, i2, n2, s2) {
            var l2 = this;
            this.status = "parsing", this.data = t2, this.collisionBoxArray = new e.CollisionBoxArray();
            var u2 = new e.DictionaryCoder(Object.keys(t2.layers).sort()), h2 = new e.FeatureIndex(this.tileID, this.promoteId);
            h2.bucketLayerIDs = [];
            var c2, p2, f2, d2, g2 = {}, v2 = { featureIndex: h2, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: i2 }, m2 = r2.familiesBySource[this.source];
            for (var y2 in m2) {
              var x2 = t2.layers[y2];
              if (x2) {
                1 === x2.version && e.warnOnce('Vector tile source "' + this.source + '" layer "' + y2 + '" does not use vector tile spec v2 and therefore may have some rendering errors.');
                for (var w2 = u2.encode(y2), S2 = [], I2 = 0; I2 < x2.length; I2++) {
                  var M2 = x2.feature(I2), b2 = h2.getId(M2, y2);
                  S2.push({ feature: M2, id: b2, index: I2, sourceLayerIndex: w2 });
                }
                for (var _2 = 0, k2 = m2[y2]; _2 < k2.length; _2 += 1) {
                  var P2 = k2[_2], T2 = P2[0];
                  T2.minzoom && this.zoom < Math.floor(T2.minzoom) || T2.maxzoom && this.zoom >= T2.maxzoom || "none" !== T2.visibility && (a(P2, this.zoom, i2), (g2[T2.id] = T2.createBucket({ index: h2.bucketLayerIDs.length, layers: P2, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: w2, sourceID: this.source })).populate(S2, v2, this.tileID.canonical), h2.bucketLayerIDs.push(P2.map(function(e2) {
                    return e2.id;
                  })));
                }
              }
            }
            var C2 = e.mapObject(v2.glyphDependencies, function(e2) {
              return Object.keys(e2).map(Number);
            });
            Object.keys(C2).length ? n2.send("getGlyphs", { uid: this.uid, stacks: C2 }, function(e2, t3) {
              c2 || (c2 = e2, p2 = t3, z2.call(l2));
            }) : p2 = {};
            var D2 = Object.keys(v2.iconDependencies);
            D2.length ? n2.send("getImages", { icons: D2, source: this.source, tileID: this.tileID, type: "icons" }, function(e2, t3) {
              c2 || (c2 = e2, f2 = t3, z2.call(l2));
            }) : f2 = {};
            var L2 = Object.keys(v2.patternDependencies);
            function z2() {
              if (c2)
                return s2(c2);
              if (p2 && f2 && d2) {
                var t3 = new o(p2), r3 = new e.ImageAtlas(f2, d2);
                for (var n3 in g2) {
                  var l3 = g2[n3];
                  l3 instanceof e.SymbolBucket ? (a(l3.layers, this.zoom, i2), e.performSymbolLayout(l3, p2, t3.positions, f2, r3.iconPositions, this.showCollisionBoxes, this.tileID.canonical)) : l3.hasPattern && (l3 instanceof e.LineBucket || l3 instanceof e.FillBucket || l3 instanceof e.FillExtrusionBucket) && (a(l3.layers, this.zoom, i2), l3.addFeatures(v2, this.tileID.canonical, r3.patternPositions));
                }
                this.status = "done", s2(null, { buckets: e.values(g2).filter(function(e2) {
                  return !e2.isEmpty();
                }), featureIndex: h2, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t3.image, imageAtlas: r3, glyphMap: this.returnDependencies ? p2 : null, iconMap: this.returnDependencies ? f2 : null, glyphPositions: this.returnDependencies ? t3.positions : null });
              }
            }
            L2.length ? n2.send("getImages", { icons: L2, source: this.source, tileID: this.tileID, type: "patterns" }, function(e2, t3) {
              c2 || (c2 = e2, d2 = t3, z2.call(l2));
            }) : d2 = {}, z2.call(this);
          };
          var l = function(e2, t2, r2, i2) {
            this.actor = e2, this.layerIndex = t2, this.availableImages = r2, this.loadVectorData = i2 || s, this.loading = {}, this.loaded = {};
          };
          l.prototype.loadTile = function(t2, r2) {
            var i2 = this, o2 = t2.uid;
            this.loading || (this.loading = {});
            var a2 = !!(t2 && t2.request && t2.request.collectResourceTiming) && new e.RequestPerformance(t2.request), s2 = this.loading[o2] = new n(t2);
            s2.abort = this.loadVectorData(t2, function(t3, n2) {
              if (delete i2.loading[o2], t3 || !n2)
                return s2.status = "done", i2.loaded[o2] = s2, r2(t3);
              var l2 = n2.rawData, u2 = {};
              n2.expires && (u2.expires = n2.expires), n2.cacheControl && (u2.cacheControl = n2.cacheControl);
              var h2 = {};
              if (a2) {
                var c2 = a2.finish();
                c2 && (h2.resourceTiming = JSON.parse(JSON.stringify(c2)));
              }
              s2.vectorTile = n2.vectorTile, s2.parse(n2.vectorTile, i2.layerIndex, i2.availableImages, i2.actor, function(t4, i3) {
                if (t4 || !i3)
                  return r2(t4);
                r2(null, e.extend({ rawTileData: l2.slice(0) }, i3, u2, h2));
              }), i2.loaded = i2.loaded || {}, i2.loaded[o2] = s2;
            });
          }, l.prototype.reloadTile = function(e2, t2) {
            var r2 = this, i2 = this.loaded, o2 = e2.uid, n2 = this;
            if (i2 && i2[o2]) {
              var a2 = i2[o2];
              a2.showCollisionBoxes = e2.showCollisionBoxes;
              var s2 = function(e3, i3) {
                var o3 = a2.reloadCallback;
                o3 && (delete a2.reloadCallback, a2.parse(a2.vectorTile, n2.layerIndex, r2.availableImages, n2.actor, o3)), t2(e3, i3);
              };
              "parsing" === a2.status ? a2.reloadCallback = s2 : "done" === a2.status && (a2.vectorTile ? a2.parse(a2.vectorTile, this.layerIndex, this.availableImages, this.actor, s2) : s2());
            }
          }, l.prototype.abortTile = function(e2, t2) {
            var r2 = this.loading, i2 = e2.uid;
            r2 && r2[i2] && r2[i2].abort && (r2[i2].abort(), delete r2[i2]), t2();
          }, l.prototype.removeTile = function(e2, t2) {
            var r2 = this.loaded, i2 = e2.uid;
            r2 && r2[i2] && delete r2[i2], t2();
          };
          var u = e.window.ImageBitmap, h = function() {
            this.loaded = {};
          };
          function c(e2, t2) {
            if (0 !== e2.length) {
              p(e2[0], t2);
              for (var r2 = 1; r2 < e2.length; r2++)
                p(e2[r2], !t2);
            }
          }
          function p(e2, t2) {
            for (var r2 = 0, i2 = 0, o2 = 0, n2 = e2.length, a2 = n2 - 1; o2 < n2; a2 = o2++) {
              var s2 = (e2[o2][0] - e2[a2][0]) * (e2[a2][1] + e2[o2][1]), l2 = r2 + s2;
              i2 += Math.abs(r2) >= Math.abs(s2) ? r2 - l2 + s2 : s2 - l2 + r2, r2 = l2;
            }
            r2 + i2 >= 0 != !!t2 && e2.reverse();
          }
          h.prototype.loadTile = function(t2, r2) {
            var i2 = t2.uid, o2 = t2.encoding, n2 = t2.rawImageData, a2 = u && n2 instanceof u ? this.getImageData(n2) : n2, s2 = new e.DEMData(i2, a2, o2);
            this.loaded = this.loaded || {}, this.loaded[i2] = s2, r2(null, s2);
          }, h.prototype.getImageData = function(t2) {
            this.offscreenCanvas && this.offscreenCanvasContext || (this.offscreenCanvas = new OffscreenCanvas(t2.width, t2.height), this.offscreenCanvasContext = this.offscreenCanvas.getContext("2d")), this.offscreenCanvas.width = t2.width, this.offscreenCanvas.height = t2.height, this.offscreenCanvasContext.drawImage(t2, 0, 0, t2.width, t2.height);
            var r2 = this.offscreenCanvasContext.getImageData(-1, -1, t2.width + 2, t2.height + 2);
            return this.offscreenCanvasContext.clearRect(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height), new e.RGBAImage({ width: r2.width, height: r2.height }, r2.data);
          }, h.prototype.removeTile = function(e2) {
            var t2 = this.loaded, r2 = e2.uid;
            t2 && t2[r2] && delete t2[r2];
          };
          var f = e.vectorTile.VectorTileFeature.prototype.toGeoJSON, d = function(t2) {
            this._feature = t2, this.extent = e.EXTENT, this.type = t2.type, this.properties = t2.tags, "id" in t2 && !isNaN(t2.id) && (this.id = parseInt(t2.id, 10));
          };
          d.prototype.loadGeometry = function() {
            if (1 === this._feature.type) {
              for (var t2 = [], r2 = 0, i2 = this._feature.geometry; r2 < i2.length; r2 += 1) {
                var o2 = i2[r2];
                t2.push([new e.Point$1(o2[0], o2[1])]);
              }
              return t2;
            }
            for (var n2 = [], a2 = 0, s2 = this._feature.geometry; a2 < s2.length; a2 += 1) {
              for (var l2 = [], u2 = 0, h2 = s2[a2]; u2 < h2.length; u2 += 1) {
                var c2 = h2[u2];
                l2.push(new e.Point$1(c2[0], c2[1]));
              }
              n2.push(l2);
            }
            return n2;
          }, d.prototype.toGeoJSON = function(e2, t2, r2) {
            return f.call(this, e2, t2, r2);
          };
          var g = function(t2) {
            this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e.EXTENT, this.length = t2.length, this._features = t2;
          };
          g.prototype.feature = function(e2) {
            return new d(this._features[e2]);
          };
          var v = e.vectorTile.VectorTileFeature, m = y;
          function y(e2, t2) {
            this.options = t2 || {}, this.features = e2, this.length = e2.length;
          }
          function x(e2, t2) {
            this.id = "number" == typeof e2.id ? e2.id : void 0, this.type = e2.type, this.rawGeometry = 1 === e2.type ? [e2.geometry] : e2.geometry, this.properties = e2.tags, this.extent = t2 || 4096;
          }
          y.prototype.feature = function(e2) {
            return new x(this.features[e2], this.options.extent);
          }, x.prototype.loadGeometry = function() {
            var t2 = this.rawGeometry;
            this.geometry = [];
            for (var r2 = 0; r2 < t2.length; r2++) {
              for (var i2 = t2[r2], o2 = [], n2 = 0; n2 < i2.length; n2++)
                o2.push(new e.Point$1(i2[n2][0], i2[n2][1]));
              this.geometry.push(o2);
            }
            return this.geometry;
          }, x.prototype.bbox = function() {
            this.geometry || this.loadGeometry();
            for (var e2 = this.geometry, t2 = 1 / 0, r2 = -1 / 0, i2 = 1 / 0, o2 = -1 / 0, n2 = 0; n2 < e2.length; n2++)
              for (var a2 = e2[n2], s2 = 0; s2 < a2.length; s2++) {
                var l2 = a2[s2];
                t2 = Math.min(t2, l2.x), r2 = Math.max(r2, l2.x), i2 = Math.min(i2, l2.y), o2 = Math.max(o2, l2.y);
              }
            return [t2, i2, r2, o2];
          }, x.prototype.toGeoJSON = v.prototype.toGeoJSON;
          var w = I, S = m;
          function I(t2) {
            var r2 = new e.pbf();
            return function(e2, t3) {
              for (var r3 in e2.layers)
                t3.writeMessage(3, M, e2.layers[r3]);
            }(t2, r2), r2.finish();
          }
          function M(e2, t2) {
            var r2;
            t2.writeVarintField(15, e2.version || 1), t2.writeStringField(1, e2.name || ""), t2.writeVarintField(5, e2.extent || 4096);
            var i2 = { keys: [], values: [], keycache: {}, valuecache: {} };
            for (r2 = 0; r2 < e2.length; r2++)
              i2.feature = e2.feature(r2), t2.writeMessage(2, b, i2);
            var o2 = i2.keys;
            for (r2 = 0; r2 < o2.length; r2++)
              t2.writeStringField(3, o2[r2]);
            var n2 = i2.values;
            for (r2 = 0; r2 < n2.length; r2++)
              t2.writeMessage(4, C, n2[r2]);
          }
          function b(e2, t2) {
            var r2 = e2.feature;
            void 0 !== r2.id && t2.writeVarintField(1, r2.id), t2.writeMessage(2, _, e2), t2.writeVarintField(3, r2.type), t2.writeMessage(4, T, r2);
          }
          function _(e2, t2) {
            var r2 = e2.feature, i2 = e2.keys, o2 = e2.values, n2 = e2.keycache, a2 = e2.valuecache;
            for (var s2 in r2.properties) {
              var l2 = n2[s2];
              void 0 === l2 && (i2.push(s2), n2[s2] = l2 = i2.length - 1), t2.writeVarint(l2);
              var u2 = r2.properties[s2], h2 = typeof u2;
              "string" !== h2 && "boolean" !== h2 && "number" !== h2 && (u2 = JSON.stringify(u2));
              var c2 = h2 + ":" + u2, p2 = a2[c2];
              void 0 === p2 && (o2.push(u2), a2[c2] = p2 = o2.length - 1), t2.writeVarint(p2);
            }
          }
          function k(e2, t2) {
            return (t2 << 3) + (7 & e2);
          }
          function P(e2) {
            return e2 << 1 ^ e2 >> 31;
          }
          function T(e2, t2) {
            for (var r2 = e2.loadGeometry(), i2 = e2.type, o2 = 0, n2 = 0, a2 = r2.length, s2 = 0; s2 < a2; s2++) {
              var l2 = r2[s2], u2 = 1;
              1 === i2 && (u2 = l2.length), t2.writeVarint(k(1, u2));
              for (var h2 = 3 === i2 ? l2.length - 1 : l2.length, c2 = 0; c2 < h2; c2++) {
                1 === c2 && 1 !== i2 && t2.writeVarint(k(2, h2 - 1));
                var p2 = l2[c2].x - o2, f2 = l2[c2].y - n2;
                t2.writeVarint(P(p2)), t2.writeVarint(P(f2)), o2 += p2, n2 += f2;
              }
              3 === i2 && t2.writeVarint(k(7, 1));
            }
          }
          function C(e2, t2) {
            var r2 = typeof e2;
            "string" === r2 ? t2.writeStringField(1, e2) : "boolean" === r2 ? t2.writeBooleanField(7, e2) : "number" === r2 && (e2 % 1 != 0 ? t2.writeDoubleField(3, e2) : e2 < 0 ? t2.writeSVarintField(6, e2) : t2.writeVarintField(5, e2));
          }
          function D(e2, t2, r2, i2) {
            L(e2, r2, i2), L(t2, 2 * r2, 2 * i2), L(t2, 2 * r2 + 1, 2 * i2 + 1);
          }
          function L(e2, t2, r2) {
            var i2 = e2[t2];
            e2[t2] = e2[r2], e2[r2] = i2;
          }
          function z(e2, t2, r2, i2) {
            var o2 = e2 - r2, n2 = t2 - i2;
            return o2 * o2 + n2 * n2;
          }
          w.fromVectorTileJs = I, w.fromGeojsonVt = function(e2, t2) {
            t2 = t2 || {};
            var r2 = {};
            for (var i2 in e2)
              r2[i2] = new m(e2[i2].features, t2), r2[i2].name = i2, r2[i2].version = t2.version, r2[i2].extent = t2.extent;
            return I({ layers: r2 });
          }, w.GeoJSONWrapper = S;
          var O = function(e2) {
            return e2[0];
          }, E = function(e2) {
            return e2[1];
          }, F = function(e2, t2, r2, i2, o2) {
            void 0 === t2 && (t2 = O), void 0 === r2 && (r2 = E), void 0 === i2 && (i2 = 64), void 0 === o2 && (o2 = Float64Array), this.nodeSize = i2, this.points = e2;
            for (var n2 = e2.length < 65536 ? Uint16Array : Uint32Array, a2 = this.ids = new n2(e2.length), s2 = this.coords = new o2(2 * e2.length), l2 = 0; l2 < e2.length; l2++)
              a2[l2] = l2, s2[2 * l2] = t2(e2[l2]), s2[2 * l2 + 1] = r2(e2[l2]);
            !function e3(t3, r3, i3, o3, n3, a3) {
              if (!(n3 - o3 <= i3)) {
                var s3 = o3 + n3 >> 1;
                !function e4(t4, r4, i4, o4, n4, a4) {
                  for (; n4 > o4; ) {
                    if (n4 - o4 > 600) {
                      var s4 = n4 - o4 + 1, l3 = i4 - o4 + 1, u2 = Math.log(s4), h2 = 0.5 * Math.exp(2 * u2 / 3), c2 = 0.5 * Math.sqrt(u2 * h2 * (s4 - h2) / s4) * (l3 - s4 / 2 < 0 ? -1 : 1);
                      e4(t4, r4, i4, Math.max(o4, Math.floor(i4 - l3 * h2 / s4 + c2)), Math.min(n4, Math.floor(i4 + (s4 - l3) * h2 / s4 + c2)), a4);
                    }
                    var p2 = r4[2 * i4 + a4], f2 = o4, d2 = n4;
                    for (D(t4, r4, o4, i4), r4[2 * n4 + a4] > p2 && D(t4, r4, o4, n4); f2 < d2; ) {
                      for (D(t4, r4, f2, d2), f2++, d2--; r4[2 * f2 + a4] < p2; )
                        f2++;
                      for (; r4[2 * d2 + a4] > p2; )
                        d2--;
                    }
                    r4[2 * o4 + a4] === p2 ? D(t4, r4, o4, d2) : D(t4, r4, ++d2, n4), d2 <= i4 && (o4 = d2 + 1), i4 <= d2 && (n4 = d2 - 1);
                  }
                }(t3, r3, s3, o3, n3, a3 % 2), e3(t3, r3, i3, o3, s3 - 1, a3 + 1), e3(t3, r3, i3, s3 + 1, n3, a3 + 1);
              }
            }(a2, s2, i2, 0, a2.length - 1, 0);
          };
          F.prototype.range = function(e2, t2, r2, i2) {
            return function(e3, t3, r3, i3, o2, n2, a2) {
              for (var s2, l2, u2 = [0, e3.length - 1, 0], h2 = []; u2.length; ) {
                var c2 = u2.pop(), p2 = u2.pop(), f2 = u2.pop();
                if (p2 - f2 <= a2)
                  for (var d2 = f2; d2 <= p2; d2++)
                    l2 = t3[2 * d2 + 1], (s2 = t3[2 * d2]) >= r3 && s2 <= o2 && l2 >= i3 && l2 <= n2 && h2.push(e3[d2]);
                else {
                  var g2 = Math.floor((f2 + p2) / 2);
                  l2 = t3[2 * g2 + 1], (s2 = t3[2 * g2]) >= r3 && s2 <= o2 && l2 >= i3 && l2 <= n2 && h2.push(e3[g2]);
                  var v2 = (c2 + 1) % 2;
                  (0 === c2 ? r3 <= s2 : i3 <= l2) && (u2.push(f2), u2.push(g2 - 1), u2.push(v2)), (0 === c2 ? o2 >= s2 : n2 >= l2) && (u2.push(g2 + 1), u2.push(p2), u2.push(v2));
                }
              }
              return h2;
            }(this.ids, this.coords, e2, t2, r2, i2, this.nodeSize);
          }, F.prototype.within = function(e2, t2, r2) {
            return function(e3, t3, r3, i2, o2, n2) {
              for (var a2 = [0, e3.length - 1, 0], s2 = [], l2 = o2 * o2; a2.length; ) {
                var u2 = a2.pop(), h2 = a2.pop(), c2 = a2.pop();
                if (h2 - c2 <= n2)
                  for (var p2 = c2; p2 <= h2; p2++)
                    z(t3[2 * p2], t3[2 * p2 + 1], r3, i2) <= l2 && s2.push(e3[p2]);
                else {
                  var f2 = Math.floor((c2 + h2) / 2), d2 = t3[2 * f2], g2 = t3[2 * f2 + 1];
                  z(d2, g2, r3, i2) <= l2 && s2.push(e3[f2]);
                  var v2 = (u2 + 1) % 2;
                  (0 === u2 ? r3 - o2 <= d2 : i2 - o2 <= g2) && (a2.push(c2), a2.push(f2 - 1), a2.push(v2)), (0 === u2 ? r3 + o2 >= d2 : i2 + o2 >= g2) && (a2.push(f2 + 1), a2.push(h2), a2.push(v2));
                }
              }
              return s2;
            }(this.ids, this.coords, e2, t2, r2, this.nodeSize);
          };
          var N = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: function(e2) {
            return e2;
          } }, J = function(e2) {
            this.options = V(Object.create(N), e2), this.trees = new Array(this.options.maxZoom + 1);
          };
          function Z(e2, t2, r2, i2, o2) {
            return { x: e2, y: t2, zoom: 1 / 0, id: r2, parentId: -1, numPoints: i2, properties: o2 };
          }
          function A(e2, t2) {
            var r2 = e2.geometry.coordinates, i2 = r2[1];
            return { x: Y(r2[0]), y: j(i2), zoom: 1 / 0, index: t2, parentId: -1 };
          }
          function B(e2) {
            return { type: "Feature", id: e2.id, properties: G(e2), geometry: { type: "Point", coordinates: [(i2 = e2.x, 360 * (i2 - 0.5)), (t2 = e2.y, r2 = (180 - 360 * t2) * Math.PI / 180, 360 * Math.atan(Math.exp(r2)) / Math.PI - 90)] } };
            var t2, r2, i2;
          }
          function G(e2) {
            var t2 = e2.numPoints, r2 = t2 >= 1e4 ? Math.round(t2 / 1e3) + "k" : t2 >= 1e3 ? Math.round(t2 / 100) / 10 + "k" : t2;
            return V(V({}, e2.properties), { cluster: true, cluster_id: e2.id, point_count: t2, point_count_abbreviated: r2 });
          }
          function Y(e2) {
            return e2 / 360 + 0.5;
          }
          function j(e2) {
            var t2 = Math.sin(e2 * Math.PI / 180), r2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
            return r2 < 0 ? 0 : r2 > 1 ? 1 : r2;
          }
          function V(e2, t2) {
            for (var r2 in t2)
              e2[r2] = t2[r2];
            return e2;
          }
          function X(e2) {
            return e2.x;
          }
          function W(e2) {
            return e2.y;
          }
          function R(e2, t2, r2, i2, o2, n2) {
            var a2 = o2 - r2, s2 = n2 - i2;
            if (0 !== a2 || 0 !== s2) {
              var l2 = ((e2 - r2) * a2 + (t2 - i2) * s2) / (a2 * a2 + s2 * s2);
              l2 > 1 ? (r2 = o2, i2 = n2) : l2 > 0 && (r2 += a2 * l2, i2 += s2 * l2);
            }
            return (a2 = e2 - r2) * a2 + (s2 = t2 - i2) * s2;
          }
          function q(e2, t2, r2, i2) {
            var o2 = { id: void 0 === e2 ? null : e2, type: t2, geometry: r2, tags: i2, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
            return function(e3) {
              var t3 = e3.geometry, r3 = e3.type;
              if ("Point" === r3 || "MultiPoint" === r3 || "LineString" === r3)
                U(e3, t3);
              else if ("Polygon" === r3 || "MultiLineString" === r3)
                for (var i3 = 0; i3 < t3.length; i3++)
                  U(e3, t3[i3]);
              else if ("MultiPolygon" === r3)
                for (i3 = 0; i3 < t3.length; i3++)
                  for (var o3 = 0; o3 < t3[i3].length; o3++)
                    U(e3, t3[i3][o3]);
            }(o2), o2;
          }
          function U(e2, t2) {
            for (var r2 = 0; r2 < t2.length; r2 += 3)
              e2.minX = Math.min(e2.minX, t2[r2]), e2.minY = Math.min(e2.minY, t2[r2 + 1]), e2.maxX = Math.max(e2.maxX, t2[r2]), e2.maxY = Math.max(e2.maxY, t2[r2 + 1]);
          }
          function $(e2, t2, r2, i2) {
            if (t2.geometry) {
              var o2 = t2.geometry.coordinates, n2 = t2.geometry.type, a2 = Math.pow(r2.tolerance / ((1 << r2.maxZoom) * r2.extent), 2), s2 = [], l2 = t2.id;
              if (r2.promoteId ? l2 = t2.properties[r2.promoteId] : r2.generateId && (l2 = i2 || 0), "Point" === n2)
                H(o2, s2);
              else if ("MultiPoint" === n2)
                for (var u2 = 0; u2 < o2.length; u2++)
                  H(o2[u2], s2);
              else if ("LineString" === n2)
                K(o2, s2, a2, false);
              else if ("MultiLineString" === n2) {
                if (r2.lineMetrics) {
                  for (u2 = 0; u2 < o2.length; u2++)
                    K(o2[u2], s2 = [], a2, false), e2.push(q(l2, "LineString", s2, t2.properties));
                  return;
                }
                Q(o2, s2, a2, false);
              } else if ("Polygon" === n2)
                Q(o2, s2, a2, true);
              else {
                if ("MultiPolygon" !== n2) {
                  if ("GeometryCollection" === n2) {
                    for (u2 = 0; u2 < t2.geometry.geometries.length; u2++)
                      $(e2, { id: l2, geometry: t2.geometry.geometries[u2], properties: t2.properties }, r2, i2);
                    return;
                  }
                  throw new Error("Input data is not a valid GeoJSON object.");
                }
                for (u2 = 0; u2 < o2.length; u2++) {
                  var h2 = [];
                  Q(o2[u2], h2, a2, true), s2.push(h2);
                }
              }
              e2.push(q(l2, n2, s2, t2.properties));
            }
          }
          function H(e2, t2) {
            t2.push(ee(e2[0])), t2.push(te(e2[1])), t2.push(0);
          }
          function K(e2, t2, r2, i2) {
            for (var o2, n2, a2 = 0, s2 = 0; s2 < e2.length; s2++) {
              var l2 = ee(e2[s2][0]), u2 = te(e2[s2][1]);
              t2.push(l2), t2.push(u2), t2.push(0), s2 > 0 && (a2 += i2 ? (o2 * u2 - l2 * n2) / 2 : Math.sqrt(Math.pow(l2 - o2, 2) + Math.pow(u2 - n2, 2))), o2 = l2, n2 = u2;
            }
            var h2 = t2.length - 3;
            t2[2] = 1, function e3(t3, r3, i3, o3) {
              for (var n3, a3 = o3, s3 = i3 - r3 >> 1, l3 = i3 - r3, u3 = t3[r3], h3 = t3[r3 + 1], c2 = t3[i3], p2 = t3[i3 + 1], f2 = r3 + 3; f2 < i3; f2 += 3) {
                var d2 = R(t3[f2], t3[f2 + 1], u3, h3, c2, p2);
                if (d2 > a3)
                  n3 = f2, a3 = d2;
                else if (d2 === a3) {
                  var g2 = Math.abs(f2 - s3);
                  g2 < l3 && (n3 = f2, l3 = g2);
                }
              }
              a3 > o3 && (n3 - r3 > 3 && e3(t3, r3, n3, o3), t3[n3 + 2] = a3, i3 - n3 > 3 && e3(t3, n3, i3, o3));
            }(t2, 0, h2, r2), t2[h2 + 2] = 1, t2.size = Math.abs(a2), t2.start = 0, t2.end = t2.size;
          }
          function Q(e2, t2, r2, i2) {
            for (var o2 = 0; o2 < e2.length; o2++) {
              var n2 = [];
              K(e2[o2], n2, r2, i2), t2.push(n2);
            }
          }
          function ee(e2) {
            return e2 / 360 + 0.5;
          }
          function te(e2) {
            var t2 = Math.sin(e2 * Math.PI / 180), r2 = 0.5 - 0.25 * Math.log((1 + t2) / (1 - t2)) / Math.PI;
            return r2 < 0 ? 0 : r2 > 1 ? 1 : r2;
          }
          function re(e2, t2, r2, i2, o2, n2, a2, s2) {
            if (i2 /= t2, n2 >= (r2 /= t2) && a2 < i2)
              return e2;
            if (a2 < r2 || n2 >= i2)
              return null;
            for (var l2 = [], u2 = 0; u2 < e2.length; u2++) {
              var h2 = e2[u2], c2 = h2.geometry, p2 = h2.type, f2 = 0 === o2 ? h2.minX : h2.minY, d2 = 0 === o2 ? h2.maxX : h2.maxY;
              if (f2 >= r2 && d2 < i2)
                l2.push(h2);
              else if (!(d2 < r2 || f2 >= i2)) {
                var g2 = [];
                if ("Point" === p2 || "MultiPoint" === p2)
                  ie(c2, g2, r2, i2, o2);
                else if ("LineString" === p2)
                  oe(c2, g2, r2, i2, o2, false, s2.lineMetrics);
                else if ("MultiLineString" === p2)
                  ae(c2, g2, r2, i2, o2, false);
                else if ("Polygon" === p2)
                  ae(c2, g2, r2, i2, o2, true);
                else if ("MultiPolygon" === p2)
                  for (var v2 = 0; v2 < c2.length; v2++) {
                    var m2 = [];
                    ae(c2[v2], m2, r2, i2, o2, true), m2.length && g2.push(m2);
                  }
                if (g2.length) {
                  if (s2.lineMetrics && "LineString" === p2) {
                    for (v2 = 0; v2 < g2.length; v2++)
                      l2.push(q(h2.id, p2, g2[v2], h2.tags));
                    continue;
                  }
                  "LineString" !== p2 && "MultiLineString" !== p2 || (1 === g2.length ? (p2 = "LineString", g2 = g2[0]) : p2 = "MultiLineString"), "Point" !== p2 && "MultiPoint" !== p2 || (p2 = 3 === g2.length ? "Point" : "MultiPoint"), l2.push(q(h2.id, p2, g2, h2.tags));
                }
              }
            }
            return l2.length ? l2 : null;
          }
          function ie(e2, t2, r2, i2, o2) {
            for (var n2 = 0; n2 < e2.length; n2 += 3) {
              var a2 = e2[n2 + o2];
              a2 >= r2 && a2 <= i2 && (t2.push(e2[n2]), t2.push(e2[n2 + 1]), t2.push(e2[n2 + 2]));
            }
          }
          function oe(e2, t2, r2, i2, o2, n2, a2) {
            for (var s2, l2, u2 = ne(e2), h2 = 0 === o2 ? le : ue, c2 = e2.start, p2 = 0; p2 < e2.length - 3; p2 += 3) {
              var f2 = e2[p2], d2 = e2[p2 + 1], g2 = e2[p2 + 2], v2 = e2[p2 + 3], m2 = e2[p2 + 4], y2 = 0 === o2 ? f2 : d2, x2 = 0 === o2 ? v2 : m2, w2 = false;
              a2 && (s2 = Math.sqrt(Math.pow(f2 - v2, 2) + Math.pow(d2 - m2, 2))), y2 < r2 ? x2 > r2 && (l2 = h2(u2, f2, d2, v2, m2, r2), a2 && (u2.start = c2 + s2 * l2)) : y2 > i2 ? x2 < i2 && (l2 = h2(u2, f2, d2, v2, m2, i2), a2 && (u2.start = c2 + s2 * l2)) : se(u2, f2, d2, g2), x2 < r2 && y2 >= r2 && (l2 = h2(u2, f2, d2, v2, m2, r2), w2 = true), x2 > i2 && y2 <= i2 && (l2 = h2(u2, f2, d2, v2, m2, i2), w2 = true), !n2 && w2 && (a2 && (u2.end = c2 + s2 * l2), t2.push(u2), u2 = ne(e2)), a2 && (c2 += s2);
            }
            var S2 = e2.length - 3;
            f2 = e2[S2], d2 = e2[S2 + 1], g2 = e2[S2 + 2], (y2 = 0 === o2 ? f2 : d2) >= r2 && y2 <= i2 && se(u2, f2, d2, g2), S2 = u2.length - 3, n2 && S2 >= 3 && (u2[S2] !== u2[0] || u2[S2 + 1] !== u2[1]) && se(u2, u2[0], u2[1], u2[2]), u2.length && t2.push(u2);
          }
          function ne(e2) {
            var t2 = [];
            return t2.size = e2.size, t2.start = e2.start, t2.end = e2.end, t2;
          }
          function ae(e2, t2, r2, i2, o2, n2) {
            for (var a2 = 0; a2 < e2.length; a2++)
              oe(e2[a2], t2, r2, i2, o2, n2, false);
          }
          function se(e2, t2, r2, i2) {
            e2.push(t2), e2.push(r2), e2.push(i2);
          }
          function le(e2, t2, r2, i2, o2, n2) {
            var a2 = (n2 - t2) / (i2 - t2);
            return e2.push(n2), e2.push(r2 + (o2 - r2) * a2), e2.push(1), a2;
          }
          function ue(e2, t2, r2, i2, o2, n2) {
            var a2 = (n2 - r2) / (o2 - r2);
            return e2.push(t2 + (i2 - t2) * a2), e2.push(n2), e2.push(1), a2;
          }
          function he(e2, t2) {
            for (var r2 = [], i2 = 0; i2 < e2.length; i2++) {
              var o2, n2 = e2[i2], a2 = n2.type;
              if ("Point" === a2 || "MultiPoint" === a2 || "LineString" === a2)
                o2 = ce(n2.geometry, t2);
              else if ("MultiLineString" === a2 || "Polygon" === a2) {
                o2 = [];
                for (var s2 = 0; s2 < n2.geometry.length; s2++)
                  o2.push(ce(n2.geometry[s2], t2));
              } else if ("MultiPolygon" === a2)
                for (o2 = [], s2 = 0; s2 < n2.geometry.length; s2++) {
                  for (var l2 = [], u2 = 0; u2 < n2.geometry[s2].length; u2++)
                    l2.push(ce(n2.geometry[s2][u2], t2));
                  o2.push(l2);
                }
              r2.push(q(n2.id, a2, o2, n2.tags));
            }
            return r2;
          }
          function ce(e2, t2) {
            var r2 = [];
            r2.size = e2.size, void 0 !== e2.start && (r2.start = e2.start, r2.end = e2.end);
            for (var i2 = 0; i2 < e2.length; i2 += 3)
              r2.push(e2[i2] + t2, e2[i2 + 1], e2[i2 + 2]);
            return r2;
          }
          function pe(e2, t2) {
            if (e2.transformed)
              return e2;
            var r2, i2, o2, n2 = 1 << e2.z, a2 = e2.x, s2 = e2.y;
            for (r2 = 0; r2 < e2.features.length; r2++) {
              var l2 = e2.features[r2], u2 = l2.geometry, h2 = l2.type;
              if (l2.geometry = [], 1 === h2)
                for (i2 = 0; i2 < u2.length; i2 += 2)
                  l2.geometry.push(fe(u2[i2], u2[i2 + 1], t2, n2, a2, s2));
              else
                for (i2 = 0; i2 < u2.length; i2++) {
                  var c2 = [];
                  for (o2 = 0; o2 < u2[i2].length; o2 += 2)
                    c2.push(fe(u2[i2][o2], u2[i2][o2 + 1], t2, n2, a2, s2));
                  l2.geometry.push(c2);
                }
            }
            return e2.transformed = true, e2;
          }
          function fe(e2, t2, r2, i2, o2, n2) {
            return [Math.round(r2 * (e2 * i2 - o2)), Math.round(r2 * (t2 * i2 - n2))];
          }
          function de(e2, t2, r2, i2, o2) {
            for (var n2 = t2 === o2.maxZoom ? 0 : o2.tolerance / ((1 << t2) * o2.extent), a2 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: r2, y: i2, z: t2, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, s2 = 0; s2 < e2.length; s2++) {
              a2.numFeatures++, ge(a2, e2[s2], n2, o2);
              var l2 = e2[s2].minX, u2 = e2[s2].minY, h2 = e2[s2].maxX, c2 = e2[s2].maxY;
              l2 < a2.minX && (a2.minX = l2), u2 < a2.minY && (a2.minY = u2), h2 > a2.maxX && (a2.maxX = h2), c2 > a2.maxY && (a2.maxY = c2);
            }
            return a2;
          }
          function ge(e2, t2, r2, i2) {
            var o2 = t2.geometry, n2 = t2.type, a2 = [];
            if ("Point" === n2 || "MultiPoint" === n2)
              for (var s2 = 0; s2 < o2.length; s2 += 3)
                a2.push(o2[s2]), a2.push(o2[s2 + 1]), e2.numPoints++, e2.numSimplified++;
            else if ("LineString" === n2)
              ve(a2, o2, e2, r2, false, false);
            else if ("MultiLineString" === n2 || "Polygon" === n2)
              for (s2 = 0; s2 < o2.length; s2++)
                ve(a2, o2[s2], e2, r2, "Polygon" === n2, 0 === s2);
            else if ("MultiPolygon" === n2)
              for (var l2 = 0; l2 < o2.length; l2++) {
                var u2 = o2[l2];
                for (s2 = 0; s2 < u2.length; s2++)
                  ve(a2, u2[s2], e2, r2, true, 0 === s2);
              }
            if (a2.length) {
              var h2 = t2.tags || null;
              if ("LineString" === n2 && i2.lineMetrics) {
                for (var c2 in h2 = {}, t2.tags)
                  h2[c2] = t2.tags[c2];
                h2.mapbox_clip_start = o2.start / o2.size, h2.mapbox_clip_end = o2.end / o2.size;
              }
              var p2 = { geometry: a2, type: "Polygon" === n2 || "MultiPolygon" === n2 ? 3 : "LineString" === n2 || "MultiLineString" === n2 ? 2 : 1, tags: h2 };
              null !== t2.id && (p2.id = t2.id), e2.features.push(p2);
            }
          }
          function ve(e2, t2, r2, i2, o2, n2) {
            var a2 = i2 * i2;
            if (i2 > 0 && t2.size < (o2 ? a2 : i2))
              r2.numPoints += t2.length / 3;
            else {
              for (var s2 = [], l2 = 0; l2 < t2.length; l2 += 3)
                (0 === i2 || t2[l2 + 2] > a2) && (r2.numSimplified++, s2.push(t2[l2]), s2.push(t2[l2 + 1])), r2.numPoints++;
              o2 && function(e3, t3) {
                for (var r3 = 0, i3 = 0, o3 = e3.length, n3 = o3 - 2; i3 < o3; n3 = i3, i3 += 2)
                  r3 += (e3[i3] - e3[n3]) * (e3[i3 + 1] + e3[n3 + 1]);
                if (r3 > 0 === t3)
                  for (i3 = 0, o3 = e3.length; i3 < o3 / 2; i3 += 2) {
                    var a3 = e3[i3], s3 = e3[i3 + 1];
                    e3[i3] = e3[o3 - 2 - i3], e3[i3 + 1] = e3[o3 - 1 - i3], e3[o3 - 2 - i3] = a3, e3[o3 - 1 - i3] = s3;
                  }
              }(s2, n2), e2.push(s2);
            }
          }
          function me(e2, t2) {
            var r2 = (t2 = this.options = function(e3, t3) {
              for (var r3 in t3)
                e3[r3] = t3[r3];
              return e3;
            }(Object.create(this.options), t2)).debug;
            if (r2 && console.time("preprocess data"), t2.maxZoom < 0 || t2.maxZoom > 24)
              throw new Error("maxZoom should be in the 0-24 range");
            if (t2.promoteId && t2.generateId)
              throw new Error("promoteId and generateId cannot be used together.");
            var i2 = function(e3, t3) {
              var r3 = [];
              if ("FeatureCollection" === e3.type)
                for (var i3 = 0; i3 < e3.features.length; i3++)
                  $(r3, e3.features[i3], t3, i3);
              else
                $(r3, "Feature" === e3.type ? e3 : { geometry: e3 }, t3);
              return r3;
            }(e2, t2);
            this.tiles = {}, this.tileCoords = [], r2 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t2.indexMaxZoom, t2.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), (i2 = function(e3, t3) {
              var r3 = t3.buffer / t3.extent, i3 = e3, o2 = re(e3, 1, -1 - r3, r3, 0, -1, 2, t3), n2 = re(e3, 1, 1 - r3, 2 + r3, 0, -1, 2, t3);
              return (o2 || n2) && (i3 = re(e3, 1, -r3, 1 + r3, 0, -1, 2, t3) || [], o2 && (i3 = he(o2, 1).concat(i3)), n2 && (i3 = i3.concat(he(n2, -1)))), i3;
            }(i2, t2)).length && this.splitTile(i2, 0, 0, 0), r2 && (i2.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          function ye(e2, t2, r2) {
            return 32 * ((1 << e2) * r2 + t2) + e2;
          }
          function xe(e2, t2) {
            var r2 = e2.tileID.canonical;
            if (!this._geoJSONIndex)
              return t2(null, null);
            var i2 = this._geoJSONIndex.getTile(r2.z, r2.x, r2.y);
            if (!i2)
              return t2(null, null);
            var o2 = new g(i2.features), n2 = w(o2);
            0 === n2.byteOffset && n2.byteLength === n2.buffer.byteLength || (n2 = new Uint8Array(n2)), t2(null, { vectorTile: o2, rawData: n2.buffer });
          }
          J.prototype.load = function(e2) {
            var t2 = this.options, r2 = t2.log, i2 = t2.minZoom, o2 = t2.maxZoom, n2 = t2.nodeSize;
            r2 && console.time("total time");
            var a2 = "prepare " + e2.length + " points";
            r2 && console.time(a2), this.points = e2;
            for (var s2 = [], l2 = 0; l2 < e2.length; l2++)
              e2[l2].geometry && s2.push(A(e2[l2], l2));
            this.trees[o2 + 1] = new F(s2, X, W, n2, Float32Array), r2 && console.timeEnd(a2);
            for (var u2 = o2; u2 >= i2; u2--) {
              var h2 = +Date.now();
              s2 = this._cluster(s2, u2), this.trees[u2] = new F(s2, X, W, n2, Float32Array), r2 && console.log("z%d: %d clusters in %dms", u2, s2.length, +Date.now() - h2);
            }
            return r2 && console.timeEnd("total time"), this;
          }, J.prototype.getClusters = function(e2, t2) {
            var r2 = ((e2[0] + 180) % 360 + 360) % 360 - 180, i2 = Math.max(-90, Math.min(90, e2[1])), o2 = 180 === e2[2] ? 180 : ((e2[2] + 180) % 360 + 360) % 360 - 180, n2 = Math.max(-90, Math.min(90, e2[3]));
            if (e2[2] - e2[0] >= 360)
              r2 = -180, o2 = 180;
            else if (r2 > o2) {
              var a2 = this.getClusters([r2, i2, 180, n2], t2), s2 = this.getClusters([-180, i2, o2, n2], t2);
              return a2.concat(s2);
            }
            for (var l2 = this.trees[this._limitZoom(t2)], u2 = [], h2 = 0, c2 = l2.range(Y(r2), j(n2), Y(o2), j(i2)); h2 < c2.length; h2 += 1) {
              var p2 = l2.points[c2[h2]];
              u2.push(p2.numPoints ? B(p2) : this.points[p2.index]);
            }
            return u2;
          }, J.prototype.getChildren = function(e2) {
            var t2 = this._getOriginId(e2), r2 = this._getOriginZoom(e2), i2 = "No cluster with the specified id.", o2 = this.trees[r2];
            if (!o2)
              throw new Error(i2);
            var n2 = o2.points[t2];
            if (!n2)
              throw new Error(i2);
            for (var a2 = this.options.radius / (this.options.extent * Math.pow(2, r2 - 1)), s2 = [], l2 = 0, u2 = o2.within(n2.x, n2.y, a2); l2 < u2.length; l2 += 1) {
              var h2 = o2.points[u2[l2]];
              h2.parentId === e2 && s2.push(h2.numPoints ? B(h2) : this.points[h2.index]);
            }
            if (0 === s2.length)
              throw new Error(i2);
            return s2;
          }, J.prototype.getLeaves = function(e2, t2, r2) {
            var i2 = [];
            return this._appendLeaves(i2, e2, t2 = t2 || 10, r2 = r2 || 0, 0), i2;
          }, J.prototype.getTile = function(e2, t2, r2) {
            var i2 = this.trees[this._limitZoom(e2)], o2 = Math.pow(2, e2), n2 = this.options, a2 = n2.radius / n2.extent, s2 = (r2 - a2) / o2, l2 = (r2 + 1 + a2) / o2, u2 = { features: [] };
            return this._addTileFeatures(i2.range((t2 - a2) / o2, s2, (t2 + 1 + a2) / o2, l2), i2.points, t2, r2, o2, u2), 0 === t2 && this._addTileFeatures(i2.range(1 - a2 / o2, s2, 1, l2), i2.points, o2, r2, o2, u2), t2 === o2 - 1 && this._addTileFeatures(i2.range(0, s2, a2 / o2, l2), i2.points, -1, r2, o2, u2), u2.features.length ? u2 : null;
          }, J.prototype.getClusterExpansionZoom = function(e2) {
            for (var t2 = this._getOriginZoom(e2) - 1; t2 <= this.options.maxZoom; ) {
              var r2 = this.getChildren(e2);
              if (t2++, 1 !== r2.length)
                break;
              e2 = r2[0].properties.cluster_id;
            }
            return t2;
          }, J.prototype._appendLeaves = function(e2, t2, r2, i2, o2) {
            for (var n2 = 0, a2 = this.getChildren(t2); n2 < a2.length; n2 += 1) {
              var s2 = a2[n2], l2 = s2.properties;
              if (l2 && l2.cluster ? o2 + l2.point_count <= i2 ? o2 += l2.point_count : o2 = this._appendLeaves(e2, l2.cluster_id, r2, i2, o2) : o2 < i2 ? o2++ : e2.push(s2), e2.length === r2)
                break;
            }
            return o2;
          }, J.prototype._addTileFeatures = function(e2, t2, r2, i2, o2, n2) {
            for (var a2 = 0, s2 = e2; a2 < s2.length; a2 += 1) {
              var l2 = t2[s2[a2]], u2 = l2.numPoints, h2 = { type: 1, geometry: [[Math.round(this.options.extent * (l2.x * o2 - r2)), Math.round(this.options.extent * (l2.y * o2 - i2))]], tags: u2 ? G(l2) : this.points[l2.index].properties }, c2 = void 0;
              u2 ? c2 = l2.id : this.options.generateId ? c2 = l2.index : this.points[l2.index].id && (c2 = this.points[l2.index].id), void 0 !== c2 && (h2.id = c2), n2.features.push(h2);
            }
          }, J.prototype._limitZoom = function(e2) {
            return Math.max(this.options.minZoom, Math.min(+e2, this.options.maxZoom + 1));
          }, J.prototype._cluster = function(e2, t2) {
            for (var r2 = [], i2 = this.options, o2 = i2.reduce, n2 = i2.minPoints, a2 = i2.radius / (i2.extent * Math.pow(2, t2)), s2 = 0; s2 < e2.length; s2++) {
              var l2 = e2[s2];
              if (!(l2.zoom <= t2)) {
                l2.zoom = t2;
                for (var u2 = this.trees[t2 + 1], h2 = u2.within(l2.x, l2.y, a2), c2 = l2.numPoints || 1, p2 = c2, f2 = 0, d2 = h2; f2 < d2.length; f2 += 1) {
                  var g2 = u2.points[d2[f2]];
                  g2.zoom > t2 && (p2 += g2.numPoints || 1);
                }
                if (p2 >= n2) {
                  for (var v2 = l2.x * c2, m2 = l2.y * c2, y2 = o2 && c2 > 1 ? this._map(l2, true) : null, x2 = (s2 << 5) + (t2 + 1) + this.points.length, w2 = 0, S2 = h2; w2 < S2.length; w2 += 1) {
                    var I2 = u2.points[S2[w2]];
                    if (!(I2.zoom <= t2)) {
                      I2.zoom = t2;
                      var M2 = I2.numPoints || 1;
                      v2 += I2.x * M2, m2 += I2.y * M2, I2.parentId = x2, o2 && (y2 || (y2 = this._map(l2, true)), o2(y2, this._map(I2)));
                    }
                  }
                  l2.parentId = x2, r2.push(Z(v2 / p2, m2 / p2, x2, p2, y2));
                } else if (r2.push(l2), p2 > 1)
                  for (var b2 = 0, _2 = h2; b2 < _2.length; b2 += 1) {
                    var k2 = u2.points[_2[b2]];
                    k2.zoom <= t2 || (k2.zoom = t2, r2.push(k2));
                  }
              }
            }
            return r2;
          }, J.prototype._getOriginId = function(e2) {
            return e2 - this.points.length >> 5;
          }, J.prototype._getOriginZoom = function(e2) {
            return (e2 - this.points.length) % 32;
          }, J.prototype._map = function(e2, t2) {
            if (e2.numPoints)
              return t2 ? V({}, e2.properties) : e2.properties;
            var r2 = this.points[e2.index].properties, i2 = this.options.map(r2);
            return t2 && i2 === r2 ? V({}, i2) : i2;
          }, me.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, me.prototype.splitTile = function(e2, t2, r2, i2, o2, n2, a2) {
            for (var s2 = [e2, t2, r2, i2], l2 = this.options, u2 = l2.debug; s2.length; ) {
              i2 = s2.pop(), r2 = s2.pop(), t2 = s2.pop(), e2 = s2.pop();
              var h2 = 1 << t2, c2 = ye(t2, r2, i2), p2 = this.tiles[c2];
              if (!p2 && (u2 > 1 && console.time("creation"), p2 = this.tiles[c2] = de(e2, t2, r2, i2, l2), this.tileCoords.push({ z: t2, x: r2, y: i2 }), u2)) {
                u2 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t2, r2, i2, p2.numFeatures, p2.numPoints, p2.numSimplified), console.timeEnd("creation"));
                var f2 = "z" + t2;
                this.stats[f2] = (this.stats[f2] || 0) + 1, this.total++;
              }
              if (p2.source = e2, o2) {
                if (t2 === l2.maxZoom || t2 === o2)
                  continue;
                var d2 = 1 << o2 - t2;
                if (r2 !== Math.floor(n2 / d2) || i2 !== Math.floor(a2 / d2))
                  continue;
              } else if (t2 === l2.indexMaxZoom || p2.numPoints <= l2.indexMaxPoints)
                continue;
              if (p2.source = null, 0 !== e2.length) {
                u2 > 1 && console.time("clipping");
                var g2, v2, m2, y2, x2, w2, S2 = 0.5 * l2.buffer / l2.extent, I2 = 0.5 - S2, M2 = 0.5 + S2, b2 = 1 + S2;
                g2 = v2 = m2 = y2 = null, x2 = re(e2, h2, r2 - S2, r2 + M2, 0, p2.minX, p2.maxX, l2), w2 = re(e2, h2, r2 + I2, r2 + b2, 0, p2.minX, p2.maxX, l2), e2 = null, x2 && (g2 = re(x2, h2, i2 - S2, i2 + M2, 1, p2.minY, p2.maxY, l2), v2 = re(x2, h2, i2 + I2, i2 + b2, 1, p2.minY, p2.maxY, l2), x2 = null), w2 && (m2 = re(w2, h2, i2 - S2, i2 + M2, 1, p2.minY, p2.maxY, l2), y2 = re(w2, h2, i2 + I2, i2 + b2, 1, p2.minY, p2.maxY, l2), w2 = null), u2 > 1 && console.timeEnd("clipping"), s2.push(g2 || [], t2 + 1, 2 * r2, 2 * i2), s2.push(v2 || [], t2 + 1, 2 * r2, 2 * i2 + 1), s2.push(m2 || [], t2 + 1, 2 * r2 + 1, 2 * i2), s2.push(y2 || [], t2 + 1, 2 * r2 + 1, 2 * i2 + 1);
              }
            }
          }, me.prototype.getTile = function(e2, t2, r2) {
            var i2 = this.options, o2 = i2.extent, n2 = i2.debug;
            if (e2 < 0 || e2 > 24)
              return null;
            var a2 = 1 << e2, s2 = ye(e2, t2 = (t2 % a2 + a2) % a2, r2);
            if (this.tiles[s2])
              return pe(this.tiles[s2], o2);
            n2 > 1 && console.log("drilling down to z%d-%d-%d", e2, t2, r2);
            for (var l2, u2 = e2, h2 = t2, c2 = r2; !l2 && u2 > 0; )
              u2--, h2 = Math.floor(h2 / 2), c2 = Math.floor(c2 / 2), l2 = this.tiles[ye(u2, h2, c2)];
            return l2 && l2.source ? (n2 > 1 && console.log("found parent tile z%d-%d-%d", u2, h2, c2), n2 > 1 && console.time("drilling down"), this.splitTile(l2.source, u2, h2, c2, e2, t2, r2), n2 > 1 && console.timeEnd("drilling down"), this.tiles[s2] ? pe(this.tiles[s2], o2) : null) : null;
          };
          var we = function(t2) {
            function r2(e2, r3, i2, o2) {
              t2.call(this, e2, r3, i2, xe), o2 && (this.loadGeoJSON = o2);
            }
            return t2 && (r2.__proto__ = t2), (r2.prototype = Object.create(t2 && t2.prototype)).constructor = r2, r2.prototype.loadData = function(e2, t3) {
              this._pendingCallback && this._pendingCallback(null, { abandoned: true }), this._pendingCallback = t3, this._pendingLoadDataParams = e2, this._state && "Idle" !== this._state ? this._state = "NeedsLoadData" : (this._state = "Coalescing", this._loadData());
            }, r2.prototype._loadData = function() {
              var t3 = this;
              if (this._pendingCallback && this._pendingLoadDataParams) {
                var r3 = this._pendingCallback, i2 = this._pendingLoadDataParams;
                delete this._pendingCallback, delete this._pendingLoadDataParams;
                var o2 = !!(i2 && i2.request && i2.request.collectResourceTiming) && new e.RequestPerformance(i2.request);
                this.loadGeoJSON(i2, function(n2, a2) {
                  if (n2 || !a2)
                    return r3(n2);
                  if ("object" != typeof a2)
                    return r3(new Error("Input data given to '" + i2.source + "' is not a valid GeoJSON object."));
                  !function e2(t4, r4) {
                    var i3, o3 = t4 && t4.type;
                    if ("FeatureCollection" === o3)
                      for (i3 = 0; i3 < t4.features.length; i3++)
                        e2(t4.features[i3], r4);
                    else if ("GeometryCollection" === o3)
                      for (i3 = 0; i3 < t4.geometries.length; i3++)
                        e2(t4.geometries[i3], r4);
                    else if ("Feature" === o3)
                      e2(t4.geometry, r4);
                    else if ("Polygon" === o3)
                      c(t4.coordinates, r4);
                    else if ("MultiPolygon" === o3)
                      for (i3 = 0; i3 < t4.coordinates.length; i3++)
                        c(t4.coordinates[i3], r4);
                    return t4;
                  }(a2, true);
                  try {
                    if (i2.filter) {
                      var s2 = e.createExpression(i2.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                      if ("error" === s2.result)
                        throw new Error(s2.value.map(function(e2) {
                          return e2.key + ": " + e2.message;
                        }).join(", "));
                      var l2 = a2.features.filter(function(e2) {
                        return s2.value.evaluate({ zoom: 0 }, e2);
                      });
                      a2 = { type: "FeatureCollection", features: l2 };
                    }
                    t3._geoJSONIndex = i2.cluster ? new J(function(t4) {
                      var r4 = t4.superclusterOptions, i3 = t4.clusterProperties;
                      if (!i3 || !r4)
                        return r4;
                      for (var o3 = {}, n3 = {}, a3 = { accumulated: null, zoom: 0 }, s3 = { properties: null }, l3 = Object.keys(i3), u3 = 0, h3 = l3; u3 < h3.length; u3 += 1) {
                        var c2 = h3[u3], p2 = i3[c2], f2 = p2[0], d2 = e.createExpression(p2[1]), g2 = e.createExpression("string" == typeof f2 ? [f2, ["accumulated"], ["get", c2]] : f2);
                        o3[c2] = d2.value, n3[c2] = g2.value;
                      }
                      return r4.map = function(e2) {
                        s3.properties = e2;
                        for (var t5 = {}, r5 = 0, i4 = l3; r5 < i4.length; r5 += 1) {
                          var n4 = i4[r5];
                          t5[n4] = o3[n4].evaluate(a3, s3);
                        }
                        return t5;
                      }, r4.reduce = function(e2, t5) {
                        s3.properties = t5;
                        for (var r5 = 0, i4 = l3; r5 < i4.length; r5 += 1) {
                          var o4 = i4[r5];
                          a3.accumulated = e2[o4], e2[o4] = n3[o4].evaluate(a3, s3);
                        }
                      }, r4;
                    }(i2)).load(a2.features) : function(e2, t4) {
                      return new me(e2, t4);
                    }(a2, i2.geojsonVtOptions);
                  } catch (n3) {
                    return r3(n3);
                  }
                  t3.loaded = {};
                  var u2 = {};
                  if (o2) {
                    var h2 = o2.finish();
                    h2 && (u2.resourceTiming = {}, u2.resourceTiming[i2.source] = JSON.parse(JSON.stringify(h2)));
                  }
                  r3(null, u2);
                });
              }
            }, r2.prototype.coalesce = function() {
              "Coalescing" === this._state ? this._state = "Idle" : "NeedsLoadData" === this._state && (this._state = "Coalescing", this._loadData());
            }, r2.prototype.reloadTile = function(e2, r3) {
              var i2 = this.loaded;
              return i2 && i2[e2.uid] ? t2.prototype.reloadTile.call(this, e2, r3) : this.loadTile(e2, r3);
            }, r2.prototype.loadGeoJSON = function(t3, r3) {
              if (t3.request)
                e.getJSON(t3.request, r3);
              else {
                if ("string" != typeof t3.data)
                  return r3(new Error("Input data given to '" + t3.source + "' is not a valid GeoJSON object."));
                try {
                  return r3(null, JSON.parse(t3.data));
                } catch (e2) {
                  return r3(new Error("Input data given to '" + t3.source + "' is not a valid GeoJSON object."));
                }
              }
            }, r2.prototype.removeSource = function(e2, t3) {
              this._pendingCallback && this._pendingCallback(null, { abandoned: true }), t3();
            }, r2.prototype.getClusterExpansionZoom = function(e2, t3) {
              try {
                t3(null, this._geoJSONIndex.getClusterExpansionZoom(e2.clusterId));
              } catch (e3) {
                t3(e3);
              }
            }, r2.prototype.getClusterChildren = function(e2, t3) {
              try {
                t3(null, this._geoJSONIndex.getChildren(e2.clusterId));
              } catch (e3) {
                t3(e3);
              }
            }, r2.prototype.getClusterLeaves = function(e2, t3) {
              try {
                t3(null, this._geoJSONIndex.getLeaves(e2.clusterId, e2.limit, e2.offset));
              } catch (e3) {
                t3(e3);
              }
            }, r2;
          }(l), Se = function(t2) {
            var r2 = this;
            this.self = t2, this.actor = new e.Actor(t2, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = { vector: l, geojson: we }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = function(e2, t3) {
              if (r2.workerSourceTypes[e2])
                throw new Error('Worker source with name "' + e2 + '" already registered.');
              r2.workerSourceTypes[e2] = t3;
            }, this.self.registerRTLTextPlugin = function(t3) {
              if (e.plugin.isParsed())
                throw new Error("RTL text plugin already registered.");
              e.plugin.applyArabicShaping = t3.applyArabicShaping, e.plugin.processBidirectionalText = t3.processBidirectionalText, e.plugin.processStyledBidirectionalText = t3.processStyledBidirectionalText;
            };
          };
          return Se.prototype.setReferrer = function(e2, t2) {
            this.referrer = t2;
          }, Se.prototype.setImages = function(e2, t2, r2) {
            for (var i2 in this.availableImages[e2] = t2, this.workerSources[e2]) {
              var o2 = this.workerSources[e2][i2];
              for (var n2 in o2)
                o2[n2].availableImages = t2;
            }
            r2();
          }, Se.prototype.setLayers = function(e2, t2, r2) {
            this.getLayerIndex(e2).replace(t2), r2();
          }, Se.prototype.updateLayers = function(e2, t2, r2) {
            this.getLayerIndex(e2).update(t2.layers, t2.removedIds), r2();
          }, Se.prototype.loadTile = function(e2, t2, r2) {
            this.getWorkerSource(e2, t2.type, t2.source).loadTile(t2, r2);
          }, Se.prototype.loadDEMTile = function(e2, t2, r2) {
            this.getDEMWorkerSource(e2, t2.source).loadTile(t2, r2);
          }, Se.prototype.reloadTile = function(e2, t2, r2) {
            this.getWorkerSource(e2, t2.type, t2.source).reloadTile(t2, r2);
          }, Se.prototype.abortTile = function(e2, t2, r2) {
            this.getWorkerSource(e2, t2.type, t2.source).abortTile(t2, r2);
          }, Se.prototype.removeTile = function(e2, t2, r2) {
            this.getWorkerSource(e2, t2.type, t2.source).removeTile(t2, r2);
          }, Se.prototype.removeDEMTile = function(e2, t2) {
            this.getDEMWorkerSource(e2, t2.source).removeTile(t2);
          }, Se.prototype.removeSource = function(e2, t2, r2) {
            if (this.workerSources[e2] && this.workerSources[e2][t2.type] && this.workerSources[e2][t2.type][t2.source]) {
              var i2 = this.workerSources[e2][t2.type][t2.source];
              delete this.workerSources[e2][t2.type][t2.source], void 0 !== i2.removeSource ? i2.removeSource(t2, r2) : r2();
            }
          }, Se.prototype.loadWorkerSource = function(e2, t2, r2) {
            try {
              this.self.importScripts(t2.url), r2();
            } catch (e3) {
              r2(e3.toString());
            }
          }, Se.prototype.syncRTLPluginState = function(t2, r2, i2) {
            try {
              e.plugin.setState(r2);
              var o2 = e.plugin.getPluginURL();
              if (e.plugin.isLoaded() && !e.plugin.isParsed() && null != o2) {
                this.self.importScripts(o2);
                var n2 = e.plugin.isParsed();
                i2(n2 ? void 0 : new Error("RTL Text Plugin failed to import scripts from " + o2), n2);
              }
            } catch (e2) {
              i2(e2.toString());
            }
          }, Se.prototype.getAvailableImages = function(e2) {
            var t2 = this.availableImages[e2];
            return t2 || (t2 = []), t2;
          }, Se.prototype.getLayerIndex = function(e2) {
            var t2 = this.layerIndexes[e2];
            return t2 || (t2 = this.layerIndexes[e2] = new i()), t2;
          }, Se.prototype.getWorkerSource = function(e2, t2, r2) {
            var i2 = this;
            return this.workerSources[e2] || (this.workerSources[e2] = {}), this.workerSources[e2][t2] || (this.workerSources[e2][t2] = {}), this.workerSources[e2][t2][r2] || (this.workerSources[e2][t2][r2] = new this.workerSourceTypes[t2]({ send: function(t3, r3, o2) {
              i2.actor.send(t3, r3, o2, e2);
            } }, this.getLayerIndex(e2), this.getAvailableImages(e2))), this.workerSources[e2][t2][r2];
          }, Se.prototype.getDEMWorkerSource = function(e2, t2) {
            return this.demWorkerSources[e2] || (this.demWorkerSources[e2] = {}), this.demWorkerSources[e2][t2] || (this.demWorkerSources[e2][t2] = new h()), this.demWorkerSources[e2][t2];
          }, Se.prototype.enforceCacheSizeLimit = function(t2, r2) {
            e.enforceCacheSizeLimit(r2);
          }, "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope && (self.worker = new Se(self)), Se;
        });
        define2(["./shared"], function(t) {
          "use strict";
          var e = t.createCommonjsModule(function(t2) {
            function e2(t3) {
              return !i2(t3);
            }
            function i2(t3) {
              return "undefined" == typeof window || "undefined" == typeof document ? "not a browser" : Array.prototype && Array.prototype.every && Array.prototype.filter && Array.prototype.forEach && Array.prototype.indexOf && Array.prototype.lastIndexOf && Array.prototype.map && Array.prototype.some && Array.prototype.reduce && Array.prototype.reduceRight && Array.isArray ? Function.prototype && Function.prototype.bind ? Object.keys && Object.create && Object.getPrototypeOf && Object.getOwnPropertyNames && Object.isSealed && Object.isFrozen && Object.isExtensible && Object.getOwnPropertyDescriptor && Object.defineProperty && Object.defineProperties && Object.seal && Object.freeze && Object.preventExtensions ? "JSON" in window && "parse" in JSON && "stringify" in JSON ? function() {
                if (!("Worker" in window && "Blob" in window && "URL" in window))
                  return false;
                var t4, e3, i4 = new Blob([""], { type: "text/javascript" }), o3 = URL.createObjectURL(i4);
                try {
                  e3 = new Worker(o3), t4 = true;
                } catch (e4) {
                  t4 = false;
                }
                return e3 && e3.terminate(), URL.revokeObjectURL(o3), t4;
              }() ? "Uint8ClampedArray" in window ? ArrayBuffer.isView ? function() {
                var t4 = document.createElement("canvas");
                t4.width = t4.height = 1;
                var e3 = t4.getContext("2d");
                if (!e3)
                  return false;
                var i4 = e3.getImageData(0, 0, 1, 1);
                return i4 && i4.width === t4.width;
              }() ? (void 0 === o2[i3 = t3 && t3.failIfMajorPerformanceCaveat] && (o2[i3] = function(t4) {
                var i4 = function(t5) {
                  var i5 = document.createElement("canvas"), o4 = Object.create(e2.webGLContextAttributes);
                  return o4.failIfMajorPerformanceCaveat = t5, i5.probablySupportsContext ? i5.probablySupportsContext("webgl", o4) || i5.probablySupportsContext("experimental-webgl", o4) : i5.supportsContext ? i5.supportsContext("webgl", o4) || i5.supportsContext("experimental-webgl", o4) : i5.getContext("webgl", o4) || i5.getContext("experimental-webgl", o4);
                }(t4);
                if (!i4)
                  return false;
                var o3 = i4.createShader(i4.VERTEX_SHADER);
                return !(!o3 || i4.isContextLost()) && (i4.shaderSource(o3, "void main() {}"), i4.compileShader(o3), true === i4.getShaderParameter(o3, i4.COMPILE_STATUS));
              }(i3)), o2[i3] ? void 0 : "insufficient WebGL support") : "insufficient Canvas/getImageData support" : "insufficient ArrayBuffer support" : "insufficient Uint8ClampedArray support" : "insufficient worker support" : "insufficient JSON support" : "insufficient Object support" : "insufficient Function support" : "insufficent Array support";
              var i3;
            }
            t2.exports ? t2.exports = e2 : window && (window.mapboxgl = window.mapboxgl || {}, window.mapboxgl.supported = e2, window.mapboxgl.notSupportedReason = i2);
            var o2 = {};
            e2.webGLContextAttributes = { antialias: false, alpha: true, stencil: true, depth: true };
          }), i = { create: function(e2, i2, o2) {
            var r2 = t.window.document.createElement(e2);
            return void 0 !== i2 && (r2.className = i2), o2 && o2.appendChild(r2), r2;
          }, createNS: function(e2, i2) {
            return t.window.document.createElementNS(e2, i2);
          } }, o = t.window.document && t.window.document.documentElement.style;
          function r(t2) {
            if (!o)
              return t2[0];
            for (var e2 = 0; e2 < t2.length; e2++)
              if (t2[e2] in o)
                return t2[e2];
            return t2[0];
          }
          var a, n = r(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]);
          i.disableDrag = function() {
            o && n && (a = o[n], o[n] = "none");
          }, i.enableDrag = function() {
            o && n && (o[n] = a);
          };
          var s = r(["transform", "WebkitTransform"]);
          i.setTransform = function(t2, e2) {
            t2.style[s] = e2;
          };
          var l = false;
          try {
            var c = Object.defineProperty({}, "passive", { get: function() {
              l = true;
            } });
            t.window.addEventListener("test", c, c), t.window.removeEventListener("test", c, c);
          } catch (t2) {
            l = false;
          }
          i.addEventListener = function(t2, e2, i2, o2) {
            void 0 === o2 && (o2 = {}), t2.addEventListener(e2, i2, "passive" in o2 && l ? o2 : o2.capture);
          }, i.removeEventListener = function(t2, e2, i2, o2) {
            void 0 === o2 && (o2 = {}), t2.removeEventListener(e2, i2, "passive" in o2 && l ? o2 : o2.capture);
          };
          var u = function(e2) {
            e2.preventDefault(), e2.stopPropagation(), t.window.removeEventListener("click", u, true);
          };
          function h(t2) {
            var e2 = t2.userImage;
            return !!(e2 && e2.render && e2.render()) && (t2.data.replace(new Uint8Array(e2.data.buffer)), true);
          }
          i.suppressClick = function() {
            t.window.addEventListener("click", u, true), t.window.setTimeout(function() {
              t.window.removeEventListener("click", u, true);
            }, 0);
          }, i.mousePos = function(e2, i2) {
            var o2 = e2.getBoundingClientRect();
            return new t.Point(i2.clientX - o2.left - e2.clientLeft, i2.clientY - o2.top - e2.clientTop);
          }, i.touchPos = function(e2, i2) {
            for (var o2 = e2.getBoundingClientRect(), r2 = [], a2 = 0; a2 < i2.length; a2++)
              r2.push(new t.Point(i2[a2].clientX - o2.left - e2.clientLeft, i2[a2].clientY - o2.top - e2.clientTop));
            return r2;
          }, i.mouseButton = function(e2) {
            return void 0 !== t.window.InstallTrigger && 2 === e2.button && e2.ctrlKey && t.window.navigator.platform.toUpperCase().indexOf("MAC") >= 0 ? 0 : e2.button;
          }, i.remove = function(t2) {
            t2.parentNode && t2.parentNode.removeChild(t2);
          };
          var p = function(e2) {
            function i2() {
              e2.call(this), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new t.RGBAImage({ width: 1, height: 1 }), this.dirty = true;
            }
            return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.isLoaded = function() {
              return this.loaded;
            }, i2.prototype.setLoaded = function(t2) {
              if (this.loaded !== t2 && (this.loaded = t2, t2)) {
                for (var e3 = 0, i3 = this.requestors; e3 < i3.length; e3 += 1) {
                  var o2 = i3[e3];
                  this._notify(o2.ids, o2.callback);
                }
                this.requestors = [];
              }
            }, i2.prototype.getImage = function(t2) {
              return this.images[t2];
            }, i2.prototype.addImage = function(t2, e3) {
              this._validate(t2, e3) && (this.images[t2] = e3);
            }, i2.prototype._validate = function(e3, i3) {
              var o2 = true;
              return this._validateStretch(i3.stretchX, i3.data && i3.data.width) || (this.fire(new t.ErrorEvent(new Error('Image "' + e3 + '" has invalid "stretchX" value'))), o2 = false), this._validateStretch(i3.stretchY, i3.data && i3.data.height) || (this.fire(new t.ErrorEvent(new Error('Image "' + e3 + '" has invalid "stretchY" value'))), o2 = false), this._validateContent(i3.content, i3) || (this.fire(new t.ErrorEvent(new Error('Image "' + e3 + '" has invalid "content" value'))), o2 = false), o2;
            }, i2.prototype._validateStretch = function(t2, e3) {
              if (!t2)
                return true;
              for (var i3 = 0, o2 = 0, r2 = t2; o2 < r2.length; o2 += 1) {
                var a2 = r2[o2];
                if (a2[0] < i3 || a2[1] < a2[0] || e3 < a2[1])
                  return false;
                i3 = a2[1];
              }
              return true;
            }, i2.prototype._validateContent = function(t2, e3) {
              return !(t2 && (4 !== t2.length || t2[0] < 0 || e3.data.width < t2[0] || t2[1] < 0 || e3.data.height < t2[1] || t2[2] < 0 || e3.data.width < t2[2] || t2[3] < 0 || e3.data.height < t2[3] || t2[2] < t2[0] || t2[3] < t2[1]));
            }, i2.prototype.updateImage = function(t2, e3) {
              e3.version = this.images[t2].version + 1, this.images[t2] = e3, this.updatedImages[t2] = true;
            }, i2.prototype.removeImage = function(t2) {
              var e3 = this.images[t2];
              delete this.images[t2], delete this.patterns[t2], e3.userImage && e3.userImage.onRemove && e3.userImage.onRemove();
            }, i2.prototype.listImages = function() {
              return Object.keys(this.images);
            }, i2.prototype.getImages = function(t2, e3) {
              var i3 = true;
              if (!this.isLoaded())
                for (var o2 = 0, r2 = t2; o2 < r2.length; o2 += 1)
                  this.images[r2[o2]] || (i3 = false);
              this.isLoaded() || i3 ? this._notify(t2, e3) : this.requestors.push({ ids: t2, callback: e3 });
            }, i2.prototype._notify = function(e3, i3) {
              for (var o2 = {}, r2 = 0, a2 = e3; r2 < a2.length; r2 += 1) {
                var n2 = a2[r2];
                this.images[n2] || this.fire(new t.Event("styleimagemissing", { id: n2 }));
                var s2 = this.images[n2];
                s2 ? o2[n2] = { data: s2.data.clone(), pixelRatio: s2.pixelRatio, sdf: s2.sdf, version: s2.version, stretchX: s2.stretchX, stretchY: s2.stretchY, content: s2.content, hasRenderCallback: Boolean(s2.userImage && s2.userImage.render) } : t.warnOnce('Image "' + n2 + '" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.');
              }
              i3(null, o2);
            }, i2.prototype.getPixelSize = function() {
              var t2 = this.atlasImage;
              return { width: t2.width, height: t2.height };
            }, i2.prototype.getPattern = function(e3) {
              var i3 = this.patterns[e3], o2 = this.getImage(e3);
              if (!o2)
                return null;
              if (i3 && i3.position.version === o2.version)
                return i3.position;
              if (i3)
                i3.position.version = o2.version;
              else {
                var r2 = { w: o2.data.width + 2, h: o2.data.height + 2, x: 0, y: 0 }, a2 = new t.ImagePosition(r2, o2);
                this.patterns[e3] = { bin: r2, position: a2 };
              }
              return this._updatePatternAtlas(), this.patterns[e3].position;
            }, i2.prototype.bind = function(e3) {
              var i3 = e3.gl;
              this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new t.Texture(e3, this.atlasImage, i3.RGBA), this.atlasTexture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE);
            }, i2.prototype._updatePatternAtlas = function() {
              var e3 = [];
              for (var i3 in this.patterns)
                e3.push(this.patterns[i3].bin);
              var o2 = t.potpack(e3), r2 = o2.w, a2 = o2.h, n2 = this.atlasImage;
              for (var s2 in n2.resize({ width: r2 || 1, height: a2 || 1 }), this.patterns) {
                var l2 = this.patterns[s2].bin, c2 = l2.x + 1, u2 = l2.y + 1, h2 = this.images[s2].data, p2 = h2.width, d2 = h2.height;
                t.RGBAImage.copy(h2, n2, { x: 0, y: 0 }, { x: c2, y: u2 }, { width: p2, height: d2 }), t.RGBAImage.copy(h2, n2, { x: 0, y: d2 - 1 }, { x: c2, y: u2 - 1 }, { width: p2, height: 1 }), t.RGBAImage.copy(h2, n2, { x: 0, y: 0 }, { x: c2, y: u2 + d2 }, { width: p2, height: 1 }), t.RGBAImage.copy(h2, n2, { x: p2 - 1, y: 0 }, { x: c2 - 1, y: u2 }, { width: 1, height: d2 }), t.RGBAImage.copy(h2, n2, { x: 0, y: 0 }, { x: c2 + p2, y: u2 }, { width: 1, height: d2 });
              }
              this.dirty = true;
            }, i2.prototype.beginFrame = function() {
              this.callbackDispatchedThisFrame = {};
            }, i2.prototype.dispatchRenderCallbacks = function(t2) {
              for (var e3 = 0, i3 = t2; e3 < i3.length; e3 += 1) {
                var o2 = i3[e3];
                if (!this.callbackDispatchedThisFrame[o2]) {
                  this.callbackDispatchedThisFrame[o2] = true;
                  var r2 = this.images[o2];
                  h(r2) && this.updateImage(o2, r2);
                }
              }
            }, i2;
          }(t.Evented), d = m, _ = m, f = 1e20;
          function m(t2, e2, i2, o2, r2, a2) {
            this.fontSize = t2 || 24, this.buffer = void 0 === e2 ? 3 : e2, this.cutoff = o2 || 0.25, this.fontFamily = r2 || "sans-serif", this.fontWeight = a2 || "normal", this.radius = i2 || 8;
            var n2 = this.size = this.fontSize + 2 * this.buffer;
            this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = n2, this.ctx = this.canvas.getContext("2d"), this.ctx.font = this.fontWeight + " " + this.fontSize + "px " + this.fontFamily, this.ctx.textBaseline = "middle", this.ctx.fillStyle = "black", this.gridOuter = new Float64Array(n2 * n2), this.gridInner = new Float64Array(n2 * n2), this.f = new Float64Array(n2), this.d = new Float64Array(n2), this.z = new Float64Array(n2 + 1), this.v = new Int16Array(n2), this.middle = Math.round(n2 / 2 * (navigator.userAgent.indexOf("Gecko/") >= 0 ? 1.2 : 1));
          }
          function g(t2, e2, i2, o2, r2, a2, n2) {
            for (var s2 = 0; s2 < e2; s2++) {
              for (var l2 = 0; l2 < i2; l2++)
                o2[l2] = t2[l2 * e2 + s2];
              for (v(o2, r2, a2, n2, i2), l2 = 0; l2 < i2; l2++)
                t2[l2 * e2 + s2] = r2[l2];
            }
            for (l2 = 0; l2 < i2; l2++) {
              for (s2 = 0; s2 < e2; s2++)
                o2[s2] = t2[l2 * e2 + s2];
              for (v(o2, r2, a2, n2, e2), s2 = 0; s2 < e2; s2++)
                t2[l2 * e2 + s2] = Math.sqrt(r2[s2]);
            }
          }
          function v(t2, e2, i2, o2, r2) {
            i2[0] = 0, o2[0] = -f, o2[1] = +f;
            for (var a2 = 1, n2 = 0; a2 < r2; a2++) {
              for (var s2 = (t2[a2] + a2 * a2 - (t2[i2[n2]] + i2[n2] * i2[n2])) / (2 * a2 - 2 * i2[n2]); s2 <= o2[n2]; )
                n2--, s2 = (t2[a2] + a2 * a2 - (t2[i2[n2]] + i2[n2] * i2[n2])) / (2 * a2 - 2 * i2[n2]);
              i2[++n2] = a2, o2[n2] = s2, o2[n2 + 1] = +f;
            }
            for (a2 = 0, n2 = 0; a2 < r2; a2++) {
              for (; o2[n2 + 1] < a2; )
                n2++;
              e2[a2] = (a2 - i2[n2]) * (a2 - i2[n2]) + t2[i2[n2]];
            }
          }
          m.prototype.draw = function(t2) {
            this.ctx.clearRect(0, 0, this.size, this.size), this.ctx.fillText(t2, this.buffer, this.middle);
            for (var e2 = this.ctx.getImageData(0, 0, this.size, this.size), i2 = new Uint8ClampedArray(this.size * this.size), o2 = 0; o2 < this.size * this.size; o2++) {
              var r2 = e2.data[4 * o2 + 3] / 255;
              this.gridOuter[o2] = 1 === r2 ? 0 : 0 === r2 ? f : Math.pow(Math.max(0, 0.5 - r2), 2), this.gridInner[o2] = 1 === r2 ? f : 0 === r2 ? 0 : Math.pow(Math.max(0, r2 - 0.5), 2);
            }
            for (g(this.gridOuter, this.size, this.size, this.f, this.d, this.v, this.z), g(this.gridInner, this.size, this.size, this.f, this.d, this.v, this.z), o2 = 0; o2 < this.size * this.size; o2++)
              i2[o2] = Math.max(0, Math.min(255, Math.round(255 - 255 * ((this.gridOuter[o2] - this.gridInner[o2]) / this.radius + this.cutoff))));
            return i2;
          }, d.default = _;
          var y = function(t2, e2) {
            this.requestManager = t2, this.localIdeographFontFamily = e2, this.entries = {};
          };
          y.prototype.setURL = function(t2) {
            this.url = t2;
          }, y.prototype.getGlyphs = function(e2, i2) {
            var o2 = this, r2 = [];
            for (var a2 in e2)
              for (var n2 = 0, s2 = e2[a2]; n2 < s2.length; n2 += 1)
                r2.push({ stack: a2, id: s2[n2] });
            t.asyncAll(r2, function(t2, e3) {
              var i3 = t2.stack, r3 = t2.id, a3 = o2.entries[i3];
              a3 || (a3 = o2.entries[i3] = { glyphs: {}, requests: {}, ranges: {} });
              var n3 = a3.glyphs[r3];
              if (void 0 === n3) {
                if (n3 = o2._tinySDF(a3, i3, r3))
                  return a3.glyphs[r3] = n3, void e3(null, { stack: i3, id: r3, glyph: n3 });
                var s3 = Math.floor(r3 / 256);
                if (256 * s3 > 65535)
                  e3(new Error("glyphs > 65535 not supported"));
                else if (a3.ranges[s3])
                  e3(null, { stack: i3, id: r3, glyph: n3 });
                else {
                  var l2 = a3.requests[s3];
                  l2 || (l2 = a3.requests[s3] = [], y.loadGlyphRange(i3, s3, o2.url, o2.requestManager, function(t3, e4) {
                    if (e4) {
                      for (var i4 in e4)
                        o2._doesCharSupportLocalGlyph(+i4) || (a3.glyphs[+i4] = e4[+i4]);
                      a3.ranges[s3] = true;
                    }
                    for (var r4 = 0, n4 = l2; r4 < n4.length; r4 += 1)
                      (0, n4[r4])(t3, e4);
                    delete a3.requests[s3];
                  })), l2.push(function(t3, o3) {
                    t3 ? e3(t3) : o3 && e3(null, { stack: i3, id: r3, glyph: o3[r3] || null });
                  });
                }
              } else
                e3(null, { stack: i3, id: r3, glyph: n3 });
            }, function(t2, e3) {
              if (t2)
                i2(t2);
              else if (e3) {
                for (var o3 = {}, r3 = 0, a3 = e3; r3 < a3.length; r3 += 1) {
                  var n3 = a3[r3], s3 = n3.stack, l2 = n3.id, c2 = n3.glyph;
                  (o3[s3] || (o3[s3] = {}))[l2] = c2 && { id: c2.id, bitmap: c2.bitmap.clone(), metrics: c2.metrics };
                }
                i2(null, o3);
              }
            });
          }, y.prototype._doesCharSupportLocalGlyph = function(e2) {
            return !!this.localIdeographFontFamily && (t.isChar["CJK Unified Ideographs"](e2) || t.isChar["Hangul Syllables"](e2) || t.isChar.Hiragana(e2) || t.isChar.Katakana(e2));
          }, y.prototype._tinySDF = function(e2, i2, o2) {
            var r2 = this.localIdeographFontFamily;
            if (r2 && this._doesCharSupportLocalGlyph(o2)) {
              var a2 = e2.tinySDF;
              if (!a2) {
                var n2 = "400";
                /bold/i.test(i2) ? n2 = "900" : /medium/i.test(i2) ? n2 = "500" : /light/i.test(i2) && (n2 = "200"), a2 = e2.tinySDF = new y.TinySDF(24, 3, 8, 0.25, r2, n2);
              }
              return { id: o2, bitmap: new t.AlphaImage({ width: 30, height: 30 }, a2.draw(String.fromCharCode(o2))), metrics: { width: 24, height: 24, left: 0, top: -8, advance: 24 } };
            }
          }, y.loadGlyphRange = function(e2, i2, o2, r2, a2) {
            var n2 = 256 * i2, s2 = n2 + 255, l2 = r2.transformRequest(r2.normalizeGlyphsURL(o2).replace("{fontstack}", e2).replace("{range}", n2 + "-" + s2), t.ResourceType.Glyphs);
            t.getArrayBuffer(l2, function(e3, i3) {
              if (e3)
                a2(e3);
              else if (i3) {
                for (var o3 = {}, r3 = 0, n3 = t.parseGlyphPBF(i3); r3 < n3.length; r3 += 1) {
                  var s3 = n3[r3];
                  o3[s3.id] = s3;
                }
                a2(null, o3);
              }
            });
          }, y.TinySDF = d;
          var x = function() {
            this.specification = t.styleSpec.light.position;
          };
          x.prototype.possiblyEvaluate = function(e2, i2) {
            return t.sphericalToCartesian(e2.expression.evaluate(i2));
          }, x.prototype.interpolate = function(e2, i2, o2) {
            return { x: t.number(e2.x, i2.x, o2), y: t.number(e2.y, i2.y, o2), z: t.number(e2.z, i2.z, o2) };
          };
          var b = new t.Properties({ anchor: new t.DataConstantProperty(t.styleSpec.light.anchor), position: new x(), color: new t.DataConstantProperty(t.styleSpec.light.color), intensity: new t.DataConstantProperty(t.styleSpec.light.intensity) }), w = function(e2) {
            function i2(i3) {
              e2.call(this), this._transitionable = new t.Transitionable(b), this.setLight(i3), this._transitioning = this._transitionable.untransitioned();
            }
            return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.getLight = function() {
              return this._transitionable.serialize();
            }, i2.prototype.setLight = function(e3, i3) {
              if (void 0 === i3 && (i3 = {}), !this._validate(t.validateLight, e3, i3))
                for (var o2 in e3) {
                  var r2 = e3[o2];
                  t.endsWith(o2, "-transition") ? this._transitionable.setTransition(o2.slice(0, -"-transition".length), r2) : this._transitionable.setValue(o2, r2);
                }
            }, i2.prototype.updateTransitions = function(t2) {
              this._transitioning = this._transitionable.transitioned(t2, this._transitioning);
            }, i2.prototype.hasTransition = function() {
              return this._transitioning.hasTransition();
            }, i2.prototype.recalculate = function(t2) {
              this.properties = this._transitioning.possiblyEvaluate(t2);
            }, i2.prototype._validate = function(e3, i3, o2) {
              return (!o2 || false !== o2.validate) && t.emitValidationErrors(this, e3.call(t.validateStyle, t.extend({ value: i3, style: { glyphs: true, sprite: true }, styleSpec: t.styleSpec })));
            }, i2;
          }(t.Evented), T = function(t2, e2) {
            this.width = t2, this.height = e2, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
          };
          T.prototype.getDash = function(t2, e2) {
            var i2 = t2.join(",") + String(e2);
            return this.dashEntry[i2] || (this.dashEntry[i2] = this.addDash(t2, e2)), this.dashEntry[i2];
          }, T.prototype.getDashRanges = function(t2, e2, i2) {
            var o2 = [], r2 = t2.length % 2 == 1 ? -t2[t2.length - 1] * i2 : 0, a2 = t2[0] * i2, n2 = true;
            o2.push({ left: r2, right: a2, isDash: n2, zeroLength: 0 === t2[0] });
            for (var s2 = t2[0], l2 = 1; l2 < t2.length; l2++) {
              var c2 = t2[l2];
              o2.push({ left: r2 = s2 * i2, right: a2 = (s2 += c2) * i2, isDash: n2 = !n2, zeroLength: 0 === c2 });
            }
            return o2;
          }, T.prototype.addRoundDash = function(t2, e2, i2) {
            for (var o2 = e2 / 2, r2 = -i2; r2 <= i2; r2++)
              for (var a2 = this.width * (this.nextRow + i2 + r2), n2 = 0, s2 = t2[n2], l2 = 0; l2 < this.width; l2++) {
                l2 / s2.right > 1 && (s2 = t2[++n2]);
                var c2 = Math.abs(l2 - s2.left), u2 = Math.abs(l2 - s2.right), h2 = Math.min(c2, u2), p2 = void 0, d2 = r2 / i2 * (o2 + 1);
                if (s2.isDash) {
                  var _2 = o2 - Math.abs(d2);
                  p2 = Math.sqrt(h2 * h2 + _2 * _2);
                } else
                  p2 = o2 - Math.sqrt(h2 * h2 + d2 * d2);
                this.data[a2 + l2] = Math.max(0, Math.min(255, p2 + 128));
              }
          }, T.prototype.addRegularDash = function(t2) {
            for (var e2 = t2.length - 1; e2 >= 0; --e2) {
              var i2 = t2[e2], o2 = t2[e2 + 1];
              i2.zeroLength ? t2.splice(e2, 1) : o2 && o2.isDash === i2.isDash && (o2.left = i2.left, t2.splice(e2, 1));
            }
            var r2 = t2[0], a2 = t2[t2.length - 1];
            r2.isDash === a2.isDash && (r2.left = a2.left - this.width, a2.right = r2.right + this.width);
            for (var n2 = this.width * this.nextRow, s2 = 0, l2 = t2[s2], c2 = 0; c2 < this.width; c2++) {
              c2 / l2.right > 1 && (l2 = t2[++s2]);
              var u2 = Math.abs(c2 - l2.left), h2 = Math.abs(c2 - l2.right), p2 = Math.min(u2, h2);
              this.data[n2 + c2] = Math.max(0, Math.min(255, (l2.isDash ? p2 : -p2) + 128));
            }
          }, T.prototype.addDash = function(e2, i2) {
            var o2 = i2 ? 7 : 0, r2 = 2 * o2 + 1;
            if (this.nextRow + r2 > this.height)
              return t.warnOnce("LineAtlas out of space"), null;
            for (var a2 = 0, n2 = 0; n2 < e2.length; n2++)
              a2 += e2[n2];
            if (0 !== a2) {
              var s2 = this.width / a2, l2 = this.getDashRanges(e2, this.width, s2);
              i2 ? this.addRoundDash(l2, s2, o2) : this.addRegularDash(l2);
            }
            var c2 = { y: (this.nextRow + o2 + 0.5) / this.height, height: 2 * o2 / this.height, width: a2 };
            return this.nextRow += r2, this.dirty = true, c2;
          }, T.prototype.bind = function(t2) {
            var e2 = t2.gl;
            this.texture ? (e2.bindTexture(e2.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, e2.texSubImage2D(e2.TEXTURE_2D, 0, 0, 0, this.width, this.height, e2.ALPHA, e2.UNSIGNED_BYTE, this.data))) : (this.texture = e2.createTexture(), e2.bindTexture(e2.TEXTURE_2D, this.texture), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.REPEAT), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, e2.LINEAR), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, e2.LINEAR), e2.texImage2D(e2.TEXTURE_2D, 0, e2.ALPHA, this.width, this.height, 0, e2.ALPHA, e2.UNSIGNED_BYTE, this.data));
          };
          var E = function e2(i2, o2) {
            this.workerPool = i2, this.actors = [], this.currentActor = 0, this.id = t.uniqueId();
            for (var r2 = this.workerPool.acquire(this.id), a2 = 0; a2 < r2.length; a2++) {
              var n2 = new e2.Actor(r2[a2], o2, this.id);
              n2.name = "Worker " + a2, this.actors.push(n2);
            }
          };
          function I(e2, i2, o2) {
            var r2 = function(r3, a2) {
              if (r3)
                return o2(r3);
              if (a2) {
                var n2 = t.pick(t.extend(a2, e2), ["tiles", "minzoom", "maxzoom", "attribution", "mapbox_logo", "bounds", "scheme", "tileSize", "encoding"]);
                a2.vector_layers && (n2.vectorLayers = a2.vector_layers, n2.vectorLayerIds = n2.vectorLayers.map(function(t2) {
                  return t2.id;
                })), n2.tiles = i2.canonicalizeTileset(n2, e2.url), o2(null, n2);
              }
            };
            return e2.url ? t.getJSON(i2.transformRequest(i2.normalizeSourceURL(e2.url), t.ResourceType.Source), r2) : t.browser.frame(function() {
              return r2(null, e2);
            });
          }
          E.prototype.broadcast = function(e2, i2, o2) {
            t.asyncAll(this.actors, function(t2, o3) {
              t2.send(e2, i2, o3);
            }, o2 = o2 || function() {
            });
          }, E.prototype.getActor = function() {
            return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
          }, E.prototype.remove = function() {
            this.actors.forEach(function(t2) {
              t2.remove();
            }), this.actors = [], this.workerPool.release(this.id);
          }, E.Actor = t.Actor;
          var P = function(e2, i2, o2) {
            this.bounds = t.LngLatBounds.convert(this.validateBounds(e2)), this.minzoom = i2 || 0, this.maxzoom = o2 || 24;
          };
          P.prototype.validateBounds = function(t2) {
            return Array.isArray(t2) && 4 === t2.length ? [Math.max(-180, t2[0]), Math.max(-90, t2[1]), Math.min(180, t2[2]), Math.min(90, t2[3])] : [-180, -90, 180, 90];
          }, P.prototype.contains = function(e2) {
            var i2 = Math.pow(2, e2.z), o2 = Math.floor(t.mercatorXfromLng(this.bounds.getWest()) * i2), r2 = Math.floor(t.mercatorYfromLat(this.bounds.getNorth()) * i2), a2 = Math.ceil(t.mercatorXfromLng(this.bounds.getEast()) * i2), n2 = Math.ceil(t.mercatorYfromLat(this.bounds.getSouth()) * i2);
            return e2.x >= o2 && e2.x < a2 && e2.y >= r2 && e2.y < n2;
          };
          var S = function(e2) {
            function i2(i3, o2, r2, a2) {
              if (e2.call(this), this.id = i3, this.dispatcher = r2, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, t.extend(this, t.pick(o2, ["url", "scheme", "tileSize", "promoteId"])), this._options = t.extend({ type: "vector" }, o2), this._collectResourceTiming = o2.collectResourceTiming, 512 !== this.tileSize)
                throw new Error("vector tile sources must have a tileSize of 512");
              this.setEventedParent(a2);
            }
            return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.load = function() {
              var e3 = this;
              this._loaded = false, this.fire(new t.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = I(this._options, this.map._requestManager, function(i3, o2) {
                e3._tileJSONRequest = null, e3._loaded = true, i3 ? e3.fire(new t.ErrorEvent(i3)) : o2 && (t.extend(e3, o2), o2.bounds && (e3.tileBounds = new P(o2.bounds, e3.minzoom, e3.maxzoom)), t.postTurnstileEvent(o2.tiles, e3.map._requestManager._customAccessToken), t.postMapLoadEvent(o2.tiles, e3.map._getMapId(), e3.map._requestManager._skuToken, e3.map._requestManager._customAccessToken), e3.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })), e3.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })));
              });
            }, i2.prototype.loaded = function() {
              return this._loaded;
            }, i2.prototype.hasTile = function(t2) {
              return !this.tileBounds || this.tileBounds.contains(t2.canonical);
            }, i2.prototype.onAdd = function(t2) {
              this.map = t2, this.load();
            }, i2.prototype.setSourceProperty = function(t2) {
              this._tileJSONRequest && this._tileJSONRequest.cancel(), t2(), this.map.style.sourceCaches[this.id].clearTiles(), this.load();
            }, i2.prototype.setTiles = function(t2) {
              var e3 = this;
              return this.setSourceProperty(function() {
                e3._options.tiles = t2;
              }), this;
            }, i2.prototype.setUrl = function(t2) {
              var e3 = this;
              return this.setSourceProperty(function() {
                e3.url = t2, e3._options.url = t2;
              }), this;
            }, i2.prototype.onRemove = function() {
              this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }, i2.prototype.serialize = function() {
              return t.extend({}, this._options);
            }, i2.prototype.loadTile = function(e3, i3) {
              var o2 = this.map._requestManager.normalizeTileURL(e3.tileID.canonical.url(this.tiles, this.scheme)), r2 = { request: this.map._requestManager.transformRequest(o2, t.ResourceType.Tile), uid: e3.uid, tileID: e3.tileID, zoom: e3.tileID.overscaledZ, tileSize: this.tileSize * e3.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: t.browser.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
              function a2(o3, r3) {
                return delete e3.request, e3.aborted ? i3(null) : o3 && 404 !== o3.status ? i3(o3) : (r3 && r3.resourceTiming && (e3.resourceTiming = r3.resourceTiming), this.map._refreshExpiredTiles && r3 && e3.setExpiryData(r3), e3.loadVectorData(r3, this.map.painter), t.cacheEntryPossiblyAdded(this.dispatcher), i3(null), void (e3.reloadCallback && (this.loadTile(e3, e3.reloadCallback), e3.reloadCallback = null)));
              }
              r2.request.collectResourceTiming = this._collectResourceTiming, e3.actor && "expired" !== e3.state ? "loading" === e3.state ? e3.reloadCallback = i3 : e3.request = e3.actor.send("reloadTile", r2, a2.bind(this)) : (e3.actor = this.dispatcher.getActor(), e3.request = e3.actor.send("loadTile", r2, a2.bind(this)));
            }, i2.prototype.abortTile = function(t2) {
              t2.request && (t2.request.cancel(), delete t2.request), t2.actor && t2.actor.send("abortTile", { uid: t2.uid, type: this.type, source: this.id }, void 0);
            }, i2.prototype.unloadTile = function(t2) {
              t2.unloadVectorData(), t2.actor && t2.actor.send("removeTile", { uid: t2.uid, type: this.type, source: this.id }, void 0);
            }, i2.prototype.hasTransition = function() {
              return false;
            }, i2;
          }(t.Evented), C = function(e2) {
            function i2(i3, o2, r2, a2) {
              e2.call(this), this.id = i3, this.dispatcher = r2, this.setEventedParent(a2), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = t.extend({ type: "raster" }, o2), t.extend(this, t.pick(o2, ["url", "scheme", "tileSize"]));
            }
            return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.load = function() {
              var e3 = this;
              this._loaded = false, this.fire(new t.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = I(this._options, this.map._requestManager, function(i3, o2) {
                e3._tileJSONRequest = null, e3._loaded = true, i3 ? e3.fire(new t.ErrorEvent(i3)) : o2 && (t.extend(e3, o2), o2.bounds && (e3.tileBounds = new P(o2.bounds, e3.minzoom, e3.maxzoom)), t.postTurnstileEvent(o2.tiles), t.postMapLoadEvent(o2.tiles, e3.map._getMapId(), e3.map._requestManager._skuToken), e3.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })), e3.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })));
              });
            }, i2.prototype.loaded = function() {
              return this._loaded;
            }, i2.prototype.onAdd = function(t2) {
              this.map = t2, this.load();
            }, i2.prototype.onRemove = function() {
              this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }, i2.prototype.serialize = function() {
              return t.extend({}, this._options);
            }, i2.prototype.hasTile = function(t2) {
              return !this.tileBounds || this.tileBounds.contains(t2.canonical);
            }, i2.prototype.loadTile = function(e3, i3) {
              var o2 = this, r2 = this.map._requestManager.normalizeTileURL(e3.tileID.canonical.url(this.tiles, this.scheme), this.tileSize);
              e3.request = t.getImage(this.map._requestManager.transformRequest(r2, t.ResourceType.Tile), function(r3, a2) {
                if (delete e3.request, e3.aborted)
                  e3.state = "unloaded", i3(null);
                else if (r3)
                  e3.state = "errored", i3(r3);
                else if (a2) {
                  o2.map._refreshExpiredTiles && e3.setExpiryData(a2), delete a2.cacheControl, delete a2.expires;
                  var n2 = o2.map.painter.context, s2 = n2.gl;
                  e3.texture = o2.map.painter.getTileTexture(a2.width), e3.texture ? e3.texture.update(a2, { useMipmap: true }) : (e3.texture = new t.Texture(n2, a2, s2.RGBA, { useMipmap: true }), e3.texture.bind(s2.LINEAR, s2.CLAMP_TO_EDGE, s2.LINEAR_MIPMAP_NEAREST), n2.extTextureFilterAnisotropic && s2.texParameterf(s2.TEXTURE_2D, n2.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, n2.extTextureFilterAnisotropicMax)), e3.state = "loaded", t.cacheEntryPossiblyAdded(o2.dispatcher), i3(null);
                }
              });
            }, i2.prototype.abortTile = function(t2, e3) {
              t2.request && (t2.request.cancel(), delete t2.request), e3();
            }, i2.prototype.unloadTile = function(t2, e3) {
              t2.texture && this.map.painter.saveTileTexture(t2.texture), e3();
            }, i2.prototype.hasTransition = function() {
              return false;
            }, i2;
          }(t.Evented), z = function(e2) {
            function i2(i3, o2, r2, a2) {
              e2.call(this, i3, o2, r2, a2), this.type = "raster-dem", this.maxzoom = 22, this._options = t.extend({ type: "raster-dem" }, o2), this.encoding = o2.encoding || "mapbox";
            }
            return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.serialize = function() {
              return { type: "raster-dem", url: this.url, tileSize: this.tileSize, tiles: this.tiles, bounds: this.bounds, encoding: this.encoding };
            }, i2.prototype.loadTile = function(e3, i3) {
              var o2 = this.map._requestManager.normalizeTileURL(e3.tileID.canonical.url(this.tiles, this.scheme), this.tileSize);
              function r2(t2, o3) {
                t2 && (e3.state = "errored", i3(t2)), o3 && (e3.dem = o3, e3.needsHillshadePrepare = true, e3.state = "loaded", i3(null));
              }
              e3.request = t.getImage(this.map._requestManager.transformRequest(o2, t.ResourceType.Tile), function(o3, a2) {
                if (delete e3.request, e3.aborted)
                  e3.state = "unloaded", i3(null);
                else if (o3)
                  e3.state = "errored", i3(o3);
                else if (a2) {
                  this.map._refreshExpiredTiles && e3.setExpiryData(a2), delete a2.cacheControl, delete a2.expires;
                  var n2 = t.window.ImageBitmap && a2 instanceof t.window.ImageBitmap && t.offscreenCanvasSupported() ? a2 : t.browser.getImageData(a2, 1), s2 = { uid: e3.uid, coord: e3.tileID, source: this.id, rawImageData: n2, encoding: this.encoding };
                  e3.actor && "expired" !== e3.state || (e3.actor = this.dispatcher.getActor(), e3.actor.send("loadDEMTile", s2, r2.bind(this)));
                }
              }.bind(this)), e3.neighboringTiles = this._getNeighboringTiles(e3.tileID);
            }, i2.prototype._getNeighboringTiles = function(e3) {
              var i3 = e3.canonical, o2 = Math.pow(2, i3.z), r2 = (i3.x - 1 + o2) % o2, a2 = 0 === i3.x ? e3.wrap - 1 : e3.wrap, n2 = (i3.x + 1 + o2) % o2, s2 = i3.x + 1 === o2 ? e3.wrap + 1 : e3.wrap, l2 = {};
              return l2[new t.OverscaledTileID(e3.overscaledZ, a2, i3.z, r2, i3.y).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, s2, i3.z, n2, i3.y).key] = { backfilled: false }, i3.y > 0 && (l2[new t.OverscaledTileID(e3.overscaledZ, a2, i3.z, r2, i3.y - 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, e3.wrap, i3.z, i3.x, i3.y - 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, s2, i3.z, n2, i3.y - 1).key] = { backfilled: false }), i3.y + 1 < o2 && (l2[new t.OverscaledTileID(e3.overscaledZ, a2, i3.z, r2, i3.y + 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, e3.wrap, i3.z, i3.x, i3.y + 1).key] = { backfilled: false }, l2[new t.OverscaledTileID(e3.overscaledZ, s2, i3.z, n2, i3.y + 1).key] = { backfilled: false }), l2;
            }, i2.prototype.unloadTile = function(t2) {
              t2.demTexture && this.map.painter.saveTileTexture(t2.demTexture), t2.fbo && (t2.fbo.destroy(), delete t2.fbo), t2.dem && delete t2.dem, delete t2.neighboringTiles, t2.state = "unloaded", t2.actor && t2.actor.send("removeDEMTile", { uid: t2.uid, source: this.id });
            }, i2;
          }(C), D = function(e2) {
            function i2(i3, o2, r2, a2) {
              e2.call(this), this.id = i3, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._loaded = false, this.actor = r2.getActor(), this.setEventedParent(a2), this._data = o2.data, this._options = t.extend({}, o2), this._collectResourceTiming = o2.collectResourceTiming, this._resourceTiming = [], void 0 !== o2.maxzoom && (this.maxzoom = o2.maxzoom), o2.type && (this.type = o2.type), o2.attribution && (this.attribution = o2.attribution), this.promoteId = o2.promoteId;
              var n2 = t.EXTENT / this.tileSize;
              this.workerOptions = t.extend({ source: this.id, cluster: o2.cluster || false, geojsonVtOptions: { buffer: (void 0 !== o2.buffer ? o2.buffer : 128) * n2, tolerance: (void 0 !== o2.tolerance ? o2.tolerance : 0.375) * n2, extent: t.EXTENT, maxZoom: this.maxzoom, lineMetrics: o2.lineMetrics || false, generateId: o2.generateId || false }, superclusterOptions: { maxZoom: void 0 !== o2.clusterMaxZoom ? Math.min(o2.clusterMaxZoom, this.maxzoom - 1) : this.maxzoom - 1, minPoints: Math.max(2, o2.clusterMinPoints || 2), extent: t.EXTENT, radius: (o2.clusterRadius || 50) * n2, log: false, generateId: o2.generateId || false }, clusterProperties: o2.clusterProperties, filter: o2.filter }, o2.workerOptions);
            }
            return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.load = function() {
              var e3 = this;
              this.fire(new t.Event("dataloading", { dataType: "source" })), this._updateWorkerData(function(i3) {
                if (i3)
                  e3.fire(new t.ErrorEvent(i3));
                else {
                  var o2 = { dataType: "source", sourceDataType: "metadata" };
                  e3._collectResourceTiming && e3._resourceTiming && e3._resourceTiming.length > 0 && (o2.resourceTiming = e3._resourceTiming, e3._resourceTiming = []), e3.fire(new t.Event("data", o2));
                }
              });
            }, i2.prototype.onAdd = function(t2) {
              this.map = t2, this.load();
            }, i2.prototype.setData = function(e3) {
              var i3 = this;
              return this._data = e3, this.fire(new t.Event("dataloading", { dataType: "source" })), this._updateWorkerData(function(e4) {
                if (e4)
                  i3.fire(new t.ErrorEvent(e4));
                else {
                  var o2 = { dataType: "source", sourceDataType: "content" };
                  i3._collectResourceTiming && i3._resourceTiming && i3._resourceTiming.length > 0 && (o2.resourceTiming = i3._resourceTiming, i3._resourceTiming = []), i3.fire(new t.Event("data", o2));
                }
              }), this;
            }, i2.prototype.getClusterExpansionZoom = function(t2, e3) {
              return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: t2, source: this.id }, e3), this;
            }, i2.prototype.getClusterChildren = function(t2, e3) {
              return this.actor.send("geojson.getClusterChildren", { clusterId: t2, source: this.id }, e3), this;
            }, i2.prototype.getClusterLeaves = function(t2, e3, i3, o2) {
              return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: t2, limit: e3, offset: i3 }, o2), this;
            }, i2.prototype._updateWorkerData = function(e3) {
              var i3 = this;
              this._loaded = false;
              var o2 = t.extend({}, this.workerOptions), r2 = this._data;
              "string" == typeof r2 ? (o2.request = this.map._requestManager.transformRequest(t.browser.resolveURL(r2), t.ResourceType.Source), o2.request.collectResourceTiming = this._collectResourceTiming) : o2.data = JSON.stringify(r2), this.actor.send(this.type + ".loadData", o2, function(t2, r3) {
                i3._removed || r3 && r3.abandoned || (i3._loaded = true, r3 && r3.resourceTiming && r3.resourceTiming[i3.id] && (i3._resourceTiming = r3.resourceTiming[i3.id].slice(0)), i3.actor.send(i3.type + ".coalesce", { source: o2.source }, null), e3(t2));
              });
            }, i2.prototype.loaded = function() {
              return this._loaded;
            }, i2.prototype.loadTile = function(e3, i3) {
              var o2 = this, r2 = e3.actor ? "reloadTile" : "loadTile";
              e3.actor = this.actor, e3.request = this.actor.send(r2, { type: this.type, uid: e3.uid, tileID: e3.tileID, zoom: e3.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: t.browser.devicePixelRatio, showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId }, function(t2, a2) {
                return delete e3.request, e3.unloadVectorData(), e3.aborted ? i3(null) : t2 ? i3(t2) : (e3.loadVectorData(a2, o2.map.painter, "reloadTile" === r2), i3(null));
              });
            }, i2.prototype.abortTile = function(t2) {
              t2.request && (t2.request.cancel(), delete t2.request), t2.aborted = true;
            }, i2.prototype.unloadTile = function(t2) {
              t2.unloadVectorData(), this.actor.send("removeTile", { uid: t2.uid, type: this.type, source: this.id });
            }, i2.prototype.onRemove = function() {
              this._removed = true, this.actor.send("removeSource", { type: this.type, source: this.id });
            }, i2.prototype.serialize = function() {
              return t.extend({}, this._options, { type: this.type, data: this._data });
            }, i2.prototype.hasTransition = function() {
              return false;
            }, i2;
          }(t.Evented), A = t.createLayout([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]), M = function(e2) {
            function i2(t2, i3, o2, r2) {
              e2.call(this), this.id = t2, this.dispatcher = o2, this.coordinates = i3.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(r2), this.options = i3;
            }
            return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.load = function(e3, i3) {
              var o2 = this;
              this._loaded = false, this.fire(new t.Event("dataloading", { dataType: "source" })), this.url = this.options.url, t.getImage(this.map._requestManager.transformRequest(this.url, t.ResourceType.Image), function(r2, a2) {
                o2._loaded = true, r2 ? o2.fire(new t.ErrorEvent(r2)) : a2 && (o2.image = a2, e3 && (o2.coordinates = e3), i3 && i3(), o2._finishLoading());
              });
            }, i2.prototype.loaded = function() {
              return this._loaded;
            }, i2.prototype.updateImage = function(t2) {
              var e3 = this;
              return this.image && t2.url ? (this.options.url = t2.url, this.load(t2.coordinates, function() {
                e3.texture = null;
              }), this) : this;
            }, i2.prototype._finishLoading = function() {
              this.map && (this.setCoordinates(this.coordinates), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "metadata" })));
            }, i2.prototype.onAdd = function(t2) {
              this.map = t2, this.load();
            }, i2.prototype.setCoordinates = function(e3) {
              var i3 = this;
              this.coordinates = e3;
              var o2 = e3.map(t.MercatorCoordinate.fromLngLat);
              this.tileID = function(e4) {
                for (var i4 = 1 / 0, o3 = 1 / 0, r3 = -1 / 0, a2 = -1 / 0, n2 = 0, s2 = e4; n2 < s2.length; n2 += 1) {
                  var l2 = s2[n2];
                  i4 = Math.min(i4, l2.x), o3 = Math.min(o3, l2.y), r3 = Math.max(r3, l2.x), a2 = Math.max(a2, l2.y);
                }
                var c2 = Math.max(r3 - i4, a2 - o3), u2 = Math.max(0, Math.floor(-Math.log(c2) / Math.LN2)), h2 = Math.pow(2, u2);
                return new t.CanonicalTileID(u2, Math.floor((i4 + r3) / 2 * h2), Math.floor((o3 + a2) / 2 * h2));
              }(o2), this.minzoom = this.maxzoom = this.tileID.z;
              var r2 = o2.map(function(t2) {
                return i3.tileID.getTilePoint(t2)._round();
              });
              return this._boundsArray = new t.StructArrayLayout4i8(), this._boundsArray.emplaceBack(r2[0].x, r2[0].y, 0, 0), this._boundsArray.emplaceBack(r2[1].x, r2[1].y, t.EXTENT, 0), this._boundsArray.emplaceBack(r2[3].x, r2[3].y, 0, t.EXTENT), this._boundsArray.emplaceBack(r2[2].x, r2[2].y, t.EXTENT, t.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new t.Event("data", { dataType: "source", sourceDataType: "content" })), this;
            }, i2.prototype.prepare = function() {
              if (0 !== Object.keys(this.tiles).length && this.image) {
                var e3 = this.map.painter.context, i3 = e3.gl;
                for (var o2 in this.boundsBuffer || (this.boundsBuffer = e3.createVertexBuffer(this._boundsArray, A.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new t.Texture(e3, this.image, i3.RGBA), this.texture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE)), this.tiles) {
                  var r2 = this.tiles[o2];
                  "loaded" !== r2.state && (r2.state = "loaded", r2.texture = this.texture);
                }
              }
            }, i2.prototype.loadTile = function(t2, e3) {
              this.tileID && this.tileID.equals(t2.tileID.canonical) ? (this.tiles[String(t2.tileID.wrap)] = t2, t2.buckets = {}, e3(null)) : (t2.state = "errored", e3(null));
            }, i2.prototype.serialize = function() {
              return { type: "image", url: this.options.url, coordinates: this.coordinates };
            }, i2.prototype.hasTransition = function() {
              return false;
            }, i2;
          }(t.Evented), L = function(e2) {
            function i2(t2, i3, o2, r2) {
              e2.call(this, t2, i3, o2, r2), this.roundZoom = true, this.type = "video", this.options = i3;
            }
            return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.load = function() {
              var e3 = this;
              this._loaded = false;
              var i3 = this.options;
              this.urls = [];
              for (var o2 = 0, r2 = i3.urls; o2 < r2.length; o2 += 1)
                this.urls.push(this.map._requestManager.transformRequest(r2[o2], t.ResourceType.Source).url);
              t.getVideo(this.urls, function(i4, o3) {
                e3._loaded = true, i4 ? e3.fire(new t.ErrorEvent(i4)) : o3 && (e3.video = o3, e3.video.loop = true, e3.video.setAttribute("playsinline", ""), e3.video.addEventListener("playing", function() {
                  e3.map.triggerRepaint();
                }), e3.map && e3.video.play(), e3._finishLoading());
              });
            }, i2.prototype.pause = function() {
              this.video && this.video.pause();
            }, i2.prototype.play = function() {
              this.video && this.video.play();
            }, i2.prototype.seek = function(e3) {
              if (this.video) {
                var i3 = this.video.seekable;
                e3 < i3.start(0) || e3 > i3.end(0) ? this.fire(new t.ErrorEvent(new t.ValidationError("sources." + this.id, null, "Playback for this video can be set only between the " + i3.start(0) + " and " + i3.end(0) + "-second mark."))) : this.video.currentTime = e3;
              }
            }, i2.prototype.getVideo = function() {
              return this.video;
            }, i2.prototype.onAdd = function(t2) {
              this.map || (this.map = t2, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
            }, i2.prototype.prepare = function() {
              if (!(0 === Object.keys(this.tiles).length || this.video.readyState < 2)) {
                var e3 = this.map.painter.context, i3 = e3.gl;
                for (var o2 in this.boundsBuffer || (this.boundsBuffer = e3.createVertexBuffer(this._boundsArray, A.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE), i3.texSubImage2D(i3.TEXTURE_2D, 0, 0, 0, i3.RGBA, i3.UNSIGNED_BYTE, this.video)) : (this.texture = new t.Texture(e3, this.video, i3.RGBA), this.texture.bind(i3.LINEAR, i3.CLAMP_TO_EDGE)), this.tiles) {
                  var r2 = this.tiles[o2];
                  "loaded" !== r2.state && (r2.state = "loaded", r2.texture = this.texture);
                }
              }
            }, i2.prototype.serialize = function() {
              return { type: "video", urls: this.urls, coordinates: this.coordinates };
            }, i2.prototype.hasTransition = function() {
              return this.video && !this.video.paused;
            }, i2;
          }(M), R = function(e2) {
            function i2(i3, o2, r2, a2) {
              e2.call(this, i3, o2, r2, a2), o2.coordinates ? Array.isArray(o2.coordinates) && 4 === o2.coordinates.length && !o2.coordinates.some(function(t2) {
                return !Array.isArray(t2) || 2 !== t2.length || t2.some(function(t3) {
                  return "number" != typeof t3;
                });
              }) || this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i3, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i3, null, 'missing required property "coordinates"'))), o2.animate && "boolean" != typeof o2.animate && this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i3, null, 'optional "animate" property must be a boolean value'))), o2.canvas ? "string" == typeof o2.canvas || o2.canvas instanceof t.window.HTMLCanvasElement || this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i3, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t.ErrorEvent(new t.ValidationError("sources." + i3, null, 'missing required property "canvas"'))), this.options = o2, this.animate = void 0 === o2.animate || o2.animate;
            }
            return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.load = function() {
              this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof t.window.HTMLCanvasElement ? this.options.canvas : t.window.document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                this._playing = true, this.map.triggerRepaint();
              }, this.pause = function() {
                this._playing && (this.prepare(), this._playing = false);
              }, this._finishLoading());
            }, i2.prototype.getCanvas = function() {
              return this.canvas;
            }, i2.prototype.onAdd = function(t2) {
              this.map = t2, this.load(), this.canvas && this.animate && this.play();
            }, i2.prototype.onRemove = function() {
              this.pause();
            }, i2.prototype.prepare = function() {
              var e3 = false;
              if (this.canvas.width !== this.width && (this.width = this.canvas.width, e3 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e3 = true), !this._hasInvalidDimensions() && 0 !== Object.keys(this.tiles).length) {
                var i3 = this.map.painter.context, o2 = i3.gl;
                for (var r2 in this.boundsBuffer || (this.boundsBuffer = i3.createVertexBuffer(this._boundsArray, A.members)), this.boundsSegments || (this.boundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (e3 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new t.Texture(i3, this.canvas, o2.RGBA, { premultiply: true }), this.tiles) {
                  var a2 = this.tiles[r2];
                  "loaded" !== a2.state && (a2.state = "loaded", a2.texture = this.texture);
                }
              }
            }, i2.prototype.serialize = function() {
              return { type: "canvas", coordinates: this.coordinates };
            }, i2.prototype.hasTransition = function() {
              return this._playing;
            }, i2.prototype._hasInvalidDimensions = function() {
              for (var t2 = 0, e3 = [this.canvas.width, this.canvas.height]; t2 < e3.length; t2 += 1) {
                var i3 = e3[t2];
                if (isNaN(i3) || i3 <= 0)
                  return true;
              }
              return false;
            }, i2;
          }(M), k = { vector: S, raster: C, "raster-dem": z, geojson: D, video: L, image: M, canvas: R };
          function B(e2, i2) {
            var o2 = t.identity([]);
            return t.translate(o2, o2, [1, 1, 0]), t.scale(o2, o2, [0.5 * e2.width, 0.5 * e2.height, 1]), t.multiply(o2, o2, e2.calculatePosMatrix(i2.toUnwrapped()));
          }
          function O(t2, e2, i2, o2, r2, a2) {
            var n2 = function(t3, e3, i3) {
              if (t3)
                for (var o3 = 0, r3 = t3; o3 < r3.length; o3 += 1) {
                  var a3 = e3[r3[o3]];
                  if (a3 && a3.source === i3 && "fill-extrusion" === a3.type)
                    return true;
                }
              else
                for (var n3 in e3) {
                  var s3 = e3[n3];
                  if (s3.source === i3 && "fill-extrusion" === s3.type)
                    return true;
                }
              return false;
            }(r2 && r2.layers, e2, t2.id), s2 = a2.maxPitchScaleFactor(), l2 = t2.tilesIn(o2, s2, n2);
            l2.sort(F);
            for (var c2 = [], u2 = 0, h2 = l2; u2 < h2.length; u2 += 1) {
              var p2 = h2[u2];
              c2.push({ wrappedTileID: p2.tileID.wrapped().key, queryResults: p2.tile.queryRenderedFeatures(e2, i2, t2._state, p2.queryGeometry, p2.cameraQueryGeometry, p2.scale, r2, a2, s2, B(t2.transform, p2.tileID)) });
            }
            var d2 = function(t3) {
              for (var e3 = {}, i3 = {}, o3 = 0, r3 = t3; o3 < r3.length; o3 += 1) {
                var a3 = r3[o3], n3 = a3.queryResults, s3 = a3.wrappedTileID, l3 = i3[s3] = i3[s3] || {};
                for (var c3 in n3)
                  for (var u3 = n3[c3], h3 = l3[c3] = l3[c3] || {}, p3 = e3[c3] = e3[c3] || [], d3 = 0, _3 = u3; d3 < _3.length; d3 += 1) {
                    var f2 = _3[d3];
                    h3[f2.featureIndex] || (h3[f2.featureIndex] = true, p3.push(f2));
                  }
              }
              return e3;
            }(c2);
            for (var _2 in d2)
              d2[_2].forEach(function(e3) {
                var i3 = e3.feature, o3 = t2.getFeatureState(i3.layer["source-layer"], i3.id);
                i3.source = i3.layer.source, i3.layer["source-layer"] && (i3.sourceLayer = i3.layer["source-layer"]), i3.state = o3;
              });
            return d2;
          }
          function F(t2, e2) {
            var i2 = t2.tileID, o2 = e2.tileID;
            return i2.overscaledZ - o2.overscaledZ || i2.canonical.y - o2.canonical.y || i2.wrap - o2.wrap || i2.canonical.x - o2.canonical.x;
          }
          var U = function(t2, e2) {
            this.max = t2, this.onRemove = e2, this.reset();
          };
          U.prototype.reset = function() {
            for (var t2 in this.data)
              for (var e2 = 0, i2 = this.data[t2]; e2 < i2.length; e2 += 1) {
                var o2 = i2[e2];
                o2.timeout && clearTimeout(o2.timeout), this.onRemove(o2.value);
              }
            return this.data = {}, this.order = [], this;
          }, U.prototype.add = function(t2, e2, i2) {
            var o2 = this, r2 = t2.wrapped().key;
            void 0 === this.data[r2] && (this.data[r2] = []);
            var a2 = { value: e2, timeout: void 0 };
            if (void 0 !== i2 && (a2.timeout = setTimeout(function() {
              o2.remove(t2, a2);
            }, i2)), this.data[r2].push(a2), this.order.push(r2), this.order.length > this.max) {
              var n2 = this._getAndRemoveByKey(this.order[0]);
              n2 && this.onRemove(n2);
            }
            return this;
          }, U.prototype.has = function(t2) {
            return t2.wrapped().key in this.data;
          }, U.prototype.getAndRemove = function(t2) {
            return this.has(t2) ? this._getAndRemoveByKey(t2.wrapped().key) : null;
          }, U.prototype._getAndRemoveByKey = function(t2) {
            var e2 = this.data[t2].shift();
            return e2.timeout && clearTimeout(e2.timeout), 0 === this.data[t2].length && delete this.data[t2], this.order.splice(this.order.indexOf(t2), 1), e2.value;
          }, U.prototype.getByKey = function(t2) {
            var e2 = this.data[t2];
            return e2 ? e2[0].value : null;
          }, U.prototype.get = function(t2) {
            return this.has(t2) ? this.data[t2.wrapped().key][0].value : null;
          }, U.prototype.remove = function(t2, e2) {
            if (!this.has(t2))
              return this;
            var i2 = t2.wrapped().key, o2 = void 0 === e2 ? 0 : this.data[i2].indexOf(e2), r2 = this.data[i2][o2];
            return this.data[i2].splice(o2, 1), r2.timeout && clearTimeout(r2.timeout), 0 === this.data[i2].length && delete this.data[i2], this.onRemove(r2.value), this.order.splice(this.order.indexOf(i2), 1), this;
          }, U.prototype.setMaxSize = function(t2) {
            for (this.max = t2; this.order.length > this.max; ) {
              var e2 = this._getAndRemoveByKey(this.order[0]);
              e2 && this.onRemove(e2);
            }
            return this;
          }, U.prototype.filter = function(t2) {
            var e2 = [];
            for (var i2 in this.data)
              for (var o2 = 0, r2 = this.data[i2]; o2 < r2.length; o2 += 1) {
                var a2 = r2[o2];
                t2(a2.value) || e2.push(a2);
              }
            for (var n2 = 0, s2 = e2; n2 < s2.length; n2 += 1) {
              var l2 = s2[n2];
              this.remove(l2.value.tileID, l2);
            }
          };
          var N = function(t2, e2, i2) {
            this.context = t2;
            var o2 = t2.gl;
            this.buffer = o2.createBuffer(), this.dynamicDraw = Boolean(i2), this.context.unbindVAO(), t2.bindElementBuffer.set(this.buffer), o2.bufferData(o2.ELEMENT_ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? o2.DYNAMIC_DRAW : o2.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
          };
          N.prototype.bind = function() {
            this.context.bindElementBuffer.set(this.buffer);
          }, N.prototype.updateData = function(t2) {
            var e2 = this.context.gl;
            this.context.unbindVAO(), this.bind(), e2.bufferSubData(e2.ELEMENT_ARRAY_BUFFER, 0, t2.arrayBuffer);
          }, N.prototype.destroy = function() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          };
          var Z = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" }, q = function(t2, e2, i2, o2) {
            this.length = e2.length, this.attributes = i2, this.itemSize = e2.bytesPerElement, this.dynamicDraw = o2, this.context = t2;
            var r2 = t2.gl;
            this.buffer = r2.createBuffer(), t2.bindVertexBuffer.set(this.buffer), r2.bufferData(r2.ARRAY_BUFFER, e2.arrayBuffer, this.dynamicDraw ? r2.DYNAMIC_DRAW : r2.STATIC_DRAW), this.dynamicDraw || delete e2.arrayBuffer;
          };
          q.prototype.bind = function() {
            this.context.bindVertexBuffer.set(this.buffer);
          }, q.prototype.updateData = function(t2) {
            var e2 = this.context.gl;
            this.bind(), e2.bufferSubData(e2.ARRAY_BUFFER, 0, t2.arrayBuffer);
          }, q.prototype.enableAttributes = function(t2, e2) {
            for (var i2 = 0; i2 < this.attributes.length; i2++) {
              var o2 = e2.attributes[this.attributes[i2].name];
              void 0 !== o2 && t2.enableVertexAttribArray(o2);
            }
          }, q.prototype.setVertexAttribPointers = function(t2, e2, i2) {
            for (var o2 = 0; o2 < this.attributes.length; o2++) {
              var r2 = this.attributes[o2], a2 = e2.attributes[r2.name];
              void 0 !== a2 && t2.vertexAttribPointer(a2, r2.components, t2[Z[r2.type]], false, this.itemSize, r2.offset + this.itemSize * (i2 || 0));
            }
          }, q.prototype.destroy = function() {
            this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
          };
          var j = function(t2) {
            this.gl = t2.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
          };
          j.prototype.get = function() {
            return this.current;
          }, j.prototype.set = function(t2) {
          }, j.prototype.getDefault = function() {
            return this.default;
          }, j.prototype.setDefault = function() {
            this.set(this.default);
          };
          var V = function(e2) {
            function i2() {
              e2.apply(this, arguments);
            }
            return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.getDefault = function() {
              return t.Color.transparent;
            }, i2.prototype.set = function(t2) {
              var e3 = this.current;
              (t2.r !== e3.r || t2.g !== e3.g || t2.b !== e3.b || t2.a !== e3.a || this.dirty) && (this.gl.clearColor(t2.r, t2.g, t2.b, t2.a), this.current = t2, this.dirty = false);
            }, i2;
          }(j), G = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return 1;
            }, e2.prototype.set = function(t3) {
              (t3 !== this.current || this.dirty) && (this.gl.clearDepth(t3), this.current = t3, this.dirty = false);
            }, e2;
          }(j), W = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return 0;
            }, e2.prototype.set = function(t3) {
              (t3 !== this.current || this.dirty) && (this.gl.clearStencil(t3), this.current = t3, this.dirty = false);
            }, e2;
          }(j), X = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return [true, true, true, true];
            }, e2.prototype.set = function(t3) {
              var e3 = this.current;
              (t3[0] !== e3[0] || t3[1] !== e3[1] || t3[2] !== e3[2] || t3[3] !== e3[3] || this.dirty) && (this.gl.colorMask(t3[0], t3[1], t3[2], t3[3]), this.current = t3, this.dirty = false);
            }, e2;
          }(j), H = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return true;
            }, e2.prototype.set = function(t3) {
              (t3 !== this.current || this.dirty) && (this.gl.depthMask(t3), this.current = t3, this.dirty = false);
            }, e2;
          }(j), K = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return 255;
            }, e2.prototype.set = function(t3) {
              (t3 !== this.current || this.dirty) && (this.gl.stencilMask(t3), this.current = t3, this.dirty = false);
            }, e2;
          }(j), Y = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
            }, e2.prototype.set = function(t3) {
              var e3 = this.current;
              (t3.func !== e3.func || t3.ref !== e3.ref || t3.mask !== e3.mask || this.dirty) && (this.gl.stencilFunc(t3.func, t3.ref, t3.mask), this.current = t3, this.dirty = false);
            }, e2;
          }(j), J = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              var t3 = this.gl;
              return [t3.KEEP, t3.KEEP, t3.KEEP];
            }, e2.prototype.set = function(t3) {
              var e3 = this.current;
              (t3[0] !== e3[0] || t3[1] !== e3[1] || t3[2] !== e3[2] || this.dirty) && (this.gl.stencilOp(t3[0], t3[1], t3[2]), this.current = t3, this.dirty = false);
            }, e2;
          }(j), Q = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return false;
            }, e2.prototype.set = function(t3) {
              if (t3 !== this.current || this.dirty) {
                var e3 = this.gl;
                t3 ? e3.enable(e3.STENCIL_TEST) : e3.disable(e3.STENCIL_TEST), this.current = t3, this.dirty = false;
              }
            }, e2;
          }(j), $ = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return [0, 1];
            }, e2.prototype.set = function(t3) {
              var e3 = this.current;
              (t3[0] !== e3[0] || t3[1] !== e3[1] || this.dirty) && (this.gl.depthRange(t3[0], t3[1]), this.current = t3, this.dirty = false);
            }, e2;
          }(j), tt2 = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return false;
            }, e2.prototype.set = function(t3) {
              if (t3 !== this.current || this.dirty) {
                var e3 = this.gl;
                t3 ? e3.enable(e3.DEPTH_TEST) : e3.disable(e3.DEPTH_TEST), this.current = t3, this.dirty = false;
              }
            }, e2;
          }(j), et = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return this.gl.LESS;
            }, e2.prototype.set = function(t3) {
              (t3 !== this.current || this.dirty) && (this.gl.depthFunc(t3), this.current = t3, this.dirty = false);
            }, e2;
          }(j), it = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return false;
            }, e2.prototype.set = function(t3) {
              if (t3 !== this.current || this.dirty) {
                var e3 = this.gl;
                t3 ? e3.enable(e3.BLEND) : e3.disable(e3.BLEND), this.current = t3, this.dirty = false;
              }
            }, e2;
          }(j), ot = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              var t3 = this.gl;
              return [t3.ONE, t3.ZERO];
            }, e2.prototype.set = function(t3) {
              var e3 = this.current;
              (t3[0] !== e3[0] || t3[1] !== e3[1] || this.dirty) && (this.gl.blendFunc(t3[0], t3[1]), this.current = t3, this.dirty = false);
            }, e2;
          }(j), rt = function(e2) {
            function i2() {
              e2.apply(this, arguments);
            }
            return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.getDefault = function() {
              return t.Color.transparent;
            }, i2.prototype.set = function(t2) {
              var e3 = this.current;
              (t2.r !== e3.r || t2.g !== e3.g || t2.b !== e3.b || t2.a !== e3.a || this.dirty) && (this.gl.blendColor(t2.r, t2.g, t2.b, t2.a), this.current = t2, this.dirty = false);
            }, i2;
          }(j), at = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return this.gl.FUNC_ADD;
            }, e2.prototype.set = function(t3) {
              (t3 !== this.current || this.dirty) && (this.gl.blendEquation(t3), this.current = t3, this.dirty = false);
            }, e2;
          }(j), nt = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return false;
            }, e2.prototype.set = function(t3) {
              if (t3 !== this.current || this.dirty) {
                var e3 = this.gl;
                t3 ? e3.enable(e3.CULL_FACE) : e3.disable(e3.CULL_FACE), this.current = t3, this.dirty = false;
              }
            }, e2;
          }(j), st = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return this.gl.BACK;
            }, e2.prototype.set = function(t3) {
              (t3 !== this.current || this.dirty) && (this.gl.cullFace(t3), this.current = t3, this.dirty = false);
            }, e2;
          }(j), lt = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return this.gl.CCW;
            }, e2.prototype.set = function(t3) {
              (t3 !== this.current || this.dirty) && (this.gl.frontFace(t3), this.current = t3, this.dirty = false);
            }, e2;
          }(j), ct = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return null;
            }, e2.prototype.set = function(t3) {
              (t3 !== this.current || this.dirty) && (this.gl.useProgram(t3), this.current = t3, this.dirty = false);
            }, e2;
          }(j), ut = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return this.gl.TEXTURE0;
            }, e2.prototype.set = function(t3) {
              (t3 !== this.current || this.dirty) && (this.gl.activeTexture(t3), this.current = t3, this.dirty = false);
            }, e2;
          }(j), ht = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              var t3 = this.gl;
              return [0, 0, t3.drawingBufferWidth, t3.drawingBufferHeight];
            }, e2.prototype.set = function(t3) {
              var e3 = this.current;
              (t3[0] !== e3[0] || t3[1] !== e3[1] || t3[2] !== e3[2] || t3[3] !== e3[3] || this.dirty) && (this.gl.viewport(t3[0], t3[1], t3[2], t3[3]), this.current = t3, this.dirty = false);
            }, e2;
          }(j), pt = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return null;
            }, e2.prototype.set = function(t3) {
              if (t3 !== this.current || this.dirty) {
                var e3 = this.gl;
                e3.bindFramebuffer(e3.FRAMEBUFFER, t3), this.current = t3, this.dirty = false;
              }
            }, e2;
          }(j), dt = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return null;
            }, e2.prototype.set = function(t3) {
              if (t3 !== this.current || this.dirty) {
                var e3 = this.gl;
                e3.bindRenderbuffer(e3.RENDERBUFFER, t3), this.current = t3, this.dirty = false;
              }
            }, e2;
          }(j), _t = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return null;
            }, e2.prototype.set = function(t3) {
              if (t3 !== this.current || this.dirty) {
                var e3 = this.gl;
                e3.bindTexture(e3.TEXTURE_2D, t3), this.current = t3, this.dirty = false;
              }
            }, e2;
          }(j), ft = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return null;
            }, e2.prototype.set = function(t3) {
              if (t3 !== this.current || this.dirty) {
                var e3 = this.gl;
                e3.bindBuffer(e3.ARRAY_BUFFER, t3), this.current = t3, this.dirty = false;
              }
            }, e2;
          }(j), mt = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return null;
            }, e2.prototype.set = function(t3) {
              var e3 = this.gl;
              e3.bindBuffer(e3.ELEMENT_ARRAY_BUFFER, t3), this.current = t3, this.dirty = false;
            }, e2;
          }(j), gt = function(t2) {
            function e2(e3) {
              t2.call(this, e3), this.vao = e3.extVertexArrayObject;
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return null;
            }, e2.prototype.set = function(t3) {
              this.vao && (t3 !== this.current || this.dirty) && (this.vao.bindVertexArrayOES(t3), this.current = t3, this.dirty = false);
            }, e2;
          }(j), vt = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return 4;
            }, e2.prototype.set = function(t3) {
              if (t3 !== this.current || this.dirty) {
                var e3 = this.gl;
                e3.pixelStorei(e3.UNPACK_ALIGNMENT, t3), this.current = t3, this.dirty = false;
              }
            }, e2;
          }(j), yt = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return false;
            }, e2.prototype.set = function(t3) {
              if (t3 !== this.current || this.dirty) {
                var e3 = this.gl;
                e3.pixelStorei(e3.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t3), this.current = t3, this.dirty = false;
              }
            }, e2;
          }(j), xt = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return false;
            }, e2.prototype.set = function(t3) {
              if (t3 !== this.current || this.dirty) {
                var e3 = this.gl;
                e3.pixelStorei(e3.UNPACK_FLIP_Y_WEBGL, t3), this.current = t3, this.dirty = false;
              }
            }, e2;
          }(j), bt = function(t2) {
            function e2(e3, i2) {
              t2.call(this, e3), this.context = e3, this.parent = i2;
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.getDefault = function() {
              return null;
            }, e2;
          }(j), wt = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.setDirty = function() {
              this.dirty = true;
            }, e2.prototype.set = function(t3) {
              if (t3 !== this.current || this.dirty) {
                this.context.bindFramebuffer.set(this.parent);
                var e3 = this.gl;
                e3.framebufferTexture2D(e3.FRAMEBUFFER, e3.COLOR_ATTACHMENT0, e3.TEXTURE_2D, t3, 0), this.current = t3, this.dirty = false;
              }
            }, e2;
          }(bt), Tt = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.set = function(t3) {
              if (t3 !== this.current || this.dirty) {
                this.context.bindFramebuffer.set(this.parent);
                var e3 = this.gl;
                e3.framebufferRenderbuffer(e3.FRAMEBUFFER, e3.DEPTH_ATTACHMENT, e3.RENDERBUFFER, t3), this.current = t3, this.dirty = false;
              }
            }, e2;
          }(bt), Et = function(t2, e2, i2, o2) {
            this.context = t2, this.width = e2, this.height = i2;
            var r2 = this.framebuffer = t2.gl.createFramebuffer();
            this.colorAttachment = new wt(t2, r2), o2 && (this.depthAttachment = new Tt(t2, r2));
          };
          Et.prototype.destroy = function() {
            var t2 = this.context.gl, e2 = this.colorAttachment.get();
            if (e2 && t2.deleteTexture(e2), this.depthAttachment) {
              var i2 = this.depthAttachment.get();
              i2 && t2.deleteRenderbuffer(i2);
            }
            t2.deleteFramebuffer(this.framebuffer);
          };
          var It = function(t2, e2, i2) {
            this.func = t2, this.mask = e2, this.range = i2;
          };
          It.ReadOnly = false, It.ReadWrite = true, It.disabled = new It(519, It.ReadOnly, [0, 1]);
          var Pt = function(t2, e2, i2, o2, r2, a2) {
            this.test = t2, this.ref = e2, this.mask = i2, this.fail = o2, this.depthFail = r2, this.pass = a2;
          };
          Pt.disabled = new Pt({ func: 519, mask: 0 }, 0, 0, 7680, 7680, 7680);
          var St = function(t2, e2, i2) {
            this.blendFunction = t2, this.blendColor = e2, this.mask = i2;
          };
          St.disabled = new St(St.Replace = [1, 0], t.Color.transparent, [false, false, false, false]), St.unblended = new St(St.Replace, t.Color.transparent, [true, true, true, true]), St.alphaBlended = new St([1, 771], t.Color.transparent, [true, true, true, true]);
          var Ct = function(t2, e2, i2) {
            this.enable = t2, this.mode = e2, this.frontFace = i2;
          };
          Ct.disabled = new Ct(false, 1029, 2305), Ct.backCCW = new Ct(true, 1029, 2305);
          var zt = function(t2) {
            this.gl = t2, this.extVertexArrayObject = this.gl.getExtension("OES_vertex_array_object"), this.clearColor = new V(this), this.clearDepth = new G(this), this.clearStencil = new W(this), this.colorMask = new X(this), this.depthMask = new H(this), this.stencilMask = new K(this), this.stencilFunc = new Y(this), this.stencilOp = new J(this), this.stencilTest = new Q(this), this.depthRange = new $(this), this.depthTest = new tt2(this), this.depthFunc = new et(this), this.blend = new it(this), this.blendFunc = new ot(this), this.blendColor = new rt(this), this.blendEquation = new at(this), this.cullFace = new nt(this), this.cullFaceSide = new st(this), this.frontFace = new lt(this), this.program = new ct(this), this.activeTexture = new ut(this), this.viewport = new ht(this), this.bindFramebuffer = new pt(this), this.bindRenderbuffer = new dt(this), this.bindTexture = new _t(this), this.bindVertexBuffer = new ft(this), this.bindElementBuffer = new mt(this), this.bindVertexArrayOES = this.extVertexArrayObject && new gt(this), this.pixelStoreUnpack = new vt(this), this.pixelStoreUnpackPremultiplyAlpha = new yt(this), this.pixelStoreUnpackFlipY = new xt(this), this.extTextureFilterAnisotropic = t2.getExtension("EXT_texture_filter_anisotropic") || t2.getExtension("MOZ_EXT_texture_filter_anisotropic") || t2.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t2.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.extTextureHalfFloat = t2.getExtension("OES_texture_half_float"), this.extTextureHalfFloat && (t2.getExtension("OES_texture_half_float_linear"), this.extRenderToTextureHalfFloat = t2.getExtension("EXT_color_buffer_half_float")), this.extTimerQuery = t2.getExtension("EXT_disjoint_timer_query"), this.maxTextureSize = t2.getParameter(t2.MAX_TEXTURE_SIZE);
          };
          zt.prototype.setDefault = function() {
            this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
          }, zt.prototype.setDirty = function() {
            this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.extVertexArrayObject && (this.bindVertexArrayOES.dirty = true), this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
          }, zt.prototype.createIndexBuffer = function(t2, e2) {
            return new N(this, t2, e2);
          }, zt.prototype.createVertexBuffer = function(t2, e2, i2) {
            return new q(this, t2, e2, i2);
          }, zt.prototype.createRenderbuffer = function(t2, e2, i2) {
            var o2 = this.gl, r2 = o2.createRenderbuffer();
            return this.bindRenderbuffer.set(r2), o2.renderbufferStorage(o2.RENDERBUFFER, t2, e2, i2), this.bindRenderbuffer.set(null), r2;
          }, zt.prototype.createFramebuffer = function(t2, e2, i2) {
            return new Et(this, t2, e2, i2);
          }, zt.prototype.clear = function(t2) {
            var e2 = t2.color, i2 = t2.depth, o2 = this.gl, r2 = 0;
            e2 && (r2 |= o2.COLOR_BUFFER_BIT, this.clearColor.set(e2), this.colorMask.set([true, true, true, true])), void 0 !== i2 && (r2 |= o2.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(i2), this.depthMask.set(true)), o2.clear(r2);
          }, zt.prototype.setCullFace = function(t2) {
            false === t2.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(t2.mode), this.frontFace.set(t2.frontFace));
          }, zt.prototype.setDepthMode = function(t2) {
            t2.func !== this.gl.ALWAYS || t2.mask ? (this.depthTest.set(true), this.depthFunc.set(t2.func), this.depthMask.set(t2.mask), this.depthRange.set(t2.range)) : this.depthTest.set(false);
          }, zt.prototype.setStencilMode = function(t2) {
            t2.test.func !== this.gl.ALWAYS || t2.mask ? (this.stencilTest.set(true), this.stencilMask.set(t2.mask), this.stencilOp.set([t2.fail, t2.depthFail, t2.pass]), this.stencilFunc.set({ func: t2.test.func, ref: t2.ref, mask: t2.test.mask })) : this.stencilTest.set(false);
          }, zt.prototype.setColorMode = function(e2) {
            t.deepEqual(e2.blendFunction, St.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e2.blendFunction), this.blendColor.set(e2.blendColor)), this.colorMask.set(e2.mask);
          }, zt.prototype.unbindVAO = function() {
            this.extVertexArrayObject && this.bindVertexArrayOES.set(null);
          };
          var Dt = function(e2) {
            function i2(i3, o2, r2) {
              var a2 = this;
              e2.call(this), this.id = i3, this.dispatcher = r2, this.on("data", function(t2) {
                "source" === t2.dataType && "metadata" === t2.sourceDataType && (a2._sourceLoaded = true), a2._sourceLoaded && !a2._paused && "source" === t2.dataType && "content" === t2.sourceDataType && (a2.reload(), a2.transform && a2.update(a2.transform));
              }), this.on("error", function() {
                a2._sourceErrored = true;
              }), this._source = function(e3, i4, o3, r3) {
                var a3 = new k[i4.type](e3, i4, o3, r3);
                if (a3.id !== e3)
                  throw new Error("Expected Source id to be " + e3 + " instead of " + a3.id);
                return t.bindAll(["load", "abort", "unload", "serialize", "prepare"], a3), a3;
              }(i3, o2, r2, this), this._tiles = {}, this._cache = new U(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new t.SourceFeatureState();
            }
            return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.onAdd = function(t2) {
              this.map = t2, this._maxTileCacheSize = t2 ? t2._maxTileCacheSize : null, this._source && this._source.onAdd && this._source.onAdd(t2);
            }, i2.prototype.onRemove = function(t2) {
              this._source && this._source.onRemove && this._source.onRemove(t2);
            }, i2.prototype.loaded = function() {
              if (this._sourceErrored)
                return true;
              if (!this._sourceLoaded)
                return false;
              if (!this._source.loaded())
                return false;
              for (var t2 in this._tiles) {
                var e3 = this._tiles[t2];
                if ("loaded" !== e3.state && "errored" !== e3.state)
                  return false;
              }
              return true;
            }, i2.prototype.getSource = function() {
              return this._source;
            }, i2.prototype.pause = function() {
              this._paused = true;
            }, i2.prototype.resume = function() {
              if (this._paused) {
                var t2 = this._shouldReloadOnResume;
                this._paused = false, this._shouldReloadOnResume = false, t2 && this.reload(), this.transform && this.update(this.transform);
              }
            }, i2.prototype._loadTile = function(t2, e3) {
              return this._source.loadTile(t2, e3);
            }, i2.prototype._unloadTile = function(t2) {
              if (this._source.unloadTile)
                return this._source.unloadTile(t2, function() {
                });
            }, i2.prototype._abortTile = function(t2) {
              if (this._source.abortTile)
                return this._source.abortTile(t2, function() {
                });
            }, i2.prototype.serialize = function() {
              return this._source.serialize();
            }, i2.prototype.prepare = function(t2) {
              for (var e3 in this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null), this._tiles) {
                var i3 = this._tiles[e3];
                i3.upload(t2), i3.prepare(this.map.style.imageManager);
              }
            }, i2.prototype.getIds = function() {
              return t.values(this._tiles).map(function(t2) {
                return t2.tileID;
              }).sort(At).map(function(t2) {
                return t2.key;
              });
            }, i2.prototype.getRenderableIds = function(e3) {
              var i3 = this, o2 = [];
              for (var r2 in this._tiles)
                this._isIdRenderable(r2, e3) && o2.push(this._tiles[r2]);
              return e3 ? o2.sort(function(e4, o3) {
                var r3 = e4.tileID, a2 = o3.tileID, n2 = new t.Point(r3.canonical.x, r3.canonical.y)._rotate(i3.transform.angle), s2 = new t.Point(a2.canonical.x, a2.canonical.y)._rotate(i3.transform.angle);
                return r3.overscaledZ - a2.overscaledZ || s2.y - n2.y || s2.x - n2.x;
              }).map(function(t2) {
                return t2.tileID.key;
              }) : o2.map(function(t2) {
                return t2.tileID;
              }).sort(At).map(function(t2) {
                return t2.key;
              });
            }, i2.prototype.hasRenderableParent = function(t2) {
              var e3 = this.findLoadedParent(t2, 0);
              return !!e3 && this._isIdRenderable(e3.tileID.key);
            }, i2.prototype._isIdRenderable = function(t2, e3) {
              return this._tiles[t2] && this._tiles[t2].hasData() && !this._coveredTiles[t2] && (e3 || !this._tiles[t2].holdingForFade());
            }, i2.prototype.reload = function() {
              if (this._paused)
                this._shouldReloadOnResume = true;
              else
                for (var t2 in this._cache.reset(), this._tiles)
                  "errored" !== this._tiles[t2].state && this._reloadTile(t2, "reloading");
            }, i2.prototype._reloadTile = function(t2, e3) {
              var i3 = this._tiles[t2];
              i3 && ("loading" !== i3.state && (i3.state = e3), this._loadTile(i3, this._tileLoaded.bind(this, i3, t2, e3)));
            }, i2.prototype._tileLoaded = function(e3, i3, o2, r2) {
              if (r2)
                return e3.state = "errored", void (404 !== r2.status ? this._source.fire(new t.ErrorEvent(r2, { tile: e3 })) : this.update(this.transform));
              e3.timeAdded = t.browser.now(), "expired" === o2 && (e3.refreshedUponExpiration = true), this._setTileReloadTimer(i3, e3), "raster-dem" === this.getSource().type && e3.dem && this._backfillDEM(e3), this._state.initializeTileState(e3, this.map ? this.map.painter : null), this._source.fire(new t.Event("data", { dataType: "source", tile: e3, coord: e3.tileID }));
            }, i2.prototype._backfillDEM = function(t2) {
              for (var e3 = this.getRenderableIds(), i3 = 0; i3 < e3.length; i3++) {
                var o2 = e3[i3];
                if (t2.neighboringTiles && t2.neighboringTiles[o2]) {
                  var r2 = this.getTileByID(o2);
                  a2(t2, r2), a2(r2, t2);
                }
              }
              function a2(t3, e4) {
                t3.needsHillshadePrepare = true;
                var i4 = e4.tileID.canonical.x - t3.tileID.canonical.x, o3 = e4.tileID.canonical.y - t3.tileID.canonical.y, r3 = Math.pow(2, t3.tileID.canonical.z), a3 = e4.tileID.key;
                0 === i4 && 0 === o3 || Math.abs(o3) > 1 || (Math.abs(i4) > 1 && (1 === Math.abs(i4 + r3) ? i4 += r3 : 1 === Math.abs(i4 - r3) && (i4 -= r3)), e4.dem && t3.dem && (t3.dem.backfillBorder(e4.dem, i4, o3), t3.neighboringTiles && t3.neighboringTiles[a3] && (t3.neighboringTiles[a3].backfilled = true)));
              }
            }, i2.prototype.getTile = function(t2) {
              return this.getTileByID(t2.key);
            }, i2.prototype.getTileByID = function(t2) {
              return this._tiles[t2];
            }, i2.prototype._retainLoadedChildren = function(t2, e3, i3, o2) {
              for (var r2 in this._tiles) {
                var a2 = this._tiles[r2];
                if (!(o2[r2] || !a2.hasData() || a2.tileID.overscaledZ <= e3 || a2.tileID.overscaledZ > i3)) {
                  for (var n2 = a2.tileID; a2 && a2.tileID.overscaledZ > e3 + 1; ) {
                    var s2 = a2.tileID.scaledTo(a2.tileID.overscaledZ - 1);
                    (a2 = this._tiles[s2.key]) && a2.hasData() && (n2 = s2);
                  }
                  for (var l2 = n2; l2.overscaledZ > e3; )
                    if (t2[(l2 = l2.scaledTo(l2.overscaledZ - 1)).key]) {
                      o2[n2.key] = n2;
                      break;
                    }
                }
              }
            }, i2.prototype.findLoadedParent = function(t2, e3) {
              if (t2.key in this._loadedParentTiles) {
                var i3 = this._loadedParentTiles[t2.key];
                return i3 && i3.tileID.overscaledZ >= e3 ? i3 : null;
              }
              for (var o2 = t2.overscaledZ - 1; o2 >= e3; o2--) {
                var r2 = t2.scaledTo(o2), a2 = this._getLoadedTile(r2);
                if (a2)
                  return a2;
              }
            }, i2.prototype._getLoadedTile = function(t2) {
              var e3 = this._tiles[t2.key];
              return e3 && e3.hasData() ? e3 : this._cache.getByKey(t2.wrapped().key);
            }, i2.prototype.updateCacheSize = function(t2) {
              var e3 = Math.ceil(t2.width / this._source.tileSize) + 1, i3 = Math.ceil(t2.height / this._source.tileSize) + 1, o2 = Math.floor(e3 * i3 * 5), r2 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, o2) : o2;
              this._cache.setMaxSize(r2);
            }, i2.prototype.handleWrapJump = function(t2) {
              var e3 = Math.round((t2 - (void 0 === this._prevLng ? t2 : this._prevLng)) / 360);
              if (this._prevLng = t2, e3) {
                var i3 = {};
                for (var o2 in this._tiles) {
                  var r2 = this._tiles[o2];
                  r2.tileID = r2.tileID.unwrapTo(r2.tileID.wrap + e3), i3[r2.tileID.key] = r2;
                }
                for (var a2 in this._tiles = i3, this._timers)
                  clearTimeout(this._timers[a2]), delete this._timers[a2];
                for (var n2 in this._tiles)
                  this._setTileReloadTimer(n2, this._tiles[n2]);
              }
            }, i2.prototype.update = function(e3) {
              var o2 = this;
              if (this.transform = e3, this._sourceLoaded && !this._paused) {
                var r2;
                this.updateCacheSize(e3), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used ? this._source.tileID ? r2 = e3.getVisibleUnwrappedCoordinates(this._source.tileID).map(function(e4) {
                  return new t.OverscaledTileID(e4.canonical.z, e4.wrap, e4.canonical.z, e4.canonical.x, e4.canonical.y);
                }) : (r2 = e3.coveringTiles({ tileSize: this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled }), this._source.hasTile && (r2 = r2.filter(function(t2) {
                  return o2._source.hasTile(t2);
                }))) : r2 = [];
                var a2 = e3.coveringZoomLevel(this._source), n2 = Math.max(a2 - i2.maxOverzooming, this._source.minzoom), s2 = Math.max(a2 + i2.maxUnderzooming, this._source.minzoom), l2 = this._updateRetainedTiles(r2, a2);
                if (Mt(this._source.type)) {
                  for (var c2 = {}, u2 = {}, h2 = 0, p2 = Object.keys(l2); h2 < p2.length; h2 += 1) {
                    var d2 = p2[h2], _2 = l2[d2], f2 = this._tiles[d2];
                    if (f2 && !(f2.fadeEndTime && f2.fadeEndTime <= t.browser.now())) {
                      var m2 = this.findLoadedParent(_2, n2);
                      m2 && (this._addTile(m2.tileID), c2[m2.tileID.key] = m2.tileID), u2[d2] = _2;
                    }
                  }
                  for (var g2 in this._retainLoadedChildren(u2, a2, s2, l2), c2)
                    l2[g2] || (this._coveredTiles[g2] = true, l2[g2] = c2[g2]);
                }
                for (var v2 in l2)
                  this._tiles[v2].clearFadeHold();
                for (var y2 = 0, x2 = t.keysDifference(this._tiles, l2); y2 < x2.length; y2 += 1) {
                  var b2 = x2[y2], w2 = this._tiles[b2];
                  w2.hasSymbolBuckets && !w2.holdingForFade() ? w2.setHoldDuration(this.map._fadeDuration) : w2.hasSymbolBuckets && !w2.symbolFadeFinished() || this._removeTile(b2);
                }
                this._updateLoadedParentTileCache();
              }
            }, i2.prototype.releaseSymbolFadeTiles = function() {
              for (var t2 in this._tiles)
                this._tiles[t2].holdingForFade() && this._removeTile(t2);
            }, i2.prototype._updateRetainedTiles = function(t2, e3) {
              for (var o2 = {}, r2 = {}, a2 = Math.max(e3 - i2.maxOverzooming, this._source.minzoom), n2 = Math.max(e3 + i2.maxUnderzooming, this._source.minzoom), s2 = {}, l2 = 0, c2 = t2; l2 < c2.length; l2 += 1) {
                var u2 = c2[l2], h2 = this._addTile(u2);
                o2[u2.key] = u2, h2.hasData() || e3 < this._source.maxzoom && (s2[u2.key] = u2);
              }
              this._retainLoadedChildren(s2, e3, n2, o2);
              for (var p2 = 0, d2 = t2; p2 < d2.length; p2 += 1) {
                var _2 = d2[p2], f2 = this._tiles[_2.key];
                if (!f2.hasData()) {
                  if (e3 + 1 > this._source.maxzoom) {
                    var m2 = _2.children(this._source.maxzoom)[0], g2 = this.getTile(m2);
                    if (g2 && g2.hasData()) {
                      o2[m2.key] = m2;
                      continue;
                    }
                  } else {
                    var v2 = _2.children(this._source.maxzoom);
                    if (o2[v2[0].key] && o2[v2[1].key] && o2[v2[2].key] && o2[v2[3].key])
                      continue;
                  }
                  for (var y2 = f2.wasRequested(), x2 = _2.overscaledZ - 1; x2 >= a2; --x2) {
                    var b2 = _2.scaledTo(x2);
                    if (r2[b2.key])
                      break;
                    if (r2[b2.key] = true, !(f2 = this.getTile(b2)) && y2 && (f2 = this._addTile(b2)), f2 && (o2[b2.key] = b2, y2 = f2.wasRequested(), f2.hasData()))
                      break;
                  }
                }
              }
              return o2;
            }, i2.prototype._updateLoadedParentTileCache = function() {
              for (var t2 in this._loadedParentTiles = {}, this._tiles) {
                for (var e3 = [], i3 = void 0, o2 = this._tiles[t2].tileID; o2.overscaledZ > 0; ) {
                  if (o2.key in this._loadedParentTiles) {
                    i3 = this._loadedParentTiles[o2.key];
                    break;
                  }
                  e3.push(o2.key);
                  var r2 = o2.scaledTo(o2.overscaledZ - 1);
                  if (i3 = this._getLoadedTile(r2))
                    break;
                  o2 = r2;
                }
                for (var a2 = 0, n2 = e3; a2 < n2.length; a2 += 1)
                  this._loadedParentTiles[n2[a2]] = i3;
              }
            }, i2.prototype._addTile = function(e3) {
              var i3 = this._tiles[e3.key];
              if (i3)
                return i3;
              (i3 = this._cache.getAndRemove(e3)) && (this._setTileReloadTimer(e3.key, i3), i3.tileID = e3, this._state.initializeTileState(i3, this.map ? this.map.painter : null), this._cacheTimers[e3.key] && (clearTimeout(this._cacheTimers[e3.key]), delete this._cacheTimers[e3.key], this._setTileReloadTimer(e3.key, i3)));
              var o2 = Boolean(i3);
              return o2 || (i3 = new t.Tile(e3, this._source.tileSize * e3.overscaleFactor()), this._loadTile(i3, this._tileLoaded.bind(this, i3, e3.key, i3.state))), i3 ? (i3.uses++, this._tiles[e3.key] = i3, o2 || this._source.fire(new t.Event("dataloading", { tile: i3, coord: i3.tileID, dataType: "source" })), i3) : null;
            }, i2.prototype._setTileReloadTimer = function(t2, e3) {
              var i3 = this;
              t2 in this._timers && (clearTimeout(this._timers[t2]), delete this._timers[t2]);
              var o2 = e3.getExpiryTimeout();
              o2 && (this._timers[t2] = setTimeout(function() {
                i3._reloadTile(t2, "expired"), delete i3._timers[t2];
              }, o2));
            }, i2.prototype._removeTile = function(t2) {
              var e3 = this._tiles[t2];
              e3 && (e3.uses--, delete this._tiles[t2], this._timers[t2] && (clearTimeout(this._timers[t2]), delete this._timers[t2]), e3.uses > 0 || (e3.hasData() && "reloading" !== e3.state ? this._cache.add(e3.tileID, e3, e3.getExpiryTimeout()) : (e3.aborted = true, this._abortTile(e3), this._unloadTile(e3))));
            }, i2.prototype.clearTiles = function() {
              for (var t2 in this._shouldReloadOnResume = false, this._paused = false, this._tiles)
                this._removeTile(t2);
              this._cache.reset();
            }, i2.prototype.tilesIn = function(e3, i3, o2) {
              var r2 = this, a2 = [], n2 = this.transform;
              if (!n2)
                return a2;
              for (var s2 = o2 ? n2.getCameraQueryGeometry(e3) : e3, l2 = e3.map(function(t2) {
                return n2.pointCoordinate(t2);
              }), c2 = s2.map(function(t2) {
                return n2.pointCoordinate(t2);
              }), u2 = this.getIds(), h2 = 1 / 0, p2 = 1 / 0, d2 = -1 / 0, _2 = -1 / 0, f2 = 0, m2 = c2; f2 < m2.length; f2 += 1) {
                var g2 = m2[f2];
                h2 = Math.min(h2, g2.x), p2 = Math.min(p2, g2.y), d2 = Math.max(d2, g2.x), _2 = Math.max(_2, g2.y);
              }
              for (var v2 = function(e4) {
                var o3 = r2._tiles[u2[e4]];
                if (!o3.holdingForFade()) {
                  var s3 = o3.tileID, f3 = Math.pow(2, n2.zoom - o3.tileID.overscaledZ), m3 = i3 * o3.queryPadding * t.EXTENT / o3.tileSize / f3, g3 = [s3.getTilePoint(new t.MercatorCoordinate(h2, p2)), s3.getTilePoint(new t.MercatorCoordinate(d2, _2))];
                  if (g3[0].x - m3 < t.EXTENT && g3[0].y - m3 < t.EXTENT && g3[1].x + m3 >= 0 && g3[1].y + m3 >= 0) {
                    var v3 = l2.map(function(t2) {
                      return s3.getTilePoint(t2);
                    }), y3 = c2.map(function(t2) {
                      return s3.getTilePoint(t2);
                    });
                    a2.push({ tile: o3, tileID: s3, queryGeometry: v3, cameraQueryGeometry: y3, scale: f3 });
                  }
                }
              }, y2 = 0; y2 < u2.length; y2++)
                v2(y2);
              return a2;
            }, i2.prototype.getVisibleCoordinates = function(t2) {
              for (var e3 = this, i3 = this.getRenderableIds(t2).map(function(t3) {
                return e3._tiles[t3].tileID;
              }), o2 = 0, r2 = i3; o2 < r2.length; o2 += 1) {
                var a2 = r2[o2];
                a2.posMatrix = this.transform.calculatePosMatrix(a2.toUnwrapped());
              }
              return i3;
            }, i2.prototype.hasTransition = function() {
              if (this._source.hasTransition())
                return true;
              if (Mt(this._source.type))
                for (var e3 in this._tiles) {
                  var i3 = this._tiles[e3];
                  if (void 0 !== i3.fadeEndTime && i3.fadeEndTime >= t.browser.now())
                    return true;
                }
              return false;
            }, i2.prototype.setFeatureState = function(t2, e3, i3) {
              this._state.updateState(t2 = t2 || "_geojsonTileLayer", e3, i3);
            }, i2.prototype.removeFeatureState = function(t2, e3, i3) {
              this._state.removeFeatureState(t2 = t2 || "_geojsonTileLayer", e3, i3);
            }, i2.prototype.getFeatureState = function(t2, e3) {
              return this._state.getState(t2 = t2 || "_geojsonTileLayer", e3);
            }, i2.prototype.setDependencies = function(t2, e3, i3) {
              var o2 = this._tiles[t2];
              o2 && o2.setDependencies(e3, i3);
            }, i2.prototype.reloadTilesForDependencies = function(t2, e3) {
              for (var i3 in this._tiles)
                this._tiles[i3].hasDependency(t2, e3) && this._reloadTile(i3, "reloading");
              this._cache.filter(function(i4) {
                return !i4.hasDependency(t2, e3);
              });
            }, i2;
          }(t.Evented);
          function At(t2, e2) {
            var i2 = Math.abs(2 * t2.wrap) - +(t2.wrap < 0), o2 = Math.abs(2 * e2.wrap) - +(e2.wrap < 0);
            return t2.overscaledZ - e2.overscaledZ || o2 - i2 || e2.canonical.y - t2.canonical.y || e2.canonical.x - t2.canonical.x;
          }
          function Mt(t2) {
            return "raster" === t2 || "image" === t2 || "video" === t2;
          }
          function Lt() {
            return new t.window.Worker(Kr.workerUrl);
          }
          Dt.maxOverzooming = 10, Dt.maxUnderzooming = 3;
          var Rt = "mapboxgl_preloaded_worker_pool", kt = function() {
            this.active = {};
          };
          kt.prototype.acquire = function(t2) {
            if (!this.workers)
              for (this.workers = []; this.workers.length < kt.workerCount; )
                this.workers.push(new Lt());
            return this.active[t2] = true, this.workers.slice();
          }, kt.prototype.release = function(t2) {
            delete this.active[t2], 0 === this.numActive() && (this.workers.forEach(function(t3) {
              t3.terminate();
            }), this.workers = null);
          }, kt.prototype.isPreloaded = function() {
            return !!this.active[Rt];
          }, kt.prototype.numActive = function() {
            return Object.keys(this.active).length;
          };
          var Bt, Ot = Math.floor(t.browser.hardwareConcurrency / 2);
          function Ft() {
            return Bt || (Bt = new kt()), Bt;
          }
          function Ut(e2, i2) {
            var o2 = {};
            for (var r2 in e2)
              "ref" !== r2 && (o2[r2] = e2[r2]);
            return t.refProperties.forEach(function(t2) {
              t2 in i2 && (o2[t2] = i2[t2]);
            }), o2;
          }
          function Nt(t2) {
            t2 = t2.slice();
            for (var e2 = /* @__PURE__ */ Object.create(null), i2 = 0; i2 < t2.length; i2++)
              e2[t2[i2].id] = t2[i2];
            for (var o2 = 0; o2 < t2.length; o2++)
              "ref" in t2[o2] && (t2[o2] = Ut(t2[o2], e2[t2[o2].ref]));
            return t2;
          }
          kt.workerCount = Math.max(Math.min(Ot, 6), 1);
          var Zt = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight" };
          function qt(t2, e2, i2) {
            i2.push({ command: Zt.addSource, args: [t2, e2[t2]] });
          }
          function jt(t2, e2, i2) {
            e2.push({ command: Zt.removeSource, args: [t2] }), i2[t2] = true;
          }
          function Vt(t2, e2, i2, o2) {
            jt(t2, i2, o2), qt(t2, e2, i2);
          }
          function Gt(e2, i2, o2) {
            var r2;
            for (r2 in e2[o2])
              if (e2[o2].hasOwnProperty(r2) && "data" !== r2 && !t.deepEqual(e2[o2][r2], i2[o2][r2]))
                return false;
            for (r2 in i2[o2])
              if (i2[o2].hasOwnProperty(r2) && "data" !== r2 && !t.deepEqual(e2[o2][r2], i2[o2][r2]))
                return false;
            return true;
          }
          function Wt(e2, i2, o2, r2, a2, n2) {
            var s2;
            for (s2 in i2 = i2 || {}, e2 = e2 || {})
              e2.hasOwnProperty(s2) && (t.deepEqual(e2[s2], i2[s2]) || o2.push({ command: n2, args: [r2, s2, i2[s2], a2] }));
            for (s2 in i2)
              i2.hasOwnProperty(s2) && !e2.hasOwnProperty(s2) && (t.deepEqual(e2[s2], i2[s2]) || o2.push({ command: n2, args: [r2, s2, i2[s2], a2] }));
          }
          function Xt(t2) {
            return t2.id;
          }
          function Ht(t2, e2) {
            return t2[e2.id] = e2, t2;
          }
          var Kt = function(t2, e2) {
            this.reset(t2, e2);
          };
          Kt.prototype.reset = function(t2, e2) {
            this.points = t2 || [], this._distances = [0];
            for (var i2 = 1; i2 < this.points.length; i2++)
              this._distances[i2] = this._distances[i2 - 1] + this.points[i2].dist(this.points[i2 - 1]);
            this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e2 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
          }, Kt.prototype.lerp = function(e2) {
            if (1 === this.points.length)
              return this.points[0];
            e2 = t.clamp(e2, 0, 1);
            for (var i2 = 1, o2 = this._distances[i2], r2 = e2 * this.paddedLength + this.padding; o2 < r2 && i2 < this._distances.length; )
              o2 = this._distances[++i2];
            var a2 = i2 - 1, n2 = this._distances[a2], s2 = o2 - n2, l2 = s2 > 0 ? (r2 - n2) / s2 : 0;
            return this.points[a2].mult(1 - l2).add(this.points[i2].mult(l2));
          };
          var Yt = function(t2, e2, i2) {
            var o2 = this.boxCells = [], r2 = this.circleCells = [];
            this.xCellCount = Math.ceil(t2 / i2), this.yCellCount = Math.ceil(e2 / i2);
            for (var a2 = 0; a2 < this.xCellCount * this.yCellCount; a2++)
              o2.push([]), r2.push([]);
            this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t2, this.height = e2, this.xScale = this.xCellCount / t2, this.yScale = this.yCellCount / e2, this.boxUid = 0, this.circleUid = 0;
          };
          function Jt(e2, i2, o2, r2, a2) {
            var n2 = t.create();
            return i2 ? (t.scale(n2, n2, [1 / a2, 1 / a2, 1]), o2 || t.rotateZ(n2, n2, r2.angle)) : t.multiply(n2, r2.labelPlaneMatrix, e2), n2;
          }
          function Qt(e2, i2, o2, r2, a2) {
            if (i2) {
              var n2 = t.clone(e2);
              return t.scale(n2, n2, [a2, a2, 1]), o2 || t.rotateZ(n2, n2, -r2.angle), n2;
            }
            return r2.glCoordMatrix;
          }
          function $t(e2, i2) {
            var o2 = [e2.x, e2.y, 0, 1];
            ue(o2, o2, i2);
            var r2 = o2[3];
            return { point: new t.Point(o2[0] / r2, o2[1] / r2), signedDistanceFromCamera: r2 };
          }
          function te(t2, e2) {
            return 0.5 + t2 / e2 * 0.5;
          }
          function ee(t2, e2) {
            var i2 = t2[0] / t2[3], o2 = t2[1] / t2[3];
            return i2 >= -e2[0] && i2 <= e2[0] && o2 >= -e2[1] && o2 <= e2[1];
          }
          function ie(e2, i2, o2, r2, a2, n2, s2, l2) {
            var c2 = r2 ? e2.textSizeData : e2.iconSizeData, u2 = t.evaluateSizeForZoom(c2, o2.transform.zoom), h2 = [256 / o2.width * 2 + 1, 256 / o2.height * 2 + 1], p2 = r2 ? e2.text.dynamicLayoutVertexArray : e2.icon.dynamicLayoutVertexArray;
            p2.clear();
            for (var d2 = e2.lineVertexArray, _2 = r2 ? e2.text.placedSymbolArray : e2.icon.placedSymbolArray, f2 = o2.transform.width / o2.transform.height, m2 = false, g2 = 0; g2 < _2.length; g2++) {
              var v2 = _2.get(g2);
              if (v2.hidden || v2.writingMode === t.WritingMode.vertical && !m2)
                ce(v2.numGlyphs, p2);
              else {
                m2 = false;
                var y2 = [v2.anchorX, v2.anchorY, 0, 1];
                if (t.transformMat4(y2, y2, i2), ee(y2, h2)) {
                  var x2 = te(o2.transform.cameraToCenterDistance, y2[3]), b2 = t.evaluateSizeForFeature(c2, u2, v2), w2 = s2 ? b2 / x2 : b2 * x2, T2 = new t.Point(v2.anchorX, v2.anchorY), E2 = $t(T2, a2).point, I2 = {}, P2 = ae(v2, w2, false, l2, i2, a2, n2, e2.glyphOffsetArray, d2, p2, E2, T2, I2, f2);
                  m2 = P2.useVertical, (P2.notEnoughRoom || m2 || P2.needsFlipping && ae(v2, w2, true, l2, i2, a2, n2, e2.glyphOffsetArray, d2, p2, E2, T2, I2, f2).notEnoughRoom) && ce(v2.numGlyphs, p2);
                } else
                  ce(v2.numGlyphs, p2);
              }
            }
            r2 ? e2.text.dynamicLayoutVertexBuffer.updateData(p2) : e2.icon.dynamicLayoutVertexBuffer.updateData(p2);
          }
          function oe(t2, e2, i2, o2, r2, a2, n2, s2, l2, c2, u2) {
            var h2 = s2.glyphStartIndex + s2.numGlyphs, p2 = s2.lineStartIndex, d2 = s2.lineStartIndex + s2.lineLength, _2 = e2.getoffsetX(s2.glyphStartIndex), f2 = e2.getoffsetX(h2 - 1), m2 = se(t2 * _2, i2, o2, r2, a2, n2, s2.segment, p2, d2, l2, c2, u2);
            if (!m2)
              return null;
            var g2 = se(t2 * f2, i2, o2, r2, a2, n2, s2.segment, p2, d2, l2, c2, u2);
            return g2 ? { first: m2, last: g2 } : null;
          }
          function re(e2, i2, o2, r2) {
            return e2 === t.WritingMode.horizontal && Math.abs(o2.y - i2.y) > Math.abs(o2.x - i2.x) * r2 ? { useVertical: true } : (e2 === t.WritingMode.vertical ? i2.y < o2.y : i2.x > o2.x) ? { needsFlipping: true } : null;
          }
          function ae(e2, i2, o2, r2, a2, n2, s2, l2, c2, u2, h2, p2, d2, _2) {
            var f2, m2 = i2 / 24, g2 = e2.lineOffsetX * m2, v2 = e2.lineOffsetY * m2;
            if (e2.numGlyphs > 1) {
              var y2 = e2.glyphStartIndex + e2.numGlyphs, x2 = e2.lineStartIndex, b2 = e2.lineStartIndex + e2.lineLength, w2 = oe(m2, l2, g2, v2, o2, h2, p2, e2, c2, n2, d2);
              if (!w2)
                return { notEnoughRoom: true };
              var T2 = $t(w2.first.point, s2).point, E2 = $t(w2.last.point, s2).point;
              if (r2 && !o2) {
                var I2 = re(e2.writingMode, T2, E2, _2);
                if (I2)
                  return I2;
              }
              f2 = [w2.first];
              for (var P2 = e2.glyphStartIndex + 1; P2 < y2 - 1; P2++)
                f2.push(se(m2 * l2.getoffsetX(P2), g2, v2, o2, h2, p2, e2.segment, x2, b2, c2, n2, d2));
              f2.push(w2.last);
            } else {
              if (r2 && !o2) {
                var S2 = $t(p2, a2).point, C2 = e2.lineStartIndex + e2.segment + 1, z2 = new t.Point(c2.getx(C2), c2.gety(C2)), D2 = $t(z2, a2), A2 = D2.signedDistanceFromCamera > 0 ? D2.point : ne(p2, z2, S2, 1, a2), M2 = re(e2.writingMode, S2, A2, _2);
                if (M2)
                  return M2;
              }
              var L2 = se(m2 * l2.getoffsetX(e2.glyphStartIndex), g2, v2, o2, h2, p2, e2.segment, e2.lineStartIndex, e2.lineStartIndex + e2.lineLength, c2, n2, d2);
              if (!L2)
                return { notEnoughRoom: true };
              f2 = [L2];
            }
            for (var R2 = 0, k2 = f2; R2 < k2.length; R2 += 1) {
              var B2 = k2[R2];
              t.addDynamicAttributes(u2, B2.point, B2.angle);
            }
            return {};
          }
          function ne(t2, e2, i2, o2, r2) {
            var a2 = $t(t2.add(t2.sub(e2)._unit()), r2).point, n2 = i2.sub(a2);
            return i2.add(n2._mult(o2 / n2.mag()));
          }
          function se(e2, i2, o2, r2, a2, n2, s2, l2, c2, u2, h2, p2) {
            var d2 = r2 ? e2 - i2 : e2 + i2, _2 = d2 > 0 ? 1 : -1, f2 = 0;
            r2 && (_2 *= -1, f2 = Math.PI), _2 < 0 && (f2 += Math.PI);
            for (var m2 = _2 > 0 ? l2 + s2 : l2 + s2 + 1, g2 = a2, v2 = a2, y2 = 0, x2 = 0, b2 = Math.abs(d2), w2 = []; y2 + x2 <= b2; ) {
              if ((m2 += _2) < l2 || m2 >= c2)
                return null;
              if (v2 = g2, w2.push(g2), void 0 === (g2 = p2[m2])) {
                var T2 = new t.Point(u2.getx(m2), u2.gety(m2)), E2 = $t(T2, h2);
                if (E2.signedDistanceFromCamera > 0)
                  g2 = p2[m2] = E2.point;
                else {
                  var I2 = m2 - _2;
                  g2 = ne(0 === y2 ? n2 : new t.Point(u2.getx(I2), u2.gety(I2)), T2, v2, b2 - y2 + 1, h2);
                }
              }
              y2 += x2, x2 = v2.dist(g2);
            }
            var P2 = (b2 - y2) / x2, S2 = g2.sub(v2), C2 = S2.mult(P2)._add(v2);
            C2._add(S2._unit()._perp()._mult(o2 * _2));
            var z2 = f2 + Math.atan2(g2.y - v2.y, g2.x - v2.x);
            return w2.push(C2), { point: C2, angle: z2, path: w2 };
          }
          Yt.prototype.keysLength = function() {
            return this.boxKeys.length + this.circleKeys.length;
          }, Yt.prototype.insert = function(t2, e2, i2, o2, r2) {
            this._forEachCell(e2, i2, o2, r2, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t2), this.bboxes.push(e2), this.bboxes.push(i2), this.bboxes.push(o2), this.bboxes.push(r2);
          }, Yt.prototype.insertCircle = function(t2, e2, i2, o2) {
            this._forEachCell(e2 - o2, i2 - o2, e2 + o2, i2 + o2, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t2), this.circles.push(e2), this.circles.push(i2), this.circles.push(o2);
          }, Yt.prototype._insertBoxCell = function(t2, e2, i2, o2, r2, a2) {
            this.boxCells[r2].push(a2);
          }, Yt.prototype._insertCircleCell = function(t2, e2, i2, o2, r2, a2) {
            this.circleCells[r2].push(a2);
          }, Yt.prototype._query = function(t2, e2, i2, o2, r2, a2) {
            if (i2 < 0 || t2 > this.width || o2 < 0 || e2 > this.height)
              return !r2 && [];
            var n2 = [];
            if (t2 <= 0 && e2 <= 0 && this.width <= i2 && this.height <= o2) {
              if (r2)
                return true;
              for (var s2 = 0; s2 < this.boxKeys.length; s2++)
                n2.push({ key: this.boxKeys[s2], x1: this.bboxes[4 * s2], y1: this.bboxes[4 * s2 + 1], x2: this.bboxes[4 * s2 + 2], y2: this.bboxes[4 * s2 + 3] });
              for (var l2 = 0; l2 < this.circleKeys.length; l2++) {
                var c2 = this.circles[3 * l2], u2 = this.circles[3 * l2 + 1], h2 = this.circles[3 * l2 + 2];
                n2.push({ key: this.circleKeys[l2], x1: c2 - h2, y1: u2 - h2, x2: c2 + h2, y2: u2 + h2 });
              }
              return a2 ? n2.filter(a2) : n2;
            }
            return this._forEachCell(t2, e2, i2, o2, this._queryCell, n2, { hitTest: r2, seenUids: { box: {}, circle: {} } }, a2), r2 ? n2.length > 0 : n2;
          }, Yt.prototype._queryCircle = function(t2, e2, i2, o2, r2) {
            var a2 = t2 - i2, n2 = t2 + i2, s2 = e2 - i2, l2 = e2 + i2;
            if (n2 < 0 || a2 > this.width || l2 < 0 || s2 > this.height)
              return !o2 && [];
            var c2 = [];
            return this._forEachCell(a2, s2, n2, l2, this._queryCellCircle, c2, { hitTest: o2, circle: { x: t2, y: e2, radius: i2 }, seenUids: { box: {}, circle: {} } }, r2), o2 ? c2.length > 0 : c2;
          }, Yt.prototype.query = function(t2, e2, i2, o2, r2) {
            return this._query(t2, e2, i2, o2, false, r2);
          }, Yt.prototype.hitTest = function(t2, e2, i2, o2, r2) {
            return this._query(t2, e2, i2, o2, true, r2);
          }, Yt.prototype.hitTestCircle = function(t2, e2, i2, o2) {
            return this._queryCircle(t2, e2, i2, true, o2);
          }, Yt.prototype._queryCell = function(t2, e2, i2, o2, r2, a2, n2, s2) {
            var l2 = n2.seenUids, c2 = this.boxCells[r2];
            if (null !== c2)
              for (var u2 = this.bboxes, h2 = 0, p2 = c2; h2 < p2.length; h2 += 1) {
                var d2 = p2[h2];
                if (!l2.box[d2]) {
                  l2.box[d2] = true;
                  var _2 = 4 * d2;
                  if (t2 <= u2[_2 + 2] && e2 <= u2[_2 + 3] && i2 >= u2[_2 + 0] && o2 >= u2[_2 + 1] && (!s2 || s2(this.boxKeys[d2]))) {
                    if (n2.hitTest)
                      return a2.push(true), true;
                    a2.push({ key: this.boxKeys[d2], x1: u2[_2], y1: u2[_2 + 1], x2: u2[_2 + 2], y2: u2[_2 + 3] });
                  }
                }
              }
            var f2 = this.circleCells[r2];
            if (null !== f2)
              for (var m2 = this.circles, g2 = 0, v2 = f2; g2 < v2.length; g2 += 1) {
                var y2 = v2[g2];
                if (!l2.circle[y2]) {
                  l2.circle[y2] = true;
                  var x2 = 3 * y2;
                  if (this._circleAndRectCollide(m2[x2], m2[x2 + 1], m2[x2 + 2], t2, e2, i2, o2) && (!s2 || s2(this.circleKeys[y2]))) {
                    if (n2.hitTest)
                      return a2.push(true), true;
                    var b2 = m2[x2], w2 = m2[x2 + 1], T2 = m2[x2 + 2];
                    a2.push({ key: this.circleKeys[y2], x1: b2 - T2, y1: w2 - T2, x2: b2 + T2, y2: w2 + T2 });
                  }
                }
              }
          }, Yt.prototype._queryCellCircle = function(t2, e2, i2, o2, r2, a2, n2, s2) {
            var l2 = n2.circle, c2 = n2.seenUids, u2 = this.boxCells[r2];
            if (null !== u2)
              for (var h2 = this.bboxes, p2 = 0, d2 = u2; p2 < d2.length; p2 += 1) {
                var _2 = d2[p2];
                if (!c2.box[_2]) {
                  c2.box[_2] = true;
                  var f2 = 4 * _2;
                  if (this._circleAndRectCollide(l2.x, l2.y, l2.radius, h2[f2 + 0], h2[f2 + 1], h2[f2 + 2], h2[f2 + 3]) && (!s2 || s2(this.boxKeys[_2])))
                    return a2.push(true), true;
                }
              }
            var m2 = this.circleCells[r2];
            if (null !== m2)
              for (var g2 = this.circles, v2 = 0, y2 = m2; v2 < y2.length; v2 += 1) {
                var x2 = y2[v2];
                if (!c2.circle[x2]) {
                  c2.circle[x2] = true;
                  var b2 = 3 * x2;
                  if (this._circlesCollide(g2[b2], g2[b2 + 1], g2[b2 + 2], l2.x, l2.y, l2.radius) && (!s2 || s2(this.circleKeys[x2])))
                    return a2.push(true), true;
                }
              }
          }, Yt.prototype._forEachCell = function(t2, e2, i2, o2, r2, a2, n2, s2) {
            for (var l2 = this._convertToXCellCoord(t2), c2 = this._convertToYCellCoord(e2), u2 = this._convertToXCellCoord(i2), h2 = this._convertToYCellCoord(o2), p2 = l2; p2 <= u2; p2++)
              for (var d2 = c2; d2 <= h2; d2++)
                if (r2.call(this, t2, e2, i2, o2, this.xCellCount * d2 + p2, a2, n2, s2))
                  return;
          }, Yt.prototype._convertToXCellCoord = function(t2) {
            return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t2 * this.xScale)));
          }, Yt.prototype._convertToYCellCoord = function(t2) {
            return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t2 * this.yScale)));
          }, Yt.prototype._circlesCollide = function(t2, e2, i2, o2, r2, a2) {
            var n2 = o2 - t2, s2 = r2 - e2, l2 = i2 + a2;
            return l2 * l2 > n2 * n2 + s2 * s2;
          }, Yt.prototype._circleAndRectCollide = function(t2, e2, i2, o2, r2, a2, n2) {
            var s2 = (a2 - o2) / 2, l2 = Math.abs(t2 - (o2 + s2));
            if (l2 > s2 + i2)
              return false;
            var c2 = (n2 - r2) / 2, u2 = Math.abs(e2 - (r2 + c2));
            if (u2 > c2 + i2)
              return false;
            if (l2 <= s2 || u2 <= c2)
              return true;
            var h2 = l2 - s2, p2 = u2 - c2;
            return h2 * h2 + p2 * p2 <= i2 * i2;
          };
          var le = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
          function ce(t2, e2) {
            for (var i2 = 0; i2 < t2; i2++) {
              var o2 = e2.length;
              e2.resize(o2 + 4), e2.float32.set(le, 3 * o2);
            }
          }
          function ue(t2, e2, i2) {
            var o2 = e2[0], r2 = e2[1];
            return t2[0] = i2[0] * o2 + i2[4] * r2 + i2[12], t2[1] = i2[1] * o2 + i2[5] * r2 + i2[13], t2[3] = i2[3] * o2 + i2[7] * r2 + i2[15], t2;
          }
          var he = function(t2, e2, i2) {
            void 0 === e2 && (e2 = new Yt(t2.width + 200, t2.height + 200, 25)), void 0 === i2 && (i2 = new Yt(t2.width + 200, t2.height + 200, 25)), this.transform = t2, this.grid = e2, this.ignoredGrid = i2, this.pitchfactor = Math.cos(t2._pitch) * t2.cameraToCenterDistance, this.screenRightBoundary = t2.width + 100, this.screenBottomBoundary = t2.height + 100, this.gridRightBoundary = t2.width + 200, this.gridBottomBoundary = t2.height + 200;
          };
          function pe(e2, i2, o2) {
            return i2 * (t.EXTENT / (e2.tileSize * Math.pow(2, o2 - e2.tileID.overscaledZ)));
          }
          he.prototype.placeCollisionBox = function(t2, e2, i2, o2, r2) {
            var a2 = this.projectAndGetPerspectiveRatio(o2, t2.anchorPointX, t2.anchorPointY), n2 = i2 * a2.perspectiveRatio, s2 = t2.x1 * n2 + a2.point.x, l2 = t2.y1 * n2 + a2.point.y, c2 = t2.x2 * n2 + a2.point.x, u2 = t2.y2 * n2 + a2.point.y;
            return !this.isInsideGrid(s2, l2, c2, u2) || !e2 && this.grid.hitTest(s2, l2, c2, u2, r2) ? { box: [], offscreen: false } : { box: [s2, l2, c2, u2], offscreen: this.isOffscreen(s2, l2, c2, u2) };
          }, he.prototype.placeCollisionCircles = function(e2, i2, o2, r2, a2, n2, s2, l2, c2, u2, h2, p2, d2) {
            var _2 = [], f2 = new t.Point(i2.anchorX, i2.anchorY), m2 = $t(f2, n2), g2 = te(this.transform.cameraToCenterDistance, m2.signedDistanceFromCamera), v2 = (u2 ? a2 / g2 : a2 * g2) / t.ONE_EM, y2 = $t(f2, s2).point, x2 = oe(v2, r2, i2.lineOffsetX * v2, i2.lineOffsetY * v2, false, y2, f2, i2, o2, s2, {}), b2 = false, w2 = false, T2 = true;
            if (x2) {
              for (var E2 = 0.5 * p2 * g2 + d2, I2 = new t.Point(-100, -100), P2 = new t.Point(this.screenRightBoundary, this.screenBottomBoundary), S2 = new Kt(), C2 = x2.first, z2 = x2.last, D2 = [], A2 = C2.path.length - 1; A2 >= 1; A2--)
                D2.push(C2.path[A2]);
              for (var M2 = 1; M2 < z2.path.length; M2++)
                D2.push(z2.path[M2]);
              var L2 = 2.5 * E2;
              if (l2) {
                var R2 = D2.map(function(t2) {
                  return $t(t2, l2);
                });
                D2 = R2.some(function(t2) {
                  return t2.signedDistanceFromCamera <= 0;
                }) ? [] : R2.map(function(t2) {
                  return t2.point;
                });
              }
              var k2 = [];
              if (D2.length > 0) {
                for (var B2 = D2[0].clone(), O2 = D2[0].clone(), F2 = 1; F2 < D2.length; F2++)
                  B2.x = Math.min(B2.x, D2[F2].x), B2.y = Math.min(B2.y, D2[F2].y), O2.x = Math.max(O2.x, D2[F2].x), O2.y = Math.max(O2.y, D2[F2].y);
                k2 = B2.x >= I2.x && O2.x <= P2.x && B2.y >= I2.y && O2.y <= P2.y ? [D2] : O2.x < I2.x || B2.x > P2.x || O2.y < I2.y || B2.y > P2.y ? [] : t.clipLine([D2], I2.x, I2.y, P2.x, P2.y);
              }
              for (var U2 = 0, N2 = k2; U2 < N2.length; U2 += 1) {
                var Z2;
                S2.reset(N2[U2], 0.25 * E2), Z2 = S2.length <= 0.5 * E2 ? 1 : Math.ceil(S2.paddedLength / L2) + 1;
                for (var q2 = 0; q2 < Z2; q2++) {
                  var j2 = q2 / Math.max(Z2 - 1, 1), V2 = S2.lerp(j2), G2 = V2.x + 100, W2 = V2.y + 100;
                  _2.push(G2, W2, E2, 0);
                  var X2 = G2 - E2, H2 = W2 - E2, K2 = G2 + E2, Y2 = W2 + E2;
                  if (T2 = T2 && this.isOffscreen(X2, H2, K2, Y2), w2 = w2 || this.isInsideGrid(X2, H2, K2, Y2), !e2 && this.grid.hitTestCircle(G2, W2, E2, h2) && (b2 = true, !c2))
                    return { circles: [], offscreen: false, collisionDetected: b2 };
                }
              }
            }
            return { circles: !c2 && b2 || !w2 ? [] : _2, offscreen: T2, collisionDetected: b2 };
          }, he.prototype.queryRenderedSymbols = function(e2) {
            if (0 === e2.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
              return {};
            for (var i2 = [], o2 = 1 / 0, r2 = 1 / 0, a2 = -1 / 0, n2 = -1 / 0, s2 = 0, l2 = e2; s2 < l2.length; s2 += 1) {
              var c2 = l2[s2], u2 = new t.Point(c2.x + 100, c2.y + 100);
              o2 = Math.min(o2, u2.x), r2 = Math.min(r2, u2.y), a2 = Math.max(a2, u2.x), n2 = Math.max(n2, u2.y), i2.push(u2);
            }
            for (var h2 = {}, p2 = {}, d2 = 0, _2 = this.grid.query(o2, r2, a2, n2).concat(this.ignoredGrid.query(o2, r2, a2, n2)); d2 < _2.length; d2 += 1) {
              var f2 = _2[d2], m2 = f2.key;
              if (void 0 === h2[m2.bucketInstanceId] && (h2[m2.bucketInstanceId] = {}), !h2[m2.bucketInstanceId][m2.featureIndex]) {
                var g2 = [new t.Point(f2.x1, f2.y1), new t.Point(f2.x2, f2.y1), new t.Point(f2.x2, f2.y2), new t.Point(f2.x1, f2.y2)];
                t.polygonIntersectsPolygon(i2, g2) && (h2[m2.bucketInstanceId][m2.featureIndex] = true, void 0 === p2[m2.bucketInstanceId] && (p2[m2.bucketInstanceId] = []), p2[m2.bucketInstanceId].push(m2.featureIndex));
              }
            }
            return p2;
          }, he.prototype.insertCollisionBox = function(t2, e2, i2, o2, r2) {
            (e2 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r2 }, t2[0], t2[1], t2[2], t2[3]);
          }, he.prototype.insertCollisionCircles = function(t2, e2, i2, o2, r2) {
            for (var a2 = e2 ? this.ignoredGrid : this.grid, n2 = { bucketInstanceId: i2, featureIndex: o2, collisionGroupID: r2 }, s2 = 0; s2 < t2.length; s2 += 4)
              a2.insertCircle(n2, t2[s2], t2[s2 + 1], t2[s2 + 2]);
          }, he.prototype.projectAndGetPerspectiveRatio = function(e2, i2, o2) {
            var r2 = [i2, o2, 0, 1];
            return ue(r2, r2, e2), { point: new t.Point((r2[0] / r2[3] + 1) / 2 * this.transform.width + 100, (-r2[1] / r2[3] + 1) / 2 * this.transform.height + 100), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / r2[3] * 0.5 };
          }, he.prototype.isOffscreen = function(t2, e2, i2, o2) {
            return i2 < 100 || t2 >= this.screenRightBoundary || o2 < 100 || e2 > this.screenBottomBoundary;
          }, he.prototype.isInsideGrid = function(t2, e2, i2, o2) {
            return i2 >= 0 && t2 < this.gridRightBoundary && o2 >= 0 && e2 < this.gridBottomBoundary;
          }, he.prototype.getViewportMatrix = function() {
            var e2 = t.identity([]);
            return t.translate(e2, e2, [-100, -100, 0]), e2;
          };
          var de = function(t2, e2, i2, o2) {
            this.opacity = t2 ? Math.max(0, Math.min(1, t2.opacity + (t2.placed ? e2 : -e2))) : o2 && i2 ? 1 : 0, this.placed = i2;
          };
          de.prototype.isHidden = function() {
            return 0 === this.opacity && !this.placed;
          };
          var _e = function(t2, e2, i2, o2, r2) {
            this.text = new de(t2 ? t2.text : null, e2, i2, r2), this.icon = new de(t2 ? t2.icon : null, e2, o2, r2);
          };
          _e.prototype.isHidden = function() {
            return this.text.isHidden() && this.icon.isHidden();
          };
          var fe = function(t2, e2, i2) {
            this.text = t2, this.icon = e2, this.skipFade = i2;
          }, me = function() {
            this.invProjMatrix = t.create(), this.viewportMatrix = t.create(), this.circles = [];
          }, ge = function(t2, e2, i2, o2, r2) {
            this.bucketInstanceId = t2, this.featureIndex = e2, this.sourceLayerIndex = i2, this.bucketIndex = o2, this.tileID = r2;
          }, ve = function(t2) {
            this.crossSourceCollisions = t2, this.maxGroupID = 0, this.collisionGroups = {};
          };
          function ye(e2, i2, o2, r2, a2) {
            var n2 = t.getAnchorAlignment(e2), s2 = -(n2.horizontalAlign - 0.5) * i2, l2 = -(n2.verticalAlign - 0.5) * o2, c2 = t.evaluateVariableOffset(e2, r2);
            return new t.Point(s2 + c2[0] * a2, l2 + c2[1] * a2);
          }
          function xe(e2, i2, o2, r2, a2, n2) {
            var s2 = e2.x1, l2 = e2.x2, c2 = e2.y1, u2 = e2.y2, h2 = e2.anchorPointX, p2 = e2.anchorPointY, d2 = new t.Point(i2, o2);
            return r2 && d2._rotate(a2 ? n2 : -n2), { x1: s2 + d2.x, y1: c2 + d2.y, x2: l2 + d2.x, y2: u2 + d2.y, anchorPointX: h2, anchorPointY: p2 };
          }
          ve.prototype.get = function(t2) {
            if (this.crossSourceCollisions)
              return { ID: 0, predicate: null };
            if (!this.collisionGroups[t2]) {
              var e2 = ++this.maxGroupID;
              this.collisionGroups[t2] = { ID: e2, predicate: function(t3) {
                return t3.collisionGroupID === e2;
              } };
            }
            return this.collisionGroups[t2];
          };
          var be = function(t2, e2, i2, o2) {
            this.transform = t2.clone(), this.collisionIndex = new he(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = e2, this.retainedQueryData = {}, this.collisionGroups = new ve(i2), this.collisionCircleArrays = {}, this.prevPlacement = o2, o2 && (o2.prevPlacement = void 0), this.placedOrientations = {};
          };
          function we(t2, e2, i2, o2, r2) {
            t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0), t2.emplaceBack(e2 ? 1 : 0, i2 ? 1 : 0, o2 || 0, r2 || 0);
          }
          be.prototype.getBucketParts = function(e2, i2, o2, r2) {
            var a2 = o2.getBucket(i2), n2 = o2.latestFeatureIndex;
            if (a2 && n2 && i2.id === a2.layerIds[0]) {
              var s2 = o2.collisionBoxArray, l2 = a2.layers[0].layout, c2 = Math.pow(2, this.transform.zoom - o2.tileID.overscaledZ), u2 = o2.tileSize / t.EXTENT, h2 = this.transform.calculatePosMatrix(o2.tileID.toUnwrapped()), p2 = "map" === l2.get("text-pitch-alignment"), d2 = "map" === l2.get("text-rotation-alignment"), _2 = pe(o2, 1, this.transform.zoom), f2 = Jt(h2, p2, d2, this.transform, _2), m2 = null;
              if (p2) {
                var g2 = Qt(h2, p2, d2, this.transform, _2);
                m2 = t.multiply([], this.transform.labelPlaneMatrix, g2);
              }
              this.retainedQueryData[a2.bucketInstanceId] = new ge(a2.bucketInstanceId, n2, a2.sourceLayerIndex, a2.index, o2.tileID);
              var v2 = { bucket: a2, layout: l2, posMatrix: h2, textLabelPlaneMatrix: f2, labelToScreenMatrix: m2, scale: c2, textPixelRatio: u2, holdingForFade: o2.holdingForFade(), collisionBoxArray: s2, partiallyEvaluatedTextSize: t.evaluateSizeForZoom(a2.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(a2.sourceID) };
              if (r2)
                for (var y2 = 0, x2 = a2.sortKeyRanges; y2 < x2.length; y2 += 1) {
                  var b2 = x2[y2];
                  e2.push({ sortKey: b2.sortKey, symbolInstanceStart: b2.symbolInstanceStart, symbolInstanceEnd: b2.symbolInstanceEnd, parameters: v2 });
                }
              else
                e2.push({ symbolInstanceStart: 0, symbolInstanceEnd: a2.symbolInstances.length, parameters: v2 });
            }
          }, be.prototype.attemptAnchorPlacement = function(t2, e2, i2, o2, r2, a2, n2, s2, l2, c2, u2, h2, p2, d2, _2) {
            var f2, m2 = [h2.textOffset0, h2.textOffset1], g2 = ye(t2, i2, o2, m2, r2), v2 = this.collisionIndex.placeCollisionBox(xe(e2, g2.x, g2.y, a2, n2, this.transform.angle), u2, s2, l2, c2.predicate);
            if (!_2 || 0 !== this.collisionIndex.placeCollisionBox(xe(_2, g2.x, g2.y, a2, n2, this.transform.angle), u2, s2, l2, c2.predicate).box.length)
              return v2.box.length > 0 ? (this.prevPlacement && this.prevPlacement.variableOffsets[h2.crossTileID] && this.prevPlacement.placements[h2.crossTileID] && this.prevPlacement.placements[h2.crossTileID].text && (f2 = this.prevPlacement.variableOffsets[h2.crossTileID].anchor), this.variableOffsets[h2.crossTileID] = { textOffset: m2, width: i2, height: o2, anchor: t2, textBoxScale: r2, prevAnchor: f2 }, this.markUsedJustification(p2, t2, h2, d2), p2.allowVerticalPlacement && (this.markUsedOrientation(p2, d2, h2), this.placedOrientations[h2.crossTileID] = d2), { shift: g2, placedGlyphBoxes: v2 }) : void 0;
          }, be.prototype.placeLayerBucketPart = function(e2, i2, o2) {
            var r2 = this, a2 = e2.parameters, n2 = a2.bucket, s2 = a2.layout, l2 = a2.posMatrix, c2 = a2.textLabelPlaneMatrix, u2 = a2.labelToScreenMatrix, h2 = a2.textPixelRatio, p2 = a2.holdingForFade, d2 = a2.collisionBoxArray, _2 = a2.partiallyEvaluatedTextSize, f2 = a2.collisionGroup, m2 = s2.get("text-optional"), g2 = s2.get("icon-optional"), v2 = s2.get("text-allow-overlap"), y2 = s2.get("icon-allow-overlap"), x2 = "map" === s2.get("text-rotation-alignment"), b2 = "map" === s2.get("text-pitch-alignment"), w2 = "none" !== s2.get("icon-text-fit"), T2 = "viewport-y" === s2.get("symbol-z-order"), E2 = v2 && (y2 || !n2.hasIconData() || g2), I2 = y2 && (v2 || !n2.hasTextData() || m2);
            !n2.collisionArrays && d2 && n2.deserializeCollisionBoxes(d2);
            var P2 = function(e3, a3) {
              if (!i2[e3.crossTileID])
                if (p2)
                  r2.placements[e3.crossTileID] = new fe(false, false, false);
                else {
                  var d3, T3 = false, P3 = false, S3 = true, C3 = null, z3 = { box: null, offscreen: null }, D3 = { box: null, offscreen: null }, A3 = null, M2 = null, L2 = 0, R2 = 0, k2 = 0;
                  a3.textFeatureIndex ? L2 = a3.textFeatureIndex : e3.useRuntimeCollisionCircles && (L2 = e3.featureIndex), a3.verticalTextFeatureIndex && (R2 = a3.verticalTextFeatureIndex);
                  var B2 = a3.textBox;
                  if (B2) {
                    var O2 = function(i3) {
                      var o3 = t.WritingMode.horizontal;
                      if (n2.allowVerticalPlacement && !i3 && r2.prevPlacement) {
                        var a4 = r2.prevPlacement.placedOrientations[e3.crossTileID];
                        a4 && (r2.placedOrientations[e3.crossTileID] = a4, r2.markUsedOrientation(n2, o3 = a4, e3));
                      }
                      return o3;
                    }, F2 = function(i3, o3) {
                      if (n2.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && a3.verticalTextBox)
                        for (var r3 = 0, s3 = n2.writingModes; r3 < s3.length && (s3[r3] === t.WritingMode.vertical ? (z3 = o3(), D3 = z3) : z3 = i3(), !(z3 && z3.box && z3.box.length)); r3 += 1)
                          ;
                      else
                        z3 = i3();
                    };
                    if (s2.get("text-variable-anchor")) {
                      var U2 = s2.get("text-variable-anchor");
                      if (r2.prevPlacement && r2.prevPlacement.variableOffsets[e3.crossTileID]) {
                        var N2 = r2.prevPlacement.variableOffsets[e3.crossTileID];
                        U2.indexOf(N2.anchor) > 0 && (U2 = U2.filter(function(t2) {
                          return t2 !== N2.anchor;
                        })).unshift(N2.anchor);
                      }
                      var Z2 = function(t2, i3, o3) {
                        for (var a4 = t2.x2 - t2.x1, s3 = t2.y2 - t2.y1, c3 = e3.textBoxScale, u3 = w2 && !y2 ? i3 : null, p3 = { box: [], offscreen: false }, d4 = v2 ? 2 * U2.length : U2.length, _3 = 0; _3 < d4; ++_3) {
                          var m3 = r2.attemptAnchorPlacement(U2[_3 % U2.length], t2, a4, s3, c3, x2, b2, h2, l2, f2, _3 >= U2.length, e3, n2, o3, u3);
                          if (m3 && (p3 = m3.placedGlyphBoxes) && p3.box && p3.box.length) {
                            T3 = true, C3 = m3.shift;
                            break;
                          }
                        }
                        return p3;
                      };
                      F2(function() {
                        return Z2(B2, a3.iconBox, t.WritingMode.horizontal);
                      }, function() {
                        var i3 = a3.verticalTextBox;
                        return n2.allowVerticalPlacement && !(z3 && z3.box && z3.box.length) && e3.numVerticalGlyphVertices > 0 && i3 ? Z2(i3, a3.verticalIconBox, t.WritingMode.vertical) : { box: null, offscreen: null };
                      }), z3 && (T3 = z3.box, S3 = z3.offscreen);
                      var q2 = O2(z3 && z3.box);
                      if (!T3 && r2.prevPlacement) {
                        var j2 = r2.prevPlacement.variableOffsets[e3.crossTileID];
                        j2 && (r2.variableOffsets[e3.crossTileID] = j2, r2.markUsedJustification(n2, j2.anchor, e3, q2));
                      }
                    } else {
                      var V2 = function(t2, i3) {
                        var o3 = r2.collisionIndex.placeCollisionBox(t2, v2, h2, l2, f2.predicate);
                        return o3 && o3.box && o3.box.length && (r2.markUsedOrientation(n2, i3, e3), r2.placedOrientations[e3.crossTileID] = i3), o3;
                      };
                      F2(function() {
                        return V2(B2, t.WritingMode.horizontal);
                      }, function() {
                        var i3 = a3.verticalTextBox;
                        return n2.allowVerticalPlacement && e3.numVerticalGlyphVertices > 0 && i3 ? V2(i3, t.WritingMode.vertical) : { box: null, offscreen: null };
                      }), O2(z3 && z3.box && z3.box.length);
                    }
                  }
                  if (T3 = (d3 = z3) && d3.box && d3.box.length > 0, S3 = d3 && d3.offscreen, e3.useRuntimeCollisionCircles) {
                    var G2 = n2.text.placedSymbolArray.get(e3.centerJustifiedTextSymbolIndex), W2 = t.evaluateSizeForFeature(n2.textSizeData, _2, G2), X2 = s2.get("text-padding");
                    A3 = r2.collisionIndex.placeCollisionCircles(v2, G2, n2.lineVertexArray, n2.glyphOffsetArray, W2, l2, c2, u2, o2, b2, f2.predicate, e3.collisionCircleDiameter, X2), T3 = v2 || A3.circles.length > 0 && !A3.collisionDetected, S3 = S3 && A3.offscreen;
                  }
                  if (a3.iconFeatureIndex && (k2 = a3.iconFeatureIndex), a3.iconBox) {
                    var H2 = function(t2) {
                      var e4 = w2 && C3 ? xe(t2, C3.x, C3.y, x2, b2, r2.transform.angle) : t2;
                      return r2.collisionIndex.placeCollisionBox(e4, y2, h2, l2, f2.predicate);
                    };
                    P3 = D3 && D3.box && D3.box.length && a3.verticalIconBox ? (M2 = H2(a3.verticalIconBox)).box.length > 0 : (M2 = H2(a3.iconBox)).box.length > 0, S3 = S3 && M2.offscreen;
                  }
                  var K2 = m2 || 0 === e3.numHorizontalGlyphVertices && 0 === e3.numVerticalGlyphVertices, Y2 = g2 || 0 === e3.numIconVertices;
                  if (K2 || Y2 ? Y2 ? K2 || (P3 = P3 && T3) : T3 = P3 && T3 : P3 = T3 = P3 && T3, T3 && d3 && d3.box && r2.collisionIndex.insertCollisionBox(d3.box, s2.get("text-ignore-placement"), n2.bucketInstanceId, D3 && D3.box && R2 ? R2 : L2, f2.ID), P3 && M2 && r2.collisionIndex.insertCollisionBox(M2.box, s2.get("icon-ignore-placement"), n2.bucketInstanceId, k2, f2.ID), A3 && (T3 && r2.collisionIndex.insertCollisionCircles(A3.circles, s2.get("text-ignore-placement"), n2.bucketInstanceId, L2, f2.ID), o2)) {
                    var J2 = n2.bucketInstanceId, Q2 = r2.collisionCircleArrays[J2];
                    void 0 === Q2 && (Q2 = r2.collisionCircleArrays[J2] = new me());
                    for (var $2 = 0; $2 < A3.circles.length; $2 += 4)
                      Q2.circles.push(A3.circles[$2 + 0]), Q2.circles.push(A3.circles[$2 + 1]), Q2.circles.push(A3.circles[$2 + 2]), Q2.circles.push(A3.collisionDetected ? 1 : 0);
                  }
                  r2.placements[e3.crossTileID] = new fe(T3 || E2, P3 || I2, S3 || n2.justReloaded), i2[e3.crossTileID] = true;
                }
            };
            if (T2)
              for (var S2 = n2.getSortedSymbolIndexes(this.transform.angle), C2 = S2.length - 1; C2 >= 0; --C2) {
                var z2 = S2[C2];
                P2(n2.symbolInstances.get(z2), n2.collisionArrays[z2]);
              }
            else
              for (var D2 = e2.symbolInstanceStart; D2 < e2.symbolInstanceEnd; D2++)
                P2(n2.symbolInstances.get(D2), n2.collisionArrays[D2]);
            if (o2 && n2.bucketInstanceId in this.collisionCircleArrays) {
              var A2 = this.collisionCircleArrays[n2.bucketInstanceId];
              t.invert(A2.invProjMatrix, l2), A2.viewportMatrix = this.collisionIndex.getViewportMatrix();
            }
            n2.justReloaded = false;
          }, be.prototype.markUsedJustification = function(e2, i2, o2, r2) {
            var a2;
            a2 = r2 === t.WritingMode.vertical ? o2.verticalPlacedTextSymbolIndex : { left: o2.leftJustifiedTextSymbolIndex, center: o2.centerJustifiedTextSymbolIndex, right: o2.rightJustifiedTextSymbolIndex }[t.getAnchorJustification(i2)];
            for (var n2 = 0, s2 = [o2.leftJustifiedTextSymbolIndex, o2.centerJustifiedTextSymbolIndex, o2.rightJustifiedTextSymbolIndex, o2.verticalPlacedTextSymbolIndex]; n2 < s2.length; n2 += 1) {
              var l2 = s2[n2];
              l2 >= 0 && (e2.text.placedSymbolArray.get(l2).crossTileID = a2 >= 0 && l2 !== a2 ? 0 : o2.crossTileID);
            }
          }, be.prototype.markUsedOrientation = function(e2, i2, o2) {
            for (var r2 = i2 === t.WritingMode.horizontal || i2 === t.WritingMode.horizontalOnly ? i2 : 0, a2 = i2 === t.WritingMode.vertical ? i2 : 0, n2 = 0, s2 = [o2.leftJustifiedTextSymbolIndex, o2.centerJustifiedTextSymbolIndex, o2.rightJustifiedTextSymbolIndex]; n2 < s2.length; n2 += 1)
              e2.text.placedSymbolArray.get(s2[n2]).placedOrientation = r2;
            o2.verticalPlacedTextSymbolIndex && (e2.text.placedSymbolArray.get(o2.verticalPlacedTextSymbolIndex).placedOrientation = a2);
          }, be.prototype.commit = function(t2) {
            this.commitTime = t2, this.zoomAtLastRecencyCheck = this.transform.zoom;
            var e2 = this.prevPlacement, i2 = false;
            this.prevZoomAdjustment = e2 ? e2.zoomAdjustment(this.transform.zoom) : 0;
            var o2 = e2 ? e2.symbolFadeChange(t2) : 1, r2 = e2 ? e2.opacities : {}, a2 = e2 ? e2.variableOffsets : {}, n2 = e2 ? e2.placedOrientations : {};
            for (var s2 in this.placements) {
              var l2 = this.placements[s2], c2 = r2[s2];
              c2 ? (this.opacities[s2] = new _e(c2, o2, l2.text, l2.icon), i2 = i2 || l2.text !== c2.text.placed || l2.icon !== c2.icon.placed) : (this.opacities[s2] = new _e(null, o2, l2.text, l2.icon, l2.skipFade), i2 = i2 || l2.text || l2.icon);
            }
            for (var u2 in r2) {
              var h2 = r2[u2];
              if (!this.opacities[u2]) {
                var p2 = new _e(h2, o2, false, false);
                p2.isHidden() || (this.opacities[u2] = p2, i2 = i2 || h2.text.placed || h2.icon.placed);
              }
            }
            for (var d2 in a2)
              this.variableOffsets[d2] || !this.opacities[d2] || this.opacities[d2].isHidden() || (this.variableOffsets[d2] = a2[d2]);
            for (var _2 in n2)
              this.placedOrientations[_2] || !this.opacities[_2] || this.opacities[_2].isHidden() || (this.placedOrientations[_2] = n2[_2]);
            i2 ? this.lastPlacementChangeTime = t2 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = e2 ? e2.lastPlacementChangeTime : t2);
          }, be.prototype.updateLayerOpacities = function(t2, e2) {
            for (var i2 = {}, o2 = 0, r2 = e2; o2 < r2.length; o2 += 1) {
              var a2 = r2[o2], n2 = a2.getBucket(t2);
              n2 && a2.latestFeatureIndex && t2.id === n2.layerIds[0] && this.updateBucketOpacities(n2, i2, a2.collisionBoxArray);
            }
          }, be.prototype.updateBucketOpacities = function(e2, i2, o2) {
            var r2 = this;
            e2.hasTextData() && e2.text.opacityVertexArray.clear(), e2.hasIconData() && e2.icon.opacityVertexArray.clear(), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexArray.clear(), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexArray.clear();
            var a2 = e2.layers[0].layout, n2 = new _e(null, 0, false, false, true), s2 = a2.get("text-allow-overlap"), l2 = a2.get("icon-allow-overlap"), c2 = a2.get("text-variable-anchor"), u2 = "map" === a2.get("text-rotation-alignment"), h2 = "map" === a2.get("text-pitch-alignment"), p2 = "none" !== a2.get("icon-text-fit"), d2 = new _e(null, 0, s2 && (l2 || !e2.hasIconData() || a2.get("icon-optional")), l2 && (s2 || !e2.hasTextData() || a2.get("text-optional")), true);
            !e2.collisionArrays && o2 && (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) && e2.deserializeCollisionBoxes(o2);
            for (var _2 = function(t2, e3, i3) {
              for (var o3 = 0; o3 < e3 / 4; o3++)
                t2.opacityVertexArray.emplaceBack(i3);
            }, f2 = function(o3) {
              var a3 = e2.symbolInstances.get(o3), s3 = a3.numHorizontalGlyphVertices, l3 = a3.numVerticalGlyphVertices, f3 = a3.crossTileID, m3 = r2.opacities[f3];
              i2[f3] ? m3 = n2 : m3 || (r2.opacities[f3] = m3 = d2), i2[f3] = true;
              var g3 = a3.numIconVertices > 0, v2 = r2.placedOrientations[a3.crossTileID], y2 = v2 === t.WritingMode.vertical, x2 = v2 === t.WritingMode.horizontal || v2 === t.WritingMode.horizontalOnly;
              if (s3 > 0 || l3 > 0) {
                var b2 = De(m3.text);
                _2(e2.text, s3, y2 ? Ae : b2), _2(e2.text, l3, x2 ? Ae : b2);
                var w2 = m3.text.isHidden();
                [a3.rightJustifiedTextSymbolIndex, a3.centerJustifiedTextSymbolIndex, a3.leftJustifiedTextSymbolIndex].forEach(function(t2) {
                  t2 >= 0 && (e2.text.placedSymbolArray.get(t2).hidden = w2 || y2 ? 1 : 0);
                }), a3.verticalPlacedTextSymbolIndex >= 0 && (e2.text.placedSymbolArray.get(a3.verticalPlacedTextSymbolIndex).hidden = w2 || x2 ? 1 : 0);
                var T2 = r2.variableOffsets[a3.crossTileID];
                T2 && r2.markUsedJustification(e2, T2.anchor, a3, v2);
                var E2 = r2.placedOrientations[a3.crossTileID];
                E2 && (r2.markUsedJustification(e2, "left", a3, E2), r2.markUsedOrientation(e2, E2, a3));
              }
              if (g3) {
                var I2 = De(m3.icon), P2 = !(p2 && a3.verticalPlacedIconSymbolIndex && y2);
                a3.placedIconSymbolIndex >= 0 && (_2(e2.icon, a3.numIconVertices, P2 ? I2 : Ae), e2.icon.placedSymbolArray.get(a3.placedIconSymbolIndex).hidden = m3.icon.isHidden()), a3.verticalPlacedIconSymbolIndex >= 0 && (_2(e2.icon, a3.numVerticalIconVertices, P2 ? Ae : I2), e2.icon.placedSymbolArray.get(a3.verticalPlacedIconSymbolIndex).hidden = m3.icon.isHidden());
              }
              if (e2.hasIconCollisionBoxData() || e2.hasTextCollisionBoxData()) {
                var S2 = e2.collisionArrays[o3];
                if (S2) {
                  var C2 = new t.Point(0, 0);
                  if (S2.textBox || S2.verticalTextBox) {
                    var z2 = true;
                    if (c2) {
                      var D2 = r2.variableOffsets[f3];
                      D2 ? (C2 = ye(D2.anchor, D2.width, D2.height, D2.textOffset, D2.textBoxScale), u2 && C2._rotate(h2 ? r2.transform.angle : -r2.transform.angle)) : z2 = false;
                    }
                    S2.textBox && we(e2.textCollisionBox.collisionVertexArray, m3.text.placed, !z2 || y2, C2.x, C2.y), S2.verticalTextBox && we(e2.textCollisionBox.collisionVertexArray, m3.text.placed, !z2 || x2, C2.x, C2.y);
                  }
                  var A2 = Boolean(!x2 && S2.verticalIconBox);
                  S2.iconBox && we(e2.iconCollisionBox.collisionVertexArray, m3.icon.placed, A2, p2 ? C2.x : 0, p2 ? C2.y : 0), S2.verticalIconBox && we(e2.iconCollisionBox.collisionVertexArray, m3.icon.placed, !A2, p2 ? C2.x : 0, p2 ? C2.y : 0);
                }
              }
            }, m2 = 0; m2 < e2.symbolInstances.length; m2++)
              f2(m2);
            if (e2.sortFeatures(this.transform.angle), this.retainedQueryData[e2.bucketInstanceId] && (this.retainedQueryData[e2.bucketInstanceId].featureSortOrder = e2.featureSortOrder), e2.hasTextData() && e2.text.opacityVertexBuffer && e2.text.opacityVertexBuffer.updateData(e2.text.opacityVertexArray), e2.hasIconData() && e2.icon.opacityVertexBuffer && e2.icon.opacityVertexBuffer.updateData(e2.icon.opacityVertexArray), e2.hasIconCollisionBoxData() && e2.iconCollisionBox.collisionVertexBuffer && e2.iconCollisionBox.collisionVertexBuffer.updateData(e2.iconCollisionBox.collisionVertexArray), e2.hasTextCollisionBoxData() && e2.textCollisionBox.collisionVertexBuffer && e2.textCollisionBox.collisionVertexBuffer.updateData(e2.textCollisionBox.collisionVertexArray), e2.bucketInstanceId in this.collisionCircleArrays) {
              var g2 = this.collisionCircleArrays[e2.bucketInstanceId];
              e2.placementInvProjMatrix = g2.invProjMatrix, e2.placementViewportMatrix = g2.viewportMatrix, e2.collisionCircleArray = g2.circles, delete this.collisionCircleArrays[e2.bucketInstanceId];
            }
          }, be.prototype.symbolFadeChange = function(t2) {
            return 0 === this.fadeDuration ? 1 : (t2 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
          }, be.prototype.zoomAdjustment = function(t2) {
            return Math.max(0, (this.transform.zoom - t2) / 1.5);
          }, be.prototype.hasTransitions = function(t2) {
            return this.stale || t2 - this.lastPlacementChangeTime < this.fadeDuration;
          }, be.prototype.stillRecent = function(t2, e2) {
            var i2 = this.zoomAtLastRecencyCheck === e2 ? 1 - this.zoomAdjustment(e2) : 1;
            return this.zoomAtLastRecencyCheck = e2, this.commitTime + this.fadeDuration * i2 > t2;
          }, be.prototype.setStale = function() {
            this.stale = true;
          };
          var Te = Math.pow(2, 25), Ee = Math.pow(2, 24), Ie = Math.pow(2, 17), Pe = Math.pow(2, 16), Se = Math.pow(2, 9), Ce = Math.pow(2, 8), ze = Math.pow(2, 1);
          function De(t2) {
            if (0 === t2.opacity && !t2.placed)
              return 0;
            if (1 === t2.opacity && t2.placed)
              return 4294967295;
            var e2 = t2.placed ? 1 : 0, i2 = Math.floor(127 * t2.opacity);
            return i2 * Te + e2 * Ee + i2 * Ie + e2 * Pe + i2 * Se + e2 * Ce + i2 * ze + e2;
          }
          var Ae = 0, Me = function(t2) {
            this._sortAcrossTiles = "viewport-y" !== t2.layout.get("symbol-z-order") && void 0 !== t2.layout.get("symbol-sort-key").constantOr(1), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
          };
          Me.prototype.continuePlacement = function(t2, e2, i2, o2, r2) {
            for (var a2 = this._bucketParts; this._currentTileIndex < t2.length; )
              if (e2.getBucketParts(a2, o2, t2[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, r2())
                return true;
            for (this._sortAcrossTiles && (this._sortAcrossTiles = false, a2.sort(function(t3, e3) {
              return t3.sortKey - e3.sortKey;
            })); this._currentPartIndex < a2.length; )
              if (e2.placeLayerBucketPart(a2[this._currentPartIndex], this._seenCrossTileIDs, i2), this._currentPartIndex++, r2())
                return true;
            return false;
          };
          var Le = function(t2, e2, i2, o2, r2, a2, n2) {
            this.placement = new be(t2, r2, a2, n2), this._currentPlacementIndex = e2.length - 1, this._forceFullPlacement = i2, this._showCollisionBoxes = o2, this._done = false;
          };
          Le.prototype.isDone = function() {
            return this._done;
          }, Le.prototype.continuePlacement = function(e2, i2, o2) {
            for (var r2 = this, a2 = t.browser.now(), n2 = function() {
              var e3 = t.browser.now() - a2;
              return !r2._forceFullPlacement && e3 > 2;
            }; this._currentPlacementIndex >= 0; ) {
              var s2 = i2[e2[this._currentPlacementIndex]], l2 = this.placement.collisionIndex.transform.zoom;
              if ("symbol" === s2.type && (!s2.minzoom || s2.minzoom <= l2) && (!s2.maxzoom || s2.maxzoom > l2)) {
                if (this._inProgressLayer || (this._inProgressLayer = new Me(s2)), this._inProgressLayer.continuePlacement(o2[s2.source], this.placement, this._showCollisionBoxes, s2, n2))
                  return;
                delete this._inProgressLayer;
              }
              this._currentPlacementIndex--;
            }
            this._done = true;
          }, Le.prototype.commit = function(t2) {
            return this.placement.commit(t2), this.placement;
          };
          var Re = 512 / t.EXTENT / 2, ke = function(t2, e2, i2) {
            this.tileID = t2, this.indexedSymbolInstances = {}, this.bucketInstanceId = i2;
            for (var o2 = 0; o2 < e2.length; o2++) {
              var r2 = e2.get(o2), a2 = r2.key;
              this.indexedSymbolInstances[a2] || (this.indexedSymbolInstances[a2] = []), this.indexedSymbolInstances[a2].push({ crossTileID: r2.crossTileID, coord: this.getScaledCoordinates(r2, t2) });
            }
          };
          ke.prototype.getScaledCoordinates = function(e2, i2) {
            var o2 = Re / Math.pow(2, i2.canonical.z - this.tileID.canonical.z);
            return { x: Math.floor((i2.canonical.x * t.EXTENT + e2.anchorX) * o2), y: Math.floor((i2.canonical.y * t.EXTENT + e2.anchorY) * o2) };
          }, ke.prototype.findMatches = function(t2, e2, i2) {
            for (var o2 = this.tileID.canonical.z < e2.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e2.canonical.z), r2 = 0; r2 < t2.length; r2++) {
              var a2 = t2.get(r2);
              if (!a2.crossTileID) {
                var n2 = this.indexedSymbolInstances[a2.key];
                if (n2)
                  for (var s2 = this.getScaledCoordinates(a2, e2), l2 = 0, c2 = n2; l2 < c2.length; l2 += 1) {
                    var u2 = c2[l2];
                    if (Math.abs(u2.coord.x - s2.x) <= o2 && Math.abs(u2.coord.y - s2.y) <= o2 && !i2[u2.crossTileID]) {
                      i2[u2.crossTileID] = true, a2.crossTileID = u2.crossTileID;
                      break;
                    }
                  }
              }
            }
          };
          var Be = function() {
            this.maxCrossTileID = 0;
          };
          Be.prototype.generate = function() {
            return ++this.maxCrossTileID;
          };
          var Oe = function() {
            this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
          };
          Oe.prototype.handleWrapJump = function(t2) {
            var e2 = Math.round((t2 - this.lng) / 360);
            if (0 !== e2)
              for (var i2 in this.indexes) {
                var o2 = this.indexes[i2], r2 = {};
                for (var a2 in o2) {
                  var n2 = o2[a2];
                  n2.tileID = n2.tileID.unwrapTo(n2.tileID.wrap + e2), r2[n2.tileID.key] = n2;
                }
                this.indexes[i2] = r2;
              }
            this.lng = t2;
          }, Oe.prototype.addBucket = function(t2, e2, i2) {
            if (this.indexes[t2.overscaledZ] && this.indexes[t2.overscaledZ][t2.key]) {
              if (this.indexes[t2.overscaledZ][t2.key].bucketInstanceId === e2.bucketInstanceId)
                return false;
              this.removeBucketCrossTileIDs(t2.overscaledZ, this.indexes[t2.overscaledZ][t2.key]);
            }
            for (var o2 = 0; o2 < e2.symbolInstances.length; o2++)
              e2.symbolInstances.get(o2).crossTileID = 0;
            this.usedCrossTileIDs[t2.overscaledZ] || (this.usedCrossTileIDs[t2.overscaledZ] = {});
            var r2 = this.usedCrossTileIDs[t2.overscaledZ];
            for (var a2 in this.indexes) {
              var n2 = this.indexes[a2];
              if (Number(a2) > t2.overscaledZ)
                for (var s2 in n2) {
                  var l2 = n2[s2];
                  l2.tileID.isChildOf(t2) && l2.findMatches(e2.symbolInstances, t2, r2);
                }
              else {
                var c2 = n2[t2.scaledTo(Number(a2)).key];
                c2 && c2.findMatches(e2.symbolInstances, t2, r2);
              }
            }
            for (var u2 = 0; u2 < e2.symbolInstances.length; u2++) {
              var h2 = e2.symbolInstances.get(u2);
              h2.crossTileID || (h2.crossTileID = i2.generate(), r2[h2.crossTileID] = true);
            }
            return void 0 === this.indexes[t2.overscaledZ] && (this.indexes[t2.overscaledZ] = {}), this.indexes[t2.overscaledZ][t2.key] = new ke(t2, e2.symbolInstances, e2.bucketInstanceId), true;
          }, Oe.prototype.removeBucketCrossTileIDs = function(t2, e2) {
            for (var i2 in e2.indexedSymbolInstances)
              for (var o2 = 0, r2 = e2.indexedSymbolInstances[i2]; o2 < r2.length; o2 += 1)
                delete this.usedCrossTileIDs[t2][r2[o2].crossTileID];
          }, Oe.prototype.removeStaleBuckets = function(t2) {
            var e2 = false;
            for (var i2 in this.indexes) {
              var o2 = this.indexes[i2];
              for (var r2 in o2)
                t2[o2[r2].bucketInstanceId] || (this.removeBucketCrossTileIDs(i2, o2[r2]), delete o2[r2], e2 = true);
            }
            return e2;
          };
          var Fe = function() {
            this.layerIndexes = {}, this.crossTileIDs = new Be(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
          };
          Fe.prototype.addLayer = function(t2, e2, i2) {
            var o2 = this.layerIndexes[t2.id];
            void 0 === o2 && (o2 = this.layerIndexes[t2.id] = new Oe());
            var r2 = false, a2 = {};
            o2.handleWrapJump(i2);
            for (var n2 = 0, s2 = e2; n2 < s2.length; n2 += 1) {
              var l2 = s2[n2], c2 = l2.getBucket(t2);
              c2 && t2.id === c2.layerIds[0] && (c2.bucketInstanceId || (c2.bucketInstanceId = ++this.maxBucketInstanceId), o2.addBucket(l2.tileID, c2, this.crossTileIDs) && (r2 = true), a2[c2.bucketInstanceId] = true);
            }
            return o2.removeStaleBuckets(a2) && (r2 = true), r2;
          }, Fe.prototype.pruneUnusedLayers = function(t2) {
            var e2 = {};
            for (var i2 in t2.forEach(function(t3) {
              e2[t3] = true;
            }), this.layerIndexes)
              e2[i2] || delete this.layerIndexes[i2];
          };
          var Ue = function(e2, i2) {
            return t.emitValidationErrors(e2, i2 && i2.filter(function(t2) {
              return "source.canvas" !== t2.identifier;
            }));
          }, Ne = t.pick(Zt, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData"]), Ze = t.pick(Zt, ["setCenter", "setZoom", "setBearing", "setPitch"]), qe = function() {
            var e2 = {}, i2 = t.styleSpec.$version;
            for (var o2 in t.styleSpec.$root) {
              var r2, a2 = t.styleSpec.$root[o2];
              if (a2.required)
                null != (r2 = "version" === o2 ? i2 : "array" === a2.type ? [] : {}) && (e2[o2] = r2);
            }
            return e2;
          }(), je = function(e2) {
            function i2(o2, r2) {
              var a2 = this;
              void 0 === r2 && (r2 = {}), e2.call(this), this.map = o2, this.dispatcher = new E(Ft(), this), this.imageManager = new p(), this.imageManager.setEventedParent(this), this.glyphManager = new y(o2._requestManager, r2.localIdeographFontFamily), this.lineAtlas = new T(256, 512), this.crossTileSymbolIndex = new Fe(), this._layers = {}, this._serializedLayers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t.ZoomHistory(), this._loaded = false, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", t.getReferrer());
              var n2 = this;
              this._rtlTextPluginCallback = i2.registerForPluginStateChange(function(e3) {
                n2.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: e3.pluginStatus, pluginURL: e3.pluginURL }, function(e4, i3) {
                  if (t.triggerPluginCompletionEvent(e4), i3 && i3.every(function(t2) {
                    return t2;
                  }))
                    for (var o3 in n2.sourceCaches)
                      n2.sourceCaches[o3].reload();
                });
              }), this.on("data", function(t2) {
                if ("source" === t2.dataType && "metadata" === t2.sourceDataType) {
                  var e3 = a2.sourceCaches[t2.sourceId];
                  if (e3) {
                    var i3 = e3.getSource();
                    if (i3 && i3.vectorLayerIds)
                      for (var o3 in a2._layers) {
                        var r3 = a2._layers[o3];
                        r3.source === i3.id && a2._validateLayer(r3);
                      }
                  }
                }
              });
            }
            return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.loadURL = function(e3, i3) {
              var o2 = this;
              void 0 === i3 && (i3 = {}), this.fire(new t.Event("dataloading", { dataType: "style" }));
              var r2 = "boolean" == typeof i3.validate ? i3.validate : !t.isMapboxURL(e3);
              e3 = this.map._requestManager.normalizeStyleURL(e3, i3.accessToken);
              var a2 = this.map._requestManager.transformRequest(e3, t.ResourceType.Style);
              this._request = t.getJSON(a2, function(e4, i4) {
                o2._request = null, e4 ? o2.fire(new t.ErrorEvent(e4)) : i4 && o2._load(i4, r2);
              });
            }, i2.prototype.loadJSON = function(e3, i3) {
              var o2 = this;
              void 0 === i3 && (i3 = {}), this.fire(new t.Event("dataloading", { dataType: "style" })), this._request = t.browser.frame(function() {
                o2._request = null, o2._load(e3, false !== i3.validate);
              });
            }, i2.prototype.loadEmpty = function() {
              this.fire(new t.Event("dataloading", { dataType: "style" })), this._load(qe, false);
            }, i2.prototype._load = function(e3, i3) {
              if (!i3 || !Ue(this, t.validateStyle(e3))) {
                for (var o2 in this._loaded = true, this.stylesheet = e3, e3.sources)
                  this.addSource(o2, e3.sources[o2], { validate: false });
                e3.sprite ? this._loadSprite(e3.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(e3.glyphs);
                var r2 = Nt(this.stylesheet.layers);
                this._order = r2.map(function(t2) {
                  return t2.id;
                }), this._layers = {}, this._serializedLayers = {};
                for (var a2 = 0, n2 = r2; a2 < n2.length; a2 += 1) {
                  var s2 = n2[a2];
                  (s2 = t.createStyleLayer(s2)).setEventedParent(this, { layer: { id: s2.id } }), this._layers[s2.id] = s2, this._serializedLayers[s2.id] = s2.serialize();
                }
                this.dispatcher.broadcast("setLayers", this._serializeLayers(this._order)), this.light = new w(this.stylesheet.light), this.fire(new t.Event("data", { dataType: "style" })), this.fire(new t.Event("style.load"));
              }
            }, i2.prototype._loadSprite = function(e3) {
              var i3 = this;
              this._spriteRequest = function(e4, i4, o2) {
                var r2, a2, n2, s2 = t.browser.devicePixelRatio > 1 ? "@2x" : "", l2 = t.getJSON(i4.transformRequest(i4.normalizeSpriteURL(e4, s2, ".json"), t.ResourceType.SpriteJSON), function(t2, e5) {
                  l2 = null, n2 || (n2 = t2, r2 = e5, u2());
                }), c2 = t.getImage(i4.transformRequest(i4.normalizeSpriteURL(e4, s2, ".png"), t.ResourceType.SpriteImage), function(t2, e5) {
                  c2 = null, n2 || (n2 = t2, a2 = e5, u2());
                });
                function u2() {
                  if (n2)
                    o2(n2);
                  else if (r2 && a2) {
                    var e5 = t.browser.getImageData(a2), i5 = {};
                    for (var s3 in r2) {
                      var l3 = r2[s3], c3 = l3.width, u3 = l3.height, h2 = l3.x, p2 = l3.y, d2 = l3.sdf, _2 = l3.pixelRatio, f2 = l3.stretchX, m2 = l3.stretchY, g2 = l3.content, v2 = new t.RGBAImage({ width: c3, height: u3 });
                      t.RGBAImage.copy(e5, v2, { x: h2, y: p2 }, { x: 0, y: 0 }, { width: c3, height: u3 }), i5[s3] = { data: v2, pixelRatio: _2, sdf: d2, stretchX: f2, stretchY: m2, content: g2 };
                    }
                    o2(null, i5);
                  }
                }
                return { cancel: function() {
                  l2 && (l2.cancel(), l2 = null), c2 && (c2.cancel(), c2 = null);
                } };
              }(e3, this.map._requestManager, function(e4, o2) {
                if (i3._spriteRequest = null, e4)
                  i3.fire(new t.ErrorEvent(e4));
                else if (o2)
                  for (var r2 in o2)
                    i3.imageManager.addImage(r2, o2[r2]);
                i3.imageManager.setLoaded(true), i3._availableImages = i3.imageManager.listImages(), i3.dispatcher.broadcast("setImages", i3._availableImages), i3.fire(new t.Event("data", { dataType: "style" }));
              });
            }, i2.prototype._validateLayer = function(e3) {
              var i3 = this.sourceCaches[e3.source];
              if (i3) {
                var o2 = e3.sourceLayer;
                if (o2) {
                  var r2 = i3.getSource();
                  ("geojson" === r2.type || r2.vectorLayerIds && -1 === r2.vectorLayerIds.indexOf(o2)) && this.fire(new t.ErrorEvent(new Error('Source layer "' + o2 + '" does not exist on source "' + r2.id + '" as specified by style layer "' + e3.id + '"')));
                }
              }
            }, i2.prototype.loaded = function() {
              if (!this._loaded)
                return false;
              if (Object.keys(this._updatedSources).length)
                return false;
              for (var t2 in this.sourceCaches)
                if (!this.sourceCaches[t2].loaded())
                  return false;
              return !!this.imageManager.isLoaded();
            }, i2.prototype._serializeLayers = function(t2) {
              for (var e3 = [], i3 = 0, o2 = t2; i3 < o2.length; i3 += 1) {
                var r2 = this._layers[o2[i3]];
                "custom" !== r2.type && e3.push(r2.serialize());
              }
              return e3;
            }, i2.prototype.hasTransitions = function() {
              if (this.light && this.light.hasTransition())
                return true;
              for (var t2 in this.sourceCaches)
                if (this.sourceCaches[t2].hasTransition())
                  return true;
              for (var e3 in this._layers)
                if (this._layers[e3].hasTransition())
                  return true;
              return false;
            }, i2.prototype._checkLoaded = function() {
              if (!this._loaded)
                throw new Error("Style is not done loading");
            }, i2.prototype.update = function(e3) {
              if (this._loaded) {
                var i3 = this._changed;
                if (this._changed) {
                  var o2 = Object.keys(this._updatedLayers), r2 = Object.keys(this._removedLayers);
                  for (var a2 in (o2.length || r2.length) && this._updateWorkerLayers(o2, r2), this._updatedSources) {
                    var n2 = this._updatedSources[a2];
                    "reload" === n2 ? this._reloadSource(a2) : "clear" === n2 && this._clearSource(a2);
                  }
                  for (var s2 in this._updateTilesForChangedImages(), this._updatedPaintProps)
                    this._layers[s2].updateTransitions(e3);
                  this.light.updateTransitions(e3), this._resetUpdates();
                }
                var l2 = {};
                for (var c2 in this.sourceCaches) {
                  var u2 = this.sourceCaches[c2];
                  l2[c2] = u2.used, u2.used = false;
                }
                for (var h2 = 0, p2 = this._order; h2 < p2.length; h2 += 1) {
                  var d2 = this._layers[p2[h2]];
                  d2.recalculate(e3, this._availableImages), !d2.isHidden(e3.zoom) && d2.source && (this.sourceCaches[d2.source].used = true);
                }
                for (var _2 in l2) {
                  var f2 = this.sourceCaches[_2];
                  l2[_2] !== f2.used && f2.fire(new t.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: _2 }));
                }
                this.light.recalculate(e3), this.z = e3.zoom, i3 && this.fire(new t.Event("data", { dataType: "style" }));
              }
            }, i2.prototype._updateTilesForChangedImages = function() {
              var t2 = Object.keys(this._changedImages);
              if (t2.length) {
                for (var e3 in this.sourceCaches)
                  this.sourceCaches[e3].reloadTilesForDependencies(["icons", "patterns"], t2);
                this._changedImages = {};
              }
            }, i2.prototype._updateWorkerLayers = function(t2, e3) {
              this.dispatcher.broadcast("updateLayers", { layers: this._serializeLayers(t2), removedIds: e3 });
            }, i2.prototype._resetUpdates = function() {
              this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {};
            }, i2.prototype.setState = function(e3) {
              var i3 = this;
              if (this._checkLoaded(), Ue(this, t.validateStyle(e3)))
                return false;
              (e3 = t.clone$1(e3)).layers = Nt(e3.layers);
              var o2 = function(e4, i4) {
                if (!e4)
                  return [{ command: Zt.setStyle, args: [i4] }];
                var o3 = [];
                try {
                  if (!t.deepEqual(e4.version, i4.version))
                    return [{ command: Zt.setStyle, args: [i4] }];
                  t.deepEqual(e4.center, i4.center) || o3.push({ command: Zt.setCenter, args: [i4.center] }), t.deepEqual(e4.zoom, i4.zoom) || o3.push({ command: Zt.setZoom, args: [i4.zoom] }), t.deepEqual(e4.bearing, i4.bearing) || o3.push({ command: Zt.setBearing, args: [i4.bearing] }), t.deepEqual(e4.pitch, i4.pitch) || o3.push({ command: Zt.setPitch, args: [i4.pitch] }), t.deepEqual(e4.sprite, i4.sprite) || o3.push({ command: Zt.setSprite, args: [i4.sprite] }), t.deepEqual(e4.glyphs, i4.glyphs) || o3.push({ command: Zt.setGlyphs, args: [i4.glyphs] }), t.deepEqual(e4.transition, i4.transition) || o3.push({ command: Zt.setTransition, args: [i4.transition] }), t.deepEqual(e4.light, i4.light) || o3.push({ command: Zt.setLight, args: [i4.light] });
                  var r3 = {}, a2 = [];
                  !function(e5, i5, o4, r4) {
                    var a3;
                    for (a3 in i5 = i5 || {}, e5 = e5 || {})
                      e5.hasOwnProperty(a3) && (i5.hasOwnProperty(a3) || jt(a3, o4, r4));
                    for (a3 in i5)
                      i5.hasOwnProperty(a3) && (e5.hasOwnProperty(a3) ? t.deepEqual(e5[a3], i5[a3]) || ("geojson" === e5[a3].type && "geojson" === i5[a3].type && Gt(e5, i5, a3) ? o4.push({ command: Zt.setGeoJSONSourceData, args: [a3, i5[a3].data] }) : Vt(a3, i5, o4, r4)) : qt(a3, i5, o4));
                  }(e4.sources, i4.sources, a2, r3);
                  var n2 = [];
                  e4.layers && e4.layers.forEach(function(t2) {
                    r3[t2.source] ? o3.push({ command: Zt.removeLayer, args: [t2.id] }) : n2.push(t2);
                  }), o3 = o3.concat(a2), function(e5, i5, o4) {
                    i5 = i5 || [];
                    var r4, a3, n3, s2, l2, c2, u2, h2 = (e5 = e5 || []).map(Xt), p2 = i5.map(Xt), d2 = e5.reduce(Ht, {}), _2 = i5.reduce(Ht, {}), f2 = h2.slice(), m2 = /* @__PURE__ */ Object.create(null);
                    for (r4 = 0, a3 = 0; r4 < h2.length; r4++)
                      _2.hasOwnProperty(n3 = h2[r4]) ? a3++ : (o4.push({ command: Zt.removeLayer, args: [n3] }), f2.splice(f2.indexOf(n3, a3), 1));
                    for (r4 = 0, a3 = 0; r4 < p2.length; r4++)
                      f2[f2.length - 1 - r4] !== (n3 = p2[p2.length - 1 - r4]) && (d2.hasOwnProperty(n3) ? (o4.push({ command: Zt.removeLayer, args: [n3] }), f2.splice(f2.lastIndexOf(n3, f2.length - a3), 1)) : a3++, o4.push({ command: Zt.addLayer, args: [_2[n3], c2 = f2[f2.length - r4]] }), f2.splice(f2.length - r4, 0, n3), m2[n3] = true);
                    for (r4 = 0; r4 < p2.length; r4++)
                      if (s2 = d2[n3 = p2[r4]], l2 = _2[n3], !m2[n3] && !t.deepEqual(s2, l2))
                        if (t.deepEqual(s2.source, l2.source) && t.deepEqual(s2["source-layer"], l2["source-layer"]) && t.deepEqual(s2.type, l2.type)) {
                          for (u2 in Wt(s2.layout, l2.layout, o4, n3, null, Zt.setLayoutProperty), Wt(s2.paint, l2.paint, o4, n3, null, Zt.setPaintProperty), t.deepEqual(s2.filter, l2.filter) || o4.push({ command: Zt.setFilter, args: [n3, l2.filter] }), t.deepEqual(s2.minzoom, l2.minzoom) && t.deepEqual(s2.maxzoom, l2.maxzoom) || o4.push({ command: Zt.setLayerZoomRange, args: [n3, l2.minzoom, l2.maxzoom] }), s2)
                            s2.hasOwnProperty(u2) && "layout" !== u2 && "paint" !== u2 && "filter" !== u2 && "metadata" !== u2 && "minzoom" !== u2 && "maxzoom" !== u2 && (0 === u2.indexOf("paint.") ? Wt(s2[u2], l2[u2], o4, n3, u2.slice(6), Zt.setPaintProperty) : t.deepEqual(s2[u2], l2[u2]) || o4.push({ command: Zt.setLayerProperty, args: [n3, u2, l2[u2]] }));
                          for (u2 in l2)
                            l2.hasOwnProperty(u2) && !s2.hasOwnProperty(u2) && "layout" !== u2 && "paint" !== u2 && "filter" !== u2 && "metadata" !== u2 && "minzoom" !== u2 && "maxzoom" !== u2 && (0 === u2.indexOf("paint.") ? Wt(s2[u2], l2[u2], o4, n3, u2.slice(6), Zt.setPaintProperty) : t.deepEqual(s2[u2], l2[u2]) || o4.push({ command: Zt.setLayerProperty, args: [n3, u2, l2[u2]] }));
                        } else
                          o4.push({ command: Zt.removeLayer, args: [n3] }), c2 = f2[f2.lastIndexOf(n3) + 1], o4.push({ command: Zt.addLayer, args: [l2, c2] });
                  }(n2, i4.layers, o3);
                } catch (t2) {
                  console.warn("Unable to compute style diff:", t2), o3 = [{ command: Zt.setStyle, args: [i4] }];
                }
                return o3;
              }(this.serialize(), e3).filter(function(t2) {
                return !(t2.command in Ze);
              });
              if (0 === o2.length)
                return false;
              var r2 = o2.filter(function(t2) {
                return !(t2.command in Ne);
              });
              if (r2.length > 0)
                throw new Error("Unimplemented: " + r2.map(function(t2) {
                  return t2.command;
                }).join(", ") + ".");
              return o2.forEach(function(t2) {
                "setTransition" !== t2.command && i3[t2.command].apply(i3, t2.args);
              }), this.stylesheet = e3, true;
            }, i2.prototype.addImage = function(e3, i3) {
              if (this.getImage(e3))
                return this.fire(new t.ErrorEvent(new Error("An image with this name already exists.")));
              this.imageManager.addImage(e3, i3), this._afterImageUpdated(e3);
            }, i2.prototype.updateImage = function(t2, e3) {
              this.imageManager.updateImage(t2, e3);
            }, i2.prototype.getImage = function(t2) {
              return this.imageManager.getImage(t2);
            }, i2.prototype.removeImage = function(e3) {
              if (!this.getImage(e3))
                return this.fire(new t.ErrorEvent(new Error("No image with this name exists.")));
              this.imageManager.removeImage(e3), this._afterImageUpdated(e3);
            }, i2.prototype._afterImageUpdated = function(e3) {
              this._availableImages = this.imageManager.listImages(), this._changedImages[e3] = true, this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t.Event("data", { dataType: "style" }));
            }, i2.prototype.listImages = function() {
              return this._checkLoaded(), this.imageManager.listImages();
            }, i2.prototype.addSource = function(e3, i3, o2) {
              var r2 = this;
              if (void 0 === o2 && (o2 = {}), this._checkLoaded(), void 0 !== this.sourceCaches[e3])
                throw new Error("There is already a source with this ID");
              if (!i3.type)
                throw new Error("The type property must be defined, but only the following properties were given: " + Object.keys(i3).join(", ") + ".");
              if (!(["vector", "raster", "geojson", "video", "image"].indexOf(i3.type) >= 0 && this._validate(t.validateStyle.source, "sources." + e3, i3, null, o2))) {
                this.map && this.map._collectResourceTiming && (i3.collectResourceTiming = true);
                var a2 = this.sourceCaches[e3] = new Dt(e3, i3, this.dispatcher);
                a2.style = this, a2.setEventedParent(this, function() {
                  return { isSourceLoaded: r2.loaded(), source: a2.serialize(), sourceId: e3 };
                }), a2.onAdd(this.map), this._changed = true;
              }
            }, i2.prototype.removeSource = function(e3) {
              if (this._checkLoaded(), void 0 === this.sourceCaches[e3])
                throw new Error("There is no source with this ID");
              for (var i3 in this._layers)
                if (this._layers[i3].source === e3)
                  return this.fire(new t.ErrorEvent(new Error('Source "' + e3 + '" cannot be removed while layer "' + i3 + '" is using it.')));
              var o2 = this.sourceCaches[e3];
              delete this.sourceCaches[e3], delete this._updatedSources[e3], o2.fire(new t.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: e3 })), o2.setEventedParent(null), o2.clearTiles(), o2.onRemove && o2.onRemove(this.map), this._changed = true;
            }, i2.prototype.setGeoJSONSourceData = function(t2, e3) {
              this._checkLoaded(), this.sourceCaches[t2].getSource().setData(e3), this._changed = true;
            }, i2.prototype.getSource = function(t2) {
              return this.sourceCaches[t2] && this.sourceCaches[t2].getSource();
            }, i2.prototype.addLayer = function(e3, i3, o2) {
              void 0 === o2 && (o2 = {}), this._checkLoaded();
              var r2 = e3.id;
              if (this.getLayer(r2))
                this.fire(new t.ErrorEvent(new Error('Layer with id "' + r2 + '" already exists on this map')));
              else {
                var a2;
                if ("custom" === e3.type) {
                  if (Ue(this, t.validateCustomStyleLayer(e3)))
                    return;
                  a2 = t.createStyleLayer(e3);
                } else {
                  if ("object" == typeof e3.source && (this.addSource(r2, e3.source), e3 = t.clone$1(e3), e3 = t.extend(e3, { source: r2 })), this._validate(t.validateStyle.layer, "layers." + r2, e3, { arrayIndex: -1 }, o2))
                    return;
                  a2 = t.createStyleLayer(e3), this._validateLayer(a2), a2.setEventedParent(this, { layer: { id: r2 } }), this._serializedLayers[a2.id] = a2.serialize();
                }
                var n2 = i3 ? this._order.indexOf(i3) : this._order.length;
                if (i3 && -1 === n2)
                  this.fire(new t.ErrorEvent(new Error('Layer with id "' + i3 + '" does not exist on this map.')));
                else {
                  if (this._order.splice(n2, 0, r2), this._layerOrderChanged = true, this._layers[r2] = a2, this._removedLayers[r2] && a2.source && "custom" !== a2.type) {
                    var s2 = this._removedLayers[r2];
                    delete this._removedLayers[r2], s2.type !== a2.type ? this._updatedSources[a2.source] = "clear" : (this._updatedSources[a2.source] = "reload", this.sourceCaches[a2.source].pause());
                  }
                  this._updateLayer(a2), a2.onAdd && a2.onAdd(this.map);
                }
              }
            }, i2.prototype.moveLayer = function(e3, i3) {
              if (this._checkLoaded(), this._changed = true, this._layers[e3]) {
                if (e3 !== i3) {
                  var o2 = this._order.indexOf(e3);
                  this._order.splice(o2, 1);
                  var r2 = i3 ? this._order.indexOf(i3) : this._order.length;
                  i3 && -1 === r2 ? this.fire(new t.ErrorEvent(new Error('Layer with id "' + i3 + '" does not exist on this map.'))) : (this._order.splice(r2, 0, e3), this._layerOrderChanged = true);
                }
              } else
                this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style and cannot be moved.")));
            }, i2.prototype.removeLayer = function(e3) {
              this._checkLoaded();
              var i3 = this._layers[e3];
              if (i3) {
                i3.setEventedParent(null);
                var o2 = this._order.indexOf(e3);
                this._order.splice(o2, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e3] = i3, delete this._layers[e3], delete this._serializedLayers[e3], delete this._updatedLayers[e3], delete this._updatedPaintProps[e3], i3.onRemove && i3.onRemove(this.map);
              } else
                this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style and cannot be removed.")));
            }, i2.prototype.getLayer = function(t2) {
              return this._layers[t2];
            }, i2.prototype.hasLayer = function(t2) {
              return t2 in this._layers;
            }, i2.prototype.setLayerZoomRange = function(e3, i3, o2) {
              this._checkLoaded();
              var r2 = this.getLayer(e3);
              r2 ? r2.minzoom === i3 && r2.maxzoom === o2 || (null != i3 && (r2.minzoom = i3), null != o2 && (r2.maxzoom = o2), this._updateLayer(r2)) : this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style and cannot have zoom extent.")));
            }, i2.prototype.setFilter = function(e3, i3, o2) {
              void 0 === o2 && (o2 = {}), this._checkLoaded();
              var r2 = this.getLayer(e3);
              if (r2) {
                if (!t.deepEqual(r2.filter, i3))
                  return null == i3 ? (r2.filter = void 0, void this._updateLayer(r2)) : void (this._validate(t.validateStyle.filter, "layers." + r2.id + ".filter", i3, null, o2) || (r2.filter = t.clone$1(i3), this._updateLayer(r2)));
              } else
                this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style and cannot be filtered.")));
            }, i2.prototype.getFilter = function(e3) {
              return t.clone$1(this.getLayer(e3).filter);
            }, i2.prototype.setLayoutProperty = function(e3, i3, o2, r2) {
              void 0 === r2 && (r2 = {}), this._checkLoaded();
              var a2 = this.getLayer(e3);
              a2 ? t.deepEqual(a2.getLayoutProperty(i3), o2) || (a2.setLayoutProperty(i3, o2, r2), this._updateLayer(a2)) : this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style and cannot be styled.")));
            }, i2.prototype.getLayoutProperty = function(e3, i3) {
              var o2 = this.getLayer(e3);
              if (o2)
                return o2.getLayoutProperty(i3);
              this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style.")));
            }, i2.prototype.setPaintProperty = function(e3, i3, o2, r2) {
              void 0 === r2 && (r2 = {}), this._checkLoaded();
              var a2 = this.getLayer(e3);
              a2 ? t.deepEqual(a2.getPaintProperty(i3), o2) || (a2.setPaintProperty(i3, o2, r2) && this._updateLayer(a2), this._changed = true, this._updatedPaintProps[e3] = true) : this.fire(new t.ErrorEvent(new Error("The layer '" + e3 + "' does not exist in the map's style and cannot be styled.")));
            }, i2.prototype.getPaintProperty = function(t2, e3) {
              return this.getLayer(t2).getPaintProperty(e3);
            }, i2.prototype.setFeatureState = function(e3, i3) {
              this._checkLoaded();
              var o2 = e3.source, r2 = e3.sourceLayer, a2 = this.sourceCaches[o2];
              if (void 0 !== a2) {
                var n2 = a2.getSource().type;
                "geojson" === n2 && r2 ? this.fire(new t.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== n2 || r2 ? (void 0 === e3.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), a2.setFeatureState(r2, e3.id, i3)) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
              } else
                this.fire(new t.ErrorEvent(new Error("The source '" + o2 + "' does not exist in the map's style.")));
            }, i2.prototype.removeFeatureState = function(e3, i3) {
              this._checkLoaded();
              var o2 = e3.source, r2 = this.sourceCaches[o2];
              if (void 0 !== r2) {
                var a2 = r2.getSource().type, n2 = "vector" === a2 ? e3.sourceLayer : void 0;
                "vector" !== a2 || n2 ? i3 && "string" != typeof e3.id && "number" != typeof e3.id ? this.fire(new t.ErrorEvent(new Error("A feature id is required to remove its specific state property."))) : r2.removeFeatureState(n2, e3.id, i3) : this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
              } else
                this.fire(new t.ErrorEvent(new Error("The source '" + o2 + "' does not exist in the map's style.")));
            }, i2.prototype.getFeatureState = function(e3) {
              this._checkLoaded();
              var i3 = e3.source, o2 = e3.sourceLayer, r2 = this.sourceCaches[i3];
              if (void 0 !== r2) {
                if ("vector" !== r2.getSource().type || o2)
                  return void 0 === e3.id && this.fire(new t.ErrorEvent(new Error("The feature id parameter must be provided."))), r2.getFeatureState(o2, e3.id);
                this.fire(new t.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
              } else
                this.fire(new t.ErrorEvent(new Error("The source '" + i3 + "' does not exist in the map's style.")));
            }, i2.prototype.getTransition = function() {
              return t.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
            }, i2.prototype.serialize = function() {
              return t.filterObject({ version: this.stylesheet.version, name: this.stylesheet.name, metadata: this.stylesheet.metadata, light: this.stylesheet.light, center: this.stylesheet.center, zoom: this.stylesheet.zoom, bearing: this.stylesheet.bearing, pitch: this.stylesheet.pitch, sprite: this.stylesheet.sprite, glyphs: this.stylesheet.glyphs, transition: this.stylesheet.transition, sources: t.mapObject(this.sourceCaches, function(t2) {
                return t2.serialize();
              }), layers: this._serializeLayers(this._order) }, function(t2) {
                return void 0 !== t2;
              });
            }, i2.prototype._updateLayer = function(t2) {
              this._updatedLayers[t2.id] = true, t2.source && !this._updatedSources[t2.source] && "raster" !== this.sourceCaches[t2.source].getSource().type && (this._updatedSources[t2.source] = "reload", this.sourceCaches[t2.source].pause()), this._changed = true;
            }, i2.prototype._flattenAndSortRenderedFeatures = function(t2) {
              for (var e3 = this, i3 = function(t3) {
                return "fill-extrusion" === e3._layers[t3].type;
              }, o2 = {}, r2 = [], a2 = this._order.length - 1; a2 >= 0; a2--) {
                var n2 = this._order[a2];
                if (i3(n2)) {
                  o2[n2] = a2;
                  for (var s2 = 0, l2 = t2; s2 < l2.length; s2 += 1) {
                    var c2 = l2[s2][n2];
                    if (c2)
                      for (var u2 = 0, h2 = c2; u2 < h2.length; u2 += 1)
                        r2.push(h2[u2]);
                  }
                }
              }
              r2.sort(function(t3, e4) {
                return e4.intersectionZ - t3.intersectionZ;
              });
              for (var p2 = [], d2 = this._order.length - 1; d2 >= 0; d2--) {
                var _2 = this._order[d2];
                if (i3(_2))
                  for (var f2 = r2.length - 1; f2 >= 0; f2--) {
                    var m2 = r2[f2].feature;
                    if (o2[m2.layer.id] < d2)
                      break;
                    p2.push(m2), r2.pop();
                  }
                else
                  for (var g2 = 0, v2 = t2; g2 < v2.length; g2 += 1) {
                    var y2 = v2[g2][_2];
                    if (y2)
                      for (var x2 = 0, b2 = y2; x2 < b2.length; x2 += 1)
                        p2.push(b2[x2].feature);
                  }
              }
              return p2;
            }, i2.prototype.queryRenderedFeatures = function(e3, i3, o2) {
              i3 && i3.filter && this._validate(t.validateStyle.filter, "queryRenderedFeatures.filter", i3.filter, null, i3);
              var r2 = {};
              if (i3 && i3.layers) {
                if (!Array.isArray(i3.layers))
                  return this.fire(new t.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
                for (var a2 = 0, n2 = i3.layers; a2 < n2.length; a2 += 1) {
                  var s2 = n2[a2], l2 = this._layers[s2];
                  if (!l2)
                    return this.fire(new t.ErrorEvent(new Error("The layer '" + s2 + "' does not exist in the map's style and cannot be queried for features."))), [];
                  r2[l2.source] = true;
                }
              }
              var c2 = [];
              for (var u2 in i3.availableImages = this._availableImages, this.sourceCaches)
                i3.layers && !r2[u2] || c2.push(O(this.sourceCaches[u2], this._layers, this._serializedLayers, e3, i3, o2));
              return this.placement && c2.push(function(t2, e4, i4, o3, r3, a3, n3) {
                for (var s3 = {}, l3 = a3.queryRenderedSymbols(o3), c3 = [], u3 = 0, h2 = Object.keys(l3).map(Number); u3 < h2.length; u3 += 1)
                  c3.push(n3[h2[u3]]);
                c3.sort(F);
                for (var p2 = function() {
                  var i5 = _2[d2], o4 = i5.featureIndex.lookupSymbolFeatures(l3[i5.bucketInstanceId], e4, i5.bucketIndex, i5.sourceLayerIndex, r3.filter, r3.layers, r3.availableImages, t2);
                  for (var a4 in o4) {
                    var n4 = s3[a4] = s3[a4] || [], c4 = o4[a4];
                    c4.sort(function(t3, e5) {
                      var o5 = i5.featureSortOrder;
                      if (o5) {
                        var r4 = o5.indexOf(t3.featureIndex);
                        return o5.indexOf(e5.featureIndex) - r4;
                      }
                      return e5.featureIndex - t3.featureIndex;
                    });
                    for (var u4 = 0, h3 = c4; u4 < h3.length; u4 += 1)
                      n4.push(h3[u4]);
                  }
                }, d2 = 0, _2 = c3; d2 < _2.length; d2 += 1)
                  p2();
                var f2 = function(e5) {
                  s3[e5].forEach(function(o4) {
                    var r4 = o4.feature, a4 = i4[t2[e5].source].getFeatureState(r4.layer["source-layer"], r4.id);
                    r4.source = r4.layer.source, r4.layer["source-layer"] && (r4.sourceLayer = r4.layer["source-layer"]), r4.state = a4;
                  });
                };
                for (var m2 in s3)
                  f2(m2);
                return s3;
              }(this._layers, this._serializedLayers, this.sourceCaches, e3, i3, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(c2);
            }, i2.prototype.querySourceFeatures = function(e3, i3) {
              i3 && i3.filter && this._validate(t.validateStyle.filter, "querySourceFeatures.filter", i3.filter, null, i3);
              var o2 = this.sourceCaches[e3];
              return o2 ? function(t2, e4) {
                for (var i4 = t2.getRenderableIds().map(function(e5) {
                  return t2.getTileByID(e5);
                }), o3 = [], r2 = {}, a2 = 0; a2 < i4.length; a2++) {
                  var n2 = i4[a2], s2 = n2.tileID.canonical.key;
                  r2[s2] || (r2[s2] = true, n2.querySourceFeatures(o3, e4));
                }
                return o3;
              }(o2, i3) : [];
            }, i2.prototype.addSourceType = function(t2, e3, o2) {
              return i2.getSourceType(t2) ? o2(new Error('A source type called "' + t2 + '" already exists.')) : (i2.setSourceType(t2, e3), e3.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: t2, url: e3.workerSourceURL }, o2) : o2(null, null));
            }, i2.prototype.getLight = function() {
              return this.light.getLight();
            }, i2.prototype.setLight = function(e3, i3) {
              void 0 === i3 && (i3 = {}), this._checkLoaded();
              var o2 = this.light.getLight(), r2 = false;
              for (var a2 in e3)
                if (!t.deepEqual(e3[a2], o2[a2])) {
                  r2 = true;
                  break;
                }
              if (r2) {
                var n2 = { now: t.browser.now(), transition: t.extend({ duration: 300, delay: 0 }, this.stylesheet.transition) };
                this.light.setLight(e3, i3), this.light.updateTransitions(n2);
              }
            }, i2.prototype._validate = function(e3, i3, o2, r2, a2) {
              return void 0 === a2 && (a2 = {}), (!a2 || false !== a2.validate) && Ue(this, e3.call(t.validateStyle, t.extend({ key: i3, style: this.serialize(), value: o2, styleSpec: t.styleSpec }, r2)));
            }, i2.prototype._remove = function() {
              for (var e3 in this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), t.evented.off("pluginStateChange", this._rtlTextPluginCallback), this._layers)
                this._layers[e3].setEventedParent(null);
              for (var i3 in this.sourceCaches)
                this.sourceCaches[i3].clearTiles(), this.sourceCaches[i3].setEventedParent(null);
              this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove();
            }, i2.prototype._clearSource = function(t2) {
              this.sourceCaches[t2].clearTiles();
            }, i2.prototype._reloadSource = function(t2) {
              this.sourceCaches[t2].resume(), this.sourceCaches[t2].reload();
            }, i2.prototype._updateSources = function(t2) {
              for (var e3 in this.sourceCaches)
                this.sourceCaches[e3].update(t2);
            }, i2.prototype._generateCollisionBoxes = function() {
              for (var t2 in this.sourceCaches)
                this._reloadSource(t2);
            }, i2.prototype._updatePlacement = function(e3, i3, o2, r2, a2) {
              void 0 === a2 && (a2 = false);
              for (var n2 = false, s2 = false, l2 = {}, c2 = 0, u2 = this._order; c2 < u2.length; c2 += 1) {
                var h2 = this._layers[u2[c2]];
                if ("symbol" === h2.type) {
                  if (!l2[h2.source]) {
                    var p2 = this.sourceCaches[h2.source];
                    l2[h2.source] = p2.getRenderableIds(true).map(function(t2) {
                      return p2.getTileByID(t2);
                    }).sort(function(t2, e4) {
                      return e4.tileID.overscaledZ - t2.tileID.overscaledZ || (t2.tileID.isLessThan(e4.tileID) ? -1 : 1);
                    });
                  }
                  var d2 = this.crossTileSymbolIndex.addLayer(h2, l2[h2.source], e3.center.lng);
                  n2 = n2 || d2;
                }
              }
              if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((a2 = a2 || this._layerOrderChanged || 0 === o2) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(t.browser.now(), e3.zoom)) && (this.pauseablePlacement = new Le(e3, this._order, a2, i3, o2, r2, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l2), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(t.browser.now()), s2 = true), n2 && this.pauseablePlacement.placement.setStale()), s2 || n2)
                for (var _2 = 0, f2 = this._order; _2 < f2.length; _2 += 1) {
                  var m2 = this._layers[f2[_2]];
                  "symbol" === m2.type && this.placement.updateLayerOpacities(m2, l2[m2.source]);
                }
              return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(t.browser.now());
            }, i2.prototype._releaseSymbolFadeTiles = function() {
              for (var t2 in this.sourceCaches)
                this.sourceCaches[t2].releaseSymbolFadeTiles();
            }, i2.prototype.getImages = function(t2, e3, i3) {
              this.imageManager.getImages(e3.icons, i3), this._updateTilesForChangedImages();
              var o2 = this.sourceCaches[e3.source];
              o2 && o2.setDependencies(e3.tileID.key, e3.type, e3.icons);
            }, i2.prototype.getGlyphs = function(t2, e3, i3) {
              this.glyphManager.getGlyphs(e3.stacks, i3);
            }, i2.prototype.getResource = function(e3, i3, o2) {
              return t.makeRequest(i3, o2);
            }, i2;
          }(t.Evented);
          je.getSourceType = function(t2) {
            return k[t2];
          }, je.setSourceType = function(t2, e2) {
            k[t2] = e2;
          }, je.registerForPluginStateChange = t.registerForPluginStateChange;
          var Ve = t.createLayout([{ name: "a_pos", type: "Int16", components: 2 }]), Ge = gi("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}"), We = gi("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), Xe = gi("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), He = gi("varying vec3 v_data;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,0,1);} else {gl_Position=u_matrix*vec4(circle_center,0,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"), Ke = gi("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), Ye = gi("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}"), Je = gi("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), Qe = gi("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,0.0,1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), $e = gi("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), ti = gi("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,0,1);}"), ei = gi("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}"), ii = gi("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), oi = gi("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), ri = gi("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"), ai = gi("varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"), ni = gi("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;base=max(0.0,base);height=max(0.0,height);float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"), si = gi("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), li = gi("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), ci = gi("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"), ui = gi("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_width2=vec2(outset,inset);}"), hi = gi("uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"), pi = gi("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"), di = gi("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), _i = gi("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),0.0,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;v_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));}"), fi = gi("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), mi = gi("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),0,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,0.0,1.0);gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),0.0,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(1.0,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}");
          function gi(t2, e2) {
            var i2 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, o2 = e2.match(/attribute ([\w]+) ([\w]+)/g), r2 = t2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), a2 = e2.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), n2 = a2 ? a2.concat(r2) : r2, s2 = {};
            return { fragmentSource: t2 = t2.replace(i2, function(t3, e3, i3, o3, r3) {
              return s2[r3] = true, "define" === e3 ? "\n#ifndef HAS_UNIFORM_u_" + r3 + "\nvarying " + i3 + " " + o3 + " " + r3 + ";\n#else\nuniform " + i3 + " " + o3 + " u_" + r3 + ";\n#endif\n" : "\n#ifdef HAS_UNIFORM_u_" + r3 + "\n    " + i3 + " " + o3 + " " + r3 + " = u_" + r3 + ";\n#endif\n";
            }), vertexSource: e2 = e2.replace(i2, function(t3, e3, i3, o3, r3) {
              var a3 = "float" === o3 ? "vec2" : "vec4", n3 = r3.match(/color/) ? "color" : a3;
              return s2[r3] ? "define" === e3 ? "\n#ifndef HAS_UNIFORM_u_" + r3 + "\nuniform lowp float u_" + r3 + "_t;\nattribute " + i3 + " " + a3 + " a_" + r3 + ";\nvarying " + i3 + " " + o3 + " " + r3 + ";\n#else\nuniform " + i3 + " " + o3 + " u_" + r3 + ";\n#endif\n" : "vec4" === n3 ? "\n#ifndef HAS_UNIFORM_u_" + r3 + "\n    " + r3 + " = a_" + r3 + ";\n#else\n    " + i3 + " " + o3 + " " + r3 + " = u_" + r3 + ";\n#endif\n" : "\n#ifndef HAS_UNIFORM_u_" + r3 + "\n    " + r3 + " = unpack_mix_" + n3 + "(a_" + r3 + ", u_" + r3 + "_t);\n#else\n    " + i3 + " " + o3 + " " + r3 + " = u_" + r3 + ";\n#endif\n" : "define" === e3 ? "\n#ifndef HAS_UNIFORM_u_" + r3 + "\nuniform lowp float u_" + r3 + "_t;\nattribute " + i3 + " " + a3 + " a_" + r3 + ";\n#else\nuniform " + i3 + " " + o3 + " u_" + r3 + ";\n#endif\n" : "vec4" === n3 ? "\n#ifndef HAS_UNIFORM_u_" + r3 + "\n    " + i3 + " " + o3 + " " + r3 + " = a_" + r3 + ";\n#else\n    " + i3 + " " + o3 + " " + r3 + " = u_" + r3 + ";\n#endif\n" : "\n#ifndef HAS_UNIFORM_u_" + r3 + "\n    " + i3 + " " + o3 + " " + r3 + " = unpack_mix_" + n3 + "(a_" + r3 + ", u_" + r3 + "_t);\n#else\n    " + i3 + " " + o3 + " " + r3 + " = u_" + r3 + ";\n#endif\n";
            }), staticAttributes: o2, staticUniforms: n2 };
          }
          var vi = Object.freeze({ __proto__: null, prelude: Ge, background: We, backgroundPattern: Xe, circle: He, clippingMask: Ke, heatmap: Ye, heatmapTexture: Je, collisionBox: Qe, collisionCircle: $e, debug: ti, fill: ei, fillOutline: ii, fillOutlinePattern: oi, fillPattern: ri, fillExtrusion: ai, fillExtrusionPattern: ni, hillshadePrepare: si, hillshade: li, line: ci, lineGradient: ui, linePattern: hi, lineSDF: pi, raster: di, symbolIcon: _i, symbolSDF: fi, symbolTextAndIcon: mi }), yi = function() {
            this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
          };
          function xi(t2) {
            for (var e2 = [], i2 = 0; i2 < t2.length; i2++)
              if (null !== t2[i2]) {
                var o2 = t2[i2].split(" ");
                e2.push(o2.pop());
              }
            return e2;
          }
          yi.prototype.bind = function(t2, e2, i2, o2, r2, a2, n2, s2) {
            this.context = t2;
            for (var l2 = this.boundPaintVertexBuffers.length !== o2.length, c2 = 0; !l2 && c2 < o2.length; c2++)
              this.boundPaintVertexBuffers[c2] !== o2[c2] && (l2 = true);
            t2.extVertexArrayObject && this.vao && this.boundProgram === e2 && this.boundLayoutVertexBuffer === i2 && !l2 && this.boundIndexBuffer === r2 && this.boundVertexOffset === a2 && this.boundDynamicVertexBuffer === n2 && this.boundDynamicVertexBuffer2 === s2 ? (t2.bindVertexArrayOES.set(this.vao), n2 && n2.bind(), r2 && r2.dynamicDraw && r2.bind(), s2 && s2.bind()) : this.freshBind(e2, i2, o2, r2, a2, n2, s2);
          }, yi.prototype.freshBind = function(t2, e2, i2, o2, r2, a2, n2) {
            var s2, l2 = t2.numAttributes, c2 = this.context, u2 = c2.gl;
            if (c2.extVertexArrayObject)
              this.vao && this.destroy(), this.vao = c2.extVertexArrayObject.createVertexArrayOES(), c2.bindVertexArrayOES.set(this.vao), s2 = 0, this.boundProgram = t2, this.boundLayoutVertexBuffer = e2, this.boundPaintVertexBuffers = i2, this.boundIndexBuffer = o2, this.boundVertexOffset = r2, this.boundDynamicVertexBuffer = a2, this.boundDynamicVertexBuffer2 = n2;
            else {
              s2 = c2.currentNumAttributes || 0;
              for (var h2 = l2; h2 < s2; h2++)
                u2.disableVertexAttribArray(h2);
            }
            e2.enableAttributes(u2, t2);
            for (var p2 = 0, d2 = i2; p2 < d2.length; p2 += 1)
              d2[p2].enableAttributes(u2, t2);
            a2 && a2.enableAttributes(u2, t2), n2 && n2.enableAttributes(u2, t2), e2.bind(), e2.setVertexAttribPointers(u2, t2, r2);
            for (var _2 = 0, f2 = i2; _2 < f2.length; _2 += 1) {
              var m2 = f2[_2];
              m2.bind(), m2.setVertexAttribPointers(u2, t2, r2);
            }
            a2 && (a2.bind(), a2.setVertexAttribPointers(u2, t2, r2)), o2 && o2.bind(), n2 && (n2.bind(), n2.setVertexAttribPointers(u2, t2, r2)), c2.currentNumAttributes = l2;
          }, yi.prototype.destroy = function() {
            this.vao && (this.context.extVertexArrayObject.deleteVertexArrayOES(this.vao), this.vao = null);
          };
          var bi = function(t2, e2, i2, o2, r2, a2) {
            var n2 = t2.gl;
            this.program = n2.createProgram();
            for (var s2 = xi(i2.staticAttributes), l2 = o2 ? o2.getBinderAttributes() : [], c2 = s2.concat(l2), u2 = i2.staticUniforms ? xi(i2.staticUniforms) : [], h2 = o2 ? o2.getBinderUniforms() : [], p2 = [], d2 = 0, _2 = u2.concat(h2); d2 < _2.length; d2 += 1) {
              var f2 = _2[d2];
              p2.indexOf(f2) < 0 && p2.push(f2);
            }
            var m2 = o2 ? o2.defines() : [];
            a2 && m2.push("#define OVERDRAW_INSPECTOR;");
            var g2 = m2.concat(Ge.fragmentSource, i2.fragmentSource).join("\n"), v2 = m2.concat(Ge.vertexSource, i2.vertexSource).join("\n"), y2 = n2.createShader(n2.FRAGMENT_SHADER);
            if (n2.isContextLost())
              this.failedToCreate = true;
            else {
              n2.shaderSource(y2, g2), n2.compileShader(y2), n2.attachShader(this.program, y2);
              var x2 = n2.createShader(n2.VERTEX_SHADER);
              if (n2.isContextLost())
                this.failedToCreate = true;
              else {
                n2.shaderSource(x2, v2), n2.compileShader(x2), n2.attachShader(this.program, x2), this.attributes = {};
                var b2 = {};
                this.numAttributes = c2.length;
                for (var w2 = 0; w2 < this.numAttributes; w2++)
                  c2[w2] && (n2.bindAttribLocation(this.program, w2, c2[w2]), this.attributes[c2[w2]] = w2);
                n2.linkProgram(this.program), n2.deleteShader(x2), n2.deleteShader(y2);
                for (var T2 = 0; T2 < p2.length; T2++) {
                  var E2 = p2[T2];
                  if (E2 && !b2[E2]) {
                    var I2 = n2.getUniformLocation(this.program, E2);
                    I2 && (b2[E2] = I2);
                  }
                }
                this.fixedUniforms = r2(t2, b2), this.binderUniforms = o2 ? o2.getUniforms(t2, b2) : [];
              }
            }
          };
          function wi(t2, e2, i2) {
            var o2 = 1 / pe(i2, 1, e2.transform.tileZoom), r2 = Math.pow(2, i2.tileID.overscaledZ), a2 = i2.tileSize * Math.pow(2, e2.transform.tileZoom) / r2, n2 = a2 * (i2.tileID.canonical.x + i2.tileID.wrap * r2), s2 = a2 * i2.tileID.canonical.y;
            return { u_image: 0, u_texsize: i2.imageAtlasTexture.size, u_scale: [o2, t2.fromScale, t2.toScale], u_fade: t2.t, u_pixel_coord_upper: [n2 >> 16, s2 >> 16], u_pixel_coord_lower: [65535 & n2, 65535 & s2] };
          }
          bi.prototype.draw = function(t2, e2, i2, o2, r2, a2, n2, s2, l2, c2, u2, h2, p2, d2, _2, f2) {
            var m2, g2 = t2.gl;
            if (!this.failedToCreate) {
              for (var v2 in t2.program.set(this.program), t2.setDepthMode(i2), t2.setStencilMode(o2), t2.setColorMode(r2), t2.setCullFace(a2), this.fixedUniforms)
                this.fixedUniforms[v2].set(n2[v2]);
              d2 && d2.setUniforms(t2, this.binderUniforms, h2, { zoom: p2 });
              for (var y2 = (m2 = {}, m2[g2.LINES] = 2, m2[g2.TRIANGLES] = 3, m2[g2.LINE_STRIP] = 1, m2)[e2], x2 = 0, b2 = u2.get(); x2 < b2.length; x2 += 1) {
                var w2 = b2[x2], T2 = w2.vaos || (w2.vaos = {});
                (T2[s2] || (T2[s2] = new yi())).bind(t2, this, l2, d2 ? d2.getPaintVertexBuffers() : [], c2, w2.vertexOffset, _2, f2), g2.drawElements(e2, w2.primitiveLength * y2, g2.UNSIGNED_SHORT, w2.primitiveOffset * y2 * 2);
              }
            }
          };
          var Ti = function(e2, i2, o2, r2) {
            var a2 = i2.style.light, n2 = a2.properties.get("position"), s2 = [n2.x, n2.y, n2.z], l2 = t.create$1();
            "viewport" === a2.properties.get("anchor") && t.fromRotation(l2, -i2.transform.angle), t.transformMat3(s2, s2, l2);
            var c2 = a2.properties.get("color");
            return { u_matrix: e2, u_lightpos: s2, u_lightintensity: a2.properties.get("intensity"), u_lightcolor: [c2.r, c2.g, c2.b], u_vertical_gradient: +o2, u_opacity: r2 };
          }, Ei = function(e2, i2, o2, r2, a2, n2, s2) {
            return t.extend(Ti(e2, i2, o2, r2), wi(n2, i2, s2), { u_height_factor: -Math.pow(2, a2.overscaledZ) / s2.tileSize / 8 });
          }, Ii = function(t2) {
            return { u_matrix: t2 };
          }, Pi = function(e2, i2, o2, r2) {
            return t.extend(Ii(e2), wi(o2, i2, r2));
          }, Si = function(t2, e2) {
            return { u_matrix: t2, u_world: e2 };
          }, Ci = function(e2, i2, o2, r2, a2) {
            return t.extend(Pi(e2, i2, o2, r2), { u_world: a2 });
          }, zi = function(e2, i2, o2, r2) {
            var a2, n2, s2 = e2.transform;
            if ("map" === r2.paint.get("circle-pitch-alignment")) {
              var l2 = pe(o2, 1, s2.zoom);
              a2 = true, n2 = [l2, l2];
            } else
              a2 = false, n2 = s2.pixelsToGLUnits;
            return { u_camera_to_center_distance: s2.cameraToCenterDistance, u_scale_with_map: +("map" === r2.paint.get("circle-pitch-scale")), u_matrix: e2.translatePosMatrix(i2.posMatrix, o2, r2.paint.get("circle-translate"), r2.paint.get("circle-translate-anchor")), u_pitch_with_map: +a2, u_device_pixel_ratio: t.browser.devicePixelRatio, u_extrude_scale: n2 };
          }, Di = function(t2, e2, i2) {
            var o2 = pe(i2, 1, e2.zoom), r2 = Math.pow(2, e2.zoom - i2.tileID.overscaledZ), a2 = i2.tileID.overscaleFactor();
            return { u_matrix: t2, u_camera_to_center_distance: e2.cameraToCenterDistance, u_pixels_to_tile_units: o2, u_extrude_scale: [e2.pixelsToGLUnits[0] / (o2 * r2), e2.pixelsToGLUnits[1] / (o2 * r2)], u_overscale_factor: a2 };
          }, Ai = function(t2, e2, i2) {
            return { u_matrix: t2, u_inv_matrix: e2, u_camera_to_center_distance: i2.cameraToCenterDistance, u_viewport_size: [i2.width, i2.height] };
          }, Mi = function(t2, e2, i2) {
            return void 0 === i2 && (i2 = 1), { u_matrix: t2, u_color: e2, u_overlay: 0, u_overlay_scale: i2 };
          }, Li = function(t2) {
            return { u_matrix: t2 };
          }, Ri = function(t2, e2, i2, o2) {
            return { u_matrix: t2, u_extrude_scale: pe(e2, 1, i2), u_intensity: o2 };
          }, ki = function(e2, i2, o2) {
            var r2 = e2.transform;
            return { u_matrix: Ni(e2, i2, o2), u_ratio: 1 / pe(i2, 1, r2.zoom), u_device_pixel_ratio: t.browser.devicePixelRatio, u_units_to_pixels: [1 / r2.pixelsToGLUnits[0], 1 / r2.pixelsToGLUnits[1]] };
          }, Bi = function(e2, i2, o2, r2) {
            return t.extend(ki(e2, i2, o2), { u_image: 0, u_image_height: r2 });
          }, Oi = function(e2, i2, o2, r2) {
            var a2 = e2.transform, n2 = Ui(i2, a2);
            return { u_matrix: Ni(e2, i2, o2), u_texsize: i2.imageAtlasTexture.size, u_ratio: 1 / pe(i2, 1, a2.zoom), u_device_pixel_ratio: t.browser.devicePixelRatio, u_image: 0, u_scale: [n2, r2.fromScale, r2.toScale], u_fade: r2.t, u_units_to_pixels: [1 / a2.pixelsToGLUnits[0], 1 / a2.pixelsToGLUnits[1]] };
          }, Fi = function(e2, i2, o2, r2, a2) {
            var n2 = e2.lineAtlas, s2 = Ui(i2, e2.transform), l2 = "round" === o2.layout.get("line-cap"), c2 = n2.getDash(r2.from, l2), u2 = n2.getDash(r2.to, l2), h2 = c2.width * a2.fromScale, p2 = u2.width * a2.toScale;
            return t.extend(ki(e2, i2, o2), { u_patternscale_a: [s2 / h2, -c2.height / 2], u_patternscale_b: [s2 / p2, -u2.height / 2], u_sdfgamma: n2.width / (256 * Math.min(h2, p2) * t.browser.devicePixelRatio) / 2, u_image: 0, u_tex_y_a: c2.y, u_tex_y_b: u2.y, u_mix: a2.t });
          };
          function Ui(t2, e2) {
            return 1 / pe(t2, 1, e2.tileZoom);
          }
          function Ni(t2, e2, i2) {
            return t2.translatePosMatrix(e2.tileID.posMatrix, e2, i2.paint.get("line-translate"), i2.paint.get("line-translate-anchor"));
          }
          var Zi = function(t2, e2, i2, o2, r2) {
            return { u_matrix: t2, u_tl_parent: e2, u_scale_parent: i2, u_buffer_scale: 1, u_fade_t: o2.mix, u_opacity: o2.opacity * r2.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: r2.paint.get("raster-brightness-min"), u_brightness_high: r2.paint.get("raster-brightness-max"), u_saturation_factor: (n2 = r2.paint.get("raster-saturation"), n2 > 0 ? 1 - 1 / (1.001 - n2) : -n2), u_contrast_factor: (a2 = r2.paint.get("raster-contrast"), a2 > 0 ? 1 / (1 - a2) : 1 + a2), u_spin_weights: qi(r2.paint.get("raster-hue-rotate")) };
            var a2, n2;
          };
          function qi(t2) {
            t2 *= Math.PI / 180;
            var e2 = Math.sin(t2), i2 = Math.cos(t2);
            return [(2 * i2 + 1) / 3, (-Math.sqrt(3) * e2 - i2 + 1) / 3, (Math.sqrt(3) * e2 - i2 + 1) / 3];
          }
          var ji, Vi = function(t2, e2, i2, o2, r2, a2, n2, s2, l2, c2) {
            var u2 = r2.transform;
            return { u_is_size_zoom_constant: +("constant" === t2 || "source" === t2), u_is_size_feature_constant: +("constant" === t2 || "camera" === t2), u_size_t: e2 ? e2.uSizeT : 0, u_size: e2 ? e2.uSize : 0, u_camera_to_center_distance: u2.cameraToCenterDistance, u_pitch: u2.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i2, u_aspect_ratio: u2.width / u2.height, u_fade_change: r2.options.fadeDuration ? r2.symbolFadeChange : 1, u_matrix: a2, u_label_plane_matrix: n2, u_coord_matrix: s2, u_is_text: +l2, u_pitch_with_map: +o2, u_texsize: c2, u_texture: 0 };
          }, Gi = function(e2, i2, o2, r2, a2, n2, s2, l2, c2, u2, h2) {
            var p2 = a2.transform;
            return t.extend(Vi(e2, i2, o2, r2, a2, n2, s2, l2, c2, u2), { u_gamma_scale: r2 ? Math.cos(p2._pitch) * p2.cameraToCenterDistance : 1, u_device_pixel_ratio: t.browser.devicePixelRatio, u_is_halo: +h2 });
          }, Wi = function(e2, i2, o2, r2, a2, n2, s2, l2, c2, u2) {
            return t.extend(Gi(e2, i2, o2, r2, a2, n2, s2, l2, true, c2, true), { u_texsize_icon: u2, u_texture_icon: 1 });
          }, Xi = function(t2, e2, i2) {
            return { u_matrix: t2, u_opacity: e2, u_color: i2 };
          }, Hi = function(e2, i2, o2, r2, a2, n2) {
            return t.extend(function(t2, e3, i3, o3) {
              var r3 = i3.imageManager.getPattern(t2.from.toString()), a3 = i3.imageManager.getPattern(t2.to.toString()), n3 = i3.imageManager.getPixelSize(), s2 = n3.width, l2 = n3.height, c2 = Math.pow(2, o3.tileID.overscaledZ), u2 = o3.tileSize * Math.pow(2, i3.transform.tileZoom) / c2, h2 = u2 * (o3.tileID.canonical.x + o3.tileID.wrap * c2), p2 = u2 * o3.tileID.canonical.y;
              return { u_image: 0, u_pattern_tl_a: r3.tl, u_pattern_br_a: r3.br, u_pattern_tl_b: a3.tl, u_pattern_br_b: a3.br, u_texsize: [s2, l2], u_mix: e3.t, u_pattern_size_a: r3.displaySize, u_pattern_size_b: a3.displaySize, u_scale_a: e3.fromScale, u_scale_b: e3.toScale, u_tile_units_to_pixels: 1 / pe(o3, 1, i3.transform.tileZoom), u_pixel_coord_upper: [h2 >> 16, p2 >> 16], u_pixel_coord_lower: [65535 & h2, 65535 & p2] };
            }(r2, n2, o2, a2), { u_matrix: e2, u_opacity: i2 });
          }, Ki = { fillExtrusion: function(e2, i2) {
            return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_lightpos: new t.Uniform3f(e2, i2.u_lightpos), u_lightintensity: new t.Uniform1f(e2, i2.u_lightintensity), u_lightcolor: new t.Uniform3f(e2, i2.u_lightcolor), u_vertical_gradient: new t.Uniform1f(e2, i2.u_vertical_gradient), u_opacity: new t.Uniform1f(e2, i2.u_opacity) };
          }, fillExtrusionPattern: function(e2, i2) {
            return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_lightpos: new t.Uniform3f(e2, i2.u_lightpos), u_lightintensity: new t.Uniform1f(e2, i2.u_lightintensity), u_lightcolor: new t.Uniform3f(e2, i2.u_lightcolor), u_vertical_gradient: new t.Uniform1f(e2, i2.u_vertical_gradient), u_height_factor: new t.Uniform1f(e2, i2.u_height_factor), u_image: new t.Uniform1i(e2, i2.u_image), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i2.u_pixel_coord_lower), u_scale: new t.Uniform3f(e2, i2.u_scale), u_fade: new t.Uniform1f(e2, i2.u_fade), u_opacity: new t.Uniform1f(e2, i2.u_opacity) };
          }, fill: function(e2, i2) {
            return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) };
          }, fillPattern: function(e2, i2) {
            return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_image: new t.Uniform1i(e2, i2.u_image), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i2.u_pixel_coord_lower), u_scale: new t.Uniform3f(e2, i2.u_scale), u_fade: new t.Uniform1f(e2, i2.u_fade) };
          }, fillOutline: function(e2, i2) {
            return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_world: new t.Uniform2f(e2, i2.u_world) };
          }, fillOutlinePattern: function(e2, i2) {
            return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_world: new t.Uniform2f(e2, i2.u_world), u_image: new t.Uniform1i(e2, i2.u_image), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_pixel_coord_upper: new t.Uniform2f(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i2.u_pixel_coord_lower), u_scale: new t.Uniform3f(e2, i2.u_scale), u_fade: new t.Uniform1f(e2, i2.u_fade) };
          }, circle: function(e2, i2) {
            return { u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_scale_with_map: new t.Uniform1i(e2, i2.u_scale_with_map), u_pitch_with_map: new t.Uniform1i(e2, i2.u_pitch_with_map), u_extrude_scale: new t.Uniform2f(e2, i2.u_extrude_scale), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) };
          }, collisionBox: function(e2, i2) {
            return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_pixels_to_tile_units: new t.Uniform1f(e2, i2.u_pixels_to_tile_units), u_extrude_scale: new t.Uniform2f(e2, i2.u_extrude_scale), u_overscale_factor: new t.Uniform1f(e2, i2.u_overscale_factor) };
          }, collisionCircle: function(e2, i2) {
            return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_inv_matrix: new t.UniformMatrix4f(e2, i2.u_inv_matrix), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_viewport_size: new t.Uniform2f(e2, i2.u_viewport_size) };
          }, debug: function(e2, i2) {
            return { u_color: new t.UniformColor(e2, i2.u_color), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_overlay: new t.Uniform1i(e2, i2.u_overlay), u_overlay_scale: new t.Uniform1f(e2, i2.u_overlay_scale) };
          }, clippingMask: function(e2, i2) {
            return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) };
          }, heatmap: function(e2, i2) {
            return { u_extrude_scale: new t.Uniform1f(e2, i2.u_extrude_scale), u_intensity: new t.Uniform1f(e2, i2.u_intensity), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix) };
          }, heatmapTexture: function(e2, i2) {
            return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_world: new t.Uniform2f(e2, i2.u_world), u_image: new t.Uniform1i(e2, i2.u_image), u_color_ramp: new t.Uniform1i(e2, i2.u_color_ramp), u_opacity: new t.Uniform1f(e2, i2.u_opacity) };
          }, hillshade: function(e2, i2) {
            return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_image: new t.Uniform1i(e2, i2.u_image), u_latrange: new t.Uniform2f(e2, i2.u_latrange), u_light: new t.Uniform2f(e2, i2.u_light), u_shadow: new t.UniformColor(e2, i2.u_shadow), u_highlight: new t.UniformColor(e2, i2.u_highlight), u_accent: new t.UniformColor(e2, i2.u_accent) };
          }, hillshadePrepare: function(e2, i2) {
            return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_image: new t.Uniform1i(e2, i2.u_image), u_dimension: new t.Uniform2f(e2, i2.u_dimension), u_zoom: new t.Uniform1f(e2, i2.u_zoom), u_unpack: new t.Uniform4f(e2, i2.u_unpack) };
          }, line: function(e2, i2) {
            return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_ratio: new t.Uniform1f(e2, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e2, i2.u_units_to_pixels) };
          }, lineGradient: function(e2, i2) {
            return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_ratio: new t.Uniform1f(e2, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e2, i2.u_units_to_pixels), u_image: new t.Uniform1i(e2, i2.u_image), u_image_height: new t.Uniform1f(e2, i2.u_image_height) };
          }, linePattern: function(e2, i2) {
            return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_ratio: new t.Uniform1f(e2, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_image: new t.Uniform1i(e2, i2.u_image), u_units_to_pixels: new t.Uniform2f(e2, i2.u_units_to_pixels), u_scale: new t.Uniform3f(e2, i2.u_scale), u_fade: new t.Uniform1f(e2, i2.u_fade) };
          }, lineSDF: function(e2, i2) {
            return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_ratio: new t.Uniform1f(e2, i2.u_ratio), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_units_to_pixels: new t.Uniform2f(e2, i2.u_units_to_pixels), u_patternscale_a: new t.Uniform2f(e2, i2.u_patternscale_a), u_patternscale_b: new t.Uniform2f(e2, i2.u_patternscale_b), u_sdfgamma: new t.Uniform1f(e2, i2.u_sdfgamma), u_image: new t.Uniform1i(e2, i2.u_image), u_tex_y_a: new t.Uniform1f(e2, i2.u_tex_y_a), u_tex_y_b: new t.Uniform1f(e2, i2.u_tex_y_b), u_mix: new t.Uniform1f(e2, i2.u_mix) };
          }, raster: function(e2, i2) {
            return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_tl_parent: new t.Uniform2f(e2, i2.u_tl_parent), u_scale_parent: new t.Uniform1f(e2, i2.u_scale_parent), u_buffer_scale: new t.Uniform1f(e2, i2.u_buffer_scale), u_fade_t: new t.Uniform1f(e2, i2.u_fade_t), u_opacity: new t.Uniform1f(e2, i2.u_opacity), u_image0: new t.Uniform1i(e2, i2.u_image0), u_image1: new t.Uniform1i(e2, i2.u_image1), u_brightness_low: new t.Uniform1f(e2, i2.u_brightness_low), u_brightness_high: new t.Uniform1f(e2, i2.u_brightness_high), u_saturation_factor: new t.Uniform1f(e2, i2.u_saturation_factor), u_contrast_factor: new t.Uniform1f(e2, i2.u_contrast_factor), u_spin_weights: new t.Uniform3f(e2, i2.u_spin_weights) };
          }, symbolIcon: function(e2, i2) {
            return { u_is_size_zoom_constant: new t.Uniform1i(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e2, i2.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e2, i2.u_size_t), u_size: new t.Uniform1f(e2, i2.u_size), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e2, i2.u_pitch), u_rotate_symbol: new t.Uniform1i(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e2, i2.u_aspect_ratio), u_fade_change: new t.Uniform1f(e2, i2.u_fade_change), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e2, i2.u_coord_matrix), u_is_text: new t.Uniform1i(e2, i2.u_is_text), u_pitch_with_map: new t.Uniform1i(e2, i2.u_pitch_with_map), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_texture: new t.Uniform1i(e2, i2.u_texture) };
          }, symbolSDF: function(e2, i2) {
            return { u_is_size_zoom_constant: new t.Uniform1i(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e2, i2.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e2, i2.u_size_t), u_size: new t.Uniform1f(e2, i2.u_size), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e2, i2.u_pitch), u_rotate_symbol: new t.Uniform1i(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e2, i2.u_aspect_ratio), u_fade_change: new t.Uniform1f(e2, i2.u_fade_change), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e2, i2.u_coord_matrix), u_is_text: new t.Uniform1i(e2, i2.u_is_text), u_pitch_with_map: new t.Uniform1i(e2, i2.u_pitch_with_map), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_texture: new t.Uniform1i(e2, i2.u_texture), u_gamma_scale: new t.Uniform1f(e2, i2.u_gamma_scale), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_is_halo: new t.Uniform1i(e2, i2.u_is_halo) };
          }, symbolTextAndIcon: function(e2, i2) {
            return { u_is_size_zoom_constant: new t.Uniform1i(e2, i2.u_is_size_zoom_constant), u_is_size_feature_constant: new t.Uniform1i(e2, i2.u_is_size_feature_constant), u_size_t: new t.Uniform1f(e2, i2.u_size_t), u_size: new t.Uniform1f(e2, i2.u_size), u_camera_to_center_distance: new t.Uniform1f(e2, i2.u_camera_to_center_distance), u_pitch: new t.Uniform1f(e2, i2.u_pitch), u_rotate_symbol: new t.Uniform1i(e2, i2.u_rotate_symbol), u_aspect_ratio: new t.Uniform1f(e2, i2.u_aspect_ratio), u_fade_change: new t.Uniform1f(e2, i2.u_fade_change), u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_label_plane_matrix: new t.UniformMatrix4f(e2, i2.u_label_plane_matrix), u_coord_matrix: new t.UniformMatrix4f(e2, i2.u_coord_matrix), u_is_text: new t.Uniform1i(e2, i2.u_is_text), u_pitch_with_map: new t.Uniform1i(e2, i2.u_pitch_with_map), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_texsize_icon: new t.Uniform2f(e2, i2.u_texsize_icon), u_texture: new t.Uniform1i(e2, i2.u_texture), u_texture_icon: new t.Uniform1i(e2, i2.u_texture_icon), u_gamma_scale: new t.Uniform1f(e2, i2.u_gamma_scale), u_device_pixel_ratio: new t.Uniform1f(e2, i2.u_device_pixel_ratio), u_is_halo: new t.Uniform1i(e2, i2.u_is_halo) };
          }, background: function(e2, i2) {
            return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_opacity: new t.Uniform1f(e2, i2.u_opacity), u_color: new t.UniformColor(e2, i2.u_color) };
          }, backgroundPattern: function(e2, i2) {
            return { u_matrix: new t.UniformMatrix4f(e2, i2.u_matrix), u_opacity: new t.Uniform1f(e2, i2.u_opacity), u_image: new t.Uniform1i(e2, i2.u_image), u_pattern_tl_a: new t.Uniform2f(e2, i2.u_pattern_tl_a), u_pattern_br_a: new t.Uniform2f(e2, i2.u_pattern_br_a), u_pattern_tl_b: new t.Uniform2f(e2, i2.u_pattern_tl_b), u_pattern_br_b: new t.Uniform2f(e2, i2.u_pattern_br_b), u_texsize: new t.Uniform2f(e2, i2.u_texsize), u_mix: new t.Uniform1f(e2, i2.u_mix), u_pattern_size_a: new t.Uniform2f(e2, i2.u_pattern_size_a), u_pattern_size_b: new t.Uniform2f(e2, i2.u_pattern_size_b), u_scale_a: new t.Uniform1f(e2, i2.u_scale_a), u_scale_b: new t.Uniform1f(e2, i2.u_scale_b), u_pixel_coord_upper: new t.Uniform2f(e2, i2.u_pixel_coord_upper), u_pixel_coord_lower: new t.Uniform2f(e2, i2.u_pixel_coord_lower), u_tile_units_to_pixels: new t.Uniform1f(e2, i2.u_tile_units_to_pixels) };
          } };
          function Yi(e2, i2, o2, r2, a2, n2, s2) {
            for (var l2 = e2.context, c2 = l2.gl, u2 = e2.useProgram("collisionBox"), h2 = [], p2 = 0, d2 = 0, _2 = 0; _2 < r2.length; _2++) {
              var f2 = r2[_2], m2 = i2.getTile(f2), g2 = m2.getBucket(o2);
              if (g2) {
                var v2 = f2.posMatrix;
                0 === a2[0] && 0 === a2[1] || (v2 = e2.translatePosMatrix(f2.posMatrix, m2, a2, n2));
                var y2 = s2 ? g2.textCollisionBox : g2.iconCollisionBox, x2 = g2.collisionCircleArray;
                if (x2.length > 0) {
                  var b2 = t.create(), w2 = v2;
                  t.mul(b2, g2.placementInvProjMatrix, e2.transform.glCoordMatrix), t.mul(b2, b2, g2.placementViewportMatrix), h2.push({ circleArray: x2, circleOffset: d2, transform: w2, invTransform: b2 }), d2 = p2 += x2.length / 4;
                }
                y2 && u2.draw(l2, c2.LINES, It.disabled, Pt.disabled, e2.colorModeForRenderPass(), Ct.disabled, Di(v2, e2.transform, m2), o2.id, y2.layoutVertexBuffer, y2.indexBuffer, y2.segments, null, e2.transform.zoom, null, null, y2.collisionVertexBuffer);
              }
            }
            if (s2 && h2.length) {
              var T2 = e2.useProgram("collisionCircle"), E2 = new t.StructArrayLayout2f1f2i16();
              E2.resize(4 * p2), E2._trim();
              for (var I2 = 0, P2 = 0, S2 = h2; P2 < S2.length; P2 += 1)
                for (var C2 = S2[P2], z2 = 0; z2 < C2.circleArray.length / 4; z2++) {
                  var D2 = 4 * z2, A2 = C2.circleArray[D2 + 0], M2 = C2.circleArray[D2 + 1], L2 = C2.circleArray[D2 + 2], R2 = C2.circleArray[D2 + 3];
                  E2.emplace(I2++, A2, M2, L2, R2, 0), E2.emplace(I2++, A2, M2, L2, R2, 1), E2.emplace(I2++, A2, M2, L2, R2, 2), E2.emplace(I2++, A2, M2, L2, R2, 3);
                }
              (!ji || ji.length < 2 * p2) && (ji = function(e3) {
                var i3 = 2 * e3, o3 = new t.StructArrayLayout3ui6();
                o3.resize(i3), o3._trim();
                for (var r3 = 0; r3 < i3; r3++) {
                  var a3 = 6 * r3;
                  o3.uint16[a3 + 0] = 4 * r3 + 0, o3.uint16[a3 + 1] = 4 * r3 + 1, o3.uint16[a3 + 2] = 4 * r3 + 2, o3.uint16[a3 + 3] = 4 * r3 + 2, o3.uint16[a3 + 4] = 4 * r3 + 3, o3.uint16[a3 + 5] = 4 * r3 + 0;
                }
                return o3;
              }(p2));
              for (var k2 = l2.createIndexBuffer(ji, true), B2 = l2.createVertexBuffer(E2, t.collisionCircleLayout.members, true), O2 = 0, F2 = h2; O2 < F2.length; O2 += 1) {
                var U2 = F2[O2], N2 = Ai(U2.transform, U2.invTransform, e2.transform);
                T2.draw(l2, c2.TRIANGLES, It.disabled, Pt.disabled, e2.colorModeForRenderPass(), Ct.disabled, N2, o2.id, B2, k2, t.SegmentVector.simpleSegment(0, 2 * U2.circleOffset, U2.circleArray.length, U2.circleArray.length / 2), null, e2.transform.zoom, null, null, null);
              }
              B2.destroy(), k2.destroy();
            }
          }
          var Ji = t.identity(new Float32Array(16));
          function Qi(e2, i2, o2, r2, a2, n2) {
            var s2 = t.getAnchorAlignment(e2), l2 = -(s2.horizontalAlign - 0.5) * i2, c2 = -(s2.verticalAlign - 0.5) * o2, u2 = t.evaluateVariableOffset(e2, r2);
            return new t.Point((l2 / a2 + u2[0]) * n2, (c2 / a2 + u2[1]) * n2);
          }
          function $i(e2, i2, o2, r2, a2, n2, s2, l2, c2, u2, h2) {
            var p2 = e2.text.placedSymbolArray, d2 = e2.text.dynamicLayoutVertexArray, _2 = e2.icon.dynamicLayoutVertexArray, f2 = {};
            d2.clear();
            for (var m2 = 0; m2 < p2.length; m2++) {
              var g2 = p2.get(m2), v2 = g2.hidden || !g2.crossTileID || e2.allowVerticalPlacement && !g2.placedOrientation ? null : r2[g2.crossTileID];
              if (v2) {
                var y2 = new t.Point(g2.anchorX, g2.anchorY), x2 = $t(y2, o2 ? l2 : s2), b2 = te(n2.cameraToCenterDistance, x2.signedDistanceFromCamera), w2 = a2.evaluateSizeForFeature(e2.textSizeData, u2, g2) * b2 / t.ONE_EM;
                o2 && (w2 *= e2.tilePixelRatio / c2);
                for (var T2 = Qi(v2.anchor, v2.width, v2.height, v2.textOffset, v2.textBoxScale, w2), E2 = o2 ? $t(y2.add(T2), s2).point : x2.point.add(i2 ? T2.rotate(-n2.angle) : T2), I2 = e2.allowVerticalPlacement && g2.placedOrientation === t.WritingMode.vertical ? Math.PI / 2 : 0, P2 = 0; P2 < g2.numGlyphs; P2++)
                  t.addDynamicAttributes(d2, E2, I2);
                h2 && g2.associatedIconIndex >= 0 && (f2[g2.associatedIconIndex] = { shiftedAnchor: E2, angle: I2 });
              } else
                ce(g2.numGlyphs, d2);
            }
            if (h2) {
              _2.clear();
              for (var S2 = e2.icon.placedSymbolArray, C2 = 0; C2 < S2.length; C2++) {
                var z2 = S2.get(C2);
                if (z2.hidden)
                  ce(z2.numGlyphs, _2);
                else {
                  var D2 = f2[C2];
                  if (D2)
                    for (var A2 = 0; A2 < z2.numGlyphs; A2++)
                      t.addDynamicAttributes(_2, D2.shiftedAnchor, D2.angle);
                  else
                    ce(z2.numGlyphs, _2);
                }
              }
              e2.icon.dynamicLayoutVertexBuffer.updateData(_2);
            }
            e2.text.dynamicLayoutVertexBuffer.updateData(d2);
          }
          function to(t2, e2, i2) {
            return i2.iconsInText && e2 ? "symbolTextAndIcon" : t2 ? "symbolSDF" : "symbolIcon";
          }
          function eo(e2, i2, o2, r2, a2, n2, s2, l2, c2, u2, h2, p2) {
            for (var d2 = e2.context, _2 = d2.gl, f2 = e2.transform, m2 = "map" === l2, g2 = "map" === c2, v2 = m2 && "point" !== o2.layout.get("symbol-placement"), y2 = m2 && !g2 && !v2, x2 = void 0 !== o2.layout.get("symbol-sort-key").constantOr(1), b2 = false, w2 = e2.depthModeForSublayer(0, It.ReadOnly), T2 = o2.layout.get("text-variable-anchor"), E2 = [], I2 = 0, P2 = r2; I2 < P2.length; I2 += 1) {
              var S2 = P2[I2], C2 = i2.getTile(S2), z2 = C2.getBucket(o2);
              if (z2) {
                var D2 = a2 ? z2.text : z2.icon;
                if (D2 && D2.segments.get().length) {
                  var A2 = D2.programConfigurations.get(o2.id), M2 = a2 || z2.sdfIcons, L2 = a2 ? z2.textSizeData : z2.iconSizeData, R2 = g2 || 0 !== f2.pitch, k2 = e2.useProgram(to(M2, a2, z2), A2), B2 = t.evaluateSizeForZoom(L2, f2.zoom), O2 = void 0, F2 = [0, 0], U2 = void 0, N2 = void 0, Z2 = null, q2 = void 0;
                  if (a2)
                    U2 = C2.glyphAtlasTexture, N2 = _2.LINEAR, O2 = C2.glyphAtlasTexture.size, z2.iconsInText && (F2 = C2.imageAtlasTexture.size, Z2 = C2.imageAtlasTexture, q2 = R2 || e2.options.rotating || e2.options.zooming || "composite" === L2.kind || "camera" === L2.kind ? _2.LINEAR : _2.NEAREST);
                  else {
                    var j2 = 1 !== o2.layout.get("icon-size").constantOr(0) || z2.iconsNeedLinear;
                    U2 = C2.imageAtlasTexture, N2 = M2 || e2.options.rotating || e2.options.zooming || j2 || R2 ? _2.LINEAR : _2.NEAREST, O2 = C2.imageAtlasTexture.size;
                  }
                  var V2 = pe(C2, 1, e2.transform.zoom), G2 = Jt(S2.posMatrix, g2, m2, e2.transform, V2), W2 = Qt(S2.posMatrix, g2, m2, e2.transform, V2), X2 = T2 && z2.hasTextData(), H2 = "none" !== o2.layout.get("icon-text-fit") && X2 && z2.hasIconData();
                  v2 && ie(z2, S2.posMatrix, e2, a2, G2, W2, g2, u2);
                  var K2 = e2.translatePosMatrix(S2.posMatrix, C2, n2, s2), Y2 = v2 || a2 && T2 || H2 ? Ji : G2, J2 = e2.translatePosMatrix(W2, C2, n2, s2, true), Q2 = M2 && 0 !== o2.paint.get(a2 ? "text-halo-width" : "icon-halo-width").constantOr(1), $2 = { program: k2, buffers: D2, uniformValues: M2 ? z2.iconsInText ? Wi(L2.kind, B2, y2, g2, e2, K2, Y2, J2, O2, F2) : Gi(L2.kind, B2, y2, g2, e2, K2, Y2, J2, a2, O2, true) : Vi(L2.kind, B2, y2, g2, e2, K2, Y2, J2, a2, O2), atlasTexture: U2, atlasTextureIcon: Z2, atlasInterpolation: N2, atlasInterpolationIcon: q2, isSDF: M2, hasHalo: Q2 };
                  if (x2 && z2.canOverlap) {
                    b2 = true;
                    for (var tt3 = 0, et2 = D2.segments.get(); tt3 < et2.length; tt3 += 1) {
                      var it2 = et2[tt3];
                      E2.push({ segments: new t.SegmentVector([it2]), sortKey: it2.sortKey, state: $2 });
                    }
                  } else
                    E2.push({ segments: D2.segments, sortKey: 0, state: $2 });
                }
              }
            }
            b2 && E2.sort(function(t2, e3) {
              return t2.sortKey - e3.sortKey;
            });
            for (var ot2 = 0, rt2 = E2; ot2 < rt2.length; ot2 += 1) {
              var at2 = rt2[ot2], nt2 = at2.state;
              if (d2.activeTexture.set(_2.TEXTURE0), nt2.atlasTexture.bind(nt2.atlasInterpolation, _2.CLAMP_TO_EDGE), nt2.atlasTextureIcon && (d2.activeTexture.set(_2.TEXTURE1), nt2.atlasTextureIcon && nt2.atlasTextureIcon.bind(nt2.atlasInterpolationIcon, _2.CLAMP_TO_EDGE)), nt2.isSDF) {
                var st2 = nt2.uniformValues;
                nt2.hasHalo && (st2.u_is_halo = 1, io(nt2.buffers, at2.segments, o2, e2, nt2.program, w2, h2, p2, st2)), st2.u_is_halo = 0;
              }
              io(nt2.buffers, at2.segments, o2, e2, nt2.program, w2, h2, p2, nt2.uniformValues);
            }
          }
          function io(t2, e2, i2, o2, r2, a2, n2, s2, l2) {
            var c2 = o2.context;
            r2.draw(c2, c2.gl.TRIANGLES, a2, n2, s2, Ct.disabled, l2, i2.id, t2.layoutVertexBuffer, t2.indexBuffer, e2, i2.paint, o2.transform.zoom, t2.programConfigurations.get(i2.id), t2.dynamicLayoutVertexBuffer, t2.opacityVertexBuffer);
          }
          function oo(t2, e2, i2, o2, r2, a2, n2) {
            var s2, l2, c2, u2, h2, p2 = t2.context.gl, d2 = i2.paint.get("fill-pattern"), _2 = d2 && d2.constantOr(1), f2 = i2.getCrossfadeParameters();
            n2 ? (l2 = _2 && !i2.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", s2 = p2.LINES) : (l2 = _2 ? "fillPattern" : "fill", s2 = p2.TRIANGLES);
            for (var m2 = 0, g2 = o2; m2 < g2.length; m2 += 1) {
              var v2 = g2[m2], y2 = e2.getTile(v2);
              if (!_2 || y2.patternsLoaded()) {
                var x2 = y2.getBucket(i2);
                if (x2) {
                  var b2 = x2.programConfigurations.get(i2.id), w2 = t2.useProgram(l2, b2);
                  _2 && (t2.context.activeTexture.set(p2.TEXTURE0), y2.imageAtlasTexture.bind(p2.LINEAR, p2.CLAMP_TO_EDGE), b2.updatePaintBuffers(f2));
                  var T2 = d2.constantOr(null);
                  if (T2 && y2.imageAtlas) {
                    var E2 = y2.imageAtlas, I2 = E2.patternPositions[T2.to.toString()], P2 = E2.patternPositions[T2.from.toString()];
                    I2 && P2 && b2.setConstantPatternPositions(I2, P2);
                  }
                  var S2 = t2.translatePosMatrix(v2.posMatrix, y2, i2.paint.get("fill-translate"), i2.paint.get("fill-translate-anchor"));
                  if (n2) {
                    u2 = x2.indexBuffer2, h2 = x2.segments2;
                    var C2 = [p2.drawingBufferWidth, p2.drawingBufferHeight];
                    c2 = "fillOutlinePattern" === l2 && _2 ? Ci(S2, t2, f2, y2, C2) : Si(S2, C2);
                  } else
                    u2 = x2.indexBuffer, h2 = x2.segments, c2 = _2 ? Pi(S2, t2, f2, y2) : Ii(S2);
                  w2.draw(t2.context, s2, r2, t2.stencilModeForClipping(v2), a2, Ct.disabled, c2, i2.id, x2.layoutVertexBuffer, u2, h2, i2.paint, t2.transform.zoom, b2);
                }
              }
            }
          }
          function ro(t2, e2, i2, o2, r2, a2, n2) {
            for (var s2 = t2.context, l2 = s2.gl, c2 = i2.paint.get("fill-extrusion-pattern"), u2 = c2.constantOr(1), h2 = i2.getCrossfadeParameters(), p2 = i2.paint.get("fill-extrusion-opacity"), d2 = 0, _2 = o2; d2 < _2.length; d2 += 1) {
              var f2 = _2[d2], m2 = e2.getTile(f2), g2 = m2.getBucket(i2);
              if (g2) {
                var v2 = g2.programConfigurations.get(i2.id), y2 = t2.useProgram(u2 ? "fillExtrusionPattern" : "fillExtrusion", v2);
                u2 && (t2.context.activeTexture.set(l2.TEXTURE0), m2.imageAtlasTexture.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), v2.updatePaintBuffers(h2));
                var x2 = c2.constantOr(null);
                if (x2 && m2.imageAtlas) {
                  var b2 = m2.imageAtlas, w2 = b2.patternPositions[x2.to.toString()], T2 = b2.patternPositions[x2.from.toString()];
                  w2 && T2 && v2.setConstantPatternPositions(w2, T2);
                }
                var E2 = t2.translatePosMatrix(f2.posMatrix, m2, i2.paint.get("fill-extrusion-translate"), i2.paint.get("fill-extrusion-translate-anchor")), I2 = i2.paint.get("fill-extrusion-vertical-gradient"), P2 = u2 ? Ei(E2, t2, I2, p2, f2, h2, m2) : Ti(E2, t2, I2, p2);
                y2.draw(s2, s2.gl.TRIANGLES, r2, a2, n2, Ct.backCCW, P2, i2.id, g2.layoutVertexBuffer, g2.indexBuffer, g2.segments, i2.paint, t2.transform.zoom, v2);
              }
            }
          }
          function ao(e2, i2, o2, r2, a2, n2) {
            var s2 = e2.context, l2 = s2.gl, c2 = i2.fbo;
            if (c2) {
              var u2 = e2.useProgram("hillshade");
              s2.activeTexture.set(l2.TEXTURE0), l2.bindTexture(l2.TEXTURE_2D, c2.colorAttachment.get());
              var h2 = function(e3, i3, o3) {
                var r3 = o3.paint.get("hillshade-shadow-color"), a3 = o3.paint.get("hillshade-highlight-color"), n3 = o3.paint.get("hillshade-accent-color"), s3 = o3.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
                "viewport" === o3.paint.get("hillshade-illumination-anchor") && (s3 -= e3.transform.angle);
                var l3, c3, u3, h3 = !e3.options.moving;
                return { u_matrix: e3.transform.calculatePosMatrix(i3.tileID.toUnwrapped(), h3), u_image: 0, u_latrange: (l3 = i3.tileID, c3 = Math.pow(2, l3.canonical.z), u3 = l3.canonical.y, [new t.MercatorCoordinate(0, u3 / c3).toLngLat().lat, new t.MercatorCoordinate(0, (u3 + 1) / c3).toLngLat().lat]), u_light: [o3.paint.get("hillshade-exaggeration"), s3], u_shadow: r3, u_highlight: a3, u_accent: n3 };
              }(e2, i2, o2);
              u2.draw(s2, l2.TRIANGLES, r2, a2, n2, Ct.disabled, h2, o2.id, e2.rasterBoundsBuffer, e2.quadTriangleIndexBuffer, e2.rasterBoundsSegments);
            }
          }
          function no(e2, i2, o2, r2, a2, n2) {
            var s2 = e2.context, l2 = s2.gl, c2 = i2.dem;
            if (c2 && c2.data) {
              var u2 = c2.dim, h2 = c2.stride, p2 = c2.getPixels();
              if (s2.activeTexture.set(l2.TEXTURE1), s2.pixelStoreUnpackPremultiplyAlpha.set(false), i2.demTexture = i2.demTexture || e2.getTileTexture(h2), i2.demTexture) {
                var d2 = i2.demTexture;
                d2.update(p2, { premultiply: false }), d2.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
              } else
                i2.demTexture = new t.Texture(s2, p2, l2.RGBA, { premultiply: false }), i2.demTexture.bind(l2.NEAREST, l2.CLAMP_TO_EDGE);
              s2.activeTexture.set(l2.TEXTURE0);
              var _2 = i2.fbo;
              if (!_2) {
                var f2 = new t.Texture(s2, { width: u2, height: u2, data: null }, l2.RGBA);
                f2.bind(l2.LINEAR, l2.CLAMP_TO_EDGE), (_2 = i2.fbo = s2.createFramebuffer(u2, u2, true)).colorAttachment.set(f2.texture);
              }
              s2.bindFramebuffer.set(_2.framebuffer), s2.viewport.set([0, 0, u2, u2]), e2.useProgram("hillshadePrepare").draw(s2, l2.TRIANGLES, r2, a2, n2, Ct.disabled, function(e3, i3) {
                var o3 = i3.stride, r3 = t.create();
                return t.ortho(r3, 0, t.EXTENT, -t.EXTENT, 0, 0, 1), t.translate(r3, r3, [0, -t.EXTENT, 0]), { u_matrix: r3, u_image: 1, u_dimension: [o3, o3], u_zoom: e3.overscaledZ, u_unpack: i3.getUnpackVector() };
              }(i2.tileID, c2), o2.id, e2.rasterBoundsBuffer, e2.quadTriangleIndexBuffer, e2.rasterBoundsSegments), i2.needsHillshadePrepare = false;
            }
          }
          function so(e2, i2, o2, r2, a2) {
            var n2 = r2.paint.get("raster-fade-duration");
            if (n2 > 0) {
              var s2 = t.browser.now(), l2 = (s2 - e2.timeAdded) / n2, c2 = i2 ? (s2 - i2.timeAdded) / n2 : -1, u2 = o2.getSource(), h2 = a2.coveringZoomLevel({ tileSize: u2.tileSize, roundZoom: u2.roundZoom }), p2 = !i2 || Math.abs(i2.tileID.overscaledZ - h2) > Math.abs(e2.tileID.overscaledZ - h2), d2 = p2 && e2.refreshedUponExpiration ? 1 : t.clamp(p2 ? l2 : 1 - c2, 0, 1);
              return e2.refreshedUponExpiration && l2 >= 1 && (e2.refreshedUponExpiration = false), i2 ? { opacity: 1, mix: 1 - d2 } : { opacity: d2, mix: 0 };
            }
            return { opacity: 1, mix: 0 };
          }
          var lo = new t.Color(1, 0, 0, 1), co = new t.Color(0, 1, 0, 1), uo = new t.Color(0, 0, 1, 1), ho = new t.Color(1, 0, 1, 1), po = new t.Color(0, 1, 1, 1);
          function _o(t2, e2, i2, o2) {
            mo(t2, 0, e2 + i2 / 2, t2.transform.width, i2, o2);
          }
          function fo(t2, e2, i2, o2) {
            mo(t2, e2 - i2 / 2, 0, i2, t2.transform.height, o2);
          }
          function mo(e2, i2, o2, r2, a2, n2) {
            var s2 = e2.context, l2 = s2.gl;
            l2.enable(l2.SCISSOR_TEST), l2.scissor(i2 * t.browser.devicePixelRatio, o2 * t.browser.devicePixelRatio, r2 * t.browser.devicePixelRatio, a2 * t.browser.devicePixelRatio), s2.clear({ color: n2 }), l2.disable(l2.SCISSOR_TEST);
          }
          function go2(e2, i2, o2) {
            var r2 = e2.context, a2 = r2.gl, n2 = o2.posMatrix, s2 = e2.useProgram("debug"), l2 = It.disabled, c2 = Pt.disabled, u2 = e2.colorModeForRenderPass();
            r2.activeTexture.set(a2.TEXTURE0), e2.emptyTexture.bind(a2.LINEAR, a2.CLAMP_TO_EDGE), s2.draw(r2, a2.LINE_STRIP, l2, c2, u2, Ct.disabled, Mi(n2, t.Color.red), "$debug", e2.debugBuffer, e2.tileBorderIndexBuffer, e2.debugSegments);
            var h2 = i2.getTileByID(o2.key).latestRawTileData, p2 = Math.floor((h2 && h2.byteLength || 0) / 1024), d2 = i2.getTile(o2).tileSize, _2 = 512 / Math.min(d2, 512) * (o2.overscaledZ / e2.transform.zoom) * 0.5, f2 = o2.canonical.toString();
            o2.overscaledZ !== o2.canonical.z && (f2 += " => " + o2.overscaledZ), function(t2, e3) {
              t2.initDebugOverlayCanvas();
              var i3 = t2.debugOverlayCanvas, o3 = t2.context.gl, r3 = t2.debugOverlayCanvas.getContext("2d");
              r3.clearRect(0, 0, i3.width, i3.height), r3.shadowColor = "white", r3.shadowBlur = 2, r3.lineWidth = 1.5, r3.strokeStyle = "white", r3.textBaseline = "top", r3.font = "bold 36px Open Sans, sans-serif", r3.fillText(e3, 5, 5), r3.strokeText(e3, 5, 5), t2.debugOverlayTexture.update(i3), t2.debugOverlayTexture.bind(o3.LINEAR, o3.CLAMP_TO_EDGE);
            }(e2, f2 + " " + p2 + "kb"), s2.draw(r2, a2.TRIANGLES, l2, c2, St.alphaBlended, Ct.disabled, Mi(n2, t.Color.transparent, _2), "$debug", e2.debugBuffer, e2.quadTriangleIndexBuffer, e2.debugSegments);
          }
          var vo = { symbol: function(e2, i2, o2, r2, a2) {
            if ("translucent" === e2.renderPass) {
              var n2 = Pt.disabled, s2 = e2.colorModeForRenderPass();
              o2.layout.get("text-variable-anchor") && function(e3, i3, o3, r3, a3, n3, s3) {
                for (var l2 = i3.transform, c2 = "map" === a3, u2 = "map" === n3, h2 = 0, p2 = e3; h2 < p2.length; h2 += 1) {
                  var d2 = p2[h2], _2 = r3.getTile(d2), f2 = _2.getBucket(o3);
                  if (f2 && f2.text && f2.text.segments.get().length) {
                    var m2 = t.evaluateSizeForZoom(f2.textSizeData, l2.zoom), g2 = pe(_2, 1, i3.transform.zoom), v2 = Jt(d2.posMatrix, u2, c2, i3.transform, g2), y2 = "none" !== o3.layout.get("icon-text-fit") && f2.hasIconData();
                    if (m2) {
                      var x2 = Math.pow(2, l2.zoom - _2.tileID.overscaledZ);
                      $i(f2, c2, u2, s3, t.symbolSize, l2, v2, d2.posMatrix, x2, m2, y2);
                    }
                  }
                }
              }(r2, e2, o2, i2, o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), a2), 0 !== o2.paint.get("icon-opacity").constantOr(1) && eo(e2, i2, o2, r2, false, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), o2.layout.get("icon-rotation-alignment"), o2.layout.get("icon-pitch-alignment"), o2.layout.get("icon-keep-upright"), n2, s2), 0 !== o2.paint.get("text-opacity").constantOr(1) && eo(e2, i2, o2, r2, true, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), o2.layout.get("text-rotation-alignment"), o2.layout.get("text-pitch-alignment"), o2.layout.get("text-keep-upright"), n2, s2), i2.map.showCollisionBoxes && (Yi(e2, i2, o2, r2, o2.paint.get("text-translate"), o2.paint.get("text-translate-anchor"), true), Yi(e2, i2, o2, r2, o2.paint.get("icon-translate"), o2.paint.get("icon-translate-anchor"), false));
            }
          }, circle: function(e2, i2, o2, r2) {
            if ("translucent" === e2.renderPass) {
              var a2 = o2.paint.get("circle-opacity"), n2 = o2.paint.get("circle-stroke-width"), s2 = o2.paint.get("circle-stroke-opacity"), l2 = void 0 !== o2.layout.get("circle-sort-key").constantOr(1);
              if (0 !== a2.constantOr(1) || 0 !== n2.constantOr(1) && 0 !== s2.constantOr(1)) {
                for (var c2 = e2.context, u2 = c2.gl, h2 = e2.depthModeForSublayer(0, It.ReadOnly), p2 = Pt.disabled, d2 = e2.colorModeForRenderPass(), _2 = [], f2 = 0; f2 < r2.length; f2++) {
                  var m2 = r2[f2], g2 = i2.getTile(m2), v2 = g2.getBucket(o2);
                  if (v2) {
                    var y2 = v2.programConfigurations.get(o2.id), x2 = { programConfiguration: y2, program: e2.useProgram("circle", y2), layoutVertexBuffer: v2.layoutVertexBuffer, indexBuffer: v2.indexBuffer, uniformValues: zi(e2, m2, g2, o2) };
                    if (l2)
                      for (var b2 = 0, w2 = v2.segments.get(); b2 < w2.length; b2 += 1) {
                        var T2 = w2[b2];
                        _2.push({ segments: new t.SegmentVector([T2]), sortKey: T2.sortKey, state: x2 });
                      }
                    else
                      _2.push({ segments: v2.segments, sortKey: 0, state: x2 });
                  }
                }
                l2 && _2.sort(function(t2, e3) {
                  return t2.sortKey - e3.sortKey;
                });
                for (var E2 = 0, I2 = _2; E2 < I2.length; E2 += 1) {
                  var P2 = I2[E2], S2 = P2.state;
                  S2.program.draw(c2, u2.TRIANGLES, h2, p2, d2, Ct.disabled, S2.uniformValues, o2.id, S2.layoutVertexBuffer, S2.indexBuffer, P2.segments, o2.paint, e2.transform.zoom, S2.programConfiguration);
                }
              }
            }
          }, heatmap: function(e2, i2, o2, r2) {
            if (0 !== o2.paint.get("heatmap-opacity"))
              if ("offscreen" === e2.renderPass) {
                var a2 = e2.context, n2 = a2.gl, s2 = Pt.disabled, l2 = new St([n2.ONE, n2.ONE], t.Color.transparent, [true, true, true, true]);
                !function(t2, e3, i3) {
                  var o3 = t2.gl;
                  t2.activeTexture.set(o3.TEXTURE1), t2.viewport.set([0, 0, e3.width / 4, e3.height / 4]);
                  var r3 = i3.heatmapFbo;
                  if (r3)
                    o3.bindTexture(o3.TEXTURE_2D, r3.colorAttachment.get()), t2.bindFramebuffer.set(r3.framebuffer);
                  else {
                    var a3 = o3.createTexture();
                    o3.bindTexture(o3.TEXTURE_2D, a3), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_S, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_WRAP_T, o3.CLAMP_TO_EDGE), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MIN_FILTER, o3.LINEAR), o3.texParameteri(o3.TEXTURE_2D, o3.TEXTURE_MAG_FILTER, o3.LINEAR), r3 = i3.heatmapFbo = t2.createFramebuffer(e3.width / 4, e3.height / 4, false), function(t3, e4, i4, o4) {
                      var r4 = t3.gl;
                      r4.texImage2D(r4.TEXTURE_2D, 0, r4.RGBA, e4.width / 4, e4.height / 4, 0, r4.RGBA, t3.extRenderToTextureHalfFloat ? t3.extTextureHalfFloat.HALF_FLOAT_OES : r4.UNSIGNED_BYTE, null), o4.colorAttachment.set(i4);
                    }(t2, e3, a3, r3);
                  }
                }(a2, e2, o2), a2.clear({ color: t.Color.transparent });
                for (var c2 = 0; c2 < r2.length; c2++) {
                  var u2 = r2[c2];
                  if (!i2.hasRenderableParent(u2)) {
                    var h2 = i2.getTile(u2), p2 = h2.getBucket(o2);
                    if (p2) {
                      var d2 = p2.programConfigurations.get(o2.id);
                      e2.useProgram("heatmap", d2).draw(a2, n2.TRIANGLES, It.disabled, s2, l2, Ct.disabled, Ri(u2.posMatrix, h2, e2.transform.zoom, o2.paint.get("heatmap-intensity")), o2.id, p2.layoutVertexBuffer, p2.indexBuffer, p2.segments, o2.paint, e2.transform.zoom, d2);
                    }
                  }
                }
                a2.viewport.set([0, 0, e2.width, e2.height]);
              } else
                "translucent" === e2.renderPass && (e2.context.setColorMode(e2.colorModeForRenderPass()), function(e3, i3) {
                  var o3 = e3.context, r3 = o3.gl, a3 = i3.heatmapFbo;
                  if (a3) {
                    o3.activeTexture.set(r3.TEXTURE0), r3.bindTexture(r3.TEXTURE_2D, a3.colorAttachment.get()), o3.activeTexture.set(r3.TEXTURE1);
                    var n3 = i3.colorRampTexture;
                    n3 || (n3 = i3.colorRampTexture = new t.Texture(o3, i3.colorRamp, r3.RGBA)), n3.bind(r3.LINEAR, r3.CLAMP_TO_EDGE), e3.useProgram("heatmapTexture").draw(o3, r3.TRIANGLES, It.disabled, Pt.disabled, e3.colorModeForRenderPass(), Ct.disabled, function(e4, i4, o4, r4) {
                      var a4 = t.create();
                      t.ortho(a4, 0, e4.width, e4.height, 0, 0, 1);
                      var n4 = e4.context.gl;
                      return { u_matrix: a4, u_world: [n4.drawingBufferWidth, n4.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: i4.paint.get("heatmap-opacity") };
                    }(e3, i3), i3.id, e3.viewportBuffer, e3.quadTriangleIndexBuffer, e3.viewportSegments, i3.paint, e3.transform.zoom);
                  }
                }(e2, o2));
          }, line: function(e2, i2, o2, r2) {
            if ("translucent" === e2.renderPass) {
              var a2 = o2.paint.get("line-opacity"), n2 = o2.paint.get("line-width");
              if (0 !== a2.constantOr(1) && 0 !== n2.constantOr(1))
                for (var s2 = e2.depthModeForSublayer(0, It.ReadOnly), l2 = e2.colorModeForRenderPass(), c2 = o2.paint.get("line-dasharray"), u2 = o2.paint.get("line-pattern"), h2 = u2.constantOr(1), p2 = o2.paint.get("line-gradient"), d2 = o2.getCrossfadeParameters(), _2 = h2 ? "linePattern" : c2 ? "lineSDF" : p2 ? "lineGradient" : "line", f2 = e2.context, m2 = f2.gl, g2 = true, v2 = 0, y2 = r2; v2 < y2.length; v2 += 1) {
                  var x2 = y2[v2], b2 = i2.getTile(x2);
                  if (!h2 || b2.patternsLoaded()) {
                    var w2 = b2.getBucket(o2);
                    if (w2) {
                      var T2 = w2.programConfigurations.get(o2.id), E2 = e2.context.program.get(), I2 = e2.useProgram(_2, T2), P2 = g2 || I2.program !== E2, S2 = u2.constantOr(null);
                      if (S2 && b2.imageAtlas) {
                        var C2 = b2.imageAtlas, z2 = C2.patternPositions[S2.to.toString()], D2 = C2.patternPositions[S2.from.toString()];
                        z2 && D2 && T2.setConstantPatternPositions(z2, D2);
                      }
                      var A2 = h2 ? Oi(e2, b2, o2, d2) : c2 ? Fi(e2, b2, o2, c2, d2) : p2 ? Bi(e2, b2, o2, w2.lineClipsArray.length) : ki(e2, b2, o2);
                      if (h2)
                        f2.activeTexture.set(m2.TEXTURE0), b2.imageAtlasTexture.bind(m2.LINEAR, m2.CLAMP_TO_EDGE), T2.updatePaintBuffers(d2);
                      else if (c2 && (P2 || e2.lineAtlas.dirty))
                        f2.activeTexture.set(m2.TEXTURE0), e2.lineAtlas.bind(f2);
                      else if (p2) {
                        var M2 = w2.gradients[o2.id], L2 = M2.texture;
                        if (o2.gradientVersion !== M2.version) {
                          var R2 = 256;
                          if (o2.stepInterpolant) {
                            var k2 = i2.getSource().maxzoom, B2 = x2.canonical.z === k2 ? Math.ceil(1 << e2.transform.maxZoom - x2.canonical.z) : 1;
                            R2 = t.clamp(t.nextPowerOfTwo(w2.maxLineLength / t.EXTENT * 1024 * B2), 256, f2.maxTextureSize);
                          }
                          M2.gradient = t.renderColorRamp({ expression: o2.gradientExpression(), evaluationKey: "lineProgress", resolution: R2, image: M2.gradient || void 0, clips: w2.lineClipsArray }), M2.texture ? M2.texture.update(M2.gradient) : M2.texture = new t.Texture(f2, M2.gradient, m2.RGBA), M2.version = o2.gradientVersion, L2 = M2.texture;
                        }
                        f2.activeTexture.set(m2.TEXTURE0), L2.bind(o2.stepInterpolant ? m2.NEAREST : m2.LINEAR, m2.CLAMP_TO_EDGE);
                      }
                      I2.draw(f2, m2.TRIANGLES, s2, e2.stencilModeForClipping(x2), l2, Ct.disabled, A2, o2.id, w2.layoutVertexBuffer, w2.indexBuffer, w2.segments, o2.paint, e2.transform.zoom, T2, w2.layoutVertexBuffer2), g2 = false;
                    }
                  }
                }
            }
          }, fill: function(e2, i2, o2, r2) {
            var a2 = o2.paint.get("fill-color"), n2 = o2.paint.get("fill-opacity");
            if (0 !== n2.constantOr(1)) {
              var s2 = e2.colorModeForRenderPass(), l2 = o2.paint.get("fill-pattern"), c2 = e2.opaquePassEnabledForLayer() && !l2.constantOr(1) && 1 === a2.constantOr(t.Color.transparent).a && 1 === n2.constantOr(0) ? "opaque" : "translucent";
              if (e2.renderPass === c2) {
                var u2 = e2.depthModeForSublayer(1, "opaque" === e2.renderPass ? It.ReadWrite : It.ReadOnly);
                oo(e2, i2, o2, r2, u2, s2, false);
              }
              if ("translucent" === e2.renderPass && o2.paint.get("fill-antialias")) {
                var h2 = e2.depthModeForSublayer(o2.getPaintProperty("fill-outline-color") ? 2 : 0, It.ReadOnly);
                oo(e2, i2, o2, r2, h2, s2, true);
              }
            }
          }, "fill-extrusion": function(t2, e2, i2, o2) {
            var r2 = i2.paint.get("fill-extrusion-opacity");
            if (0 !== r2 && "translucent" === t2.renderPass) {
              var a2 = new It(t2.context.gl.LEQUAL, It.ReadWrite, t2.depthRangeFor3D);
              if (1 !== r2 || i2.paint.get("fill-extrusion-pattern").constantOr(1))
                ro(t2, e2, i2, o2, a2, Pt.disabled, St.disabled), ro(t2, e2, i2, o2, a2, t2.stencilModeFor3D(), t2.colorModeForRenderPass());
              else {
                var n2 = t2.colorModeForRenderPass();
                ro(t2, e2, i2, o2, a2, Pt.disabled, n2);
              }
            }
          }, hillshade: function(t2, e2, i2, o2) {
            if ("offscreen" === t2.renderPass || "translucent" === t2.renderPass) {
              for (var r2 = t2.context, a2 = t2.depthModeForSublayer(0, It.ReadOnly), n2 = t2.colorModeForRenderPass(), s2 = "translucent" === t2.renderPass ? t2.stencilConfigForOverlap(o2) : [{}, o2], l2 = s2[0], c2 = 0, u2 = s2[1]; c2 < u2.length; c2 += 1) {
                var h2 = u2[c2], p2 = e2.getTile(h2);
                p2.needsHillshadePrepare && "offscreen" === t2.renderPass ? no(t2, p2, i2, a2, Pt.disabled, n2) : "translucent" === t2.renderPass && ao(t2, p2, i2, a2, l2[h2.overscaledZ], n2);
              }
              r2.viewport.set([0, 0, t2.width, t2.height]);
            }
          }, raster: function(t2, e2, i2, o2) {
            if ("translucent" === t2.renderPass && 0 !== i2.paint.get("raster-opacity") && o2.length)
              for (var r2 = t2.context, a2 = r2.gl, n2 = e2.getSource(), s2 = t2.useProgram("raster"), l2 = t2.colorModeForRenderPass(), c2 = n2 instanceof M ? [{}, o2] : t2.stencilConfigForOverlap(o2), u2 = c2[0], h2 = c2[1], p2 = h2[h2.length - 1].overscaledZ, d2 = !t2.options.moving, _2 = 0, f2 = h2; _2 < f2.length; _2 += 1) {
                var m2 = f2[_2], g2 = t2.depthModeForSublayer(m2.overscaledZ - p2, 1 === i2.paint.get("raster-opacity") ? It.ReadWrite : It.ReadOnly, a2.LESS), v2 = e2.getTile(m2), y2 = t2.transform.calculatePosMatrix(m2.toUnwrapped(), d2);
                v2.registerFadeDuration(i2.paint.get("raster-fade-duration"));
                var x2 = e2.findLoadedParent(m2, 0), b2 = so(v2, x2, e2, i2, t2.transform), w2 = void 0, T2 = void 0, E2 = "nearest" === i2.paint.get("raster-resampling") ? a2.NEAREST : a2.LINEAR;
                r2.activeTexture.set(a2.TEXTURE0), v2.texture.bind(E2, a2.CLAMP_TO_EDGE, a2.LINEAR_MIPMAP_NEAREST), r2.activeTexture.set(a2.TEXTURE1), x2 ? (x2.texture.bind(E2, a2.CLAMP_TO_EDGE, a2.LINEAR_MIPMAP_NEAREST), w2 = Math.pow(2, x2.tileID.overscaledZ - v2.tileID.overscaledZ), T2 = [v2.tileID.canonical.x * w2 % 1, v2.tileID.canonical.y * w2 % 1]) : v2.texture.bind(E2, a2.CLAMP_TO_EDGE, a2.LINEAR_MIPMAP_NEAREST);
                var I2 = Zi(y2, T2 || [0, 0], w2 || 1, b2, i2);
                n2 instanceof M ? s2.draw(r2, a2.TRIANGLES, g2, Pt.disabled, l2, Ct.disabled, I2, i2.id, n2.boundsBuffer, t2.quadTriangleIndexBuffer, n2.boundsSegments) : s2.draw(r2, a2.TRIANGLES, g2, u2[m2.overscaledZ], l2, Ct.disabled, I2, i2.id, t2.rasterBoundsBuffer, t2.quadTriangleIndexBuffer, t2.rasterBoundsSegments);
              }
          }, background: function(t2, e2, i2) {
            var o2 = i2.paint.get("background-color"), r2 = i2.paint.get("background-opacity");
            if (0 !== r2) {
              var a2 = t2.context, n2 = a2.gl, s2 = t2.transform, l2 = s2.tileSize, c2 = i2.paint.get("background-pattern");
              if (!t2.isPatternMissing(c2)) {
                var u2 = !c2 && 1 === o2.a && 1 === r2 && t2.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                if (t2.renderPass === u2) {
                  var h2 = Pt.disabled, p2 = t2.depthModeForSublayer(0, "opaque" === u2 ? It.ReadWrite : It.ReadOnly), d2 = t2.colorModeForRenderPass(), _2 = t2.useProgram(c2 ? "backgroundPattern" : "background"), f2 = s2.coveringTiles({ tileSize: l2 });
                  c2 && (a2.activeTexture.set(n2.TEXTURE0), t2.imageManager.bind(t2.context));
                  for (var m2 = i2.getCrossfadeParameters(), g2 = 0, v2 = f2; g2 < v2.length; g2 += 1) {
                    var y2 = v2[g2], x2 = t2.transform.calculatePosMatrix(y2.toUnwrapped()), b2 = c2 ? Hi(x2, r2, t2, c2, { tileID: y2, tileSize: l2 }, m2) : Xi(x2, r2, o2);
                    _2.draw(a2, n2.TRIANGLES, p2, h2, d2, Ct.disabled, b2, i2.id, t2.tileExtentBuffer, t2.quadTriangleIndexBuffer, t2.tileExtentSegments);
                  }
                }
              }
            }
          }, debug: function(t2, e2, i2) {
            for (var o2 = 0; o2 < i2.length; o2++)
              go2(t2, e2, i2[o2]);
          }, custom: function(t2, e2, i2) {
            var o2 = t2.context, r2 = i2.implementation;
            if ("offscreen" === t2.renderPass) {
              var a2 = r2.prerender;
              a2 && (t2.setCustomLayerDefaults(), o2.setColorMode(t2.colorModeForRenderPass()), a2.call(r2, o2.gl, t2.transform.customLayerMatrix()), o2.setDirty(), t2.setBaseState());
            } else if ("translucent" === t2.renderPass) {
              t2.setCustomLayerDefaults(), o2.setColorMode(t2.colorModeForRenderPass()), o2.setStencilMode(Pt.disabled);
              var n2 = "3d" === r2.renderingMode ? new It(t2.context.gl.LEQUAL, It.ReadWrite, t2.depthRangeFor3D) : t2.depthModeForSublayer(0, It.ReadOnly);
              o2.setDepthMode(n2), r2.render(o2.gl, t2.transform.customLayerMatrix()), o2.setDirty(), t2.setBaseState(), o2.bindFramebuffer.set(null);
            }
          } }, yo = function(t2, e2) {
            this.context = new zt(t2), this.transform = e2, this._tileTextures = {}, this.setup(), this.numSublayers = Dt.maxUnderzooming + Dt.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Fe(), this.gpuTimers = {};
          };
          yo.prototype.resize = function(e2, i2) {
            if (this.width = e2 * t.browser.devicePixelRatio, this.height = i2 * t.browser.devicePixelRatio, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
              for (var o2 = 0, r2 = this.style._order; o2 < r2.length; o2 += 1)
                this.style._layers[r2[o2]].resize();
          }, yo.prototype.setup = function() {
            var e2 = this.context, i2 = new t.StructArrayLayout2i4();
            i2.emplaceBack(0, 0), i2.emplaceBack(t.EXTENT, 0), i2.emplaceBack(0, t.EXTENT), i2.emplaceBack(t.EXTENT, t.EXTENT), this.tileExtentBuffer = e2.createVertexBuffer(i2, Ve.members), this.tileExtentSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
            var o2 = new t.StructArrayLayout2i4();
            o2.emplaceBack(0, 0), o2.emplaceBack(t.EXTENT, 0), o2.emplaceBack(0, t.EXTENT), o2.emplaceBack(t.EXTENT, t.EXTENT), this.debugBuffer = e2.createVertexBuffer(o2, Ve.members), this.debugSegments = t.SegmentVector.simpleSegment(0, 0, 4, 5);
            var r2 = new t.StructArrayLayout4i8();
            r2.emplaceBack(0, 0, 0, 0), r2.emplaceBack(t.EXTENT, 0, t.EXTENT, 0), r2.emplaceBack(0, t.EXTENT, 0, t.EXTENT), r2.emplaceBack(t.EXTENT, t.EXTENT, t.EXTENT, t.EXTENT), this.rasterBoundsBuffer = e2.createVertexBuffer(r2, A.members), this.rasterBoundsSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
            var a2 = new t.StructArrayLayout2i4();
            a2.emplaceBack(0, 0), a2.emplaceBack(1, 0), a2.emplaceBack(0, 1), a2.emplaceBack(1, 1), this.viewportBuffer = e2.createVertexBuffer(a2, Ve.members), this.viewportSegments = t.SegmentVector.simpleSegment(0, 0, 4, 2);
            var n2 = new t.StructArrayLayout1ui2();
            n2.emplaceBack(0), n2.emplaceBack(1), n2.emplaceBack(3), n2.emplaceBack(2), n2.emplaceBack(0), this.tileBorderIndexBuffer = e2.createIndexBuffer(n2);
            var s2 = new t.StructArrayLayout3ui6();
            s2.emplaceBack(0, 1, 2), s2.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e2.createIndexBuffer(s2), this.emptyTexture = new t.Texture(e2, { width: 1, height: 1, data: new Uint8Array([0, 0, 0, 0]) }, e2.gl.RGBA);
            var l2 = this.context.gl;
            this.stencilClearMode = new Pt({ func: l2.ALWAYS, mask: 0 }, 0, 255, l2.ZERO, l2.ZERO, l2.ZERO);
          }, yo.prototype.clearStencil = function() {
            var e2 = this.context, i2 = e2.gl;
            this.nextStencilID = 1, this.currentStencilSource = void 0;
            var o2 = t.create();
            t.ortho(o2, 0, this.width, this.height, 0, 0, 1), t.scale(o2, o2, [i2.drawingBufferWidth, i2.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e2, i2.TRIANGLES, It.disabled, this.stencilClearMode, St.disabled, Ct.disabled, Li(o2), "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
          }, yo.prototype._renderTileClippingMasks = function(t2, e2) {
            if (this.currentStencilSource !== t2.source && t2.isTileClipped() && e2 && e2.length) {
              this.currentStencilSource = t2.source;
              var i2 = this.context, o2 = i2.gl;
              this.nextStencilID + e2.length > 256 && this.clearStencil(), i2.setColorMode(St.disabled), i2.setDepthMode(It.disabled);
              var r2 = this.useProgram("clippingMask");
              this._tileClippingMaskIDs = {};
              for (var a2 = 0, n2 = e2; a2 < n2.length; a2 += 1) {
                var s2 = n2[a2], l2 = this._tileClippingMaskIDs[s2.key] = this.nextStencilID++;
                r2.draw(i2, o2.TRIANGLES, It.disabled, new Pt({ func: o2.ALWAYS, mask: 0 }, l2, 255, o2.KEEP, o2.KEEP, o2.REPLACE), St.disabled, Ct.disabled, Li(s2.posMatrix), "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
              }
            }
          }, yo.prototype.stencilModeFor3D = function() {
            this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
            var t2 = this.nextStencilID++, e2 = this.context.gl;
            return new Pt({ func: e2.NOTEQUAL, mask: 255 }, t2, 255, e2.KEEP, e2.KEEP, e2.REPLACE);
          }, yo.prototype.stencilModeForClipping = function(t2) {
            var e2 = this.context.gl;
            return new Pt({ func: e2.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t2.key], 0, e2.KEEP, e2.KEEP, e2.REPLACE);
          }, yo.prototype.stencilConfigForOverlap = function(t2) {
            var e2, i2 = this.context.gl, o2 = t2.sort(function(t3, e3) {
              return e3.overscaledZ - t3.overscaledZ;
            }), r2 = o2[o2.length - 1].overscaledZ, a2 = o2[0].overscaledZ - r2 + 1;
            if (a2 > 1) {
              this.currentStencilSource = void 0, this.nextStencilID + a2 > 256 && this.clearStencil();
              for (var n2 = {}, s2 = 0; s2 < a2; s2++)
                n2[s2 + r2] = new Pt({ func: i2.GEQUAL, mask: 255 }, s2 + this.nextStencilID, 255, i2.KEEP, i2.KEEP, i2.REPLACE);
              return this.nextStencilID += a2, [n2, o2];
            }
            return [(e2 = {}, e2[r2] = Pt.disabled, e2), o2];
          }, yo.prototype.colorModeForRenderPass = function() {
            var e2 = this.context.gl;
            return this._showOverdrawInspector ? new St([e2.CONSTANT_COLOR, e2.ONE], new t.Color(1 / 8, 1 / 8, 1 / 8, 0), [true, true, true, true]) : "opaque" === this.renderPass ? St.unblended : St.alphaBlended;
          }, yo.prototype.depthModeForSublayer = function(t2, e2, i2) {
            if (!this.opaquePassEnabledForLayer())
              return It.disabled;
            var o2 = 1 - ((1 + this.currentLayer) * this.numSublayers + t2) * this.depthEpsilon;
            return new It(i2 || this.context.gl.LEQUAL, e2, [o2, o2]);
          }, yo.prototype.opaquePassEnabledForLayer = function() {
            return this.currentLayer < this.opaquePassCutoff;
          }, yo.prototype.render = function(e2, i2) {
            var o2 = this;
            this.style = e2, this.options = i2, this.lineAtlas = e2.lineAtlas, this.imageManager = e2.imageManager, this.glyphManager = e2.glyphManager, this.symbolFadeChange = e2.placement.symbolFadeChange(t.browser.now()), this.imageManager.beginFrame();
            var r2 = this.style._order, a2 = this.style.sourceCaches;
            for (var n2 in a2) {
              var s2 = a2[n2];
              s2.used && s2.prepare(this.context);
            }
            var l2, c2, u2 = {}, h2 = {}, p2 = {};
            for (var d2 in a2) {
              var _2 = a2[d2];
              u2[d2] = _2.getVisibleCoordinates(), h2[d2] = u2[d2].slice().reverse(), p2[d2] = _2.getVisibleCoordinates(true).reverse();
            }
            this.opaquePassCutoff = 1 / 0;
            for (var f2 = 0; f2 < r2.length; f2++)
              if (this.style._layers[r2[f2]].is3D()) {
                this.opaquePassCutoff = f2;
                break;
              }
            this.renderPass = "offscreen";
            for (var m2 = 0, g2 = r2; m2 < g2.length; m2 += 1) {
              var v2 = this.style._layers[g2[m2]];
              if (v2.hasOffscreenPass() && !v2.isHidden(this.transform.zoom)) {
                var y2 = h2[v2.source];
                ("custom" === v2.type || y2.length) && this.renderLayer(this, a2[v2.source], v2, y2);
              }
            }
            for (this.context.bindFramebuffer.set(null), this.context.clear({ color: i2.showOverdrawInspector ? t.Color.black : t.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i2.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e2._order.length + 2) * this.numSublayers * this.depthEpsilon], this.renderPass = "opaque", this.currentLayer = r2.length - 1; this.currentLayer >= 0; this.currentLayer--) {
              var x2 = this.style._layers[r2[this.currentLayer]], b2 = a2[x2.source], w2 = u2[x2.source];
              this._renderTileClippingMasks(x2, w2), this.renderLayer(this, b2, x2, w2);
            }
            for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < r2.length; this.currentLayer++) {
              var T2 = this.style._layers[r2[this.currentLayer]], E2 = a2[T2.source], I2 = ("symbol" === T2.type ? p2 : h2)[T2.source];
              this._renderTileClippingMasks(T2, u2[T2.source]), this.renderLayer(this, E2, T2, I2);
            }
            this.options.showTileBoundaries && (t.values(this.style._layers).forEach(function(t2) {
              t2.source && !t2.isHidden(o2.transform.zoom) && (t2.source !== (c2 && c2.id) && (c2 = o2.style.sourceCaches[t2.source]), (!l2 || l2.getSource().maxzoom < c2.getSource().maxzoom) && (l2 = c2));
            }), l2 && vo.debug(this, l2, l2.getVisibleCoordinates())), this.options.showPadding && function(t2) {
              var e3 = t2.transform.padding;
              _o(t2, t2.transform.height - (e3.top || 0), 3, lo), _o(t2, e3.bottom || 0, 3, co), fo(t2, e3.left || 0, 3, uo), fo(t2, t2.transform.width - (e3.right || 0), 3, ho);
              var i3 = t2.transform.centerPoint;
              !function(t3, e4, i4, o3) {
                mo(t3, e4 - 1, i4 - 10, 2, 20, o3), mo(t3, e4 - 10, i4 - 1, 20, 2, o3);
              }(t2, i3.x, t2.transform.height - i3.y, po);
            }(this), this.context.setDefault();
          }, yo.prototype.renderLayer = function(t2, e2, i2, o2) {
            i2.isHidden(this.transform.zoom) || ("background" === i2.type || "custom" === i2.type || o2.length) && (this.id = i2.id, this.gpuTimingStart(i2), vo[i2.type](t2, e2, i2, o2, this.style.placement.variableOffsets), this.gpuTimingEnd());
          }, yo.prototype.gpuTimingStart = function(t2) {
            if (this.options.gpuTiming) {
              var e2 = this.context.extTimerQuery, i2 = this.gpuTimers[t2.id];
              i2 || (i2 = this.gpuTimers[t2.id] = { calls: 0, cpuTime: 0, query: e2.createQueryEXT() }), i2.calls++, e2.beginQueryEXT(e2.TIME_ELAPSED_EXT, i2.query);
            }
          }, yo.prototype.gpuTimingEnd = function() {
            if (this.options.gpuTiming) {
              var t2 = this.context.extTimerQuery;
              t2.endQueryEXT(t2.TIME_ELAPSED_EXT);
            }
          }, yo.prototype.collectGpuTimers = function() {
            var t2 = this.gpuTimers;
            return this.gpuTimers = {}, t2;
          }, yo.prototype.queryGpuTimers = function(t2) {
            var e2 = {};
            for (var i2 in t2) {
              var o2 = t2[i2], r2 = this.context.extTimerQuery, a2 = r2.getQueryObjectEXT(o2.query, r2.QUERY_RESULT_EXT) / 1e6;
              r2.deleteQueryEXT(o2.query), e2[i2] = a2;
            }
            return e2;
          }, yo.prototype.translatePosMatrix = function(e2, i2, o2, r2, a2) {
            if (!o2[0] && !o2[1])
              return e2;
            var n2 = a2 ? "map" === r2 ? this.transform.angle : 0 : "viewport" === r2 ? -this.transform.angle : 0;
            if (n2) {
              var s2 = Math.sin(n2), l2 = Math.cos(n2);
              o2 = [o2[0] * l2 - o2[1] * s2, o2[0] * s2 + o2[1] * l2];
            }
            var c2 = [a2 ? o2[0] : pe(i2, o2[0], this.transform.zoom), a2 ? o2[1] : pe(i2, o2[1], this.transform.zoom), 0], u2 = new Float32Array(16);
            return t.translate(u2, e2, c2), u2;
          }, yo.prototype.saveTileTexture = function(t2) {
            var e2 = this._tileTextures[t2.size[0]];
            e2 ? e2.push(t2) : this._tileTextures[t2.size[0]] = [t2];
          }, yo.prototype.getTileTexture = function(t2) {
            var e2 = this._tileTextures[t2];
            return e2 && e2.length > 0 ? e2.pop() : null;
          }, yo.prototype.isPatternMissing = function(t2) {
            if (!t2)
              return false;
            if (!t2.from || !t2.to)
              return true;
            var e2 = this.imageManager.getPattern(t2.from.toString()), i2 = this.imageManager.getPattern(t2.to.toString());
            return !e2 || !i2;
          }, yo.prototype.useProgram = function(t2, e2) {
            this.cache = this.cache || {};
            var i2 = "" + t2 + (e2 ? e2.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "");
            return this.cache[i2] || (this.cache[i2] = new bi(this.context, t2, vi[t2], e2, Ki[t2], this._showOverdrawInspector)), this.cache[i2];
          }, yo.prototype.setCustomLayerDefaults = function() {
            this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
          }, yo.prototype.setBaseState = function() {
            var t2 = this.context.gl;
            this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t2.FUNC_ADD);
          }, yo.prototype.initDebugOverlayCanvas = function() {
            null == this.debugOverlayCanvas && (this.debugOverlayCanvas = t.window.document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new t.Texture(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
          }, yo.prototype.destroy = function() {
            this.emptyTexture.destroy(), this.debugOverlayTexture && this.debugOverlayTexture.destroy();
          };
          var xo = function(t2, e2) {
            this.points = t2, this.planes = e2;
          };
          xo.fromInvProjectionMatrix = function(e2, i2, o2) {
            var r2 = Math.pow(2, o2), a2 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(function(i3) {
              return t.transformMat4([], i3, e2);
            }).map(function(e3) {
              return t.scale$1([], e3, 1 / e3[3] / i2 * r2);
            }), n2 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(function(e3) {
              var i3 = t.sub([], a2[e3[0]], a2[e3[1]]), o3 = t.sub([], a2[e3[2]], a2[e3[1]]), r3 = t.normalize([], t.cross([], i3, o3)), n3 = -t.dot(r3, a2[e3[1]]);
              return r3.concat(n3);
            });
            return new xo(a2, n2);
          };
          var bo = function(e2, i2) {
            this.min = e2, this.max = i2, this.center = t.scale$2([], t.add([], this.min, this.max), 0.5);
          };
          bo.prototype.quadrant = function(e2) {
            for (var i2 = [e2 % 2 == 0, e2 < 2], o2 = t.clone$2(this.min), r2 = t.clone$2(this.max), a2 = 0; a2 < i2.length; a2++)
              o2[a2] = i2[a2] ? this.min[a2] : this.center[a2], r2[a2] = i2[a2] ? this.center[a2] : this.max[a2];
            return r2[2] = this.max[2], new bo(o2, r2);
          }, bo.prototype.distanceX = function(t2) {
            return Math.max(Math.min(this.max[0], t2[0]), this.min[0]) - t2[0];
          }, bo.prototype.distanceY = function(t2) {
            return Math.max(Math.min(this.max[1], t2[1]), this.min[1]) - t2[1];
          }, bo.prototype.intersects = function(e2) {
            for (var i2 = [[this.min[0], this.min[1], 0, 1], [this.max[0], this.min[1], 0, 1], [this.max[0], this.max[1], 0, 1], [this.min[0], this.max[1], 0, 1]], o2 = true, r2 = 0; r2 < e2.planes.length; r2++) {
              for (var a2 = e2.planes[r2], n2 = 0, s2 = 0; s2 < i2.length; s2++)
                n2 += t.dot$1(a2, i2[s2]) >= 0;
              if (0 === n2)
                return 0;
              n2 !== i2.length && (o2 = false);
            }
            if (o2)
              return 2;
            for (var l2 = 0; l2 < 3; l2++) {
              for (var c2 = Number.MAX_VALUE, u2 = -Number.MAX_VALUE, h2 = 0; h2 < e2.points.length; h2++) {
                var p2 = e2.points[h2][l2] - this.min[l2];
                c2 = Math.min(c2, p2), u2 = Math.max(u2, p2);
              }
              if (u2 < 0 || c2 > this.max[l2] - this.min[l2])
                return 0;
            }
            return 1;
          };
          var wo = function(t2, e2, i2, o2) {
            if (void 0 === t2 && (t2 = 0), void 0 === e2 && (e2 = 0), void 0 === i2 && (i2 = 0), void 0 === o2 && (o2 = 0), isNaN(t2) || t2 < 0 || isNaN(e2) || e2 < 0 || isNaN(i2) || i2 < 0 || isNaN(o2) || o2 < 0)
              throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
            this.top = t2, this.bottom = e2, this.left = i2, this.right = o2;
          };
          wo.prototype.interpolate = function(e2, i2, o2) {
            return null != i2.top && null != e2.top && (this.top = t.number(e2.top, i2.top, o2)), null != i2.bottom && null != e2.bottom && (this.bottom = t.number(e2.bottom, i2.bottom, o2)), null != i2.left && null != e2.left && (this.left = t.number(e2.left, i2.left, o2)), null != i2.right && null != e2.right && (this.right = t.number(e2.right, i2.right, o2)), this;
          }, wo.prototype.getCenter = function(e2, i2) {
            var o2 = t.clamp((this.left + e2 - this.right) / 2, 0, e2), r2 = t.clamp((this.top + i2 - this.bottom) / 2, 0, i2);
            return new t.Point(o2, r2);
          }, wo.prototype.equals = function(t2) {
            return this.top === t2.top && this.bottom === t2.bottom && this.left === t2.left && this.right === t2.right;
          }, wo.prototype.clone = function() {
            return new wo(this.top, this.bottom, this.left, this.right);
          }, wo.prototype.toJSON = function() {
            return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
          };
          var To = function(e2, i2, o2, r2, a2) {
            this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = void 0 === a2 || a2, this._minZoom = e2 || 0, this._maxZoom = i2 || 22, this._minPitch = null == o2 ? 0 : o2, this._maxPitch = null == r2 ? 60 : r2, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new t.LngLat(0, 0), this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = true, this._edgeInsets = new wo(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
          }, Eo = { minZoom: { configurable: true }, maxZoom: { configurable: true }, minPitch: { configurable: true }, maxPitch: { configurable: true }, renderWorldCopies: { configurable: true }, worldSize: { configurable: true }, centerOffset: { configurable: true }, size: { configurable: true }, bearing: { configurable: true }, pitch: { configurable: true }, fov: { configurable: true }, zoom: { configurable: true }, center: { configurable: true }, padding: { configurable: true }, centerPoint: { configurable: true }, unmodified: { configurable: true }, point: { configurable: true } };
          To.prototype.clone = function() {
            var t2 = new To(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
            return t2.tileSize = this.tileSize, t2.latRange = this.latRange, t2.width = this.width, t2.height = this.height, t2._center = this._center, t2.zoom = this.zoom, t2.angle = this.angle, t2._fov = this._fov, t2._pitch = this._pitch, t2._unmodified = this._unmodified, t2._edgeInsets = this._edgeInsets.clone(), t2._calcMatrices(), t2;
          }, Eo.minZoom.get = function() {
            return this._minZoom;
          }, Eo.minZoom.set = function(t2) {
            this._minZoom !== t2 && (this._minZoom = t2, this.zoom = Math.max(this.zoom, t2));
          }, Eo.maxZoom.get = function() {
            return this._maxZoom;
          }, Eo.maxZoom.set = function(t2) {
            this._maxZoom !== t2 && (this._maxZoom = t2, this.zoom = Math.min(this.zoom, t2));
          }, Eo.minPitch.get = function() {
            return this._minPitch;
          }, Eo.minPitch.set = function(t2) {
            this._minPitch !== t2 && (this._minPitch = t2, this.pitch = Math.max(this.pitch, t2));
          }, Eo.maxPitch.get = function() {
            return this._maxPitch;
          }, Eo.maxPitch.set = function(t2) {
            this._maxPitch !== t2 && (this._maxPitch = t2, this.pitch = Math.min(this.pitch, t2));
          }, Eo.renderWorldCopies.get = function() {
            return this._renderWorldCopies;
          }, Eo.renderWorldCopies.set = function(t2) {
            void 0 === t2 ? t2 = true : null === t2 && (t2 = false), this._renderWorldCopies = t2;
          }, Eo.worldSize.get = function() {
            return this.tileSize * this.scale;
          }, Eo.centerOffset.get = function() {
            return this.centerPoint._sub(this.size._div(2));
          }, Eo.size.get = function() {
            return new t.Point(this.width, this.height);
          }, Eo.bearing.get = function() {
            return -this.angle / Math.PI * 180;
          }, Eo.bearing.set = function(e2) {
            var i2 = -t.wrap(e2, -180, 180) * Math.PI / 180;
            this.angle !== i2 && (this._unmodified = false, this.angle = i2, this._calcMatrices(), this.rotationMatrix = t.create$2(), t.rotate(this.rotationMatrix, this.rotationMatrix, this.angle));
          }, Eo.pitch.get = function() {
            return this._pitch / Math.PI * 180;
          }, Eo.pitch.set = function(e2) {
            var i2 = t.clamp(e2, this.minPitch, this.maxPitch) / 180 * Math.PI;
            this._pitch !== i2 && (this._unmodified = false, this._pitch = i2, this._calcMatrices());
          }, Eo.fov.get = function() {
            return this._fov / Math.PI * 180;
          }, Eo.fov.set = function(t2) {
            t2 = Math.max(0.01, Math.min(60, t2)), this._fov !== t2 && (this._unmodified = false, this._fov = t2 / 180 * Math.PI, this._calcMatrices());
          }, Eo.zoom.get = function() {
            return this._zoom;
          }, Eo.zoom.set = function(t2) {
            var e2 = Math.min(Math.max(t2, this.minZoom), this.maxZoom);
            this._zoom !== e2 && (this._unmodified = false, this._zoom = e2, this.scale = this.zoomScale(e2), this.tileZoom = Math.floor(e2), this.zoomFraction = e2 - this.tileZoom, this._constrain(), this._calcMatrices());
          }, Eo.center.get = function() {
            return this._center;
          }, Eo.center.set = function(t2) {
            t2.lat === this._center.lat && t2.lng === this._center.lng || (this._unmodified = false, this._center = t2, this._constrain(), this._calcMatrices());
          }, Eo.padding.get = function() {
            return this._edgeInsets.toJSON();
          }, Eo.padding.set = function(t2) {
            this._edgeInsets.equals(t2) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, t2, 1), this._calcMatrices());
          }, Eo.centerPoint.get = function() {
            return this._edgeInsets.getCenter(this.width, this.height);
          }, To.prototype.isPaddingEqual = function(t2) {
            return this._edgeInsets.equals(t2);
          }, To.prototype.interpolatePadding = function(t2, e2, i2) {
            this._unmodified = false, this._edgeInsets.interpolate(t2, e2, i2), this._constrain(), this._calcMatrices();
          }, To.prototype.coveringZoomLevel = function(t2) {
            var e2 = (t2.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t2.tileSize));
            return Math.max(0, e2);
          }, To.prototype.getVisibleUnwrappedCoordinates = function(e2) {
            var i2 = [new t.UnwrappedTileID(0, e2)];
            if (this._renderWorldCopies)
              for (var o2 = this.pointCoordinate(new t.Point(0, 0)), r2 = this.pointCoordinate(new t.Point(this.width, 0)), a2 = this.pointCoordinate(new t.Point(this.width, this.height)), n2 = this.pointCoordinate(new t.Point(0, this.height)), s2 = Math.floor(Math.min(o2.x, r2.x, a2.x, n2.x)), l2 = Math.floor(Math.max(o2.x, r2.x, a2.x, n2.x)), c2 = s2 - 1; c2 <= l2 + 1; c2++)
                0 !== c2 && i2.push(new t.UnwrappedTileID(c2, e2));
            return i2;
          }, To.prototype.coveringTiles = function(e2) {
            var i2 = this.coveringZoomLevel(e2), o2 = i2;
            if (void 0 !== e2.minzoom && i2 < e2.minzoom)
              return [];
            void 0 !== e2.maxzoom && i2 > e2.maxzoom && (i2 = e2.maxzoom);
            var r2 = t.MercatorCoordinate.fromLngLat(this.center), a2 = Math.pow(2, i2), n2 = [a2 * r2.x, a2 * r2.y, 0], s2 = xo.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, i2), l2 = e2.minzoom || 0;
            this.pitch <= 60 && this._edgeInsets.top < 0.1 && (l2 = i2);
            var c2 = function(t2) {
              return { aabb: new bo([t2 * a2, 0, 0], [(t2 + 1) * a2, a2, 0]), zoom: 0, x: 0, y: 0, wrap: t2, fullyVisible: false };
            }, u2 = [], h2 = [], p2 = i2, d2 = e2.reparseOverscaled ? o2 : i2;
            if (this._renderWorldCopies)
              for (var _2 = 1; _2 <= 3; _2++)
                u2.push(c2(-_2)), u2.push(c2(_2));
            for (u2.push(c2(0)); u2.length > 0; ) {
              var f2 = u2.pop(), m2 = f2.x, g2 = f2.y, v2 = f2.fullyVisible;
              if (!v2) {
                var y2 = f2.aabb.intersects(s2);
                if (0 === y2)
                  continue;
                v2 = 2 === y2;
              }
              var x2 = f2.aabb.distanceX(n2), b2 = f2.aabb.distanceY(n2), w2 = Math.max(Math.abs(x2), Math.abs(b2));
              if (f2.zoom === p2 || w2 > 3 + (1 << p2 - f2.zoom) - 2 && f2.zoom >= l2)
                h2.push({ tileID: new t.OverscaledTileID(f2.zoom === p2 ? d2 : f2.zoom, f2.wrap, f2.zoom, m2, g2), distanceSq: t.sqrLen([n2[0] - 0.5 - m2, n2[1] - 0.5 - g2]) });
              else
                for (var T2 = 0; T2 < 4; T2++) {
                  var E2 = (m2 << 1) + T2 % 2, I2 = (g2 << 1) + (T2 >> 1);
                  u2.push({ aabb: f2.aabb.quadrant(T2), zoom: f2.zoom + 1, x: E2, y: I2, wrap: f2.wrap, fullyVisible: v2 });
                }
            }
            return h2.sort(function(t2, e3) {
              return t2.distanceSq - e3.distanceSq;
            }).map(function(t2) {
              return t2.tileID;
            });
          }, To.prototype.resize = function(t2, e2) {
            this.width = t2, this.height = e2, this.pixelsToGLUnits = [2 / t2, -2 / e2], this._constrain(), this._calcMatrices();
          }, Eo.unmodified.get = function() {
            return this._unmodified;
          }, To.prototype.zoomScale = function(t2) {
            return Math.pow(2, t2);
          }, To.prototype.scaleZoom = function(t2) {
            return Math.log(t2) / Math.LN2;
          }, To.prototype.project = function(e2) {
            var i2 = t.clamp(e2.lat, -this.maxValidLatitude, this.maxValidLatitude);
            return new t.Point(t.mercatorXfromLng(e2.lng) * this.worldSize, t.mercatorYfromLat(i2) * this.worldSize);
          }, To.prototype.unproject = function(e2) {
            return new t.MercatorCoordinate(e2.x / this.worldSize, e2.y / this.worldSize).toLngLat();
          }, Eo.point.get = function() {
            return this.project(this.center);
          }, To.prototype.setLocationAtPoint = function(e2, i2) {
            var o2 = this.pointCoordinate(i2), r2 = this.pointCoordinate(this.centerPoint), a2 = this.locationCoordinate(e2), n2 = new t.MercatorCoordinate(a2.x - (o2.x - r2.x), a2.y - (o2.y - r2.y));
            this.center = this.coordinateLocation(n2), this._renderWorldCopies && (this.center = this.center.wrap());
          }, To.prototype.locationPoint = function(t2) {
            return this.coordinatePoint(this.locationCoordinate(t2));
          }, To.prototype.pointLocation = function(t2) {
            return this.coordinateLocation(this.pointCoordinate(t2));
          }, To.prototype.locationCoordinate = function(e2) {
            return t.MercatorCoordinate.fromLngLat(e2);
          }, To.prototype.coordinateLocation = function(t2) {
            return t2.toLngLat();
          }, To.prototype.pointCoordinate = function(e2) {
            var i2 = [e2.x, e2.y, 0, 1], o2 = [e2.x, e2.y, 1, 1];
            t.transformMat4(i2, i2, this.pixelMatrixInverse), t.transformMat4(o2, o2, this.pixelMatrixInverse);
            var r2 = i2[3], a2 = o2[3], n2 = i2[1] / r2, s2 = o2[1] / a2, l2 = i2[2] / r2, c2 = o2[2] / a2, u2 = l2 === c2 ? 0 : (0 - l2) / (c2 - l2);
            return new t.MercatorCoordinate(t.number(i2[0] / r2, o2[0] / a2, u2) / this.worldSize, t.number(n2, s2, u2) / this.worldSize);
          }, To.prototype.coordinatePoint = function(e2) {
            var i2 = [e2.x * this.worldSize, e2.y * this.worldSize, 0, 1];
            return t.transformMat4(i2, i2, this.pixelMatrix), new t.Point(i2[0] / i2[3], i2[1] / i2[3]);
          }, To.prototype.getBounds = function() {
            return new t.LngLatBounds().extend(this.pointLocation(new t.Point(0, 0))).extend(this.pointLocation(new t.Point(this.width, 0))).extend(this.pointLocation(new t.Point(this.width, this.height))).extend(this.pointLocation(new t.Point(0, this.height)));
          }, To.prototype.getMaxBounds = function() {
            return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new t.LngLatBounds([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
          }, To.prototype.setMaxBounds = function(t2) {
            t2 ? (this.lngRange = [t2.getWest(), t2.getEast()], this.latRange = [t2.getSouth(), t2.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);
          }, To.prototype.calculatePosMatrix = function(e2, i2) {
            void 0 === i2 && (i2 = false);
            var o2 = e2.key, r2 = i2 ? this._alignedPosMatrixCache : this._posMatrixCache;
            if (r2[o2])
              return r2[o2];
            var a2 = e2.canonical, n2 = this.worldSize / this.zoomScale(a2.z), s2 = a2.x + Math.pow(2, a2.z) * e2.wrap, l2 = t.identity(new Float64Array(16));
            return t.translate(l2, l2, [s2 * n2, a2.y * n2, 0]), t.scale(l2, l2, [n2 / t.EXTENT, n2 / t.EXTENT, 1]), t.multiply(l2, i2 ? this.alignedProjMatrix : this.projMatrix, l2), r2[o2] = new Float32Array(l2), r2[o2];
          }, To.prototype.customLayerMatrix = function() {
            return this.mercatorMatrix.slice();
          }, To.prototype._constrain = function() {
            if (this.center && this.width && this.height && !this._constraining) {
              this._constraining = true;
              var e2, i2, o2, r2, a2 = -90, n2 = 90, s2 = -180, l2 = 180, c2 = this.size, u2 = this._unmodified;
              if (this.latRange) {
                var h2 = this.latRange;
                a2 = t.mercatorYfromLat(h2[1]) * this.worldSize, e2 = (n2 = t.mercatorYfromLat(h2[0]) * this.worldSize) - a2 < c2.y ? c2.y / (n2 - a2) : 0;
              }
              if (this.lngRange) {
                var p2 = this.lngRange;
                s2 = t.mercatorXfromLng(p2[0]) * this.worldSize, i2 = (l2 = t.mercatorXfromLng(p2[1]) * this.worldSize) - s2 < c2.x ? c2.x / (l2 - s2) : 0;
              }
              var d2 = this.point, _2 = Math.max(i2 || 0, e2 || 0);
              if (_2)
                return this.center = this.unproject(new t.Point(i2 ? (l2 + s2) / 2 : d2.x, e2 ? (n2 + a2) / 2 : d2.y)), this.zoom += this.scaleZoom(_2), this._unmodified = u2, void (this._constraining = false);
              if (this.latRange) {
                var f2 = d2.y, m2 = c2.y / 2;
                f2 - m2 < a2 && (r2 = a2 + m2), f2 + m2 > n2 && (r2 = n2 - m2);
              }
              if (this.lngRange) {
                var g2 = d2.x, v2 = c2.x / 2;
                g2 - v2 < s2 && (o2 = s2 + v2), g2 + v2 > l2 && (o2 = l2 - v2);
              }
              void 0 === o2 && void 0 === r2 || (this.center = this.unproject(new t.Point(void 0 !== o2 ? o2 : d2.x, void 0 !== r2 ? r2 : d2.y))), this._unmodified = u2, this._constraining = false;
            }
          }, To.prototype._calcMatrices = function() {
            if (this.height) {
              var e2 = this.centerOffset;
              this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height;
              var i2 = Math.PI / 2 + this._pitch, o2 = this._fov * (0.5 + e2.y / this.height), r2 = Math.sin(o2) * this.cameraToCenterDistance / Math.sin(t.clamp(Math.PI - i2 - o2, 0.01, Math.PI - 0.01)), a2 = this.point, n2 = a2.x, s2 = a2.y, l2 = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * r2 + this.cameraToCenterDistance), c2 = this.height / 50, u2 = new Float64Array(16);
              t.perspective(u2, this._fov, this.width / this.height, c2, l2), u2[8] = 2 * -e2.x / this.width, u2[9] = 2 * e2.y / this.height, t.scale(u2, u2, [1, -1, 1]), t.translate(u2, u2, [0, 0, -this.cameraToCenterDistance]), t.rotateX(u2, u2, this._pitch), t.rotateZ(u2, u2, this.angle), t.translate(u2, u2, [-n2, -s2, 0]), this.mercatorMatrix = t.scale([], u2, [this.worldSize, this.worldSize, this.worldSize]), t.scale(u2, u2, [1, 1, t.mercatorZfromAltitude(1, this.center.lat) * this.worldSize, 1]), this.projMatrix = u2, this.invProjMatrix = t.invert([], this.projMatrix);
              var h2 = this.width % 2 / 2, p2 = this.height % 2 / 2, d2 = Math.cos(this.angle), _2 = Math.sin(this.angle), f2 = n2 - Math.round(n2) + d2 * h2 + _2 * p2, m2 = s2 - Math.round(s2) + d2 * p2 + _2 * h2, g2 = new Float64Array(u2);
              if (t.translate(g2, g2, [f2 > 0.5 ? f2 - 1 : f2, m2 > 0.5 ? m2 - 1 : m2, 0]), this.alignedProjMatrix = g2, u2 = t.create(), t.scale(u2, u2, [this.width / 2, -this.height / 2, 1]), t.translate(u2, u2, [1, -1, 0]), this.labelPlaneMatrix = u2, u2 = t.create(), t.scale(u2, u2, [1, -1, 1]), t.translate(u2, u2, [-1, -1, 0]), t.scale(u2, u2, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = u2, this.pixelMatrix = t.multiply(new Float64Array(16), this.labelPlaneMatrix, this.projMatrix), !(u2 = t.invert(new Float64Array(16), this.pixelMatrix)))
                throw new Error("failed to invert matrix");
              this.pixelMatrixInverse = u2, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
            }
          }, To.prototype.maxPitchScaleFactor = function() {
            if (!this.pixelMatrixInverse)
              return 1;
            var e2 = this.pointCoordinate(new t.Point(0, 0)), i2 = [e2.x * this.worldSize, e2.y * this.worldSize, 0, 1];
            return t.transformMat4(i2, i2, this.pixelMatrix)[3] / this.cameraToCenterDistance;
          }, To.prototype.getCameraPoint = function() {
            var e2 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
            return this.centerPoint.add(new t.Point(0, e2));
          }, To.prototype.getCameraQueryGeometry = function(e2) {
            var i2 = this.getCameraPoint();
            if (1 === e2.length)
              return [e2[0], i2];
            for (var o2 = i2.x, r2 = i2.y, a2 = i2.x, n2 = i2.y, s2 = 0, l2 = e2; s2 < l2.length; s2 += 1) {
              var c2 = l2[s2];
              o2 = Math.min(o2, c2.x), r2 = Math.min(r2, c2.y), a2 = Math.max(a2, c2.x), n2 = Math.max(n2, c2.y);
            }
            return [new t.Point(o2, r2), new t.Point(a2, r2), new t.Point(a2, n2), new t.Point(o2, n2), new t.Point(o2, r2)];
          }, Object.defineProperties(To.prototype, Eo);
          var Io = function(e2) {
            var i2, o2, r2, a2;
            this._hashName = e2 && encodeURIComponent(e2), t.bindAll(["_getCurrentHash", "_onHashChange", "_updateHash"], this), this._updateHash = (i2 = this._updateHashUnthrottled.bind(this), o2 = false, r2 = null, a2 = function() {
              r2 = null, o2 && (i2(), r2 = setTimeout(a2, 300), o2 = false);
            }, function() {
              return o2 = true, r2 || a2(), r2;
            });
          };
          Io.prototype.addTo = function(e2) {
            return this._map = e2, t.window.addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
          }, Io.prototype.remove = function() {
            return t.window.removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
          }, Io.prototype.getHashString = function(e2) {
            var i2 = this._map.getCenter(), o2 = Math.round(100 * this._map.getZoom()) / 100, r2 = Math.ceil((o2 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), a2 = Math.pow(10, r2), n2 = Math.round(i2.lng * a2) / a2, s2 = Math.round(i2.lat * a2) / a2, l2 = this._map.getBearing(), c2 = this._map.getPitch(), u2 = "";
            if (u2 += e2 ? "/" + n2 + "/" + s2 + "/" + o2 : o2 + "/" + s2 + "/" + n2, (l2 || c2) && (u2 += "/" + Math.round(10 * l2) / 10), c2 && (u2 += "/" + Math.round(c2)), this._hashName) {
              var h2 = this._hashName, p2 = false, d2 = t.window.location.hash.slice(1).split("&").map(function(t2) {
                var e3 = t2.split("=")[0];
                return e3 === h2 ? (p2 = true, e3 + "=" + u2) : t2;
              }).filter(function(t2) {
                return t2;
              });
              return p2 || d2.push(h2 + "=" + u2), "#" + d2.join("&");
            }
            return "#" + u2;
          }, Io.prototype._getCurrentHash = function() {
            var e2, i2 = this, o2 = t.window.location.hash.replace("#", "");
            return this._hashName ? (o2.split("&").map(function(t2) {
              return t2.split("=");
            }).forEach(function(t2) {
              t2[0] === i2._hashName && (e2 = t2);
            }), (e2 && e2[1] || "").split("/")) : o2.split("/");
          }, Io.prototype._onHashChange = function() {
            var t2 = this._getCurrentHash();
            if (t2.length >= 3 && !t2.some(function(t3) {
              return isNaN(t3);
            })) {
              var e2 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t2[3] || 0) : this._map.getBearing();
              return this._map.jumpTo({ center: [+t2[2], +t2[1]], zoom: +t2[0], bearing: e2, pitch: +(t2[4] || 0) }), true;
            }
            return false;
          }, Io.prototype._updateHashUnthrottled = function() {
            var e2 = t.window.location.href.replace(/(#.+)?$/, this.getHashString());
            try {
              t.window.history.replaceState(t.window.history.state, null, e2);
            } catch (t2) {
            }
          };
          var Po = { linearity: 0.3, easing: t.bezier(0, 0, 0.3, 1) }, So = t.extend({ deceleration: 2500, maxSpeed: 1400 }, Po), Co = t.extend({ deceleration: 20, maxSpeed: 1400 }, Po), zo = t.extend({ deceleration: 1e3, maxSpeed: 360 }, Po), Do = t.extend({ deceleration: 1e3, maxSpeed: 90 }, Po), Ao = function(t2) {
            this._map = t2, this.clear();
          };
          function Mo(t2, e2) {
            (!t2.duration || t2.duration < e2.duration) && (t2.duration = e2.duration, t2.easing = e2.easing);
          }
          function Lo(e2, i2, o2) {
            var r2 = o2.maxSpeed, a2 = o2.linearity, n2 = o2.deceleration, s2 = t.clamp(e2 * a2 / (i2 / 1e3), -r2, r2), l2 = Math.abs(s2) / (n2 * a2);
            return { easing: o2.easing, duration: 1e3 * l2, amount: s2 * (l2 / 2) };
          }
          Ao.prototype.clear = function() {
            this._inertiaBuffer = [];
          }, Ao.prototype.record = function(e2) {
            this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: t.browser.now(), settings: e2 });
          }, Ao.prototype._drainInertiaBuffer = function() {
            for (var e2 = this._inertiaBuffer, i2 = t.browser.now(); e2.length > 0 && i2 - e2[0].time > 160; )
              e2.shift();
          }, Ao.prototype._onMoveEnd = function(e2) {
            if (this._drainInertiaBuffer(), !(this._inertiaBuffer.length < 2)) {
              for (var i2 = { zoom: 0, bearing: 0, pitch: 0, pan: new t.Point(0, 0), pinchAround: void 0, around: void 0 }, o2 = 0, r2 = this._inertiaBuffer; o2 < r2.length; o2 += 1) {
                var a2 = r2[o2].settings;
                i2.zoom += a2.zoomDelta || 0, i2.bearing += a2.bearingDelta || 0, i2.pitch += a2.pitchDelta || 0, a2.panDelta && i2.pan._add(a2.panDelta), a2.around && (i2.around = a2.around), a2.pinchAround && (i2.pinchAround = a2.pinchAround);
              }
              var n2 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, s2 = {};
              if (i2.pan.mag()) {
                var l2 = Lo(i2.pan.mag(), n2, t.extend({}, So, e2 || {}));
                s2.offset = i2.pan.mult(l2.amount / i2.pan.mag()), s2.center = this._map.transform.center, Mo(s2, l2);
              }
              if (i2.zoom) {
                var c2 = Lo(i2.zoom, n2, Co);
                s2.zoom = this._map.transform.zoom + c2.amount, Mo(s2, c2);
              }
              if (i2.bearing) {
                var u2 = Lo(i2.bearing, n2, zo);
                s2.bearing = this._map.transform.bearing + t.clamp(u2.amount, -179, 179), Mo(s2, u2);
              }
              if (i2.pitch) {
                var h2 = Lo(i2.pitch, n2, Do);
                s2.pitch = this._map.transform.pitch + h2.amount, Mo(s2, h2);
              }
              if (s2.zoom || s2.bearing) {
                var p2 = void 0 === i2.pinchAround ? i2.around : i2.pinchAround;
                s2.around = p2 ? this._map.unproject(p2) : this._map.getCenter();
              }
              return this.clear(), t.extend(s2, { noMoveStart: true });
            }
          };
          var Ro = function(e2) {
            function o2(o3, r3, a2, n2) {
              void 0 === n2 && (n2 = {});
              var s2 = i.mousePos(r3.getCanvasContainer(), a2), l2 = r3.unproject(s2);
              e2.call(this, o3, t.extend({ point: s2, lngLat: l2, originalEvent: a2 }, n2)), this._defaultPrevented = false, this.target = r3;
            }
            e2 && (o2.__proto__ = e2), (o2.prototype = Object.create(e2 && e2.prototype)).constructor = o2;
            var r2 = { defaultPrevented: { configurable: true } };
            return o2.prototype.preventDefault = function() {
              this._defaultPrevented = true;
            }, r2.defaultPrevented.get = function() {
              return this._defaultPrevented;
            }, Object.defineProperties(o2.prototype, r2), o2;
          }(t.Event), ko = function(e2) {
            function o2(o3, r3, a2) {
              var n2 = "touchend" === o3 ? a2.changedTouches : a2.touches, s2 = i.touchPos(r3.getCanvasContainer(), n2), l2 = s2.map(function(t2) {
                return r3.unproject(t2);
              }), c2 = s2.reduce(function(t2, e3, i2, o4) {
                return t2.add(e3.div(o4.length));
              }, new t.Point(0, 0)), u2 = r3.unproject(c2);
              e2.call(this, o3, { points: s2, point: c2, lngLats: l2, lngLat: u2, originalEvent: a2 }), this._defaultPrevented = false;
            }
            e2 && (o2.__proto__ = e2), (o2.prototype = Object.create(e2 && e2.prototype)).constructor = o2;
            var r2 = { defaultPrevented: { configurable: true } };
            return o2.prototype.preventDefault = function() {
              this._defaultPrevented = true;
            }, r2.defaultPrevented.get = function() {
              return this._defaultPrevented;
            }, Object.defineProperties(o2.prototype, r2), o2;
          }(t.Event), Bo = function(t2) {
            function e2(e3, i3, o2) {
              t2.call(this, e3, { originalEvent: o2 }), this._defaultPrevented = false;
            }
            t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2;
            var i2 = { defaultPrevented: { configurable: true } };
            return e2.prototype.preventDefault = function() {
              this._defaultPrevented = true;
            }, i2.defaultPrevented.get = function() {
              return this._defaultPrevented;
            }, Object.defineProperties(e2.prototype, i2), e2;
          }(t.Event), Oo = function(t2, e2) {
            this._map = t2, this._clickTolerance = e2.clickTolerance;
          };
          Oo.prototype.reset = function() {
            delete this._mousedownPos;
          }, Oo.prototype.wheel = function(t2) {
            return this._firePreventable(new Bo(t2.type, this._map, t2));
          }, Oo.prototype.mousedown = function(t2, e2) {
            return this._mousedownPos = e2, this._firePreventable(new Ro(t2.type, this._map, t2));
          }, Oo.prototype.mouseup = function(t2) {
            this._map.fire(new Ro(t2.type, this._map, t2));
          }, Oo.prototype.click = function(t2, e2) {
            this._mousedownPos && this._mousedownPos.dist(e2) >= this._clickTolerance || this._map.fire(new Ro(t2.type, this._map, t2));
          }, Oo.prototype.dblclick = function(t2) {
            return this._firePreventable(new Ro(t2.type, this._map, t2));
          }, Oo.prototype.mouseover = function(t2) {
            this._map.fire(new Ro(t2.type, this._map, t2));
          }, Oo.prototype.mouseout = function(t2) {
            this._map.fire(new Ro(t2.type, this._map, t2));
          }, Oo.prototype.touchstart = function(t2) {
            return this._firePreventable(new ko(t2.type, this._map, t2));
          }, Oo.prototype.touchmove = function(t2) {
            this._map.fire(new ko(t2.type, this._map, t2));
          }, Oo.prototype.touchend = function(t2) {
            this._map.fire(new ko(t2.type, this._map, t2));
          }, Oo.prototype.touchcancel = function(t2) {
            this._map.fire(new ko(t2.type, this._map, t2));
          }, Oo.prototype._firePreventable = function(t2) {
            if (this._map.fire(t2), t2.defaultPrevented)
              return {};
          }, Oo.prototype.isEnabled = function() {
            return true;
          }, Oo.prototype.isActive = function() {
            return false;
          }, Oo.prototype.enable = function() {
          }, Oo.prototype.disable = function() {
          };
          var Fo = function(t2) {
            this._map = t2;
          };
          Fo.prototype.reset = function() {
            this._delayContextMenu = false, delete this._contextMenuEvent;
          }, Fo.prototype.mousemove = function(t2) {
            this._map.fire(new Ro(t2.type, this._map, t2));
          }, Fo.prototype.mousedown = function() {
            this._delayContextMenu = true;
          }, Fo.prototype.mouseup = function() {
            this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new Ro("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
          }, Fo.prototype.contextmenu = function(t2) {
            this._delayContextMenu ? this._contextMenuEvent = t2 : this._map.fire(new Ro(t2.type, this._map, t2)), this._map.listens("contextmenu") && t2.preventDefault();
          }, Fo.prototype.isEnabled = function() {
            return true;
          }, Fo.prototype.isActive = function() {
            return false;
          }, Fo.prototype.enable = function() {
          }, Fo.prototype.disable = function() {
          };
          var Uo = function(t2, e2) {
            this._map = t2, this._el = t2.getCanvasContainer(), this._container = t2.getContainer(), this._clickTolerance = e2.clickTolerance || 1;
          };
          function No(t2, e2) {
            for (var i2 = {}, o2 = 0; o2 < t2.length; o2++)
              i2[t2[o2].identifier] = e2[o2];
            return i2;
          }
          Uo.prototype.isEnabled = function() {
            return !!this._enabled;
          }, Uo.prototype.isActive = function() {
            return !!this._active;
          }, Uo.prototype.enable = function() {
            this.isEnabled() || (this._enabled = true);
          }, Uo.prototype.disable = function() {
            this.isEnabled() && (this._enabled = false);
          }, Uo.prototype.mousedown = function(t2, e2) {
            this.isEnabled() && t2.shiftKey && 0 === t2.button && (i.disableDrag(), this._startPos = this._lastPos = e2, this._active = true);
          }, Uo.prototype.mousemoveWindow = function(t2, e2) {
            if (this._active) {
              var o2 = e2;
              if (!(this._lastPos.equals(o2) || !this._box && o2.dist(this._startPos) < this._clickTolerance)) {
                var r2 = this._startPos;
                this._lastPos = o2, this._box || (this._box = i.create("div", "mapboxgl-boxzoom", this._container), this._container.classList.add("mapboxgl-crosshair"), this._fireEvent("boxzoomstart", t2));
                var a2 = Math.min(r2.x, o2.x), n2 = Math.max(r2.x, o2.x), s2 = Math.min(r2.y, o2.y), l2 = Math.max(r2.y, o2.y);
                i.setTransform(this._box, "translate(" + a2 + "px," + s2 + "px)"), this._box.style.width = n2 - a2 + "px", this._box.style.height = l2 - s2 + "px";
              }
            }
          }, Uo.prototype.mouseupWindow = function(e2, o2) {
            var r2 = this;
            if (this._active && 0 === e2.button) {
              var a2 = this._startPos, n2 = o2;
              if (this.reset(), i.suppressClick(), a2.x !== n2.x || a2.y !== n2.y)
                return this._map.fire(new t.Event("boxzoomend", { originalEvent: e2 })), { cameraAnimation: function(t2) {
                  return t2.fitScreenCoordinates(a2, n2, r2._map.getBearing(), { linear: true });
                } };
              this._fireEvent("boxzoomcancel", e2);
            }
          }, Uo.prototype.keydown = function(t2) {
            this._active && 27 === t2.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", t2));
          }, Uo.prototype.blur = function() {
            this.reset();
          }, Uo.prototype.reset = function() {
            this._active = false, this._container.classList.remove("mapboxgl-crosshair"), this._box && (i.remove(this._box), this._box = null), i.enableDrag(), delete this._startPos, delete this._lastPos;
          }, Uo.prototype._fireEvent = function(e2, i2) {
            return this._map.fire(new t.Event(e2, { originalEvent: i2 }));
          };
          var Zo = function(t2) {
            this.reset(), this.numTouches = t2.numTouches;
          };
          Zo.prototype.reset = function() {
            delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
          }, Zo.prototype.touchstart = function(e2, i2, o2) {
            (this.centroid || o2.length > this.numTouches) && (this.aborted = true), this.aborted || (void 0 === this.startTime && (this.startTime = e2.timeStamp), o2.length === this.numTouches && (this.centroid = function(e3) {
              for (var i3 = new t.Point(0, 0), o3 = 0, r2 = e3; o3 < r2.length; o3 += 1)
                i3._add(r2[o3]);
              return i3.div(e3.length);
            }(i2), this.touches = No(o2, i2)));
          }, Zo.prototype.touchmove = function(t2, e2, i2) {
            if (!this.aborted && this.centroid) {
              var o2 = No(i2, e2);
              for (var r2 in this.touches) {
                var a2 = o2[r2];
                (!a2 || a2.dist(this.touches[r2]) > 30) && (this.aborted = true);
              }
            }
          }, Zo.prototype.touchend = function(t2, e2, i2) {
            if ((!this.centroid || t2.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i2.length) {
              var o2 = !this.aborted && this.centroid;
              if (this.reset(), o2)
                return o2;
            }
          };
          var qo = function(t2) {
            this.singleTap = new Zo(t2), this.numTaps = t2.numTaps, this.reset();
          };
          qo.prototype.reset = function() {
            this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
          }, qo.prototype.touchstart = function(t2, e2, i2) {
            this.singleTap.touchstart(t2, e2, i2);
          }, qo.prototype.touchmove = function(t2, e2, i2) {
            this.singleTap.touchmove(t2, e2, i2);
          }, qo.prototype.touchend = function(t2, e2, i2) {
            var o2 = this.singleTap.touchend(t2, e2, i2);
            if (o2) {
              var r2 = t2.timeStamp - this.lastTime < 500, a2 = !this.lastTap || this.lastTap.dist(o2) < 30;
              if (r2 && a2 || this.reset(), this.count++, this.lastTime = t2.timeStamp, this.lastTap = o2, this.count === this.numTaps)
                return this.reset(), o2;
            }
          };
          var jo = function() {
            this._zoomIn = new qo({ numTouches: 1, numTaps: 2 }), this._zoomOut = new qo({ numTouches: 2, numTaps: 1 }), this.reset();
          };
          jo.prototype.reset = function() {
            this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
          }, jo.prototype.touchstart = function(t2, e2, i2) {
            this._zoomIn.touchstart(t2, e2, i2), this._zoomOut.touchstart(t2, e2, i2);
          }, jo.prototype.touchmove = function(t2, e2, i2) {
            this._zoomIn.touchmove(t2, e2, i2), this._zoomOut.touchmove(t2, e2, i2);
          }, jo.prototype.touchend = function(t2, e2, i2) {
            var o2 = this, r2 = this._zoomIn.touchend(t2, e2, i2), a2 = this._zoomOut.touchend(t2, e2, i2);
            return r2 ? (this._active = true, t2.preventDefault(), setTimeout(function() {
              return o2.reset();
            }, 0), { cameraAnimation: function(e3) {
              return e3.easeTo({ duration: 300, zoom: e3.getZoom() + 1, around: e3.unproject(r2) }, { originalEvent: t2 });
            } }) : a2 ? (this._active = true, t2.preventDefault(), setTimeout(function() {
              return o2.reset();
            }, 0), { cameraAnimation: function(e3) {
              return e3.easeTo({ duration: 300, zoom: e3.getZoom() - 1, around: e3.unproject(a2) }, { originalEvent: t2 });
            } }) : void 0;
          }, jo.prototype.touchcancel = function() {
            this.reset();
          }, jo.prototype.enable = function() {
            this._enabled = true;
          }, jo.prototype.disable = function() {
            this._enabled = false, this.reset();
          }, jo.prototype.isEnabled = function() {
            return this._enabled;
          }, jo.prototype.isActive = function() {
            return this._active;
          };
          var Vo = { 0: 1, 2: 2 }, Go = function(t2) {
            this.reset(), this._clickTolerance = t2.clickTolerance || 1;
          };
          Go.prototype.blur = function() {
            this.reset();
          }, Go.prototype.reset = function() {
            this._active = false, this._moved = false, delete this._lastPoint, delete this._eventButton;
          }, Go.prototype._correctButton = function(t2, e2) {
            return false;
          }, Go.prototype._move = function(t2, e2) {
            return {};
          }, Go.prototype.mousedown = function(t2, e2) {
            if (!this._lastPoint) {
              var o2 = i.mouseButton(t2);
              this._correctButton(t2, o2) && (this._lastPoint = e2, this._eventButton = o2);
            }
          }, Go.prototype.mousemoveWindow = function(t2, e2) {
            var i2 = this._lastPoint;
            if (i2) {
              if (t2.preventDefault(), function(t3, e3) {
                var i3 = Vo[e3];
                return void 0 === t3.buttons || (t3.buttons & i3) !== i3;
              }(t2, this._eventButton))
                this.reset();
              else if (this._moved || !(e2.dist(i2) < this._clickTolerance))
                return this._moved = true, this._lastPoint = e2, this._move(i2, e2);
            }
          }, Go.prototype.mouseupWindow = function(t2) {
            this._lastPoint && i.mouseButton(t2) === this._eventButton && (this._moved && i.suppressClick(), this.reset());
          }, Go.prototype.enable = function() {
            this._enabled = true;
          }, Go.prototype.disable = function() {
            this._enabled = false, this.reset();
          }, Go.prototype.isEnabled = function() {
            return this._enabled;
          }, Go.prototype.isActive = function() {
            return this._active;
          };
          var Wo = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.mousedown = function(e3, i2) {
              t2.prototype.mousedown.call(this, e3, i2), this._lastPoint && (this._active = true);
            }, e2.prototype._correctButton = function(t3, e3) {
              return 0 === e3 && !t3.ctrlKey;
            }, e2.prototype._move = function(t3, e3) {
              return { around: e3, panDelta: e3.sub(t3) };
            }, e2;
          }(Go), Xo = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._correctButton = function(t3, e3) {
              return 0 === e3 && t3.ctrlKey || 2 === e3;
            }, e2.prototype._move = function(t3, e3) {
              var i2 = 0.8 * (e3.x - t3.x);
              if (i2)
                return this._active = true, { bearingDelta: i2 };
            }, e2.prototype.contextmenu = function(t3) {
              t3.preventDefault();
            }, e2;
          }(Go), Ho = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype._correctButton = function(t3, e3) {
              return 0 === e3 && t3.ctrlKey || 2 === e3;
            }, e2.prototype._move = function(t3, e3) {
              var i2 = -0.5 * (e3.y - t3.y);
              if (i2)
                return this._active = true, { pitchDelta: i2 };
            }, e2.prototype.contextmenu = function(t3) {
              t3.preventDefault();
            }, e2;
          }(Go), Ko = function(t2) {
            this._minTouches = 1, this._clickTolerance = t2.clickTolerance || 1, this.reset();
          };
          Ko.prototype.reset = function() {
            this._active = false, this._touches = {}, this._sum = new t.Point(0, 0);
          }, Ko.prototype.touchstart = function(t2, e2, i2) {
            return this._calculateTransform(t2, e2, i2);
          }, Ko.prototype.touchmove = function(t2, e2, i2) {
            if (this._active && !(i2.length < this._minTouches))
              return t2.preventDefault(), this._calculateTransform(t2, e2, i2);
          }, Ko.prototype.touchend = function(t2, e2, i2) {
            this._calculateTransform(t2, e2, i2), this._active && i2.length < this._minTouches && this.reset();
          }, Ko.prototype.touchcancel = function() {
            this.reset();
          }, Ko.prototype._calculateTransform = function(e2, i2, o2) {
            o2.length > 0 && (this._active = true);
            var r2 = No(o2, i2), a2 = new t.Point(0, 0), n2 = new t.Point(0, 0), s2 = 0;
            for (var l2 in r2) {
              var c2 = r2[l2], u2 = this._touches[l2];
              u2 && (a2._add(c2), n2._add(c2.sub(u2)), s2++, r2[l2] = c2);
            }
            if (this._touches = r2, !(s2 < this._minTouches) && n2.mag()) {
              var h2 = n2.div(s2);
              if (this._sum._add(h2), !(this._sum.mag() < this._clickTolerance))
                return { around: a2.div(s2), panDelta: h2 };
            }
          }, Ko.prototype.enable = function() {
            this._enabled = true;
          }, Ko.prototype.disable = function() {
            this._enabled = false, this.reset();
          }, Ko.prototype.isEnabled = function() {
            return this._enabled;
          }, Ko.prototype.isActive = function() {
            return this._active;
          };
          var Yo = function() {
            this.reset();
          };
          function Jo(t2, e2, i2) {
            for (var o2 = 0; o2 < t2.length; o2++)
              if (t2[o2].identifier === i2)
                return e2[o2];
          }
          function Qo(t2, e2) {
            return Math.log(t2 / e2) / Math.LN2;
          }
          Yo.prototype.reset = function() {
            this._active = false, delete this._firstTwoTouches;
          }, Yo.prototype._start = function(t2) {
          }, Yo.prototype._move = function(t2, e2, i2) {
            return {};
          }, Yo.prototype.touchstart = function(t2, e2, i2) {
            this._firstTwoTouches || i2.length < 2 || (this._firstTwoTouches = [i2[0].identifier, i2[1].identifier], this._start([e2[0], e2[1]]));
          }, Yo.prototype.touchmove = function(t2, e2, i2) {
            if (this._firstTwoTouches) {
              t2.preventDefault();
              var o2 = this._firstTwoTouches, r2 = o2[1], a2 = Jo(i2, e2, o2[0]), n2 = Jo(i2, e2, r2);
              if (a2 && n2) {
                var s2 = this._aroundCenter ? null : a2.add(n2).div(2);
                return this._move([a2, n2], s2, t2);
              }
            }
          }, Yo.prototype.touchend = function(t2, e2, o2) {
            if (this._firstTwoTouches) {
              var r2 = this._firstTwoTouches, a2 = r2[1], n2 = Jo(o2, e2, r2[0]), s2 = Jo(o2, e2, a2);
              n2 && s2 || (this._active && i.suppressClick(), this.reset());
            }
          }, Yo.prototype.touchcancel = function() {
            this.reset();
          }, Yo.prototype.enable = function(t2) {
            this._enabled = true, this._aroundCenter = !!t2 && "center" === t2.around;
          }, Yo.prototype.disable = function() {
            this._enabled = false, this.reset();
          }, Yo.prototype.isEnabled = function() {
            return this._enabled;
          }, Yo.prototype.isActive = function() {
            return this._active;
          };
          var $o = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.reset = function() {
              t2.prototype.reset.call(this), delete this._distance, delete this._startDistance;
            }, e2.prototype._start = function(t3) {
              this._startDistance = this._distance = t3[0].dist(t3[1]);
            }, e2.prototype._move = function(t3, e3) {
              var i2 = this._distance;
              if (this._distance = t3[0].dist(t3[1]), this._active || !(Math.abs(Qo(this._distance, this._startDistance)) < 0.1))
                return this._active = true, { zoomDelta: Qo(this._distance, i2), pinchAround: e3 };
            }, e2;
          }(Yo);
          function tr(t2, e2) {
            return 180 * t2.angleWith(e2) / Math.PI;
          }
          var er = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.reset = function() {
              t2.prototype.reset.call(this), delete this._minDiameter, delete this._startVector, delete this._vector;
            }, e2.prototype._start = function(t3) {
              this._startVector = this._vector = t3[0].sub(t3[1]), this._minDiameter = t3[0].dist(t3[1]);
            }, e2.prototype._move = function(t3, e3) {
              var i2 = this._vector;
              if (this._vector = t3[0].sub(t3[1]), this._active || !this._isBelowThreshold(this._vector))
                return this._active = true, { bearingDelta: tr(this._vector, i2), pinchAround: e3 };
            }, e2.prototype._isBelowThreshold = function(t3) {
              this._minDiameter = Math.min(this._minDiameter, t3.mag());
              var e3 = 25 / (Math.PI * this._minDiameter) * 360, i2 = tr(t3, this._startVector);
              return Math.abs(i2) < e3;
            }, e2;
          }(Yo);
          function ir(t2) {
            return Math.abs(t2.y) > Math.abs(t2.x);
          }
          var or2 = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2.prototype.reset = function() {
              t2.prototype.reset.call(this), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
            }, e2.prototype._start = function(t3) {
              this._lastPoints = t3, ir(t3[0].sub(t3[1])) && (this._valid = false);
            }, e2.prototype._move = function(t3, e3, i2) {
              var o2 = t3[0].sub(this._lastPoints[0]), r2 = t3[1].sub(this._lastPoints[1]);
              if (this._valid = this.gestureBeginsVertically(o2, r2, i2.timeStamp), this._valid)
                return this._lastPoints = t3, this._active = true, { pitchDelta: (o2.y + r2.y) / 2 * -0.5 };
            }, e2.prototype.gestureBeginsVertically = function(t3, e3, i2) {
              if (void 0 !== this._valid)
                return this._valid;
              var o2 = t3.mag() >= 2, r2 = e3.mag() >= 2;
              if (o2 || r2) {
                if (!o2 || !r2)
                  return void 0 === this._firstMove && (this._firstMove = i2), i2 - this._firstMove < 100 && void 0;
                var a2 = t3.y > 0 == e3.y > 0;
                return ir(t3) && ir(e3) && a2;
              }
            }, e2;
          }(Yo), rr = { panStep: 100, bearingStep: 15, pitchStep: 10 }, ar = function() {
            var t2 = rr;
            this._panStep = t2.panStep, this._bearingStep = t2.bearingStep, this._pitchStep = t2.pitchStep, this._rotationDisabled = false;
          };
          function nr(t2) {
            return t2 * (2 - t2);
          }
          ar.prototype.blur = function() {
            this.reset();
          }, ar.prototype.reset = function() {
            this._active = false;
          }, ar.prototype.keydown = function(t2) {
            var e2 = this;
            if (!(t2.altKey || t2.ctrlKey || t2.metaKey)) {
              var i2 = 0, o2 = 0, r2 = 0, a2 = 0, n2 = 0;
              switch (t2.keyCode) {
                case 61:
                case 107:
                case 171:
                case 187:
                  i2 = 1;
                  break;
                case 189:
                case 109:
                case 173:
                  i2 = -1;
                  break;
                case 37:
                  t2.shiftKey ? o2 = -1 : (t2.preventDefault(), a2 = -1);
                  break;
                case 39:
                  t2.shiftKey ? o2 = 1 : (t2.preventDefault(), a2 = 1);
                  break;
                case 38:
                  t2.shiftKey ? r2 = 1 : (t2.preventDefault(), n2 = -1);
                  break;
                case 40:
                  t2.shiftKey ? r2 = -1 : (t2.preventDefault(), n2 = 1);
                  break;
                default:
                  return;
              }
              return this._rotationDisabled && (o2 = 0, r2 = 0), { cameraAnimation: function(s2) {
                var l2 = s2.getZoom();
                s2.easeTo({ duration: 300, easeId: "keyboardHandler", easing: nr, zoom: i2 ? Math.round(l2) + i2 * (t2.shiftKey ? 2 : 1) : l2, bearing: s2.getBearing() + o2 * e2._bearingStep, pitch: s2.getPitch() + r2 * e2._pitchStep, offset: [-a2 * e2._panStep, -n2 * e2._panStep], center: s2.getCenter() }, { originalEvent: t2 });
              } };
            }
          }, ar.prototype.enable = function() {
            this._enabled = true;
          }, ar.prototype.disable = function() {
            this._enabled = false, this.reset();
          }, ar.prototype.isEnabled = function() {
            return this._enabled;
          }, ar.prototype.isActive = function() {
            return this._active;
          }, ar.prototype.disableRotation = function() {
            this._rotationDisabled = true;
          }, ar.prototype.enableRotation = function() {
            this._rotationDisabled = false;
          };
          var sr = function(e2, i2) {
            this._map = e2, this._el = e2.getCanvasContainer(), this._handler = i2, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 1 / 450, t.bindAll(["_onTimeout"], this);
          };
          sr.prototype.setZoomRate = function(t2) {
            this._defaultZoomRate = t2;
          }, sr.prototype.setWheelZoomRate = function(t2) {
            this._wheelZoomRate = t2;
          }, sr.prototype.isEnabled = function() {
            return !!this._enabled;
          }, sr.prototype.isActive = function() {
            return !!this._active || void 0 !== this._finishTimeout;
          }, sr.prototype.isZooming = function() {
            return !!this._zooming;
          }, sr.prototype.enable = function(t2) {
            this.isEnabled() || (this._enabled = true, this._aroundCenter = t2 && "center" === t2.around);
          }, sr.prototype.disable = function() {
            this.isEnabled() && (this._enabled = false);
          }, sr.prototype.wheel = function(e2) {
            if (this.isEnabled()) {
              var i2 = e2.deltaMode === t.window.WheelEvent.DOM_DELTA_LINE ? 40 * e2.deltaY : e2.deltaY, o2 = t.browser.now(), r2 = o2 - (this._lastWheelEventTime || 0);
              this._lastWheelEventTime = o2, 0 !== i2 && i2 % 4.000244140625 == 0 ? this._type = "wheel" : 0 !== i2 && Math.abs(i2) < 4 ? this._type = "trackpad" : r2 > 400 ? (this._type = null, this._lastValue = i2, this._timeout = setTimeout(this._onTimeout, 40, e2)) : this._type || (this._type = Math.abs(r2 * i2) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i2 += this._lastValue)), e2.shiftKey && i2 && (i2 /= 4), this._type && (this._lastWheelEvent = e2, this._delta -= i2, this._active || this._start(e2)), e2.preventDefault();
            }
          }, sr.prototype._onTimeout = function(t2) {
            this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t2);
          }, sr.prototype._start = function(e2) {
            if (this._delta) {
              this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
              var o2 = i.mousePos(this._el, e2);
              this._around = t.LngLat.convert(this._aroundCenter ? this._map.getCenter() : this._map.unproject(o2)), this._aroundPoint = this._map.transform.locationPoint(this._around), this._frameId || (this._frameId = true, this._handler._triggerRenderFrame());
            }
          }, sr.prototype.renderFrame = function() {
            var e2 = this;
            if (this._frameId && (this._frameId = null, this.isActive())) {
              var i2 = this._map.transform;
              if (0 !== this._delta) {
                var o2 = "wheel" === this._type && Math.abs(this._delta) > 4.000244140625 ? this._wheelZoomRate : this._defaultZoomRate, r2 = 2 / (1 + Math.exp(-Math.abs(this._delta * o2)));
                this._delta < 0 && 0 !== r2 && (r2 = 1 / r2);
                var a2 = "number" == typeof this._targetZoom ? i2.zoomScale(this._targetZoom) : i2.scale;
                this._targetZoom = Math.min(i2.maxZoom, Math.max(i2.minZoom, i2.scaleZoom(a2 * r2))), "wheel" === this._type && (this._startZoom = i2.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
              }
              var n2, s2 = "number" == typeof this._targetZoom ? this._targetZoom : i2.zoom, l2 = this._startZoom, c2 = this._easing, u2 = false;
              if ("wheel" === this._type && l2 && c2) {
                var h2 = Math.min((t.browser.now() - this._lastWheelEventTime) / 200, 1), p2 = c2(h2);
                n2 = t.number(l2, s2, p2), h2 < 1 ? this._frameId || (this._frameId = true) : u2 = true;
              } else
                n2 = s2, u2 = true;
              return this._active = true, u2 && (this._active = false, this._finishTimeout = setTimeout(function() {
                e2._zooming = false, e2._handler._triggerRenderFrame(), delete e2._targetZoom, delete e2._finishTimeout;
              }, 200)), { noInertia: true, needsRenderFrame: !u2, zoomDelta: n2 - i2.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
            }
          }, sr.prototype._smoothOutEasing = function(e2) {
            var i2 = t.ease;
            if (this._prevEase) {
              var o2 = this._prevEase, r2 = (t.browser.now() - o2.start) / o2.duration, a2 = o2.easing(r2 + 0.01) - o2.easing(r2), n2 = 0.27 / Math.sqrt(a2 * a2 + 1e-4) * 0.01, s2 = Math.sqrt(0.0729 - n2 * n2);
              i2 = t.bezier(n2, s2, 0.25, 1);
            }
            return this._prevEase = { start: t.browser.now(), duration: e2, easing: i2 }, i2;
          }, sr.prototype.blur = function() {
            this.reset();
          }, sr.prototype.reset = function() {
            this._active = false;
          };
          var lr = function(t2, e2) {
            this._clickZoom = t2, this._tapZoom = e2;
          };
          lr.prototype.enable = function() {
            this._clickZoom.enable(), this._tapZoom.enable();
          }, lr.prototype.disable = function() {
            this._clickZoom.disable(), this._tapZoom.disable();
          }, lr.prototype.isEnabled = function() {
            return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
          }, lr.prototype.isActive = function() {
            return this._clickZoom.isActive() || this._tapZoom.isActive();
          };
          var cr = function() {
            this.reset();
          };
          cr.prototype.reset = function() {
            this._active = false;
          }, cr.prototype.blur = function() {
            this.reset();
          }, cr.prototype.dblclick = function(t2, e2) {
            return t2.preventDefault(), { cameraAnimation: function(i2) {
              i2.easeTo({ duration: 300, zoom: i2.getZoom() + (t2.shiftKey ? -1 : 1), around: i2.unproject(e2) }, { originalEvent: t2 });
            } };
          }, cr.prototype.enable = function() {
            this._enabled = true;
          }, cr.prototype.disable = function() {
            this._enabled = false, this.reset();
          }, cr.prototype.isEnabled = function() {
            return this._enabled;
          }, cr.prototype.isActive = function() {
            return this._active;
          };
          var ur = function() {
            this._tap = new qo({ numTouches: 1, numTaps: 1 }), this.reset();
          };
          ur.prototype.reset = function() {
            this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, this._tap.reset();
          }, ur.prototype.touchstart = function(t2, e2, i2) {
            this._swipePoint || (this._tapTime && t2.timeStamp - this._tapTime > 500 && this.reset(), this._tapTime ? i2.length > 0 && (this._swipePoint = e2[0], this._swipeTouch = i2[0].identifier) : this._tap.touchstart(t2, e2, i2));
          }, ur.prototype.touchmove = function(t2, e2, i2) {
            if (this._tapTime) {
              if (this._swipePoint) {
                if (i2[0].identifier !== this._swipeTouch)
                  return;
                var o2 = e2[0], r2 = o2.y - this._swipePoint.y;
                return this._swipePoint = o2, t2.preventDefault(), this._active = true, { zoomDelta: r2 / 128 };
              }
            } else
              this._tap.touchmove(t2, e2, i2);
          }, ur.prototype.touchend = function(t2, e2, i2) {
            this._tapTime ? this._swipePoint && 0 === i2.length && this.reset() : this._tap.touchend(t2, e2, i2) && (this._tapTime = t2.timeStamp);
          }, ur.prototype.touchcancel = function() {
            this.reset();
          }, ur.prototype.enable = function() {
            this._enabled = true;
          }, ur.prototype.disable = function() {
            this._enabled = false, this.reset();
          }, ur.prototype.isEnabled = function() {
            return this._enabled;
          }, ur.prototype.isActive = function() {
            return this._active;
          };
          var hr = function(t2, e2, i2) {
            this._el = t2, this._mousePan = e2, this._touchPan = i2;
          };
          hr.prototype.enable = function(t2) {
            this._inertiaOptions = t2 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("mapboxgl-touch-drag-pan");
          }, hr.prototype.disable = function() {
            this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("mapboxgl-touch-drag-pan");
          }, hr.prototype.isEnabled = function() {
            return this._mousePan.isEnabled() && this._touchPan.isEnabled();
          }, hr.prototype.isActive = function() {
            return this._mousePan.isActive() || this._touchPan.isActive();
          };
          var pr = function(t2, e2, i2) {
            this._pitchWithRotate = t2.pitchWithRotate, this._mouseRotate = e2, this._mousePitch = i2;
          };
          pr.prototype.enable = function() {
            this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
          }, pr.prototype.disable = function() {
            this._mouseRotate.disable(), this._mousePitch.disable();
          }, pr.prototype.isEnabled = function() {
            return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
          }, pr.prototype.isActive = function() {
            return this._mouseRotate.isActive() || this._mousePitch.isActive();
          };
          var dr = function(t2, e2, i2, o2) {
            this._el = t2, this._touchZoom = e2, this._touchRotate = i2, this._tapDragZoom = o2, this._rotationDisabled = false, this._enabled = true;
          };
          dr.prototype.enable = function(t2) {
            this._touchZoom.enable(t2), this._rotationDisabled || this._touchRotate.enable(t2), this._tapDragZoom.enable(), this._el.classList.add("mapboxgl-touch-zoom-rotate");
          }, dr.prototype.disable = function() {
            this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("mapboxgl-touch-zoom-rotate");
          }, dr.prototype.isEnabled = function() {
            return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
          }, dr.prototype.isActive = function() {
            return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
          }, dr.prototype.disableRotation = function() {
            this._rotationDisabled = true, this._touchRotate.disable();
          }, dr.prototype.enableRotation = function() {
            this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
          };
          var _r = function(t2) {
            return t2.zoom || t2.drag || t2.pitch || t2.rotate;
          }, fr = function(t2) {
            function e2() {
              t2.apply(this, arguments);
            }
            return t2 && (e2.__proto__ = t2), (e2.prototype = Object.create(t2 && t2.prototype)).constructor = e2, e2;
          }(t.Event);
          function mr(t2) {
            return t2.panDelta && t2.panDelta.mag() || t2.zoomDelta || t2.bearingDelta || t2.pitchDelta;
          }
          var gr = function(e2, o2) {
            this._map = e2, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new Ao(e2), this._bearingSnap = o2.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(o2), t.bindAll(["handleEvent", "handleWindowEvent"], this);
            var r2 = this._el;
            this._listeners = [[r2, "touchstart", { passive: true }], [r2, "touchmove", { passive: false }], [r2, "touchend", void 0], [r2, "touchcancel", void 0], [r2, "mousedown", void 0], [r2, "mousemove", void 0], [r2, "mouseup", void 0], [t.window.document, "mousemove", { capture: true }], [t.window.document, "mouseup", void 0], [r2, "mouseover", void 0], [r2, "mouseout", void 0], [r2, "dblclick", void 0], [r2, "click", void 0], [r2, "keydown", { capture: false }], [r2, "keyup", void 0], [r2, "wheel", { passive: false }], [r2, "contextmenu", void 0], [t.window, "blur", void 0]];
            for (var a2 = 0, n2 = this._listeners; a2 < n2.length; a2 += 1) {
              var s2 = n2[a2], l2 = s2[0];
              i.addEventListener(l2, s2[1], l2 === t.window.document ? this.handleWindowEvent : this.handleEvent, s2[2]);
            }
          };
          gr.prototype.destroy = function() {
            for (var e2 = 0, o2 = this._listeners; e2 < o2.length; e2 += 1) {
              var r2 = o2[e2], a2 = r2[0];
              i.removeEventListener(a2, r2[1], a2 === t.window.document ? this.handleWindowEvent : this.handleEvent, r2[2]);
            }
          }, gr.prototype._addDefaultHandlers = function(t2) {
            var e2 = this._map, i2 = e2.getCanvasContainer();
            this._add("mapEvent", new Oo(e2, t2));
            var o2 = e2.boxZoom = new Uo(e2, t2);
            this._add("boxZoom", o2);
            var r2 = new jo(), a2 = new cr();
            e2.doubleClickZoom = new lr(a2, r2), this._add("tapZoom", r2), this._add("clickZoom", a2);
            var n2 = new ur();
            this._add("tapDragZoom", n2);
            var s2 = e2.touchPitch = new or2();
            this._add("touchPitch", s2);
            var l2 = new Xo(t2), c2 = new Ho(t2);
            e2.dragRotate = new pr(t2, l2, c2), this._add("mouseRotate", l2, ["mousePitch"]), this._add("mousePitch", c2, ["mouseRotate"]);
            var u2 = new Wo(t2), h2 = new Ko(t2);
            e2.dragPan = new hr(i2, u2, h2), this._add("mousePan", u2), this._add("touchPan", h2, ["touchZoom", "touchRotate"]);
            var p2 = new er(), d2 = new $o();
            e2.touchZoomRotate = new dr(i2, d2, p2, n2), this._add("touchRotate", p2, ["touchPan", "touchZoom"]), this._add("touchZoom", d2, ["touchPan", "touchRotate"]);
            var _2 = e2.scrollZoom = new sr(e2, this);
            this._add("scrollZoom", _2, ["mousePan"]);
            var f2 = e2.keyboard = new ar();
            this._add("keyboard", f2), this._add("blockableMapEvent", new Fo(e2));
            for (var m2 = 0, g2 = ["boxZoom", "doubleClickZoom", "tapDragZoom", "touchPitch", "dragRotate", "dragPan", "touchZoomRotate", "scrollZoom", "keyboard"]; m2 < g2.length; m2 += 1) {
              var v2 = g2[m2];
              t2.interactive && t2[v2] && e2[v2].enable(t2[v2]);
            }
          }, gr.prototype._add = function(t2, e2, i2) {
            this._handlers.push({ handlerName: t2, handler: e2, allowed: i2 }), this._handlersById[t2] = e2;
          }, gr.prototype.stop = function(t2) {
            if (!this._updatingCamera) {
              for (var e2 = 0, i2 = this._handlers; e2 < i2.length; e2 += 1)
                i2[e2].handler.reset();
              this._inertia.clear(), this._fireEvents({}, {}, t2), this._changes = [];
            }
          }, gr.prototype.isActive = function() {
            for (var t2 = 0, e2 = this._handlers; t2 < e2.length; t2 += 1)
              if (e2[t2].handler.isActive())
                return true;
            return false;
          }, gr.prototype.isZooming = function() {
            return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
          }, gr.prototype.isRotating = function() {
            return !!this._eventsInProgress.rotate;
          }, gr.prototype.isMoving = function() {
            return Boolean(_r(this._eventsInProgress)) || this.isZooming();
          }, gr.prototype._blockedByActive = function(t2, e2, i2) {
            for (var o2 in t2)
              if (o2 !== i2 && (!e2 || e2.indexOf(o2) < 0))
                return true;
            return false;
          }, gr.prototype.handleWindowEvent = function(t2) {
            this.handleEvent(t2, t2.type + "Window");
          }, gr.prototype._getMapTouches = function(t2) {
            for (var e2 = [], i2 = 0, o2 = t2; i2 < o2.length; i2 += 1) {
              var r2 = o2[i2];
              this._el.contains(r2.target) && e2.push(r2);
            }
            return e2;
          }, gr.prototype.handleEvent = function(t2, e2) {
            this._updatingCamera = true;
            for (var o2 = "renderFrame" === t2.type ? void 0 : t2, r2 = { needsRenderFrame: false }, a2 = {}, n2 = {}, s2 = t2.touches ? this._getMapTouches(t2.touches) : void 0, l2 = s2 ? i.touchPos(this._el, s2) : i.mousePos(this._el, t2), c2 = 0, u2 = this._handlers; c2 < u2.length; c2 += 1) {
              var h2 = u2[c2], p2 = h2.handlerName, d2 = h2.handler, _2 = h2.allowed;
              if (d2.isEnabled()) {
                var f2 = void 0;
                this._blockedByActive(n2, _2, p2) ? d2.reset() : d2[e2 || t2.type] && (f2 = d2[e2 || t2.type](t2, l2, s2), this.mergeHandlerResult(r2, a2, f2, p2, o2), f2 && f2.needsRenderFrame && this._triggerRenderFrame()), (f2 || d2.isActive()) && (n2[p2] = d2);
              }
            }
            var m2 = {};
            for (var g2 in this._previousActiveHandlers)
              n2[g2] || (m2[g2] = o2);
            this._previousActiveHandlers = n2, (Object.keys(m2).length || mr(r2)) && (this._changes.push([r2, a2, m2]), this._triggerRenderFrame()), (Object.keys(n2).length || mr(r2)) && this._map._stop(true), this._updatingCamera = false;
            var v2 = r2.cameraAnimation;
            v2 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], v2(this._map));
          }, gr.prototype.mergeHandlerResult = function(e2, i2, o2, r2, a2) {
            if (o2) {
              t.extend(e2, o2);
              var n2 = { handlerName: r2, originalEvent: o2.originalEvent || a2 };
              void 0 !== o2.zoomDelta && (i2.zoom = n2), void 0 !== o2.panDelta && (i2.drag = n2), void 0 !== o2.pitchDelta && (i2.pitch = n2), void 0 !== o2.bearingDelta && (i2.rotate = n2);
            }
          }, gr.prototype._applyChanges = function() {
            for (var e2 = {}, i2 = {}, o2 = {}, r2 = 0, a2 = this._changes; r2 < a2.length; r2 += 1) {
              var n2 = a2[r2], s2 = n2[0], l2 = n2[1], c2 = n2[2];
              s2.panDelta && (e2.panDelta = (e2.panDelta || new t.Point(0, 0))._add(s2.panDelta)), s2.zoomDelta && (e2.zoomDelta = (e2.zoomDelta || 0) + s2.zoomDelta), s2.bearingDelta && (e2.bearingDelta = (e2.bearingDelta || 0) + s2.bearingDelta), s2.pitchDelta && (e2.pitchDelta = (e2.pitchDelta || 0) + s2.pitchDelta), void 0 !== s2.around && (e2.around = s2.around), void 0 !== s2.pinchAround && (e2.pinchAround = s2.pinchAround), s2.noInertia && (e2.noInertia = s2.noInertia), t.extend(i2, l2), t.extend(o2, c2);
            }
            this._updateMapTransform(e2, i2, o2), this._changes = [];
          }, gr.prototype._updateMapTransform = function(t2, e2, i2) {
            var o2 = this._map, r2 = o2.transform;
            if (!mr(t2))
              return this._fireEvents(e2, i2, true);
            var a2 = t2.panDelta, n2 = t2.zoomDelta, s2 = t2.bearingDelta, l2 = t2.pitchDelta, c2 = t2.around, u2 = t2.pinchAround;
            void 0 !== u2 && (c2 = u2), o2._stop(true), c2 = c2 || o2.transform.centerPoint;
            var h2 = r2.pointLocation(a2 ? c2.sub(a2) : c2);
            s2 && (r2.bearing += s2), l2 && (r2.pitch += l2), n2 && (r2.zoom += n2), r2.setLocationAtPoint(h2, c2), this._map._update(), t2.noInertia || this._inertia.record(t2), this._fireEvents(e2, i2, true);
          }, gr.prototype._fireEvents = function(e2, i2, o2) {
            var r2 = this, a2 = _r(this._eventsInProgress), n2 = _r(e2), s2 = {};
            for (var l2 in e2)
              this._eventsInProgress[l2] || (s2[l2 + "start"] = e2[l2].originalEvent), this._eventsInProgress[l2] = e2[l2];
            for (var c2 in !a2 && n2 && this._fireEvent("movestart", n2.originalEvent), s2)
              this._fireEvent(c2, s2[c2]);
            for (var u2 in n2 && this._fireEvent("move", n2.originalEvent), e2)
              this._fireEvent(u2, e2[u2].originalEvent);
            var h2, p2 = {};
            for (var d2 in this._eventsInProgress) {
              var _2 = this._eventsInProgress[d2], f2 = _2.handlerName, m2 = _2.originalEvent;
              this._handlersById[f2].isActive() || (delete this._eventsInProgress[d2], p2[d2 + "end"] = h2 = i2[f2] || m2);
            }
            for (var g2 in p2)
              this._fireEvent(g2, p2[g2]);
            var v2 = _r(this._eventsInProgress);
            if (o2 && (a2 || n2) && !v2) {
              this._updatingCamera = true;
              var y2 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), x2 = function(t2) {
                return 0 !== t2 && -r2._bearingSnap < t2 && t2 < r2._bearingSnap;
              };
              y2 ? (x2(y2.bearing || this._map.getBearing()) && (y2.bearing = 0), this._map.easeTo(y2, { originalEvent: h2 })) : (this._map.fire(new t.Event("moveend", { originalEvent: h2 })), x2(this._map.getBearing()) && this._map.resetNorth()), this._updatingCamera = false;
            }
          }, gr.prototype._fireEvent = function(e2, i2) {
            this._map.fire(new t.Event(e2, i2 ? { originalEvent: i2 } : {}));
          }, gr.prototype._requestFrame = function() {
            var t2 = this;
            return this._map.triggerRepaint(), this._map._renderTaskQueue.add(function(e2) {
              delete t2._frameId, t2.handleEvent(new fr("renderFrame", { timeStamp: e2 })), t2._applyChanges();
            });
          }, gr.prototype._triggerRenderFrame = function() {
            void 0 === this._frameId && (this._frameId = this._requestFrame());
          };
          var vr = function(e2) {
            function i2(i3, o2) {
              e2.call(this), this._moving = false, this._zooming = false, this.transform = i3, this._bearingSnap = o2.bearingSnap, t.bindAll(["_renderFrameCallback"], this);
            }
            return e2 && (i2.__proto__ = e2), (i2.prototype = Object.create(e2 && e2.prototype)).constructor = i2, i2.prototype.getCenter = function() {
              return new t.LngLat(this.transform.center.lng, this.transform.center.lat);
            }, i2.prototype.setCenter = function(t2, e3) {
              return this.jumpTo({ center: t2 }, e3);
            }, i2.prototype.panBy = function(e3, i3, o2) {
              return e3 = t.Point.convert(e3).mult(-1), this.panTo(this.transform.center, t.extend({ offset: e3 }, i3), o2);
            }, i2.prototype.panTo = function(e3, i3, o2) {
              return this.easeTo(t.extend({ center: e3 }, i3), o2);
            }, i2.prototype.getZoom = function() {
              return this.transform.zoom;
            }, i2.prototype.setZoom = function(t2, e3) {
              return this.jumpTo({ zoom: t2 }, e3), this;
            }, i2.prototype.zoomTo = function(e3, i3, o2) {
              return this.easeTo(t.extend({ zoom: e3 }, i3), o2);
            }, i2.prototype.zoomIn = function(t2, e3) {
              return this.zoomTo(this.getZoom() + 1, t2, e3), this;
            }, i2.prototype.zoomOut = function(t2, e3) {
              return this.zoomTo(this.getZoom() - 1, t2, e3), this;
            }, i2.prototype.getBearing = function() {
              return this.transform.bearing;
            }, i2.prototype.setBearing = function(t2, e3) {
              return this.jumpTo({ bearing: t2 }, e3), this;
            }, i2.prototype.getPadding = function() {
              return this.transform.padding;
            }, i2.prototype.setPadding = function(t2, e3) {
              return this.jumpTo({ padding: t2 }, e3), this;
            }, i2.prototype.rotateTo = function(e3, i3, o2) {
              return this.easeTo(t.extend({ bearing: e3 }, i3), o2);
            }, i2.prototype.resetNorth = function(e3, i3) {
              return this.rotateTo(0, t.extend({ duration: 1e3 }, e3), i3), this;
            }, i2.prototype.resetNorthPitch = function(e3, i3) {
              return this.easeTo(t.extend({ bearing: 0, pitch: 0, duration: 1e3 }, e3), i3), this;
            }, i2.prototype.snapToNorth = function(t2, e3) {
              return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t2, e3) : this;
            }, i2.prototype.getPitch = function() {
              return this.transform.pitch;
            }, i2.prototype.setPitch = function(t2, e3) {
              return this.jumpTo({ pitch: t2 }, e3), this;
            }, i2.prototype.cameraForBounds = function(e3, i3) {
              e3 = t.LngLatBounds.convert(e3);
              var o2 = i3 && i3.bearing || 0;
              return this._cameraForBoxAndBearing(e3.getNorthWest(), e3.getSouthEast(), o2, i3);
            }, i2.prototype._cameraForBoxAndBearing = function(e3, i3, o2, r2) {
              var a2 = { top: 0, bottom: 0, right: 0, left: 0 };
              if ("number" == typeof (r2 = t.extend({ padding: a2, offset: [0, 0], maxZoom: this.transform.maxZoom }, r2)).padding) {
                var n2 = r2.padding;
                r2.padding = { top: n2, bottom: n2, right: n2, left: n2 };
              }
              r2.padding = t.extend(a2, r2.padding);
              var s2 = this.transform, l2 = s2.padding, c2 = s2.project(t.LngLat.convert(e3)), u2 = s2.project(t.LngLat.convert(i3)), h2 = c2.rotate(-o2 * Math.PI / 180), p2 = u2.rotate(-o2 * Math.PI / 180), d2 = new t.Point(Math.max(h2.x, p2.x), Math.max(h2.y, p2.y)), _2 = new t.Point(Math.min(h2.x, p2.x), Math.min(h2.y, p2.y)), f2 = d2.sub(_2), m2 = (s2.width - (l2.left + l2.right + r2.padding.left + r2.padding.right)) / f2.x, g2 = (s2.height - (l2.top + l2.bottom + r2.padding.top + r2.padding.bottom)) / f2.y;
              if (!(g2 < 0 || m2 < 0)) {
                var v2 = Math.min(s2.scaleZoom(s2.scale * Math.min(m2, g2)), r2.maxZoom), y2 = "number" == typeof r2.offset.x ? new t.Point(r2.offset.x, r2.offset.y) : t.Point.convert(r2.offset), x2 = new t.Point((r2.padding.left - r2.padding.right) / 2, (r2.padding.top - r2.padding.bottom) / 2).rotate(o2 * Math.PI / 180), b2 = y2.add(x2).mult(s2.scale / s2.zoomScale(v2));
                return { center: s2.unproject(c2.add(u2).div(2).sub(b2)), zoom: v2, bearing: o2 };
              }
              t.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
            }, i2.prototype.fitBounds = function(t2, e3, i3) {
              return this._fitInternal(this.cameraForBounds(t2, e3), e3, i3);
            }, i2.prototype.fitScreenCoordinates = function(e3, i3, o2, r2, a2) {
              return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(t.Point.convert(e3)), this.transform.pointLocation(t.Point.convert(i3)), o2, r2), r2, a2);
            }, i2.prototype._fitInternal = function(e3, i3, o2) {
              return e3 ? (delete (i3 = t.extend(e3, i3)).padding, i3.linear ? this.easeTo(i3, o2) : this.flyTo(i3, o2)) : this;
            }, i2.prototype.jumpTo = function(e3, i3) {
              this.stop();
              var o2 = this.transform, r2 = false, a2 = false, n2 = false;
              return "zoom" in e3 && o2.zoom !== +e3.zoom && (r2 = true, o2.zoom = +e3.zoom), void 0 !== e3.center && (o2.center = t.LngLat.convert(e3.center)), "bearing" in e3 && o2.bearing !== +e3.bearing && (a2 = true, o2.bearing = +e3.bearing), "pitch" in e3 && o2.pitch !== +e3.pitch && (n2 = true, o2.pitch = +e3.pitch), null == e3.padding || o2.isPaddingEqual(e3.padding) || (o2.padding = e3.padding), this.fire(new t.Event("movestart", i3)).fire(new t.Event("move", i3)), r2 && this.fire(new t.Event("zoomstart", i3)).fire(new t.Event("zoom", i3)).fire(new t.Event("zoomend", i3)), a2 && this.fire(new t.Event("rotatestart", i3)).fire(new t.Event("rotate", i3)).fire(new t.Event("rotateend", i3)), n2 && this.fire(new t.Event("pitchstart", i3)).fire(new t.Event("pitch", i3)).fire(new t.Event("pitchend", i3)), this.fire(new t.Event("moveend", i3));
            }, i2.prototype.easeTo = function(e3, i3) {
              var o2 = this;
              this._stop(false, e3.easeId), (false === (e3 = t.extend({ offset: [0, 0], duration: 500, easing: t.ease }, e3)).animate || !e3.essential && t.browser.prefersReducedMotion) && (e3.duration = 0);
              var r2 = this.transform, a2 = this.getZoom(), n2 = this.getBearing(), s2 = this.getPitch(), l2 = this.getPadding(), c2 = "zoom" in e3 ? +e3.zoom : a2, u2 = "bearing" in e3 ? this._normalizeBearing(e3.bearing, n2) : n2, h2 = "pitch" in e3 ? +e3.pitch : s2, p2 = "padding" in e3 ? e3.padding : r2.padding, d2 = t.Point.convert(e3.offset), _2 = r2.centerPoint.add(d2), f2 = r2.pointLocation(_2), m2 = t.LngLat.convert(e3.center || f2);
              this._normalizeCenter(m2);
              var g2, v2, y2 = r2.project(f2), x2 = r2.project(m2).sub(y2), b2 = r2.zoomScale(c2 - a2);
              e3.around && (g2 = t.LngLat.convert(e3.around), v2 = r2.locationPoint(g2));
              var w2 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
              return this._zooming = this._zooming || c2 !== a2, this._rotating = this._rotating || n2 !== u2, this._pitching = this._pitching || h2 !== s2, this._padding = !r2.isPaddingEqual(p2), this._easeId = e3.easeId, this._prepareEase(i3, e3.noMoveStart, w2), this._ease(function(e4) {
                if (o2._zooming && (r2.zoom = t.number(a2, c2, e4)), o2._rotating && (r2.bearing = t.number(n2, u2, e4)), o2._pitching && (r2.pitch = t.number(s2, h2, e4)), o2._padding && (r2.interpolatePadding(l2, p2, e4), _2 = r2.centerPoint.add(d2)), g2)
                  r2.setLocationAtPoint(g2, v2);
                else {
                  var f3 = r2.zoomScale(r2.zoom - a2), m3 = c2 > a2 ? Math.min(2, b2) : Math.max(0.5, b2), w3 = Math.pow(m3, 1 - e4), T2 = r2.unproject(y2.add(x2.mult(e4 * w3)).mult(f3));
                  r2.setLocationAtPoint(r2.renderWorldCopies ? T2.wrap() : T2, _2);
                }
                o2._fireMoveEvents(i3);
              }, function(t2) {
                o2._afterEase(i3, t2);
              }, e3), this;
            }, i2.prototype._prepareEase = function(e3, i3, o2) {
              void 0 === o2 && (o2 = {}), this._moving = true, i3 || o2.moving || this.fire(new t.Event("movestart", e3)), this._zooming && !o2.zooming && this.fire(new t.Event("zoomstart", e3)), this._rotating && !o2.rotating && this.fire(new t.Event("rotatestart", e3)), this._pitching && !o2.pitching && this.fire(new t.Event("pitchstart", e3));
            }, i2.prototype._fireMoveEvents = function(e3) {
              this.fire(new t.Event("move", e3)), this._zooming && this.fire(new t.Event("zoom", e3)), this._rotating && this.fire(new t.Event("rotate", e3)), this._pitching && this.fire(new t.Event("pitch", e3));
            }, i2.prototype._afterEase = function(e3, i3) {
              if (!this._easeId || !i3 || this._easeId !== i3) {
                delete this._easeId;
                var o2 = this._zooming, r2 = this._rotating, a2 = this._pitching;
                this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, o2 && this.fire(new t.Event("zoomend", e3)), r2 && this.fire(new t.Event("rotateend", e3)), a2 && this.fire(new t.Event("pitchend", e3)), this.fire(new t.Event("moveend", e3));
              }
            }, i2.prototype.flyTo = function(e3, i3) {
              var o2 = this;
              if (!e3.essential && t.browser.prefersReducedMotion) {
                var r2 = t.pick(e3, ["center", "zoom", "bearing", "pitch", "around"]);
                return this.jumpTo(r2, i3);
              }
              this.stop(), e3 = t.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: t.ease }, e3);
              var a2 = this.transform, n2 = this.getZoom(), s2 = this.getBearing(), l2 = this.getPitch(), c2 = this.getPadding(), u2 = "zoom" in e3 ? t.clamp(+e3.zoom, a2.minZoom, a2.maxZoom) : n2, h2 = "bearing" in e3 ? this._normalizeBearing(e3.bearing, s2) : s2, p2 = "pitch" in e3 ? +e3.pitch : l2, d2 = "padding" in e3 ? e3.padding : a2.padding, _2 = a2.zoomScale(u2 - n2), f2 = t.Point.convert(e3.offset), m2 = a2.centerPoint.add(f2), g2 = a2.pointLocation(m2), v2 = t.LngLat.convert(e3.center || g2);
              this._normalizeCenter(v2);
              var y2 = a2.project(g2), x2 = a2.project(v2).sub(y2), b2 = e3.curve, w2 = Math.max(a2.width, a2.height), T2 = w2 / _2, E2 = x2.mag();
              if ("minZoom" in e3) {
                var I2 = t.clamp(Math.min(e3.minZoom, n2, u2), a2.minZoom, a2.maxZoom), P2 = w2 / a2.zoomScale(I2 - n2);
                b2 = Math.sqrt(P2 / E2 * 2);
              }
              var S2 = b2 * b2;
              function C2(t2) {
                var e4 = (T2 * T2 - w2 * w2 + (t2 ? -1 : 1) * S2 * S2 * E2 * E2) / (2 * (t2 ? T2 : w2) * S2 * E2);
                return Math.log(Math.sqrt(e4 * e4 + 1) - e4);
              }
              function z2(t2) {
                return (Math.exp(t2) - Math.exp(-t2)) / 2;
              }
              function D2(t2) {
                return (Math.exp(t2) + Math.exp(-t2)) / 2;
              }
              var A2 = C2(0), M2 = function(t2) {
                return D2(A2) / D2(A2 + b2 * t2);
              }, L2 = function(t2) {
                return w2 * ((D2(A2) * (z2(e4 = A2 + b2 * t2) / D2(e4)) - z2(A2)) / S2) / E2;
                var e4;
              }, R2 = (C2(1) - A2) / b2;
              if (Math.abs(E2) < 1e-6 || !isFinite(R2)) {
                if (Math.abs(w2 - T2) < 1e-6)
                  return this.easeTo(e3, i3);
                var k2 = T2 < w2 ? -1 : 1;
                R2 = Math.abs(Math.log(T2 / w2)) / b2, L2 = function() {
                  return 0;
                }, M2 = function(t2) {
                  return Math.exp(k2 * b2 * t2);
                };
              }
              return e3.duration = "duration" in e3 ? +e3.duration : 1e3 * R2 / ("screenSpeed" in e3 ? +e3.screenSpeed / b2 : +e3.speed), e3.maxDuration && e3.duration > e3.maxDuration && (e3.duration = 0), this._zooming = true, this._rotating = s2 !== h2, this._pitching = p2 !== l2, this._padding = !a2.isPaddingEqual(d2), this._prepareEase(i3, false), this._ease(function(e4) {
                var r3 = e4 * R2, _3 = 1 / M2(r3);
                a2.zoom = 1 === e4 ? u2 : n2 + a2.scaleZoom(_3), o2._rotating && (a2.bearing = t.number(s2, h2, e4)), o2._pitching && (a2.pitch = t.number(l2, p2, e4)), o2._padding && (a2.interpolatePadding(c2, d2, e4), m2 = a2.centerPoint.add(f2));
                var g3 = 1 === e4 ? v2 : a2.unproject(y2.add(x2.mult(L2(r3))).mult(_3));
                a2.setLocationAtPoint(a2.renderWorldCopies ? g3.wrap() : g3, m2), o2._fireMoveEvents(i3);
              }, function() {
                return o2._afterEase(i3);
              }, e3), this;
            }, i2.prototype.isEasing = function() {
              return !!this._easeFrameId;
            }, i2.prototype.stop = function() {
              return this._stop();
            }, i2.prototype._stop = function(t2, e3) {
              if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
                var i3 = this._onEaseEnd;
                delete this._onEaseEnd, i3.call(this, e3);
              }
              if (!t2) {
                var o2 = this.handlers;
                o2 && o2.stop(false);
              }
              return this;
            }, i2.prototype._ease = function(e3, i3, o2) {
              false === o2.animate || 0 === o2.duration ? (e3(1), i3()) : (this._easeStart = t.browser.now(), this._easeOptions = o2, this._onEaseFrame = e3, this._onEaseEnd = i3, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
            }, i2.prototype._renderFrameCallback = function() {
              var e3 = Math.min((t.browser.now() - this._easeStart) / this._easeOptions.duration, 1);
              this._onEaseFrame(this._easeOptions.easing(e3)), e3 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
            }, i2.prototype._normalizeBearing = function(e3, i3) {
              e3 = t.wrap(e3, -180, 180);
              var o2 = Math.abs(e3 - i3);
              return Math.abs(e3 - 360 - i3) < o2 && (e3 -= 360), Math.abs(e3 + 360 - i3) < o2 && (e3 += 360), e3;
            }, i2.prototype._normalizeCenter = function(t2) {
              var e3 = this.transform;
              if (e3.renderWorldCopies && !e3.lngRange) {
                var i3 = t2.lng - e3.center.lng;
                t2.lng += i3 > 180 ? -360 : i3 < -180 ? 360 : 0;
              }
            }, i2;
          }(t.Evented), yr = function(e2) {
            void 0 === e2 && (e2 = {}), this.options = e2, t.bindAll(["_toggleAttribution", "_updateEditLink", "_updateData", "_updateCompact"], this);
          };
          yr.prototype.getDefaultPosition = function() {
            return "bottom-right";
          }, yr.prototype.onAdd = function(t2) {
            var e2 = this.options && this.options.compact;
            return this._map = t2, this._container = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-attrib"), this._compactButton = i.create("button", "mapboxgl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = i.create("div", "mapboxgl-ctrl-attrib-inner", this._container), this._innerContainer.setAttribute("role", "list"), e2 && this._container.classList.add("mapboxgl-compact"), this._updateAttributions(), this._updateEditLink(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("moveend", this._updateEditLink), void 0 === e2 && (this._map.on("resize", this._updateCompact), this._updateCompact()), this._container;
          }, yr.prototype.onRemove = function() {
            i.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("moveend", this._updateEditLink), this._map.off("resize", this._updateCompact), this._map = void 0, this._attribHTML = void 0;
          }, yr.prototype._setElementTitle = function(t2, e2) {
            var i2 = this._map._getUIString("AttributionControl." + e2);
            t2.title = i2, t2.setAttribute("aria-label", i2);
          }, yr.prototype._toggleAttribution = function() {
            this._container.classList.contains("mapboxgl-compact-show") ? (this._container.classList.remove("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "false")) : (this._container.classList.add("mapboxgl-compact-show"), this._compactButton.setAttribute("aria-pressed", "true"));
          }, yr.prototype._updateEditLink = function() {
            var e2 = this._editLink;
            e2 || (e2 = this._editLink = this._container.querySelector(".mapbox-improve-map"));
            var i2 = [{ key: "owner", value: this.styleOwner }, { key: "id", value: this.styleId }, { key: "access_token", value: this._map._requestManager._customAccessToken || t.config.ACCESS_TOKEN }];
            if (e2) {
              var o2 = i2.reduce(function(t2, e3, o3) {
                return e3.value && (t2 += e3.key + "=" + e3.value + (o3 < i2.length - 1 ? "&" : "")), t2;
              }, "?");
              e2.href = t.config.FEEDBACK_URL + "/" + o2 + (this._map._hash ? this._map._hash.getHashString(true) : ""), e2.rel = "noopener nofollow", this._setElementTitle(e2, "MapFeedback");
            }
          }, yr.prototype._updateData = function(t2) {
            !t2 || "metadata" !== t2.sourceDataType && "visibility" !== t2.sourceDataType && "style" !== t2.dataType || (this._updateAttributions(), this._updateEditLink());
          }, yr.prototype._updateAttributions = function() {
            if (this._map.style) {
              var t2 = [];
              if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t2 = t2.concat(this.options.customAttribution.map(function(t3) {
                return "string" != typeof t3 ? "" : t3;
              })) : "string" == typeof this.options.customAttribution && t2.push(this.options.customAttribution)), this._map.style.stylesheet) {
                var e2 = this._map.style.stylesheet;
                this.styleOwner = e2.owner, this.styleId = e2.id;
              }
              var i2 = this._map.style.sourceCaches;
              for (var o2 in i2) {
                var r2 = i2[o2];
                if (r2.used) {
                  var a2 = r2.getSource();
                  a2.attribution && t2.indexOf(a2.attribution) < 0 && t2.push(a2.attribution);
                }
              }
              t2.sort(function(t3, e3) {
                return t3.length - e3.length;
              });
              var n2 = (t2 = t2.filter(function(e3, i3) {
                for (var o3 = i3 + 1; o3 < t2.length; o3++)
                  if (t2[o3].indexOf(e3) >= 0)
                    return false;
                return true;
              })).join(" | ");
              n2 !== this._attribHTML && (this._attribHTML = n2, t2.length ? (this._innerContainer.innerHTML = n2, this._container.classList.remove("mapboxgl-attrib-empty")) : this._container.classList.add("mapboxgl-attrib-empty"), this._editLink = null);
            }
          }, yr.prototype._updateCompact = function() {
            this._map.getCanvasContainer().offsetWidth <= 640 ? this._container.classList.add("mapboxgl-compact") : this._container.classList.remove("mapboxgl-compact", "mapboxgl-compact-show");
          };
          var xr = function() {
            t.bindAll(["_updateLogo"], this), t.bindAll(["_updateCompact"], this);
          };
          xr.prototype.onAdd = function(t2) {
            this._map = t2, this._container = i.create("div", "mapboxgl-ctrl");
            var e2 = i.create("a", "mapboxgl-ctrl-logo");
            return e2.target = "_blank", e2.rel = "noopener nofollow", e2.href = "https://www.mapbox.com/", e2.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e2.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e2), this._container.style.display = "none", this._map.on("sourcedata", this._updateLogo), this._updateLogo(), this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
          }, xr.prototype.onRemove = function() {
            i.remove(this._container), this._map.off("sourcedata", this._updateLogo), this._map.off("resize", this._updateCompact);
          }, xr.prototype.getDefaultPosition = function() {
            return "bottom-left";
          }, xr.prototype._updateLogo = function(t2) {
            t2 && "metadata" !== t2.sourceDataType || (this._container.style.display = this._logoRequired() ? "block" : "none");
          }, xr.prototype._logoRequired = function() {
            if (this._map.style) {
              var t2 = this._map.style.sourceCaches;
              for (var e2 in t2)
                if (t2[e2].getSource().mapbox_logo)
                  return true;
              return false;
            }
          }, xr.prototype._updateCompact = function() {
            var t2 = this._container.children;
            if (t2.length) {
              var e2 = t2[0];
              this._map.getCanvasContainer().offsetWidth < 250 ? e2.classList.add("mapboxgl-compact") : e2.classList.remove("mapboxgl-compact");
            }
          };
          var br = function() {
            this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
          };
          br.prototype.add = function(t2) {
            var e2 = ++this._id;
            return this._queue.push({ callback: t2, id: e2, cancelled: false }), e2;
          }, br.prototype.remove = function(t2) {
            for (var e2 = this._currentlyRunning, i2 = 0, o2 = e2 ? this._queue.concat(e2) : this._queue; i2 < o2.length; i2 += 1) {
              var r2 = o2[i2];
              if (r2.id === t2)
                return void (r2.cancelled = true);
            }
          }, br.prototype.run = function(t2) {
            void 0 === t2 && (t2 = 0);
            var e2 = this._currentlyRunning = this._queue;
            this._queue = [];
            for (var i2 = 0, o2 = e2; i2 < o2.length; i2 += 1) {
              var r2 = o2[i2];
              if (!r2.cancelled && (r2.callback(t2), this._cleared))
                break;
            }
            this._cleared = false, this._currentlyRunning = false;
          }, br.prototype.clear = function() {
            this._currentlyRunning && (this._cleared = true), this._queue = [];
          };
          var wr = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm" }, Tr = t.window.HTMLImageElement, Er = t.window.HTMLElement, Ir = t.window.ImageBitmap, Pr = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, maxTileCacheSize: null, localIdeographFontFamily: "sans-serif", transformRequest: null, accessToken: null, fadeDuration: 300, crossSourceCollisions: true }, Sr = function(o2) {
            function r2(e2) {
              var i2 = this;
              if (null != (e2 = t.extend({}, Pr, e2)).minZoom && null != e2.maxZoom && e2.minZoom > e2.maxZoom)
                throw new Error("maxZoom must be greater than or equal to minZoom");
              if (null != e2.minPitch && null != e2.maxPitch && e2.minPitch > e2.maxPitch)
                throw new Error("maxPitch must be greater than or equal to minPitch");
              if (null != e2.minPitch && e2.minPitch < 0)
                throw new Error("minPitch must be greater than or equal to 0");
              if (null != e2.maxPitch && e2.maxPitch > 60)
                throw new Error("maxPitch must be less than or equal to 60");
              var r3 = new To(e2.minZoom, e2.maxZoom, e2.minPitch, e2.maxPitch, e2.renderWorldCopies);
              if (o2.call(this, r3, e2), this._interactive = e2.interactive, this._maxTileCacheSize = e2.maxTileCacheSize, this._failIfMajorPerformanceCaveat = e2.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = e2.preserveDrawingBuffer, this._antialias = e2.antialias, this._trackResize = e2.trackResize, this._bearingSnap = e2.bearingSnap, this._refreshExpiredTiles = e2.refreshExpiredTiles, this._fadeDuration = e2.fadeDuration, this._crossSourceCollisions = e2.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = e2.collectResourceTiming, this._renderTaskQueue = new br(), this._controls = [], this._mapId = t.uniqueId(), this._locale = t.extend({}, wr, e2.locale), this._clickTolerance = e2.clickTolerance, this._requestManager = new t.RequestManager(e2.transformRequest, e2.accessToken), "string" == typeof e2.container) {
                if (this._container = t.window.document.getElementById(e2.container), !this._container)
                  throw new Error("Container '" + e2.container + "' not found.");
              } else {
                if (!(e2.container instanceof Er))
                  throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                this._container = e2.container;
              }
              if (e2.maxBounds && this.setMaxBounds(e2.maxBounds), t.bindAll(["_onWindowOnline", "_onWindowResize", "_onMapScroll", "_contextLost", "_contextRestored"], this), this._setupContainer(), this._setupPainter(), void 0 === this.painter)
                throw new Error("Failed to initialize WebGL.");
              this.on("move", function() {
                return i2._update(false);
              }), this.on("moveend", function() {
                return i2._update(false);
              }), this.on("zoom", function() {
                return i2._update(true);
              }), void 0 !== t.window && (t.window.addEventListener("online", this._onWindowOnline, false), t.window.addEventListener("resize", this._onWindowResize, false), t.window.addEventListener("orientationchange", this._onWindowResize, false)), this.handlers = new gr(this, e2), this._hash = e2.hash && new Io("string" == typeof e2.hash && e2.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: e2.center, zoom: e2.zoom, bearing: e2.bearing, pitch: e2.pitch }), e2.bounds && (this.resize(), this.fitBounds(e2.bounds, t.extend({}, e2.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = e2.localIdeographFontFamily, e2.style && this.setStyle(e2.style, { localIdeographFontFamily: e2.localIdeographFontFamily }), e2.attributionControl && this.addControl(new yr({ customAttribution: e2.customAttribution })), this.addControl(new xr(), e2.logoPosition), this.on("style.load", function() {
                i2.transform.unmodified && i2.jumpTo(i2.style.stylesheet);
              }), this.on("data", function(e3) {
                i2._update("style" === e3.dataType), i2.fire(new t.Event(e3.dataType + "data", e3));
              }), this.on("dataloading", function(e3) {
                i2.fire(new t.Event(e3.dataType + "dataloading", e3));
              });
            }
            o2 && (r2.__proto__ = o2), (r2.prototype = Object.create(o2 && o2.prototype)).constructor = r2;
            var a2 = { showTileBoundaries: { configurable: true }, showPadding: { configurable: true }, showCollisionBoxes: { configurable: true }, showOverdrawInspector: { configurable: true }, repaint: { configurable: true }, vertices: { configurable: true }, version: { configurable: true } };
            return r2.prototype._getMapId = function() {
              return this._mapId;
            }, r2.prototype.addControl = function(e2, i2) {
              if (void 0 === i2 && (i2 = e2.getDefaultPosition ? e2.getDefaultPosition() : "top-right"), !e2 || !e2.onAdd)
                return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
              var o3 = e2.onAdd(this);
              this._controls.push(e2);
              var r3 = this._controlPositions[i2];
              return -1 !== i2.indexOf("bottom") ? r3.insertBefore(o3, r3.firstChild) : r3.appendChild(o3), this;
            }, r2.prototype.removeControl = function(e2) {
              if (!e2 || !e2.onRemove)
                return this.fire(new t.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
              var i2 = this._controls.indexOf(e2);
              return i2 > -1 && this._controls.splice(i2, 1), e2.onRemove(this), this;
            }, r2.prototype.hasControl = function(t2) {
              return this._controls.indexOf(t2) > -1;
            }, r2.prototype.resize = function(e2) {
              var i2 = this._containerDimensions(), o3 = i2[0], r3 = i2[1];
              if (o3 === this.transform.width && r3 === this.transform.height)
                return this;
              this._resizeCanvas(o3, r3), this.transform.resize(o3, r3), this.painter.resize(o3, r3);
              var a3 = !this._moving;
              return a3 && this.fire(new t.Event("movestart", e2)).fire(new t.Event("move", e2)), this.fire(new t.Event("resize", e2)), a3 && this.fire(new t.Event("moveend", e2)), this;
            }, r2.prototype.getBounds = function() {
              return this.transform.getBounds();
            }, r2.prototype.getMaxBounds = function() {
              return this.transform.getMaxBounds();
            }, r2.prototype.setMaxBounds = function(e2) {
              return this.transform.setMaxBounds(t.LngLatBounds.convert(e2)), this._update();
            }, r2.prototype.setMinZoom = function(t2) {
              if ((t2 = null == t2 ? -2 : t2) >= -2 && t2 <= this.transform.maxZoom)
                return this.transform.minZoom = t2, this._update(), this.getZoom() < t2 && this.setZoom(t2), this;
              throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
            }, r2.prototype.getMinZoom = function() {
              return this.transform.minZoom;
            }, r2.prototype.setMaxZoom = function(t2) {
              if ((t2 = null == t2 ? 22 : t2) >= this.transform.minZoom)
                return this.transform.maxZoom = t2, this._update(), this.getZoom() > t2 && this.setZoom(t2), this;
              throw new Error("maxZoom must be greater than the current minZoom");
            }, r2.prototype.getMaxZoom = function() {
              return this.transform.maxZoom;
            }, r2.prototype.setMinPitch = function(t2) {
              if ((t2 = null == t2 ? 0 : t2) < 0)
                throw new Error("minPitch must be greater than or equal to 0");
              if (t2 >= 0 && t2 <= this.transform.maxPitch)
                return this.transform.minPitch = t2, this._update(), this.getPitch() < t2 && this.setPitch(t2), this;
              throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
            }, r2.prototype.getMinPitch = function() {
              return this.transform.minPitch;
            }, r2.prototype.setMaxPitch = function(t2) {
              if ((t2 = null == t2 ? 60 : t2) > 60)
                throw new Error("maxPitch must be less than or equal to 60");
              if (t2 >= this.transform.minPitch)
                return this.transform.maxPitch = t2, this._update(), this.getPitch() > t2 && this.setPitch(t2), this;
              throw new Error("maxPitch must be greater than the current minPitch");
            }, r2.prototype.getMaxPitch = function() {
              return this.transform.maxPitch;
            }, r2.prototype.getRenderWorldCopies = function() {
              return this.transform.renderWorldCopies;
            }, r2.prototype.setRenderWorldCopies = function(t2) {
              return this.transform.renderWorldCopies = t2, this._update();
            }, r2.prototype.project = function(e2) {
              return this.transform.locationPoint(t.LngLat.convert(e2));
            }, r2.prototype.unproject = function(e2) {
              return this.transform.pointLocation(t.Point.convert(e2));
            }, r2.prototype.isMoving = function() {
              return this._moving || this.handlers.isMoving();
            }, r2.prototype.isZooming = function() {
              return this._zooming || this.handlers.isZooming();
            }, r2.prototype.isRotating = function() {
              return this._rotating || this.handlers.isRotating();
            }, r2.prototype._createDelegatedListener = function(t2, e2, i2) {
              var o3, r3 = this;
              if ("mouseenter" === t2 || "mouseover" === t2) {
                var a3 = false;
                return { layer: e2, listener: i2, delegates: { mousemove: function(o4) {
                  var n3 = r3.getLayer(e2) ? r3.queryRenderedFeatures(o4.point, { layers: [e2] }) : [];
                  n3.length ? a3 || (a3 = true, i2.call(r3, new Ro(t2, r3, o4.originalEvent, { features: n3 }))) : a3 = false;
                }, mouseout: function() {
                  a3 = false;
                } } };
              }
              if ("mouseleave" === t2 || "mouseout" === t2) {
                var n2 = false;
                return { layer: e2, listener: i2, delegates: { mousemove: function(o4) {
                  (r3.getLayer(e2) ? r3.queryRenderedFeatures(o4.point, { layers: [e2] }) : []).length ? n2 = true : n2 && (n2 = false, i2.call(r3, new Ro(t2, r3, o4.originalEvent)));
                }, mouseout: function(e3) {
                  n2 && (n2 = false, i2.call(r3, new Ro(t2, r3, e3.originalEvent)));
                } } };
              }
              return { layer: e2, listener: i2, delegates: (o3 = {}, o3[t2] = function(t3) {
                var o4 = r3.getLayer(e2) ? r3.queryRenderedFeatures(t3.point, { layers: [e2] }) : [];
                o4.length && (t3.features = o4, i2.call(r3, t3), delete t3.features);
              }, o3) };
            }, r2.prototype.on = function(t2, e2, i2) {
              if (void 0 === i2)
                return o2.prototype.on.call(this, t2, e2);
              var r3 = this._createDelegatedListener(t2, e2, i2);
              for (var a3 in this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t2] = this._delegatedListeners[t2] || [], this._delegatedListeners[t2].push(r3), r3.delegates)
                this.on(a3, r3.delegates[a3]);
              return this;
            }, r2.prototype.once = function(t2, e2, i2) {
              if (void 0 === i2)
                return o2.prototype.once.call(this, t2, e2);
              var r3 = this._createDelegatedListener(t2, e2, i2);
              for (var a3 in r3.delegates)
                this.once(a3, r3.delegates[a3]);
              return this;
            }, r2.prototype.off = function(t2, e2, i2) {
              var r3 = this;
              return void 0 === i2 ? o2.prototype.off.call(this, t2, e2) : (this._delegatedListeners && this._delegatedListeners[t2] && function(o3) {
                for (var a3 = o3[t2], n2 = 0; n2 < a3.length; n2++) {
                  var s2 = a3[n2];
                  if (s2.layer === e2 && s2.listener === i2) {
                    for (var l2 in s2.delegates)
                      r3.off(l2, s2.delegates[l2]);
                    return a3.splice(n2, 1), r3;
                  }
                }
              }(this._delegatedListeners), this);
            }, r2.prototype.queryRenderedFeatures = function(e2, i2) {
              if (!this.style)
                return [];
              var o3;
              if (void 0 !== i2 || void 0 === e2 || e2 instanceof t.Point || Array.isArray(e2) || (i2 = e2, e2 = void 0), i2 = i2 || {}, (e2 = e2 || [[0, 0], [this.transform.width, this.transform.height]]) instanceof t.Point || "number" == typeof e2[0])
                o3 = [t.Point.convert(e2)];
              else {
                var r3 = t.Point.convert(e2[0]), a3 = t.Point.convert(e2[1]);
                o3 = [r3, new t.Point(a3.x, r3.y), a3, new t.Point(r3.x, a3.y), r3];
              }
              return this.style.queryRenderedFeatures(o3, i2, this.transform);
            }, r2.prototype.querySourceFeatures = function(t2, e2) {
              return this.style.querySourceFeatures(t2, e2);
            }, r2.prototype.setStyle = function(e2, i2) {
              return false !== (i2 = t.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily }, i2)).diff && i2.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e2 ? (this._diffStyle(e2, i2), this) : (this._localIdeographFontFamily = i2.localIdeographFontFamily, this._updateStyle(e2, i2));
            }, r2.prototype._getUIString = function(t2) {
              var e2 = this._locale[t2];
              if (null == e2)
                throw new Error("Missing UI string '" + t2 + "'");
              return e2;
            }, r2.prototype._updateStyle = function(t2, e2) {
              return this.style && (this.style.setEventedParent(null), this.style._remove()), t2 ? (this.style = new je(this, e2 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof t2 ? this.style.loadURL(t2) : this.style.loadJSON(t2), this) : (delete this.style, this);
            }, r2.prototype._lazyInitEmptyStyle = function() {
              this.style || (this.style = new je(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
            }, r2.prototype._diffStyle = function(e2, i2) {
              var o3 = this;
              if ("string" == typeof e2) {
                var r3 = this._requestManager.normalizeStyleURL(e2), a3 = this._requestManager.transformRequest(r3, t.ResourceType.Style);
                t.getJSON(a3, function(e3, r4) {
                  e3 ? o3.fire(new t.ErrorEvent(e3)) : r4 && o3._updateDiff(r4, i2);
                });
              } else
                "object" == typeof e2 && this._updateDiff(e2, i2);
            }, r2.prototype._updateDiff = function(e2, i2) {
              try {
                this.style.setState(e2) && this._update(true);
              } catch (o3) {
                t.warnOnce("Unable to perform style diff: " + (o3.message || o3.error || o3) + ".  Rebuilding the style from scratch."), this._updateStyle(e2, i2);
              }
            }, r2.prototype.getStyle = function() {
              if (this.style)
                return this.style.serialize();
            }, r2.prototype.isStyleLoaded = function() {
              return this.style ? this.style.loaded() : t.warnOnce("There is no style added to the map.");
            }, r2.prototype.addSource = function(t2, e2) {
              return this._lazyInitEmptyStyle(), this.style.addSource(t2, e2), this._update(true);
            }, r2.prototype.isSourceLoaded = function(e2) {
              var i2 = this.style && this.style.sourceCaches[e2];
              if (void 0 !== i2)
                return i2.loaded();
              this.fire(new t.ErrorEvent(new Error("There is no source with ID '" + e2 + "'")));
            }, r2.prototype.areTilesLoaded = function() {
              var t2 = this.style && this.style.sourceCaches;
              for (var e2 in t2) {
                var i2 = t2[e2]._tiles;
                for (var o3 in i2) {
                  var r3 = i2[o3];
                  if ("loaded" !== r3.state && "errored" !== r3.state)
                    return false;
                }
              }
              return true;
            }, r2.prototype.addSourceType = function(t2, e2, i2) {
              return this._lazyInitEmptyStyle(), this.style.addSourceType(t2, e2, i2);
            }, r2.prototype.removeSource = function(t2) {
              return this.style.removeSource(t2), this._update(true);
            }, r2.prototype.getSource = function(t2) {
              return this.style.getSource(t2);
            }, r2.prototype.addImage = function(e2, i2, o3) {
              void 0 === o3 && (o3 = {});
              var r3 = o3.pixelRatio;
              void 0 === r3 && (r3 = 1);
              var a3 = o3.sdf;
              void 0 === a3 && (a3 = false);
              var n2 = o3.stretchX, s2 = o3.stretchY, l2 = o3.content;
              if (this._lazyInitEmptyStyle(), i2 instanceof Tr || Ir && i2 instanceof Ir) {
                var c2 = t.browser.getImageData(i2);
                this.style.addImage(e2, { data: new t.RGBAImage({ width: c2.width, height: c2.height }, c2.data), pixelRatio: r3, stretchX: n2, stretchY: s2, content: l2, sdf: a3, version: 0 });
              } else {
                if (void 0 === i2.width || void 0 === i2.height)
                  return this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                var u2 = i2;
                this.style.addImage(e2, { data: new t.RGBAImage({ width: i2.width, height: i2.height }, new Uint8Array(i2.data)), pixelRatio: r3, stretchX: n2, stretchY: s2, content: l2, sdf: a3, version: 0, userImage: u2 }), u2.onAdd && u2.onAdd(this, e2);
              }
            }, r2.prototype.updateImage = function(e2, i2) {
              var o3 = this.style.getImage(e2);
              if (!o3)
                return this.fire(new t.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
              var r3 = i2 instanceof Tr || Ir && i2 instanceof Ir ? t.browser.getImageData(i2) : i2, a3 = r3.width, n2 = r3.height, s2 = r3.data;
              return void 0 === a3 || void 0 === n2 ? this.fire(new t.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`"))) : a3 !== o3.data.width || n2 !== o3.data.height ? this.fire(new t.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image"))) : (o3.data.replace(s2, !(i2 instanceof Tr || Ir && i2 instanceof Ir)), void this.style.updateImage(e2, o3));
            }, r2.prototype.hasImage = function(e2) {
              return e2 ? !!this.style.getImage(e2) : (this.fire(new t.ErrorEvent(new Error("Missing required image id"))), false);
            }, r2.prototype.removeImage = function(t2) {
              this.style.removeImage(t2);
            }, r2.prototype.loadImage = function(e2, i2) {
              t.getImage(this._requestManager.transformRequest(e2, t.ResourceType.Image), i2);
            }, r2.prototype.listImages = function() {
              return this.style.listImages();
            }, r2.prototype.addLayer = function(t2, e2) {
              return this._lazyInitEmptyStyle(), this.style.addLayer(t2, e2), this._update(true);
            }, r2.prototype.moveLayer = function(t2, e2) {
              return this.style.moveLayer(t2, e2), this._update(true);
            }, r2.prototype.removeLayer = function(t2) {
              return this.style.removeLayer(t2), this._update(true);
            }, r2.prototype.getLayer = function(t2) {
              return this.style.getLayer(t2);
            }, r2.prototype.setLayerZoomRange = function(t2, e2, i2) {
              return this.style.setLayerZoomRange(t2, e2, i2), this._update(true);
            }, r2.prototype.setFilter = function(t2, e2, i2) {
              return void 0 === i2 && (i2 = {}), this.style.setFilter(t2, e2, i2), this._update(true);
            }, r2.prototype.getFilter = function(t2) {
              return this.style.getFilter(t2);
            }, r2.prototype.setPaintProperty = function(t2, e2, i2, o3) {
              return void 0 === o3 && (o3 = {}), this.style.setPaintProperty(t2, e2, i2, o3), this._update(true);
            }, r2.prototype.getPaintProperty = function(t2, e2) {
              return this.style.getPaintProperty(t2, e2);
            }, r2.prototype.setLayoutProperty = function(t2, e2, i2, o3) {
              return void 0 === o3 && (o3 = {}), this.style.setLayoutProperty(t2, e2, i2, o3), this._update(true);
            }, r2.prototype.getLayoutProperty = function(t2, e2) {
              return this.style.getLayoutProperty(t2, e2);
            }, r2.prototype.setLight = function(t2, e2) {
              return void 0 === e2 && (e2 = {}), this._lazyInitEmptyStyle(), this.style.setLight(t2, e2), this._update(true);
            }, r2.prototype.getLight = function() {
              return this.style.getLight();
            }, r2.prototype.setFeatureState = function(t2, e2) {
              return this.style.setFeatureState(t2, e2), this._update();
            }, r2.prototype.removeFeatureState = function(t2, e2) {
              return this.style.removeFeatureState(t2, e2), this._update();
            }, r2.prototype.getFeatureState = function(t2) {
              return this.style.getFeatureState(t2);
            }, r2.prototype.getContainer = function() {
              return this._container;
            }, r2.prototype.getCanvasContainer = function() {
              return this._canvasContainer;
            }, r2.prototype.getCanvas = function() {
              return this._canvas;
            }, r2.prototype._containerDimensions = function() {
              var t2 = 0, e2 = 0;
              return this._container && (t2 = this._container.clientWidth || 400, e2 = this._container.clientHeight || 300), [t2, e2];
            }, r2.prototype._detectMissingCSS = function() {
              "rgb(250, 128, 114)" !== t.window.getComputedStyle(this._missingCSSCanary).getPropertyValue("background-color") && t.warnOnce("This page appears to be missing CSS declarations for Mapbox GL JS, which may cause the map to display incorrectly. Please ensure your page includes mapbox-gl.css, as described in https://www.mapbox.com/mapbox-gl-js/api/.");
            }, r2.prototype._setupContainer = function() {
              var t2 = this._container;
              t2.classList.add("mapboxgl-map"), (this._missingCSSCanary = i.create("div", "mapboxgl-canary", t2)).style.visibility = "hidden", this._detectMissingCSS();
              var e2 = this._canvasContainer = i.create("div", "mapboxgl-canvas-container", t2);
              this._interactive && e2.classList.add("mapboxgl-interactive"), this._canvas = i.create("canvas", "mapboxgl-canvas", e2), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
              var o3 = this._containerDimensions();
              this._resizeCanvas(o3[0], o3[1]);
              var r3 = this._controlContainer = i.create("div", "mapboxgl-control-container", t2), a3 = this._controlPositions = {};
              ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(function(t3) {
                a3[t3] = i.create("div", "mapboxgl-ctrl-" + t3, r3);
              }), this._container.addEventListener("scroll", this._onMapScroll, false);
            }, r2.prototype._resizeCanvas = function(e2, i2) {
              var o3 = t.browser.devicePixelRatio || 1;
              this._canvas.width = o3 * e2, this._canvas.height = o3 * i2, this._canvas.style.width = e2 + "px", this._canvas.style.height = i2 + "px";
            }, r2.prototype._setupPainter = function() {
              var i2 = t.extend({}, e.webGLContextAttributes, { failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false }), o3 = this._canvas.getContext("webgl", i2) || this._canvas.getContext("experimental-webgl", i2);
              o3 ? (this.painter = new yo(o3, this.transform), t.webpSupported.testSupport(o3)) : this.fire(new t.ErrorEvent(new Error("Failed to initialize WebGL")));
            }, r2.prototype._contextLost = function(e2) {
              e2.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new t.Event("webglcontextlost", { originalEvent: e2 }));
            }, r2.prototype._contextRestored = function(e2) {
              this._setupPainter(), this.resize(), this._update(), this.fire(new t.Event("webglcontextrestored", { originalEvent: e2 }));
            }, r2.prototype._onMapScroll = function(t2) {
              if (t2.target === this._container)
                return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
            }, r2.prototype.loaded = function() {
              return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
            }, r2.prototype._update = function(t2) {
              return this.style ? (this._styleDirty = this._styleDirty || t2, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
            }, r2.prototype._requestRenderFrame = function(t2) {
              return this._update(), this._renderTaskQueue.add(t2);
            }, r2.prototype._cancelRenderFrame = function(t2) {
              this._renderTaskQueue.remove(t2);
            }, r2.prototype._render = function(e2) {
              var i2, o3 = this, r3 = 0, a3 = this.painter.context.extTimerQuery;
              if (this.listens("gpu-timing-frame") && (i2 = a3.createQueryEXT(), a3.beginQueryEXT(a3.TIME_ELAPSED_EXT, i2), r3 = t.browser.now()), this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e2), !this._removed) {
                var n2 = false;
                if (this.style && this._styleDirty) {
                  this._styleDirty = false;
                  var s2 = this.transform.zoom, l2 = t.browser.now();
                  this.style.zoomHistory.update(s2, l2);
                  var c2 = new t.EvaluationParameters(s2, { now: l2, fadeDuration: this._fadeDuration, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), u2 = c2.crossFadingFactor();
                  1 === u2 && u2 === this._crossFadingFactor || (n2 = true, this._crossFadingFactor = u2), this.style.update(c2);
                }
                if (this.style && this._sourcesDirty && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, this._fadeDuration, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: this._fadeDuration, showPadding: this.showPadding, gpuTiming: !!this.listens("gpu-timing-layer") }), this.fire(new t.Event("render")), this.loaded() && !this._loaded && (this._loaded = true, this.fire(new t.Event("load"))), this.style && (this.style.hasTransitions() || n2) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles(), this.listens("gpu-timing-frame")) {
                  var h2 = t.browser.now() - r3;
                  a3.endQueryEXT(a3.TIME_ELAPSED_EXT, i2), setTimeout(function() {
                    var e3 = a3.getQueryObjectEXT(i2, a3.QUERY_RESULT_EXT) / 1e6;
                    a3.deleteQueryEXT(i2), o3.fire(new t.Event("gpu-timing-frame", { cpuTime: h2, gpuTime: e3 }));
                  }, 50);
                }
                if (this.listens("gpu-timing-layer")) {
                  var p2 = this.painter.collectGpuTimers();
                  setTimeout(function() {
                    var e3 = o3.painter.queryGpuTimers(p2);
                    o3.fire(new t.Event("gpu-timing-layer", { layerTimes: e3 }));
                  }, 50);
                }
                var d2 = this._sourcesDirty || this._styleDirty || this._placementDirty;
                return d2 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t.Event("idle")), !this._loaded || this._fullyLoaded || d2 || (this._fullyLoaded = true), this;
              }
            }, r2.prototype.remove = function() {
              this._hash && this._hash.remove();
              for (var e2 = 0, i2 = this._controls; e2 < i2.length; e2 += 1)
                i2[e2].onRemove(this);
              this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), void 0 !== t.window && (t.window.removeEventListener("resize", this._onWindowResize, false), t.window.removeEventListener("orientationchange", this._onWindowResize, false), t.window.removeEventListener("online", this._onWindowOnline, false));
              var o3 = this.painter.context.gl.getExtension("WEBGL_lose_context");
              o3 && o3.loseContext(), Cr(this._canvasContainer), Cr(this._controlContainer), Cr(this._missingCSSCanary), this._container.classList.remove("mapboxgl-map"), this._removed = true, this.fire(new t.Event("remove"));
            }, r2.prototype.triggerRepaint = function() {
              var e2 = this;
              this.style && !this._frame && (this._frame = t.browser.frame(function(t2) {
                e2._frame = null, e2._render(t2);
              }));
            }, r2.prototype._onWindowOnline = function() {
              this._update();
            }, r2.prototype._onWindowResize = function(t2) {
              this._trackResize && this.resize({ originalEvent: t2 })._update();
            }, a2.showTileBoundaries.get = function() {
              return !!this._showTileBoundaries;
            }, a2.showTileBoundaries.set = function(t2) {
              this._showTileBoundaries !== t2 && (this._showTileBoundaries = t2, this._update());
            }, a2.showPadding.get = function() {
              return !!this._showPadding;
            }, a2.showPadding.set = function(t2) {
              this._showPadding !== t2 && (this._showPadding = t2, this._update());
            }, a2.showCollisionBoxes.get = function() {
              return !!this._showCollisionBoxes;
            }, a2.showCollisionBoxes.set = function(t2) {
              this._showCollisionBoxes !== t2 && (this._showCollisionBoxes = t2, t2 ? this.style._generateCollisionBoxes() : this._update());
            }, a2.showOverdrawInspector.get = function() {
              return !!this._showOverdrawInspector;
            }, a2.showOverdrawInspector.set = function(t2) {
              this._showOverdrawInspector !== t2 && (this._showOverdrawInspector = t2, this._update());
            }, a2.repaint.get = function() {
              return !!this._repaint;
            }, a2.repaint.set = function(t2) {
              this._repaint !== t2 && (this._repaint = t2, this.triggerRepaint());
            }, a2.vertices.get = function() {
              return !!this._vertices;
            }, a2.vertices.set = function(t2) {
              this._vertices = t2, this._update();
            }, r2.prototype._setCacheLimits = function(e2, i2) {
              t.setCacheLimits(e2, i2);
            }, a2.version.get = function() {
              return t.version;
            }, Object.defineProperties(r2.prototype, a2), r2;
          }(vr);
          function Cr(t2) {
            t2.parentNode && t2.parentNode.removeChild(t2);
          }
          var zr = { showCompass: true, showZoom: true, visualizePitch: false }, Dr = function(e2) {
            var o2 = this;
            this.options = t.extend({}, zr, e2), this._container = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._container.addEventListener("contextmenu", function(t2) {
              return t2.preventDefault();
            }), this.options.showZoom && (t.bindAll(["_setButtonTitle", "_updateZoomButtons"], this), this._zoomInButton = this._createButton("mapboxgl-ctrl-zoom-in", function(t2) {
              return o2._map.zoomIn({}, { originalEvent: t2 });
            }), i.create("span", "mapboxgl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", true), this._zoomOutButton = this._createButton("mapboxgl-ctrl-zoom-out", function(t2) {
              return o2._map.zoomOut({}, { originalEvent: t2 });
            }), i.create("span", "mapboxgl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", true)), this.options.showCompass && (t.bindAll(["_rotateCompassArrow"], this), this._compass = this._createButton("mapboxgl-ctrl-compass", function(t2) {
              o2.options.visualizePitch ? o2._map.resetNorthPitch({}, { originalEvent: t2 }) : o2._map.resetNorth({}, { originalEvent: t2 });
            }), this._compassIcon = i.create("span", "mapboxgl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", true));
          };
          Dr.prototype._updateZoomButtons = function() {
            var t2 = this._map.getZoom(), e2 = t2 === this._map.getMaxZoom(), i2 = t2 === this._map.getMinZoom();
            this._zoomInButton.disabled = e2, this._zoomOutButton.disabled = i2, this._zoomInButton.setAttribute("aria-disabled", e2.toString()), this._zoomOutButton.setAttribute("aria-disabled", i2.toString());
          }, Dr.prototype._rotateCompassArrow = function() {
            var t2 = this.options.visualizePitch ? "scale(" + 1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5) + ") rotateX(" + this._map.transform.pitch + "deg) rotateZ(" + this._map.transform.angle * (180 / Math.PI) + "deg)" : "rotate(" + this._map.transform.angle * (180 / Math.PI) + "deg)";
            this._compassIcon.style.transform = t2;
          }, Dr.prototype.onAdd = function(t2) {
            return this._map = t2, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new Ar(this._map, this._compass, this.options.visualizePitch)), this._container;
          }, Dr.prototype.onRemove = function() {
            i.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
          }, Dr.prototype._createButton = function(t2, e2) {
            var o2 = i.create("button", t2, this._container);
            return o2.type = "button", o2.addEventListener("click", e2), o2;
          }, Dr.prototype._setButtonTitle = function(t2, e2) {
            var i2 = this._map._getUIString("NavigationControl." + e2);
            t2.title = i2, t2.setAttribute("aria-label", i2);
          };
          var Ar = function(e2, o2, r2) {
            void 0 === r2 && (r2 = false), this._clickTolerance = 10, this.element = o2, this.mouseRotate = new Xo({ clickTolerance: e2.dragRotate._mouseRotate._clickTolerance }), this.map = e2, r2 && (this.mousePitch = new Ho({ clickTolerance: e2.dragRotate._mousePitch._clickTolerance })), t.bindAll(["mousedown", "mousemove", "mouseup", "touchstart", "touchmove", "touchend", "reset"], this), i.addEventListener(o2, "mousedown", this.mousedown), i.addEventListener(o2, "touchstart", this.touchstart, { passive: false }), i.addEventListener(o2, "touchmove", this.touchmove), i.addEventListener(o2, "touchend", this.touchend), i.addEventListener(o2, "touchcancel", this.reset);
          };
          function Mr(e2, i2, o2) {
            if (e2 = new t.LngLat(e2.lng, e2.lat), i2) {
              var r2 = new t.LngLat(e2.lng - 360, e2.lat), a2 = new t.LngLat(e2.lng + 360, e2.lat), n2 = o2.locationPoint(e2).distSqr(i2);
              o2.locationPoint(r2).distSqr(i2) < n2 ? e2 = r2 : o2.locationPoint(a2).distSqr(i2) < n2 && (e2 = a2);
            }
            for (; Math.abs(e2.lng - o2.center.lng) > 180; ) {
              var s2 = o2.locationPoint(e2);
              if (s2.x >= 0 && s2.y >= 0 && s2.x <= o2.width && s2.y <= o2.height)
                break;
              e2.lng > o2.center.lng ? e2.lng -= 360 : e2.lng += 360;
            }
            return e2;
          }
          Ar.prototype.down = function(t2, e2) {
            this.mouseRotate.mousedown(t2, e2), this.mousePitch && this.mousePitch.mousedown(t2, e2), i.disableDrag();
          }, Ar.prototype.move = function(t2, e2) {
            var i2 = this.map, o2 = this.mouseRotate.mousemoveWindow(t2, e2);
            if (o2 && o2.bearingDelta && i2.setBearing(i2.getBearing() + o2.bearingDelta), this.mousePitch) {
              var r2 = this.mousePitch.mousemoveWindow(t2, e2);
              r2 && r2.pitchDelta && i2.setPitch(i2.getPitch() + r2.pitchDelta);
            }
          }, Ar.prototype.off = function() {
            var t2 = this.element;
            i.removeEventListener(t2, "mousedown", this.mousedown), i.removeEventListener(t2, "touchstart", this.touchstart, { passive: false }), i.removeEventListener(t2, "touchmove", this.touchmove), i.removeEventListener(t2, "touchend", this.touchend), i.removeEventListener(t2, "touchcancel", this.reset), this.offTemp();
          }, Ar.prototype.offTemp = function() {
            i.enableDrag(), i.removeEventListener(t.window, "mousemove", this.mousemove), i.removeEventListener(t.window, "mouseup", this.mouseup);
          }, Ar.prototype.mousedown = function(e2) {
            this.down(t.extend({}, e2, { ctrlKey: true, preventDefault: function() {
              return e2.preventDefault();
            } }), i.mousePos(this.element, e2)), i.addEventListener(t.window, "mousemove", this.mousemove), i.addEventListener(t.window, "mouseup", this.mouseup);
          }, Ar.prototype.mousemove = function(t2) {
            this.move(t2, i.mousePos(this.element, t2));
          }, Ar.prototype.mouseup = function(t2) {
            this.mouseRotate.mouseupWindow(t2), this.mousePitch && this.mousePitch.mouseupWindow(t2), this.offTemp();
          }, Ar.prototype.touchstart = function(t2) {
            1 !== t2.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = i.touchPos(this.element, t2.targetTouches)[0], this.down({ type: "mousedown", button: 0, ctrlKey: true, preventDefault: function() {
              return t2.preventDefault();
            } }, this._startPos));
          }, Ar.prototype.touchmove = function(t2) {
            1 !== t2.targetTouches.length ? this.reset() : (this._lastPos = i.touchPos(this.element, t2.targetTouches)[0], this.move({ preventDefault: function() {
              return t2.preventDefault();
            } }, this._lastPos));
          }, Ar.prototype.touchend = function(t2) {
            0 === t2.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), this.reset();
          }, Ar.prototype.reset = function() {
            this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
          };
          var Lr = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
          function Rr(t2, e2, i2) {
            var o2 = t2.classList;
            for (var r2 in Lr)
              o2.remove("mapboxgl-" + i2 + "-anchor-" + r2);
            o2.add("mapboxgl-" + i2 + "-anchor-" + e2);
          }
          var kr, Br = function(e2) {
            function o2(o3, r2) {
              if (e2.call(this), (o3 instanceof t.window.HTMLElement || r2) && (o3 = t.extend({ element: o3 }, r2)), t.bindAll(["_update", "_onMove", "_onUp", "_addDragHandler", "_onMapClick", "_onKeyPress"], this), this._anchor = o3 && o3.anchor || "center", this._color = o3 && o3.color || "#3FB1CE", this._scale = o3 && o3.scale || 1, this._draggable = o3 && o3.draggable || false, this._clickTolerance = o3 && o3.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = o3 && o3.rotation || 0, this._rotationAlignment = o3 && o3.rotationAlignment || "auto", this._pitchAlignment = o3 && o3.pitchAlignment && "auto" !== o3.pitchAlignment ? o3.pitchAlignment : this._rotationAlignment, o3 && o3.element)
                this._element = o3.element, this._offset = t.Point.convert(o3 && o3.offset || [0, 0]);
              else {
                this._defaultMarker = true, this._element = i.create("div"), this._element.setAttribute("aria-label", "Map marker");
                var a2 = i.createNS("http://www.w3.org/2000/svg", "svg");
                a2.setAttributeNS(null, "display", "block"), a2.setAttributeNS(null, "height", "41px"), a2.setAttributeNS(null, "width", "27px"), a2.setAttributeNS(null, "viewBox", "0 0 27 41");
                var n2 = i.createNS("http://www.w3.org/2000/svg", "g");
                n2.setAttributeNS(null, "stroke", "none"), n2.setAttributeNS(null, "stroke-width", "1"), n2.setAttributeNS(null, "fill", "none"), n2.setAttributeNS(null, "fill-rule", "evenodd");
                var s2 = i.createNS("http://www.w3.org/2000/svg", "g");
                s2.setAttributeNS(null, "fill-rule", "nonzero");
                var l2 = i.createNS("http://www.w3.org/2000/svg", "g");
                l2.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l2.setAttributeNS(null, "fill", "#000000");
                for (var c2 = 0, u2 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }]; c2 < u2.length; c2 += 1) {
                  var h2 = u2[c2], p2 = i.createNS("http://www.w3.org/2000/svg", "ellipse");
                  p2.setAttributeNS(null, "opacity", "0.04"), p2.setAttributeNS(null, "cx", "10.5"), p2.setAttributeNS(null, "cy", "5.80029008"), p2.setAttributeNS(null, "rx", h2.rx), p2.setAttributeNS(null, "ry", h2.ry), l2.appendChild(p2);
                }
                var d2 = i.createNS("http://www.w3.org/2000/svg", "g");
                d2.setAttributeNS(null, "fill", this._color);
                var _2 = i.createNS("http://www.w3.org/2000/svg", "path");
                _2.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), d2.appendChild(_2);
                var f2 = i.createNS("http://www.w3.org/2000/svg", "g");
                f2.setAttributeNS(null, "opacity", "0.25"), f2.setAttributeNS(null, "fill", "#000000");
                var m2 = i.createNS("http://www.w3.org/2000/svg", "path");
                m2.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), f2.appendChild(m2);
                var g2 = i.createNS("http://www.w3.org/2000/svg", "g");
                g2.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), g2.setAttributeNS(null, "fill", "#FFFFFF");
                var v2 = i.createNS("http://www.w3.org/2000/svg", "g");
                v2.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
                var y2 = i.createNS("http://www.w3.org/2000/svg", "circle");
                y2.setAttributeNS(null, "fill", "#000000"), y2.setAttributeNS(null, "opacity", "0.25"), y2.setAttributeNS(null, "cx", "5.5"), y2.setAttributeNS(null, "cy", "5.5"), y2.setAttributeNS(null, "r", "5.4999962");
                var x2 = i.createNS("http://www.w3.org/2000/svg", "circle");
                x2.setAttributeNS(null, "fill", "#FFFFFF"), x2.setAttributeNS(null, "cx", "5.5"), x2.setAttributeNS(null, "cy", "5.5"), x2.setAttributeNS(null, "r", "5.4999962"), v2.appendChild(y2), v2.appendChild(x2), s2.appendChild(l2), s2.appendChild(d2), s2.appendChild(f2), s2.appendChild(g2), s2.appendChild(v2), a2.appendChild(s2), a2.setAttributeNS(null, "height", 41 * this._scale + "px"), a2.setAttributeNS(null, "width", 27 * this._scale + "px"), this._element.appendChild(a2), this._offset = t.Point.convert(o3 && o3.offset || [0, -14]);
              }
              this._element.classList.add("mapboxgl-marker"), this._element.addEventListener("dragstart", function(t2) {
                t2.preventDefault();
              }), this._element.addEventListener("mousedown", function(t2) {
                t2.preventDefault();
              }), Rr(this._element, this._anchor, "marker"), this._popup = null;
            }
            return e2 && (o2.__proto__ = e2), (o2.prototype = Object.create(e2 && e2.prototype)).constructor = o2, o2.prototype.addTo = function(t2) {
              return this.remove(), this._map = t2, t2.getCanvasContainer().appendChild(this._element), t2.on("move", this._update), t2.on("moveend", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
            }, o2.prototype.remove = function() {
              return this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), i.remove(this._element), this._popup && this._popup.remove(), this;
            }, o2.prototype.getLngLat = function() {
              return this._lngLat;
            }, o2.prototype.setLngLat = function(e3) {
              return this._lngLat = t.LngLat.convert(e3), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
            }, o2.prototype.getElement = function() {
              return this._element;
            }, o2.prototype.setPopup = function(t2) {
              if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t2) {
                if (!("offset" in t2.options)) {
                  var e3 = Math.sqrt(Math.pow(13.5, 2) / 2);
                  t2.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -38.1], "bottom-left": [e3, -1 * (24.6 + e3)], "bottom-right": [-e3, -1 * (24.6 + e3)], left: [13.5, -24.6], right: [-13.5, -24.6] } : this._offset;
                }
                this._popup = t2, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
              }
              return this;
            }, o2.prototype._onKeyPress = function(t2) {
              var e3 = t2.code, i2 = t2.charCode || t2.keyCode;
              "Space" !== e3 && "Enter" !== e3 && 32 !== i2 && 13 !== i2 || this.togglePopup();
            }, o2.prototype._onMapClick = function(t2) {
              var e3 = t2.originalEvent.target, i2 = this._element;
              this._popup && (e3 === i2 || i2.contains(e3)) && this.togglePopup();
            }, o2.prototype.getPopup = function() {
              return this._popup;
            }, o2.prototype.togglePopup = function() {
              var t2 = this._popup;
              return t2 ? (t2.isOpen() ? t2.remove() : t2.addTo(this._map), this) : this;
            }, o2.prototype._update = function(t2) {
              if (this._map) {
                this._map.transform.renderWorldCopies && (this._lngLat = Mr(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);
                var e3 = "";
                "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? e3 = "rotateZ(" + this._rotation + "deg)" : "map" === this._rotationAlignment && (e3 = "rotateZ(" + (this._rotation - this._map.getBearing()) + "deg)");
                var o3 = "";
                "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? o3 = "rotateX(0deg)" : "map" === this._pitchAlignment && (o3 = "rotateX(" + this._map.getPitch() + "deg)"), t2 && "moveend" !== t2.type || (this._pos = this._pos.round()), i.setTransform(this._element, Lr[this._anchor] + " translate(" + this._pos.x + "px, " + this._pos.y + "px) " + o3 + " " + e3);
              }
            }, o2.prototype.getOffset = function() {
              return this._offset;
            }, o2.prototype.setOffset = function(e3) {
              return this._offset = t.Point.convert(e3), this._update(), this;
            }, o2.prototype._onMove = function(e3) {
              if (!this._isDragging) {
                var i2 = this._clickTolerance || this._map._clickTolerance;
                this._isDragging = e3.point.dist(this._pointerdownPos) >= i2;
              }
              this._isDragging && (this._pos = e3.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t.Event("dragstart"))), this.fire(new t.Event("drag")));
            }, o2.prototype._onUp = function() {
              this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t.Event("dragend")), this._state = "inactive";
            }, o2.prototype._addDragHandler = function(t2) {
              this._element.contains(t2.originalEvent.target) && (t2.preventDefault(), this._positionDelta = t2.point.sub(this._pos).add(this._offset), this._pointerdownPos = t2.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
            }, o2.prototype.setDraggable = function(t2) {
              return this._draggable = !!t2, this._map && (t2 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
            }, o2.prototype.isDraggable = function() {
              return this._draggable;
            }, o2.prototype.setRotation = function(t2) {
              return this._rotation = t2 || 0, this._update(), this;
            }, o2.prototype.getRotation = function() {
              return this._rotation;
            }, o2.prototype.setRotationAlignment = function(t2) {
              return this._rotationAlignment = t2 || "auto", this._update(), this;
            }, o2.prototype.getRotationAlignment = function() {
              return this._rotationAlignment;
            }, o2.prototype.setPitchAlignment = function(t2) {
              return this._pitchAlignment = t2 && "auto" !== t2 ? t2 : this._rotationAlignment, this._update(), this;
            }, o2.prototype.getPitchAlignment = function() {
              return this._pitchAlignment;
            }, o2;
          }(t.Evented), Or = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true }, Fr = 0, Ur = false, Nr = function(e2) {
            function o2(i2) {
              e2.call(this), this.options = t.extend({}, Or, i2), t.bindAll(["_onSuccess", "_onError", "_onZoom", "_finish", "_setupUI", "_updateCamera", "_updateMarker"], this);
            }
            return e2 && (o2.__proto__ = e2), (o2.prototype = Object.create(e2 && e2.prototype)).constructor = o2, o2.prototype.onAdd = function(e3) {
              var o3;
              return this._map = e3, this._container = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), o3 = this._setupUI, void 0 !== kr ? o3(kr) : void 0 !== t.window.navigator.permissions ? t.window.navigator.permissions.query({ name: "geolocation" }).then(function(t2) {
                o3(kr = "denied" !== t2.state);
              }) : o3(kr = !!t.window.navigator.geolocation), this._container;
            }, o2.prototype.onRemove = function() {
              void 0 !== this._geolocationWatchID && (t.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), i.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Fr = 0, Ur = false;
            }, o2.prototype._isOutOfMapMaxBounds = function(t2) {
              var e3 = this._map.getMaxBounds(), i2 = t2.coords;
              return e3 && (i2.longitude < e3.getWest() || i2.longitude > e3.getEast() || i2.latitude < e3.getSouth() || i2.latitude > e3.getNorth());
            }, o2.prototype._setErrorState = function() {
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                  break;
                case "ACTIVE_LOCK":
                  this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
                  break;
                case "BACKGROUND":
                  this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting");
              }
            }, o2.prototype._onSuccess = function(e3) {
              if (this._map) {
                if (this._isOutOfMapMaxBounds(e3))
                  return this._setErrorState(), this.fire(new t.Event("outofmaxbounds", e3)), this._updateMarker(), void this._finish();
                if (this.options.trackUserLocation)
                  switch (this._lastKnownPosition = e3, this._watchState) {
                    case "WAITING_ACTIVE":
                    case "ACTIVE_LOCK":
                    case "ACTIVE_ERROR":
                      this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                      break;
                    case "BACKGROUND":
                    case "BACKGROUND_ERROR":
                      this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                  }
                this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e3), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e3), this.options.showUserLocation && this._dotElement.classList.remove("mapboxgl-user-location-dot-stale"), this.fire(new t.Event("geolocate", e3)), this._finish();
              }
            }, o2.prototype._updateCamera = function(e3) {
              var i2 = new t.LngLat(e3.coords.longitude, e3.coords.latitude), o3 = e3.coords.accuracy, r2 = this._map.getBearing(), a2 = t.extend({ bearing: r2 }, this.options.fitBoundsOptions);
              this._map.fitBounds(i2.toBounds(o3), a2, { geolocateSource: true });
            }, o2.prototype._updateMarker = function(e3) {
              if (e3) {
                var i2 = new t.LngLat(e3.coords.longitude, e3.coords.latitude);
                this._accuracyCircleMarker.setLngLat(i2).addTo(this._map), this._userLocationDotMarker.setLngLat(i2).addTo(this._map), this._accuracy = e3.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
              } else
                this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
            }, o2.prototype._updateCircleRadius = function() {
              var t2 = this._map._container.clientHeight / 2, e3 = this._map.unproject([0, t2]), i2 = this._map.unproject([1, t2]), o3 = e3.distanceTo(i2), r2 = Math.ceil(2 * this._accuracy / o3);
              this._circleElement.style.width = r2 + "px", this._circleElement.style.height = r2 + "px";
            }, o2.prototype._onZoom = function() {
              this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
            }, o2.prototype._onError = function(e3) {
              if (this._map) {
                if (this.options.trackUserLocation)
                  if (1 === e3.code) {
                    this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                    var i2 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                    this._geolocateButton.title = i2, this._geolocateButton.setAttribute("aria-label", i2), void 0 !== this._geolocationWatchID && this._clearWatch();
                  } else {
                    if (3 === e3.code && Ur)
                      return;
                    this._setErrorState();
                  }
                "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("mapboxgl-user-location-dot-stale"), this.fire(new t.Event("error", e3)), this._finish();
              }
            }, o2.prototype._finish = function() {
              this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
            }, o2.prototype._setupUI = function(e3) {
              var o3 = this;
              if (this._container.addEventListener("contextmenu", function(t2) {
                return t2.preventDefault();
              }), this._geolocateButton = i.create("button", "mapboxgl-ctrl-geolocate", this._container), i.create("span", "mapboxgl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", true), this._geolocateButton.type = "button", false === e3) {
                t.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
                var r2 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                this._geolocateButton.disabled = true, this._geolocateButton.title = r2, this._geolocateButton.setAttribute("aria-label", r2);
              } else {
                var a2 = this._map._getUIString("GeolocateControl.FindMyLocation");
                this._geolocateButton.title = a2, this._geolocateButton.setAttribute("aria-label", a2);
              }
              this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = i.create("div", "mapboxgl-user-location-dot"), this._userLocationDotMarker = new Br(this._dotElement), this._circleElement = i.create("div", "mapboxgl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Br({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", function(e4) {
                e4.geolocateSource || "ACTIVE_LOCK" !== o3._watchState || e4.originalEvent && "resize" === e4.originalEvent.type || (o3._watchState = "BACKGROUND", o3._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background"), o3._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), o3.fire(new t.Event("trackuserlocationend")));
              });
            }, o2.prototype.trigger = function() {
              if (!this._setup)
                return t.warnOnce("Geolocate control triggered before added to a map"), false;
              if (this.options.trackUserLocation) {
                switch (this._watchState) {
                  case "OFF":
                    this._watchState = "WAITING_ACTIVE", this.fire(new t.Event("trackuserlocationstart"));
                    break;
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                  case "BACKGROUND_ERROR":
                    Fr--, Ur = false, this._watchState = "OFF", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background-error"), this.fire(new t.Event("trackuserlocationend"));
                    break;
                  case "BACKGROUND":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t.Event("trackuserlocationstart"));
                }
                switch (this._watchState) {
                  case "WAITING_ACTIVE":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                    break;
                  case "ACTIVE_LOCK":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active");
                    break;
                  case "ACTIVE_ERROR":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-active-error");
                    break;
                  case "BACKGROUND":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
                    break;
                  case "BACKGROUND_ERROR":
                    this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background-error");
                }
                if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
                  this._clearWatch();
                else if (void 0 === this._geolocationWatchID) {
                  var e3;
                  this._geolocateButton.classList.add("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), ++Fr > 1 ? (e3 = { maximumAge: 6e5, timeout: 0 }, Ur = true) : (e3 = this.options.positionOptions, Ur = false), this._geolocationWatchID = t.window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, e3);
                }
              } else
                t.window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
              return true;
            }, o2.prototype._clearWatch = function() {
              t.window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
            }, o2;
          }(t.Evented), Zr = { maxWidth: 100, unit: "metric" }, qr = function(e2) {
            this.options = t.extend({}, Zr, e2), t.bindAll(["_onMove", "setUnit"], this);
          };
          function jr(t2, e2, i2) {
            var o2 = i2 && i2.maxWidth || 100, r2 = t2._container.clientHeight / 2, a2 = t2.unproject([0, r2]), n2 = t2.unproject([o2, r2]), s2 = a2.distanceTo(n2);
            if (i2 && "imperial" === i2.unit) {
              var l2 = 3.2808 * s2;
              l2 > 5280 ? Vr(e2, o2, l2 / 5280, t2._getUIString("ScaleControl.Miles")) : Vr(e2, o2, l2, t2._getUIString("ScaleControl.Feet"));
            } else
              i2 && "nautical" === i2.unit ? Vr(e2, o2, s2 / 1852, t2._getUIString("ScaleControl.NauticalMiles")) : s2 >= 1e3 ? Vr(e2, o2, s2 / 1e3, t2._getUIString("ScaleControl.Kilometers")) : Vr(e2, o2, s2, t2._getUIString("ScaleControl.Meters"));
          }
          function Vr(t2, e2, i2, o2) {
            var r2, a2, n2, s2 = (r2 = i2, (a2 = Math.pow(10, ("" + Math.floor(r2)).length - 1)) * (n2 = (n2 = r2 / a2) >= 10 ? 10 : n2 >= 5 ? 5 : n2 >= 3 ? 3 : n2 >= 2 ? 2 : n2 >= 1 ? 1 : function(t3) {
              var e3 = Math.pow(10, Math.ceil(-Math.log(t3) / Math.LN10));
              return Math.round(t3 * e3) / e3;
            }(n2)));
            t2.style.width = e2 * (s2 / i2) + "px", t2.innerHTML = s2 + "&nbsp;" + o2;
          }
          qr.prototype.getDefaultPosition = function() {
            return "bottom-left";
          }, qr.prototype._onMove = function() {
            jr(this._map, this._container, this.options);
          }, qr.prototype.onAdd = function(t2) {
            return this._map = t2, this._container = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-scale", t2.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
          }, qr.prototype.onRemove = function() {
            i.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
          }, qr.prototype.setUnit = function(t2) {
            this.options.unit = t2, jr(this._map, this._container, this.options);
          };
          var Gr = function(e2) {
            this._fullscreen = false, e2 && e2.container && (e2.container instanceof t.window.HTMLElement ? this._container = e2.container : t.warnOnce("Full screen control 'container' must be a DOM element.")), t.bindAll(["_onClickFullscreen", "_changeIcon"], this), "onfullscreenchange" in t.window.document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in t.window.document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in t.window.document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in t.window.document && (this._fullscreenchange = "MSFullscreenChange");
          };
          Gr.prototype.onAdd = function(e2) {
            return this._map = e2, this._container || (this._container = this._map.getContainer()), this._controlContainer = i.create("div", "mapboxgl-ctrl mapboxgl-ctrl-group"), this._checkFullscreenSupport() ? this._setupUI() : (this._controlContainer.style.display = "none", t.warnOnce("This device does not support fullscreen mode.")), this._controlContainer;
          }, Gr.prototype.onRemove = function() {
            i.remove(this._controlContainer), this._map = null, t.window.document.removeEventListener(this._fullscreenchange, this._changeIcon);
          }, Gr.prototype._checkFullscreenSupport = function() {
            return !!(t.window.document.fullscreenEnabled || t.window.document.mozFullScreenEnabled || t.window.document.msFullscreenEnabled || t.window.document.webkitFullscreenEnabled);
          }, Gr.prototype._setupUI = function() {
            var e2 = this._fullscreenButton = i.create("button", "mapboxgl-ctrl-fullscreen", this._controlContainer);
            i.create("span", "mapboxgl-ctrl-icon", e2).setAttribute("aria-hidden", true), e2.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), t.window.document.addEventListener(this._fullscreenchange, this._changeIcon);
          }, Gr.prototype._updateTitle = function() {
            var t2 = this._getTitle();
            this._fullscreenButton.setAttribute("aria-label", t2), this._fullscreenButton.title = t2;
          }, Gr.prototype._getTitle = function() {
            return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
          }, Gr.prototype._isFullscreen = function() {
            return this._fullscreen;
          }, Gr.prototype._changeIcon = function() {
            (t.window.document.fullscreenElement || t.window.document.mozFullScreenElement || t.window.document.webkitFullscreenElement || t.window.document.msFullscreenElement) === this._container !== this._fullscreen && (this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("mapboxgl-ctrl-shrink"), this._fullscreenButton.classList.toggle("mapboxgl-ctrl-fullscreen"), this._updateTitle());
          }, Gr.prototype._onClickFullscreen = function() {
            this._isFullscreen() ? t.window.document.exitFullscreen ? t.window.document.exitFullscreen() : t.window.document.mozCancelFullScreen ? t.window.document.mozCancelFullScreen() : t.window.document.msExitFullscreen ? t.window.document.msExitFullscreen() : t.window.document.webkitCancelFullScreen && t.window.document.webkitCancelFullScreen() : this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen && this._container.webkitRequestFullscreen();
          };
          var Wr = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, Xr = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", "), Hr = function(e2) {
            function o2(i2) {
              e2.call(this), this.options = t.extend(Object.create(Wr), i2), t.bindAll(["_update", "_onClose", "remove", "_onMouseMove", "_onMouseUp", "_onDrag"], this);
            }
            return e2 && (o2.__proto__ = e2), (o2.prototype = Object.create(e2 && e2.prototype)).constructor = o2, o2.prototype.addTo = function(e3) {
              return this._map && this.remove(), this._map = e3, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")) : this._map.on("move", this._update), this.fire(new t.Event("open")), this;
            }, o2.prototype.isOpen = function() {
              return !!this._map;
            }, o2.prototype.remove = function() {
              return this._content && i.remove(this._content), this._container && (i.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new t.Event("close")), this;
            }, o2.prototype.getLngLat = function() {
              return this._lngLat;
            }, o2.prototype.setLngLat = function(e3) {
              return this._lngLat = t.LngLat.convert(e3), this._pos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.remove("mapboxgl-track-pointer")), this;
            }, o2.prototype.trackPointer = function() {
              return this._trackPointer = true, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("mapboxgl-popup-track-pointer"), this._map._canvasContainer.classList.add("mapboxgl-track-pointer")), this;
            }, o2.prototype.getElement = function() {
              return this._container;
            }, o2.prototype.setText = function(e3) {
              return this.setDOMContent(t.window.document.createTextNode(e3));
            }, o2.prototype.setHTML = function(e3) {
              var i2, o3 = t.window.document.createDocumentFragment(), r2 = t.window.document.createElement("body");
              for (r2.innerHTML = e3; i2 = r2.firstChild; )
                o3.appendChild(i2);
              return this.setDOMContent(o3);
            }, o2.prototype.getMaxWidth = function() {
              return this._container && this._container.style.maxWidth;
            }, o2.prototype.setMaxWidth = function(t2) {
              return this.options.maxWidth = t2, this._update(), this;
            }, o2.prototype.setDOMContent = function(t2) {
              if (this._content)
                for (; this._content.hasChildNodes(); )
                  this._content.firstChild && this._content.removeChild(this._content.firstChild);
              else
                this._content = i.create("div", "mapboxgl-popup-content", this._container);
              return this._content.appendChild(t2), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
            }, o2.prototype.addClassName = function(t2) {
              this._container && this._container.classList.add(t2);
            }, o2.prototype.removeClassName = function(t2) {
              this._container && this._container.classList.remove(t2);
            }, o2.prototype.setOffset = function(t2) {
              return this.options.offset = t2, this._update(), this;
            }, o2.prototype.toggleClassName = function(t2) {
              if (this._container)
                return this._container.classList.toggle(t2);
            }, o2.prototype._createCloseButton = function() {
              this.options.closeButton && (this._closeButton = i.create("button", "mapboxgl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
            }, o2.prototype._onMouseUp = function(t2) {
              this._update(t2.point);
            }, o2.prototype._onMouseMove = function(t2) {
              this._update(t2.point);
            }, o2.prototype._onDrag = function(t2) {
              this._update(t2.point);
            }, o2.prototype._update = function(e3) {
              var o3 = this;
              if (this._map && (this._lngLat || this._trackPointer) && this._content && (this._container || (this._container = i.create("div", "mapboxgl-popup", this._map.getContainer()), this._tip = i.create("div", "mapboxgl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className && this.options.className.split(" ").forEach(function(t2) {
                return o3._container.classList.add(t2);
              }), this._trackPointer && this._container.classList.add("mapboxgl-popup-track-pointer")), this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = Mr(this._lngLat, this._pos, this._map.transform)), !this._trackPointer || e3)) {
                var r2 = this._pos = this._trackPointer && e3 ? e3 : this._map.project(this._lngLat), a2 = this.options.anchor, n2 = function e4(i2) {
                  if (i2) {
                    if ("number" == typeof i2) {
                      var o4 = Math.round(Math.sqrt(0.5 * Math.pow(i2, 2)));
                      return { center: new t.Point(0, 0), top: new t.Point(0, i2), "top-left": new t.Point(o4, o4), "top-right": new t.Point(-o4, o4), bottom: new t.Point(0, -i2), "bottom-left": new t.Point(o4, -o4), "bottom-right": new t.Point(-o4, -o4), left: new t.Point(i2, 0), right: new t.Point(-i2, 0) };
                    }
                    if (i2 instanceof t.Point || Array.isArray(i2)) {
                      var r3 = t.Point.convert(i2);
                      return { center: r3, top: r3, "top-left": r3, "top-right": r3, bottom: r3, "bottom-left": r3, "bottom-right": r3, left: r3, right: r3 };
                    }
                    return { center: t.Point.convert(i2.center || [0, 0]), top: t.Point.convert(i2.top || [0, 0]), "top-left": t.Point.convert(i2["top-left"] || [0, 0]), "top-right": t.Point.convert(i2["top-right"] || [0, 0]), bottom: t.Point.convert(i2.bottom || [0, 0]), "bottom-left": t.Point.convert(i2["bottom-left"] || [0, 0]), "bottom-right": t.Point.convert(i2["bottom-right"] || [0, 0]), left: t.Point.convert(i2.left || [0, 0]), right: t.Point.convert(i2.right || [0, 0]) };
                  }
                  return e4(new t.Point(0, 0));
                }(this.options.offset);
                if (!a2) {
                  var s2, l2 = this._container.offsetWidth, c2 = this._container.offsetHeight;
                  s2 = r2.y + n2.bottom.y < c2 ? ["top"] : r2.y > this._map.transform.height - c2 ? ["bottom"] : [], r2.x < l2 / 2 ? s2.push("left") : r2.x > this._map.transform.width - l2 / 2 && s2.push("right"), a2 = 0 === s2.length ? "bottom" : s2.join("-");
                }
                var u2 = r2.add(n2[a2]).round();
                i.setTransform(this._container, Lr[a2] + " translate(" + u2.x + "px," + u2.y + "px)"), Rr(this._container, a2, "popup");
              }
            }, o2.prototype._focusFirstElement = function() {
              if (this.options.focusAfterOpen && this._container) {
                var t2 = this._container.querySelector(Xr);
                t2 && t2.focus();
              }
            }, o2.prototype._onClose = function() {
              this.remove();
            }, o2;
          }(t.Evented), Kr = { version: t.version, supported: e, setRTLTextPlugin: t.setRTLTextPlugin, getRTLTextPluginStatus: t.getRTLTextPluginStatus, Map: Sr, NavigationControl: Dr, GeolocateControl: Nr, AttributionControl: yr, ScaleControl: qr, FullscreenControl: Gr, Popup: Hr, Marker: Br, Style: je, LngLat: t.LngLat, LngLatBounds: t.LngLatBounds, Point: t.Point, MercatorCoordinate: t.MercatorCoordinate, Evented: t.Evented, config: t.config, prewarm: function() {
            Ft().acquire(Rt);
          }, clearPrewarmedResources: function() {
            var t2 = Bt;
            t2 && (t2.isPreloaded() && 1 === t2.numActive() ? (t2.release(Rt), Bt = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
          }, get accessToken() {
            return t.config.ACCESS_TOKEN;
          }, set accessToken(e2) {
            t.config.ACCESS_TOKEN = e2;
          }, get baseApiUrl() {
            return t.config.API_URL;
          }, set baseApiUrl(e2) {
            t.config.API_URL = e2;
          }, get workerCount() {
            return kt.workerCount;
          }, set workerCount(t2) {
            kt.workerCount = t2;
          }, get maxParallelImageRequests() {
            return t.config.MAX_PARALLEL_IMAGE_REQUESTS;
          }, set maxParallelImageRequests(e2) {
            t.config.MAX_PARALLEL_IMAGE_REQUESTS = e2;
          }, clearStorage: function(e2) {
            t.clearTileCache(e2);
          }, workerUrl: "" };
          return Kr;
        });
        return mapboxgl;
      });
    }
  });

  // node_modules/scheduler/cjs/scheduler.development.js
  var require_scheduler_development = __commonJS({
    "node_modules/scheduler/cjs/scheduler.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var enableSchedulerDebugging = false;
          var enableProfiling = false;
          var frameYieldMs = 5;
          function push3(heap, node) {
            var index5 = heap.length;
            heap.push(node);
            siftUp(heap, node, index5);
          }
          function peek(heap) {
            return heap.length === 0 ? null : heap[0];
          }
          function pop(heap) {
            if (heap.length === 0) {
              return null;
            }
            var first = heap[0];
            var last3 = heap.pop();
            if (last3 !== first) {
              heap[0] = last3;
              siftDown(heap, last3, 0);
            }
            return first;
          }
          function siftUp(heap, node, i) {
            var index5 = i;
            while (index5 > 0) {
              var parentIndex = index5 - 1 >>> 1;
              var parent2 = heap[parentIndex];
              if (compare2(parent2, node) > 0) {
                heap[parentIndex] = node;
                heap[index5] = parent2;
                index5 = parentIndex;
              } else {
                return;
              }
            }
          }
          function siftDown(heap, node, i) {
            var index5 = i;
            var length7 = heap.length;
            var halfLength = length7 >>> 1;
            while (index5 < halfLength) {
              var leftIndex = (index5 + 1) * 2 - 1;
              var left3 = heap[leftIndex];
              var rightIndex = leftIndex + 1;
              var right = heap[rightIndex];
              if (compare2(left3, node) < 0) {
                if (rightIndex < length7 && compare2(right, left3) < 0) {
                  heap[index5] = right;
                  heap[rightIndex] = node;
                  index5 = rightIndex;
                } else {
                  heap[index5] = left3;
                  heap[leftIndex] = node;
                  index5 = leftIndex;
                }
              } else if (rightIndex < length7 && compare2(right, node) < 0) {
                heap[index5] = right;
                heap[rightIndex] = node;
                index5 = rightIndex;
              } else {
                return;
              }
            }
          }
          function compare2(a, b) {
            var diff = a.sortIndex - b.sortIndex;
            return diff !== 0 ? diff : a.id - b.id;
          }
          var ImmediatePriority = 1;
          var UserBlockingPriority = 2;
          var NormalPriority = 3;
          var LowPriority = 4;
          var IdlePriority = 5;
          function markTaskErrored(task, ms) {
          }
          var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
          if (hasPerformanceNow) {
            var localPerformance = performance;
            exports.unstable_now = function() {
              return localPerformance.now();
            };
          } else {
            var localDate = Date;
            var initialTime = localDate.now();
            exports.unstable_now = function() {
              return localDate.now() - initialTime;
            };
          }
          var maxSigned31BitInt = 1073741823;
          var IMMEDIATE_PRIORITY_TIMEOUT = -1;
          var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
          var NORMAL_PRIORITY_TIMEOUT = 5e3;
          var LOW_PRIORITY_TIMEOUT = 1e4;
          var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
          var taskQueue = [];
          var timerQueue = [];
          var taskIdCounter = 1;
          var currentTask = null;
          var currentPriorityLevel = NormalPriority;
          var isPerformingWork = false;
          var isHostCallbackScheduled = false;
          var isHostTimeoutScheduled = false;
          var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
          var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
          var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
          var isInputPending = typeof navigator !== "undefined" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
          function advanceTimers(currentTime2) {
            var timer = peek(timerQueue);
            while (timer !== null) {
              if (timer.callback === null) {
                pop(timerQueue);
              } else if (timer.startTime <= currentTime2) {
                pop(timerQueue);
                timer.sortIndex = timer.expirationTime;
                push3(taskQueue, timer);
              } else {
                return;
              }
              timer = peek(timerQueue);
            }
          }
          function handleTimeout(currentTime2) {
            isHostTimeoutScheduled = false;
            advanceTimers(currentTime2);
            if (!isHostCallbackScheduled) {
              if (peek(taskQueue) !== null) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
              } else {
                var firstTimer = peek(timerQueue);
                if (firstTimer !== null) {
                  requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime2);
                }
              }
            }
          }
          function flushWork(hasTimeRemaining, initialTime2) {
            isHostCallbackScheduled = false;
            if (isHostTimeoutScheduled) {
              isHostTimeoutScheduled = false;
              cancelHostTimeout();
            }
            isPerformingWork = true;
            var previousPriorityLevel = currentPriorityLevel;
            try {
              if (enableProfiling) {
                try {
                  return workLoop(hasTimeRemaining, initialTime2);
                } catch (error3) {
                  if (currentTask !== null) {
                    var currentTime2 = exports.unstable_now();
                    markTaskErrored(currentTask, currentTime2);
                    currentTask.isQueued = false;
                  }
                  throw error3;
                }
              } else {
                return workLoop(hasTimeRemaining, initialTime2);
              }
            } finally {
              currentTask = null;
              currentPriorityLevel = previousPriorityLevel;
              isPerformingWork = false;
            }
          }
          function workLoop(hasTimeRemaining, initialTime2) {
            var currentTime2 = initialTime2;
            advanceTimers(currentTime2);
            currentTask = peek(taskQueue);
            while (currentTask !== null && !enableSchedulerDebugging) {
              if (currentTask.expirationTime > currentTime2 && (!hasTimeRemaining || shouldYieldToHost())) {
                break;
              }
              var callback = currentTask.callback;
              if (typeof callback === "function") {
                currentTask.callback = null;
                currentPriorityLevel = currentTask.priorityLevel;
                var didUserCallbackTimeout = currentTask.expirationTime <= currentTime2;
                var continuationCallback = callback(didUserCallbackTimeout);
                currentTime2 = exports.unstable_now();
                if (typeof continuationCallback === "function") {
                  currentTask.callback = continuationCallback;
                } else {
                  if (currentTask === peek(taskQueue)) {
                    pop(taskQueue);
                  }
                }
                advanceTimers(currentTime2);
              } else {
                pop(taskQueue);
              }
              currentTask = peek(taskQueue);
            }
            if (currentTask !== null) {
              return true;
            } else {
              var firstTimer = peek(timerQueue);
              if (firstTimer !== null) {
                requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime2);
              }
              return false;
            }
          }
          function unstable_runWithPriority(priorityLevel, eventHandler) {
            switch (priorityLevel) {
              case ImmediatePriority:
              case UserBlockingPriority:
              case NormalPriority:
              case LowPriority:
              case IdlePriority:
                break;
              default:
                priorityLevel = NormalPriority;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }
          function unstable_next(eventHandler) {
            var priorityLevel;
            switch (currentPriorityLevel) {
              case ImmediatePriority:
              case UserBlockingPriority:
              case NormalPriority:
                priorityLevel = NormalPriority;
                break;
              default:
                priorityLevel = currentPriorityLevel;
                break;
            }
            var previousPriorityLevel = currentPriorityLevel;
            currentPriorityLevel = priorityLevel;
            try {
              return eventHandler();
            } finally {
              currentPriorityLevel = previousPriorityLevel;
            }
          }
          function unstable_wrapCallback(callback) {
            var parentPriorityLevel = currentPriorityLevel;
            return function() {
              var previousPriorityLevel = currentPriorityLevel;
              currentPriorityLevel = parentPriorityLevel;
              try {
                return callback.apply(this, arguments);
              } finally {
                currentPriorityLevel = previousPriorityLevel;
              }
            };
          }
          function unstable_scheduleCallback(priorityLevel, callback, options2) {
            var currentTime2 = exports.unstable_now();
            var startTime2;
            if (typeof options2 === "object" && options2 !== null) {
              var delay2 = options2.delay;
              if (typeof delay2 === "number" && delay2 > 0) {
                startTime2 = currentTime2 + delay2;
              } else {
                startTime2 = currentTime2;
              }
            } else {
              startTime2 = currentTime2;
            }
            var timeout;
            switch (priorityLevel) {
              case ImmediatePriority:
                timeout = IMMEDIATE_PRIORITY_TIMEOUT;
                break;
              case UserBlockingPriority:
                timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
                break;
              case IdlePriority:
                timeout = IDLE_PRIORITY_TIMEOUT;
                break;
              case LowPriority:
                timeout = LOW_PRIORITY_TIMEOUT;
                break;
              case NormalPriority:
              default:
                timeout = NORMAL_PRIORITY_TIMEOUT;
                break;
            }
            var expirationTime = startTime2 + timeout;
            var newTask = {
              id: taskIdCounter++,
              callback,
              priorityLevel,
              startTime: startTime2,
              expirationTime,
              sortIndex: -1
            };
            if (startTime2 > currentTime2) {
              newTask.sortIndex = startTime2;
              push3(timerQueue, newTask);
              if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
                if (isHostTimeoutScheduled) {
                  cancelHostTimeout();
                } else {
                  isHostTimeoutScheduled = true;
                }
                requestHostTimeout(handleTimeout, startTime2 - currentTime2);
              }
            } else {
              newTask.sortIndex = expirationTime;
              push3(taskQueue, newTask);
              if (!isHostCallbackScheduled && !isPerformingWork) {
                isHostCallbackScheduled = true;
                requestHostCallback(flushWork);
              }
            }
            return newTask;
          }
          function unstable_pauseExecution() {
          }
          function unstable_continueExecution() {
            if (!isHostCallbackScheduled && !isPerformingWork) {
              isHostCallbackScheduled = true;
              requestHostCallback(flushWork);
            }
          }
          function unstable_getFirstCallbackNode() {
            return peek(taskQueue);
          }
          function unstable_cancelCallback(task) {
            task.callback = null;
          }
          function unstable_getCurrentPriorityLevel() {
            return currentPriorityLevel;
          }
          var isMessageLoopRunning = false;
          var scheduledHostCallback = null;
          var taskTimeoutID = -1;
          var frameInterval = frameYieldMs;
          var startTime = -1;
          function shouldYieldToHost() {
            var timeElapsed = exports.unstable_now() - startTime;
            if (timeElapsed < frameInterval) {
              return false;
            }
            return true;
          }
          function requestPaint() {
          }
          function forceFrameRate(fps) {
            if (fps < 0 || fps > 125) {
              console["error"]("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
              return;
            }
            if (fps > 0) {
              frameInterval = Math.floor(1e3 / fps);
            } else {
              frameInterval = frameYieldMs;
            }
          }
          var performWorkUntilDeadline = function() {
            if (scheduledHostCallback !== null) {
              var currentTime2 = exports.unstable_now();
              startTime = currentTime2;
              var hasTimeRemaining = true;
              var hasMoreWork = true;
              try {
                hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime2);
              } finally {
                if (hasMoreWork) {
                  schedulePerformWorkUntilDeadline();
                } else {
                  isMessageLoopRunning = false;
                  scheduledHostCallback = null;
                }
              }
            } else {
              isMessageLoopRunning = false;
            }
          };
          var schedulePerformWorkUntilDeadline;
          if (typeof localSetImmediate === "function") {
            schedulePerformWorkUntilDeadline = function() {
              localSetImmediate(performWorkUntilDeadline);
            };
          } else if (typeof MessageChannel !== "undefined") {
            var channel = new MessageChannel();
            var port2 = channel.port2;
            channel.port1.onmessage = performWorkUntilDeadline;
            schedulePerformWorkUntilDeadline = function() {
              port2.postMessage(null);
            };
          } else {
            schedulePerformWorkUntilDeadline = function() {
              localSetTimeout(performWorkUntilDeadline, 0);
            };
          }
          function requestHostCallback(callback) {
            scheduledHostCallback = callback;
            if (!isMessageLoopRunning) {
              isMessageLoopRunning = true;
              schedulePerformWorkUntilDeadline();
            }
          }
          function requestHostTimeout(callback, ms) {
            taskTimeoutID = localSetTimeout(function() {
              callback(exports.unstable_now());
            }, ms);
          }
          function cancelHostTimeout() {
            localClearTimeout(taskTimeoutID);
            taskTimeoutID = -1;
          }
          var unstable_requestPaint = requestPaint;
          var unstable_Profiling = null;
          exports.unstable_IdlePriority = IdlePriority;
          exports.unstable_ImmediatePriority = ImmediatePriority;
          exports.unstable_LowPriority = LowPriority;
          exports.unstable_NormalPriority = NormalPriority;
          exports.unstable_Profiling = unstable_Profiling;
          exports.unstable_UserBlockingPriority = UserBlockingPriority;
          exports.unstable_cancelCallback = unstable_cancelCallback;
          exports.unstable_continueExecution = unstable_continueExecution;
          exports.unstable_forceFrameRate = forceFrameRate;
          exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
          exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
          exports.unstable_next = unstable_next;
          exports.unstable_pauseExecution = unstable_pauseExecution;
          exports.unstable_requestPaint = unstable_requestPaint;
          exports.unstable_runWithPriority = unstable_runWithPriority;
          exports.unstable_scheduleCallback = unstable_scheduleCallback;
          exports.unstable_shouldYield = shouldYieldToHost;
          exports.unstable_wrapCallback = unstable_wrapCallback;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      if (false) {
        module.exports = null;
      } else {
        module.exports = require_scheduler_development();
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom.development.js
  var require_react_dom_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
          }
          var React18 = require_react();
          var Scheduler = require_scheduler();
          var ReactSharedInternals = React18.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          var suppressWarning = false;
          function setSuppressWarning(newSuppressWarning) {
            {
              suppressWarning = newSuppressWarning;
            }
          }
          function warn(format) {
            {
              if (!suppressWarning) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format, args);
              }
            }
          }
          function error3(format) {
            {
              if (!suppressWarning) {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format, args);
              }
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          var FunctionComponent = 0;
          var ClassComponent = 1;
          var IndeterminateComponent = 2;
          var HostRoot = 3;
          var HostPortal = 4;
          var HostComponent = 5;
          var HostText = 6;
          var Fragment2 = 7;
          var Mode = 8;
          var ContextConsumer = 9;
          var ContextProvider = 10;
          var ForwardRef = 11;
          var Profiler = 12;
          var SuspenseComponent = 13;
          var MemoComponent = 14;
          var SimpleMemoComponent = 15;
          var LazyComponent = 16;
          var IncompleteClassComponent = 17;
          var DehydratedFragment = 18;
          var SuspenseListComponent = 19;
          var ScopeComponent = 21;
          var OffscreenComponent = 22;
          var LegacyHiddenComponent = 23;
          var CacheComponent = 24;
          var TracingMarkerComponent = 25;
          var enableClientRenderFallbackOnTextMismatch = true;
          var enableNewReconciler = false;
          var enableLazyContextPropagation = false;
          var enableLegacyHidden = false;
          var enableSuspenseAvoidThisFallback = false;
          var disableCommentsAsDOMContainers = true;
          var enableCustomElementPropertySupport = false;
          var warnAboutStringRefs = false;
          var enableSchedulingProfiler = true;
          var enableProfilerTimer = true;
          var enableProfilerCommitHooks = true;
          var allNativeEvents = /* @__PURE__ */ new Set();
          var registrationNameDependencies = {};
          var possibleRegistrationNames = {};
          function registerTwoPhaseEvent(registrationName, dependencies) {
            registerDirectEvent(registrationName, dependencies);
            registerDirectEvent(registrationName + "Capture", dependencies);
          }
          function registerDirectEvent(registrationName, dependencies) {
            {
              if (registrationNameDependencies[registrationName]) {
                error3("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName);
              }
            }
            registrationNameDependencies[registrationName] = dependencies;
            {
              var lowerCasedName = registrationName.toLowerCase();
              possibleRegistrationNames[lowerCasedName] = registrationName;
              if (registrationName === "onDoubleClick") {
                possibleRegistrationNames.ondblclick = registrationName;
              }
            }
            for (var i = 0; i < dependencies.length; i++) {
              allNativeEvents.add(dependencies[i]);
            }
          }
          var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
          var hasOwnProperty3 = Object.prototype.hasOwnProperty;
          function typeName(value13) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value13[Symbol.toStringTag] || value13.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value13) {
            {
              try {
                testStringCoercion(value13);
                return false;
              } catch (e) {
                return true;
              }
            }
          }
          function testStringCoercion(value13) {
            return "" + value13;
          }
          function checkAttributeStringCoercion(value13, attributeName) {
            {
              if (willCoercionThrow(value13)) {
                error3("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value13));
                return testStringCoercion(value13);
              }
            }
          }
          function checkKeyStringCoercion(value13) {
            {
              if (willCoercionThrow(value13)) {
                error3("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value13));
                return testStringCoercion(value13);
              }
            }
          }
          function checkPropStringCoercion(value13, propName) {
            {
              if (willCoercionThrow(value13)) {
                error3("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value13));
                return testStringCoercion(value13);
              }
            }
          }
          function checkCSSPropertyStringCoercion(value13, propName) {
            {
              if (willCoercionThrow(value13)) {
                error3("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value13));
                return testStringCoercion(value13);
              }
            }
          }
          function checkHtmlStringCoercion(value13) {
            {
              if (willCoercionThrow(value13)) {
                error3("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value13));
                return testStringCoercion(value13);
              }
            }
          }
          function checkFormFieldValueStringCoercion(value13) {
            {
              if (willCoercionThrow(value13)) {
                error3("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", typeName(value13));
                return testStringCoercion(value13);
              }
            }
          }
          var RESERVED = 0;
          var STRING = 1;
          var BOOLEANISH_STRING = 2;
          var BOOLEAN = 3;
          var OVERLOADED_BOOLEAN = 4;
          var NUMERIC = 5;
          var POSITIVE_NUMERIC = 6;
          var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
          var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
          var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
          var illegalAttributeNameCache = {};
          var validatedAttributeNameCache = {};
          function isAttributeNameSafe(attributeName) {
            if (hasOwnProperty3.call(validatedAttributeNameCache, attributeName)) {
              return true;
            }
            if (hasOwnProperty3.call(illegalAttributeNameCache, attributeName)) {
              return false;
            }
            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
              validatedAttributeNameCache[attributeName] = true;
              return true;
            }
            illegalAttributeNameCache[attributeName] = true;
            {
              error3("Invalid attribute name: `%s`", attributeName);
            }
            return false;
          }
          function shouldIgnoreAttribute(name16, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null) {
              return propertyInfo.type === RESERVED;
            }
            if (isCustomComponentTag) {
              return false;
            }
            if (name16.length > 2 && (name16[0] === "o" || name16[0] === "O") && (name16[1] === "n" || name16[1] === "N")) {
              return true;
            }
            return false;
          }
          function shouldRemoveAttributeWithWarning(name16, value13, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null && propertyInfo.type === RESERVED) {
              return false;
            }
            switch (typeof value13) {
              case "function":
              case "symbol":
                return true;
              case "boolean": {
                if (isCustomComponentTag) {
                  return false;
                }
                if (propertyInfo !== null) {
                  return !propertyInfo.acceptsBooleans;
                } else {
                  var prefix2 = name16.toLowerCase().slice(0, 5);
                  return prefix2 !== "data-" && prefix2 !== "aria-";
                }
              }
              default:
                return false;
            }
          }
          function shouldRemoveAttribute(name16, value13, propertyInfo, isCustomComponentTag) {
            if (value13 === null || typeof value13 === "undefined") {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name16, value13, propertyInfo, isCustomComponentTag)) {
              return true;
            }
            if (isCustomComponentTag) {
              return false;
            }
            if (propertyInfo !== null) {
              switch (propertyInfo.type) {
                case BOOLEAN:
                  return !value13;
                case OVERLOADED_BOOLEAN:
                  return value13 === false;
                case NUMERIC:
                  return isNaN(value13);
                case POSITIVE_NUMERIC:
                  return isNaN(value13) || value13 < 1;
              }
            }
            return false;
          }
          function getPropertyInfo(name16) {
            return properties.hasOwnProperty(name16) ? properties[name16] : null;
          }
          function PropertyInfoRecord(name16, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
            this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
            this.attributeName = attributeName;
            this.attributeNamespace = attributeNamespace;
            this.mustUseProperty = mustUseProperty;
            this.propertyName = name16;
            this.type = type;
            this.sanitizeURL = sanitizeURL2;
            this.removeEmptyString = removeEmptyString;
          }
          var properties = {};
          var reservedProps = [
            "children",
            "dangerouslySetInnerHTML",
            "defaultValue",
            "defaultChecked",
            "innerHTML",
            "suppressContentEditableWarning",
            "suppressHydrationWarning",
            "style"
          ];
          reservedProps.forEach(function(name16) {
            properties[name16] = new PropertyInfoRecord(
              name16,
              RESERVED,
              false,
              name16,
              null,
              false,
              false
            );
          });
          [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
            var name16 = _ref[0], attributeName = _ref[1];
            properties[name16] = new PropertyInfoRecord(
              name16,
              STRING,
              false,
              attributeName,
              null,
              false,
              false
            );
          });
          ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name16) {
            properties[name16] = new PropertyInfoRecord(
              name16,
              BOOLEANISH_STRING,
              false,
              name16.toLowerCase(),
              null,
              false,
              false
            );
          });
          ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name16) {
            properties[name16] = new PropertyInfoRecord(
              name16,
              BOOLEANISH_STRING,
              false,
              name16,
              null,
              false,
              false
            );
          });
          [
            "allowFullScreen",
            "async",
            "autoFocus",
            "autoPlay",
            "controls",
            "default",
            "defer",
            "disabled",
            "disablePictureInPicture",
            "disableRemotePlayback",
            "formNoValidate",
            "hidden",
            "loop",
            "noModule",
            "noValidate",
            "open",
            "playsInline",
            "readOnly",
            "required",
            "reversed",
            "scoped",
            "seamless",
            "itemScope"
          ].forEach(function(name16) {
            properties[name16] = new PropertyInfoRecord(
              name16,
              BOOLEAN,
              false,
              name16.toLowerCase(),
              null,
              false,
              false
            );
          });
          [
            "checked",
            "multiple",
            "muted",
            "selected"
          ].forEach(function(name16) {
            properties[name16] = new PropertyInfoRecord(
              name16,
              BOOLEAN,
              true,
              name16,
              null,
              false,
              false
            );
          });
          [
            "capture",
            "download"
          ].forEach(function(name16) {
            properties[name16] = new PropertyInfoRecord(
              name16,
              OVERLOADED_BOOLEAN,
              false,
              name16,
              null,
              false,
              false
            );
          });
          [
            "cols",
            "rows",
            "size",
            "span"
          ].forEach(function(name16) {
            properties[name16] = new PropertyInfoRecord(
              name16,
              POSITIVE_NUMERIC,
              false,
              name16,
              null,
              false,
              false
            );
          });
          ["rowSpan", "start"].forEach(function(name16) {
            properties[name16] = new PropertyInfoRecord(
              name16,
              NUMERIC,
              false,
              name16.toLowerCase(),
              null,
              false,
              false
            );
          });
          var CAMELIZE = /[\-\:]([a-z])/g;
          var capitalize = function(token) {
            return token[1].toUpperCase();
          };
          [
            "accent-height",
            "alignment-baseline",
            "arabic-form",
            "baseline-shift",
            "cap-height",
            "clip-path",
            "clip-rule",
            "color-interpolation",
            "color-interpolation-filters",
            "color-profile",
            "color-rendering",
            "dominant-baseline",
            "enable-background",
            "fill-opacity",
            "fill-rule",
            "flood-color",
            "flood-opacity",
            "font-family",
            "font-size",
            "font-size-adjust",
            "font-stretch",
            "font-style",
            "font-variant",
            "font-weight",
            "glyph-name",
            "glyph-orientation-horizontal",
            "glyph-orientation-vertical",
            "horiz-adv-x",
            "horiz-origin-x",
            "image-rendering",
            "letter-spacing",
            "lighting-color",
            "marker-end",
            "marker-mid",
            "marker-start",
            "overline-position",
            "overline-thickness",
            "paint-order",
            "panose-1",
            "pointer-events",
            "rendering-intent",
            "shape-rendering",
            "stop-color",
            "stop-opacity",
            "strikethrough-position",
            "strikethrough-thickness",
            "stroke-dasharray",
            "stroke-dashoffset",
            "stroke-linecap",
            "stroke-linejoin",
            "stroke-miterlimit",
            "stroke-opacity",
            "stroke-width",
            "text-anchor",
            "text-decoration",
            "text-rendering",
            "underline-position",
            "underline-thickness",
            "unicode-bidi",
            "unicode-range",
            "units-per-em",
            "v-alphabetic",
            "v-hanging",
            "v-ideographic",
            "v-mathematical",
            "vector-effect",
            "vert-adv-y",
            "vert-origin-x",
            "vert-origin-y",
            "word-spacing",
            "writing-mode",
            "xmlns:xlink",
            "x-height"
          ].forEach(function(attributeName) {
            var name16 = attributeName.replace(CAMELIZE, capitalize);
            properties[name16] = new PropertyInfoRecord(
              name16,
              STRING,
              false,
              attributeName,
              null,
              false,
              false
            );
          });
          [
            "xlink:actuate",
            "xlink:arcrole",
            "xlink:role",
            "xlink:show",
            "xlink:title",
            "xlink:type"
          ].forEach(function(attributeName) {
            var name16 = attributeName.replace(CAMELIZE, capitalize);
            properties[name16] = new PropertyInfoRecord(
              name16,
              STRING,
              false,
              attributeName,
              "http://www.w3.org/1999/xlink",
              false,
              false
            );
          });
          [
            "xml:base",
            "xml:lang",
            "xml:space"
          ].forEach(function(attributeName) {
            var name16 = attributeName.replace(CAMELIZE, capitalize);
            properties[name16] = new PropertyInfoRecord(
              name16,
              STRING,
              false,
              attributeName,
              "http://www.w3.org/XML/1998/namespace",
              false,
              false
            );
          });
          ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(
              attributeName,
              STRING,
              false,
              attributeName.toLowerCase(),
              null,
              false,
              false
            );
          });
          var xlinkHref = "xlinkHref";
          properties[xlinkHref] = new PropertyInfoRecord(
            "xlinkHref",
            STRING,
            false,
            "xlink:href",
            "http://www.w3.org/1999/xlink",
            true,
            false
          );
          ["src", "href", "action", "formAction"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(
              attributeName,
              STRING,
              false,
              attributeName.toLowerCase(),
              null,
              true,
              true
            );
          });
          var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
          var didWarn = false;
          function sanitizeURL(url) {
            {
              if (!didWarn && isJavaScriptProtocol.test(url)) {
                didWarn = true;
                error3("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
              }
            }
          }
          function getValueForProperty(node, name16, expected, propertyInfo) {
            {
              if (propertyInfo.mustUseProperty) {
                var propertyName = propertyInfo.propertyName;
                return node[propertyName];
              } else {
                {
                  checkAttributeStringCoercion(expected, name16);
                }
                if (propertyInfo.sanitizeURL) {
                  sanitizeURL("" + expected);
                }
                var attributeName = propertyInfo.attributeName;
                var stringValue = null;
                if (propertyInfo.type === OVERLOADED_BOOLEAN) {
                  if (node.hasAttribute(attributeName)) {
                    var value13 = node.getAttribute(attributeName);
                    if (value13 === "") {
                      return true;
                    }
                    if (shouldRemoveAttribute(name16, expected, propertyInfo, false)) {
                      return value13;
                    }
                    if (value13 === "" + expected) {
                      return expected;
                    }
                    return value13;
                  }
                } else if (node.hasAttribute(attributeName)) {
                  if (shouldRemoveAttribute(name16, expected, propertyInfo, false)) {
                    return node.getAttribute(attributeName);
                  }
                  if (propertyInfo.type === BOOLEAN) {
                    return expected;
                  }
                  stringValue = node.getAttribute(attributeName);
                }
                if (shouldRemoveAttribute(name16, expected, propertyInfo, false)) {
                  return stringValue === null ? expected : stringValue;
                } else if (stringValue === "" + expected) {
                  return expected;
                } else {
                  return stringValue;
                }
              }
            }
          }
          function getValueForAttribute(node, name16, expected, isCustomComponentTag) {
            {
              if (!isAttributeNameSafe(name16)) {
                return;
              }
              if (!node.hasAttribute(name16)) {
                return expected === void 0 ? void 0 : null;
              }
              var value13 = node.getAttribute(name16);
              {
                checkAttributeStringCoercion(expected, name16);
              }
              if (value13 === "" + expected) {
                return expected;
              }
              return value13;
            }
          }
          function setValueForProperty(node, name16, value13, isCustomComponentTag) {
            var propertyInfo = getPropertyInfo(name16);
            if (shouldIgnoreAttribute(name16, propertyInfo, isCustomComponentTag)) {
              return;
            }
            if (shouldRemoveAttribute(name16, value13, propertyInfo, isCustomComponentTag)) {
              value13 = null;
            }
            if (isCustomComponentTag || propertyInfo === null) {
              if (isAttributeNameSafe(name16)) {
                var _attributeName = name16;
                if (value13 === null) {
                  node.removeAttribute(_attributeName);
                } else {
                  {
                    checkAttributeStringCoercion(value13, name16);
                  }
                  node.setAttribute(_attributeName, "" + value13);
                }
              }
              return;
            }
            var mustUseProperty = propertyInfo.mustUseProperty;
            if (mustUseProperty) {
              var propertyName = propertyInfo.propertyName;
              if (value13 === null) {
                var type = propertyInfo.type;
                node[propertyName] = type === BOOLEAN ? false : "";
              } else {
                node[propertyName] = value13;
              }
              return;
            }
            var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
            if (value13 === null) {
              node.removeAttribute(attributeName);
            } else {
              var _type = propertyInfo.type;
              var attributeValue;
              if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value13 === true) {
                attributeValue = "";
              } else {
                {
                  {
                    checkAttributeStringCoercion(value13, attributeName);
                  }
                  attributeValue = "" + value13;
                }
                if (propertyInfo.sanitizeURL) {
                  sanitizeURL(attributeValue.toString());
                }
              }
              if (attributeNamespace) {
                node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
              } else {
                node.setAttribute(attributeName, attributeValue);
              }
            }
          }
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_SCOPE_TYPE = Symbol.for("react.scope");
          var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
          var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
          var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
          var REACT_CACHE_TYPE = Symbol.for("react.cache");
          var REACT_TRACING_MARKER_TYPE = Symbol.for("react.tracing_marker");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          var assign2 = Object.assign;
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign2({}, props, {
                    value: prevLog
                  }),
                  info: assign2({}, props, {
                    value: prevInfo
                  }),
                  warn: assign2({}, props, {
                    value: prevWarn
                  }),
                  error: assign2({}, props, {
                    value: prevError
                  }),
                  group: assign2({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign2({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign2({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error3("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name16, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x) {
                  var match = x.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name16;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x) {
                    control = x;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x) {
                  control = x;
                }
                fn();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                  c--;
                }
                for (; s >= 1 && c >= 0; s--, c--) {
                  if (sampleLines[s] !== controlLines[c]) {
                    if (s !== 1 || c !== 1) {
                      do {
                        s--;
                        c--;
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                          var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                          if (fn.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn.displayName);
                          }
                          {
                            if (typeof fn === "function") {
                              componentFrameCache.set(fn, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s >= 1 && c >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name16 = fn ? fn.displayName || fn.name : "";
            var syntheticFrame = name16 ? describeBuiltInComponentFrame(name16) : "";
            {
              if (typeof fn === "function") {
                componentFrameCache.set(fn, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeClassComponentFrame(ctor, source, ownerFn) {
            {
              return describeNativeComponentFrame(ctor, true);
            }
          }
          function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn, false);
            }
          }
          function shouldConstruct(Component2) {
            var prototype = Component2.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init3 = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init3(payload), source, ownerFn);
                  } catch (x) {
                  }
                }
              }
            }
            return "";
          }
          function describeFiber(fiber) {
            var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
            var source = fiber._debugSource;
            switch (fiber.tag) {
              case HostComponent:
                return describeBuiltInComponentFrame(fiber.type);
              case LazyComponent:
                return describeBuiltInComponentFrame("Lazy");
              case SuspenseComponent:
                return describeBuiltInComponentFrame("Suspense");
              case SuspenseListComponent:
                return describeBuiltInComponentFrame("SuspenseList");
              case FunctionComponent:
              case IndeterminateComponent:
              case SimpleMemoComponent:
                return describeFunctionComponentFrame(fiber.type);
              case ForwardRef:
                return describeFunctionComponentFrame(fiber.type.render);
              case ClassComponent:
                return describeClassComponentFrame(fiber.type);
              default:
                return "";
            }
          }
          function getStackByFiberInDevAndProd(workInProgress2) {
            try {
              var info = "";
              var node = workInProgress2;
              do {
                info += describeFiber(node);
                node = node.return;
              } while (node);
              return info;
            } catch (x) {
              return "\nError generating stack: " + x.message + "\n" + x.stack;
            }
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error3("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init3 = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init3(payload));
                  } catch (x) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          function getWrappedName$1(outerType, innerType, wrapperName) {
            var functionName = innerType.displayName || innerType.name || "";
            return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
          }
          function getContextName$1(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromFiber(fiber) {
            var tag = fiber.tag, type = fiber.type;
            switch (tag) {
              case CacheComponent:
                return "Cache";
              case ContextConsumer:
                var context = type;
                return getContextName$1(context) + ".Consumer";
              case ContextProvider:
                var provider = type;
                return getContextName$1(provider._context) + ".Provider";
              case DehydratedFragment:
                return "DehydratedFragment";
              case ForwardRef:
                return getWrappedName$1(type, type.render, "ForwardRef");
              case Fragment2:
                return "Fragment";
              case HostComponent:
                return type;
              case HostPortal:
                return "Portal";
              case HostRoot:
                return "Root";
              case HostText:
                return "Text";
              case LazyComponent:
                return getComponentNameFromType(type);
              case Mode:
                if (type === REACT_STRICT_MODE_TYPE) {
                  return "StrictMode";
                }
                return "Mode";
              case OffscreenComponent:
                return "Offscreen";
              case Profiler:
                return "Profiler";
              case ScopeComponent:
                return "Scope";
              case SuspenseComponent:
                return "Suspense";
              case SuspenseListComponent:
                return "SuspenseList";
              case TracingMarkerComponent:
                return "TracingMarker";
              case ClassComponent:
              case FunctionComponent:
              case IncompleteClassComponent:
              case IndeterminateComponent:
              case MemoComponent:
              case SimpleMemoComponent:
                if (typeof type === "function") {
                  return type.displayName || type.name || null;
                }
                if (typeof type === "string") {
                  return type;
                }
                break;
            }
            return null;
          }
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          var current = null;
          var isRendering = false;
          function getCurrentFiberOwnerNameInDevOrNull() {
            {
              if (current === null) {
                return null;
              }
              var owner = current._debugOwner;
              if (owner !== null && typeof owner !== "undefined") {
                return getComponentNameFromFiber(owner);
              }
            }
            return null;
          }
          function getCurrentFiberStackInDev() {
            {
              if (current === null) {
                return "";
              }
              return getStackByFiberInDevAndProd(current);
            }
          }
          function resetCurrentFiber() {
            {
              ReactDebugCurrentFrame.getCurrentStack = null;
              current = null;
              isRendering = false;
            }
          }
          function setCurrentFiber(fiber) {
            {
              ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
              current = fiber;
              isRendering = false;
            }
          }
          function getCurrentFiber() {
            {
              return current;
            }
          }
          function setIsRendering(rendering) {
            {
              isRendering = rendering;
            }
          }
          function toString3(value13) {
            return "" + value13;
          }
          function getToStringValue(value13) {
            switch (typeof value13) {
              case "boolean":
              case "number":
              case "string":
              case "undefined":
                return value13;
              case "object":
                {
                  checkFormFieldValueStringCoercion(value13);
                }
                return value13;
              default:
                return "";
            }
          }
          var hasReadOnlyValue = {
            button: true,
            checkbox: true,
            image: true,
            hidden: true,
            radio: true,
            reset: true,
            submit: true
          };
          function checkControlledValueProps(tagName, props) {
            {
              if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
                error3("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
              }
              if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
                error3("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
              }
            }
          }
          function isCheckable(elem3) {
            var type = elem3.type;
            var nodeName = elem3.nodeName;
            return nodeName && nodeName.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
          }
          function getTracker(node) {
            return node._valueTracker;
          }
          function detachTracker(node) {
            node._valueTracker = null;
          }
          function getValueFromNode(node) {
            var value13 = "";
            if (!node) {
              return value13;
            }
            if (isCheckable(node)) {
              value13 = node.checked ? "true" : "false";
            } else {
              value13 = node.value;
            }
            return value13;
          }
          function trackValueOnNode(node) {
            var valueField = isCheckable(node) ? "checked" : "value";
            var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
            {
              checkFormFieldValueStringCoercion(node[valueField]);
            }
            var currentValue = "" + node[valueField];
            if (node.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
              return;
            }
            var get4 = descriptor.get, set2 = descriptor.set;
            Object.defineProperty(node, valueField, {
              configurable: true,
              get: function() {
                return get4.call(this);
              },
              set: function(value13) {
                {
                  checkFormFieldValueStringCoercion(value13);
                }
                currentValue = "" + value13;
                set2.call(this, value13);
              }
            });
            Object.defineProperty(node, valueField, {
              enumerable: descriptor.enumerable
            });
            var tracker = {
              getValue: function() {
                return currentValue;
              },
              setValue: function(value13) {
                {
                  checkFormFieldValueStringCoercion(value13);
                }
                currentValue = "" + value13;
              },
              stopTracking: function() {
                detachTracker(node);
                delete node[valueField];
              }
            };
            return tracker;
          }
          function track(node) {
            if (getTracker(node)) {
              return;
            }
            node._valueTracker = trackValueOnNode(node);
          }
          function updateValueIfChanged(node) {
            if (!node) {
              return false;
            }
            var tracker = getTracker(node);
            if (!tracker) {
              return true;
            }
            var lastValue = tracker.getValue();
            var nextValue = getValueFromNode(node);
            if (nextValue !== lastValue) {
              tracker.setValue(nextValue);
              return true;
            }
            return false;
          }
          function getActiveElement(doc) {
            doc = doc || (typeof document !== "undefined" ? document : void 0);
            if (typeof doc === "undefined") {
              return null;
            }
            try {
              return doc.activeElement || doc.body;
            } catch (e) {
              return doc.body;
            }
          }
          var didWarnValueDefaultValue = false;
          var didWarnCheckedDefaultChecked = false;
          var didWarnControlledToUncontrolled = false;
          var didWarnUncontrolledToControlled = false;
          function isControlled(props) {
            var usesChecked = props.type === "checkbox" || props.type === "radio";
            return usesChecked ? props.checked != null : props.value != null;
          }
          function getHostProps(element, props) {
            var node = element;
            var checked2 = props.checked;
            var hostProps = assign2({}, props, {
              defaultChecked: void 0,
              defaultValue: void 0,
              value: void 0,
              checked: checked2 != null ? checked2 : node._wrapperState.initialChecked
            });
            return hostProps;
          }
          function initWrapperState(element, props) {
            {
              checkControlledValueProps("input", props);
              if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked) {
                error3("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
                didWarnCheckedDefaultChecked = true;
              }
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue) {
                error3("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
                didWarnValueDefaultValue = true;
              }
            }
            var node = element;
            var defaultValue4 = props.defaultValue == null ? "" : props.defaultValue;
            node._wrapperState = {
              initialChecked: props.checked != null ? props.checked : props.defaultChecked,
              initialValue: getToStringValue(props.value != null ? props.value : defaultValue4),
              controlled: isControlled(props)
            };
          }
          function updateChecked(element, props) {
            var node = element;
            var checked2 = props.checked;
            if (checked2 != null) {
              setValueForProperty(node, "checked", checked2, false);
            }
          }
          function updateWrapper(element, props) {
            var node = element;
            {
              var controlled = isControlled(props);
              if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
                error3("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
                didWarnUncontrolledToControlled = true;
              }
              if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
                error3("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
                didWarnControlledToUncontrolled = true;
              }
            }
            updateChecked(element, props);
            var value13 = getToStringValue(props.value);
            var type = props.type;
            if (value13 != null) {
              if (type === "number") {
                if (value13 === 0 && node.value === "" || node.value != value13) {
                  node.value = toString3(value13);
                }
              } else if (node.value !== toString3(value13)) {
                node.value = toString3(value13);
              }
            } else if (type === "submit" || type === "reset") {
              node.removeAttribute("value");
              return;
            }
            {
              if (props.hasOwnProperty("value")) {
                setDefaultValue4(node, props.type, value13);
              } else if (props.hasOwnProperty("defaultValue")) {
                setDefaultValue4(node, props.type, getToStringValue(props.defaultValue));
              }
            }
            {
              if (props.checked == null && props.defaultChecked != null) {
                node.defaultChecked = !!props.defaultChecked;
              }
            }
          }
          function postMountWrapper(element, props, isHydrating2) {
            var node = element;
            if (props.hasOwnProperty("value") || props.hasOwnProperty("defaultValue")) {
              var type = props.type;
              var isButton = type === "submit" || type === "reset";
              if (isButton && (props.value === void 0 || props.value === null)) {
                return;
              }
              var initialValue = toString3(node._wrapperState.initialValue);
              if (!isHydrating2) {
                {
                  if (initialValue !== node.value) {
                    node.value = initialValue;
                  }
                }
              }
              {
                node.defaultValue = initialValue;
              }
            }
            var name16 = node.name;
            if (name16 !== "") {
              node.name = "";
            }
            {
              node.defaultChecked = !node.defaultChecked;
              node.defaultChecked = !!node._wrapperState.initialChecked;
            }
            if (name16 !== "") {
              node.name = name16;
            }
          }
          function restoreControlledState(element, props) {
            var node = element;
            updateWrapper(node, props);
            updateNamedCousins(node, props);
          }
          function updateNamedCousins(rootNode, props) {
            var name16 = props.name;
            if (props.type === "radio" && name16 != null) {
              var queryRoot = rootNode;
              while (queryRoot.parentNode) {
                queryRoot = queryRoot.parentNode;
              }
              {
                checkAttributeStringCoercion(name16, "name");
              }
              var group3 = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name16) + '][type="radio"]');
              for (var i = 0; i < group3.length; i++) {
                var otherNode = group3[i];
                if (otherNode === rootNode || otherNode.form !== rootNode.form) {
                  continue;
                }
                var otherProps = getFiberCurrentPropsFromNode(otherNode);
                if (!otherProps) {
                  throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
                }
                updateValueIfChanged(otherNode);
                updateWrapper(otherNode, otherProps);
              }
            }
          }
          function setDefaultValue4(node, type, value13) {
            if (type !== "number" || getActiveElement(node.ownerDocument) !== node) {
              if (value13 == null) {
                node.defaultValue = toString3(node._wrapperState.initialValue);
              } else if (node.defaultValue !== toString3(value13)) {
                node.defaultValue = toString3(value13);
              }
            }
          }
          var didWarnSelectedSetOnOption = false;
          var didWarnInvalidChild = false;
          var didWarnInvalidInnerHTML = false;
          function validateProps2(element, props) {
            {
              if (props.value == null) {
                if (typeof props.children === "object" && props.children !== null) {
                  React18.Children.forEach(props.children, function(child) {
                    if (child == null) {
                      return;
                    }
                    if (typeof child === "string" || typeof child === "number") {
                      return;
                    }
                    if (!didWarnInvalidChild) {
                      didWarnInvalidChild = true;
                      error3("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
                    }
                  });
                } else if (props.dangerouslySetInnerHTML != null) {
                  if (!didWarnInvalidInnerHTML) {
                    didWarnInvalidInnerHTML = true;
                    error3("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                  }
                }
              }
              if (props.selected != null && !didWarnSelectedSetOnOption) {
                error3("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                didWarnSelectedSetOnOption = true;
              }
            }
          }
          function postMountWrapper$1(element, props) {
            if (props.value != null) {
              element.setAttribute("value", toString3(getToStringValue(props.value)));
            }
          }
          var isArrayImpl = Array.isArray;
          function isArray6(a) {
            return isArrayImpl(a);
          }
          var didWarnValueDefaultValue$1;
          {
            didWarnValueDefaultValue$1 = false;
          }
          function getDeclarationErrorAddendum() {
            var ownerName = getCurrentFiberOwnerNameInDevOrNull();
            if (ownerName) {
              return "\n\nCheck the render method of `" + ownerName + "`.";
            }
            return "";
          }
          var valuePropNames = ["value", "defaultValue"];
          function checkSelectPropTypes(props) {
            {
              checkControlledValueProps("select", props);
              for (var i = 0; i < valuePropNames.length; i++) {
                var propName = valuePropNames[i];
                if (props[propName] == null) {
                  continue;
                }
                var propNameIsArray = isArray6(props[propName]);
                if (props.multiple && !propNameIsArray) {
                  error3("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum());
                } else if (!props.multiple && propNameIsArray) {
                  error3("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
                }
              }
            }
          }
          function updateOptions(node, multiple3, propValue, setDefaultSelected2) {
            var options3 = node.options;
            if (multiple3) {
              var selectedValues = propValue;
              var selectedValue = {};
              for (var i = 0; i < selectedValues.length; i++) {
                selectedValue["$" + selectedValues[i]] = true;
              }
              for (var _i = 0; _i < options3.length; _i++) {
                var selected2 = selectedValue.hasOwnProperty("$" + options3[_i].value);
                if (options3[_i].selected !== selected2) {
                  options3[_i].selected = selected2;
                }
                if (selected2 && setDefaultSelected2) {
                  options3[_i].defaultSelected = true;
                }
              }
            } else {
              var _selectedValue = toString3(getToStringValue(propValue));
              var defaultSelected2 = null;
              for (var _i2 = 0; _i2 < options3.length; _i2++) {
                if (options3[_i2].value === _selectedValue) {
                  options3[_i2].selected = true;
                  if (setDefaultSelected2) {
                    options3[_i2].defaultSelected = true;
                  }
                  return;
                }
                if (defaultSelected2 === null && !options3[_i2].disabled) {
                  defaultSelected2 = options3[_i2];
                }
              }
              if (defaultSelected2 !== null) {
                defaultSelected2.selected = true;
              }
            }
          }
          function getHostProps$1(element, props) {
            return assign2({}, props, {
              value: void 0
            });
          }
          function initWrapperState$1(element, props) {
            var node = element;
            {
              checkSelectPropTypes(props);
            }
            node._wrapperState = {
              wasMultiple: !!props.multiple
            };
            {
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1) {
                error3("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                didWarnValueDefaultValue$1 = true;
              }
            }
          }
          function postMountWrapper$2(element, props) {
            var node = element;
            node.multiple = !!props.multiple;
            var value13 = props.value;
            if (value13 != null) {
              updateOptions(node, !!props.multiple, value13, false);
            } else if (props.defaultValue != null) {
              updateOptions(node, !!props.multiple, props.defaultValue, true);
            }
          }
          function postUpdateWrapper(element, props) {
            var node = element;
            var wasMultiple = node._wrapperState.wasMultiple;
            node._wrapperState.wasMultiple = !!props.multiple;
            var value13 = props.value;
            if (value13 != null) {
              updateOptions(node, !!props.multiple, value13, false);
            } else if (wasMultiple !== !!props.multiple) {
              if (props.defaultValue != null) {
                updateOptions(node, !!props.multiple, props.defaultValue, true);
              } else {
                updateOptions(node, !!props.multiple, props.multiple ? [] : "", false);
              }
            }
          }
          function restoreControlledState$1(element, props) {
            var node = element;
            var value13 = props.value;
            if (value13 != null) {
              updateOptions(node, !!props.multiple, value13, false);
            }
          }
          var didWarnValDefaultVal = false;
          function getHostProps$2(element, props) {
            var node = element;
            if (props.dangerouslySetInnerHTML != null) {
              throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
            }
            var hostProps = assign2({}, props, {
              value: void 0,
              defaultValue: void 0,
              children: toString3(node._wrapperState.initialValue)
            });
            return hostProps;
          }
          function initWrapperState$2(element, props) {
            var node = element;
            {
              checkControlledValueProps("textarea", props);
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal) {
                error3("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component");
                didWarnValDefaultVal = true;
              }
            }
            var initialValue = props.value;
            if (initialValue == null) {
              var children = props.children, defaultValue4 = props.defaultValue;
              if (children != null) {
                {
                  error3("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
                }
                {
                  if (defaultValue4 != null) {
                    throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                  }
                  if (isArray6(children)) {
                    if (children.length > 1) {
                      throw new Error("<textarea> can only have at most one child.");
                    }
                    children = children[0];
                  }
                  defaultValue4 = children;
                }
              }
              if (defaultValue4 == null) {
                defaultValue4 = "";
              }
              initialValue = defaultValue4;
            }
            node._wrapperState = {
              initialValue: getToStringValue(initialValue)
            };
          }
          function updateWrapper$1(element, props) {
            var node = element;
            var value13 = getToStringValue(props.value);
            var defaultValue4 = getToStringValue(props.defaultValue);
            if (value13 != null) {
              var newValue = toString3(value13);
              if (newValue !== node.value) {
                node.value = newValue;
              }
              if (props.defaultValue == null && node.defaultValue !== newValue) {
                node.defaultValue = newValue;
              }
            }
            if (defaultValue4 != null) {
              node.defaultValue = toString3(defaultValue4);
            }
          }
          function postMountWrapper$3(element, props) {
            var node = element;
            var textContent = node.textContent;
            if (textContent === node._wrapperState.initialValue) {
              if (textContent !== "" && textContent !== null) {
                node.value = textContent;
              }
            }
          }
          function restoreControlledState$2(element, props) {
            updateWrapper$1(element, props);
          }
          var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
          var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
          var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
          function getIntrinsicNamespace(type) {
            switch (type) {
              case "svg":
                return SVG_NAMESPACE;
              case "math":
                return MATH_NAMESPACE;
              default:
                return HTML_NAMESPACE;
            }
          }
          function getChildNamespace(parentNamespace, type) {
            if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
              return getIntrinsicNamespace(type);
            }
            if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
              return HTML_NAMESPACE;
            }
            return parentNamespace;
          }
          var createMicrosoftUnsafeLocalFunction = function(func11) {
            if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
              return function(arg0, arg1, arg2, arg3) {
                MSApp.execUnsafeLocalFunction(function() {
                  return func11(arg0, arg1, arg2, arg3);
                });
              };
            } else {
              return func11;
            }
          };
          var reusableSVGContainer;
          var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {
            if (node.namespaceURI === SVG_NAMESPACE) {
              if (!("innerHTML" in node)) {
                reusableSVGContainer = reusableSVGContainer || document.createElement("div");
                reusableSVGContainer.innerHTML = "<svg>" + html.valueOf().toString() + "</svg>";
                var svgNode = reusableSVGContainer.firstChild;
                while (node.firstChild) {
                  node.removeChild(node.firstChild);
                }
                while (svgNode.firstChild) {
                  node.appendChild(svgNode.firstChild);
                }
                return;
              }
            }
            node.innerHTML = html;
          });
          var ELEMENT_NODE = 1;
          var TEXT_NODE = 3;
          var COMMENT_NODE = 8;
          var DOCUMENT_NODE = 9;
          var DOCUMENT_FRAGMENT_NODE = 11;
          var setTextContent = function(node, text5) {
            if (text5) {
              var firstChild = node.firstChild;
              if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
                firstChild.nodeValue = text5;
                return;
              }
            }
            node.textContent = text5;
          };
          var shorthandToLonghand = {
            animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
            background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
            backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
            border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
            borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
            borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
            borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
            borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
            borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
            borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
            borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
            borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
            borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
            borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
            borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
            borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
            columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
            columns: ["columnCount", "columnWidth"],
            flex: ["flexBasis", "flexGrow", "flexShrink"],
            flexFlow: ["flexDirection", "flexWrap"],
            font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
            fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
            gap: ["columnGap", "rowGap"],
            grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
            gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
            gridColumn: ["gridColumnEnd", "gridColumnStart"],
            gridColumnGap: ["columnGap"],
            gridGap: ["columnGap", "rowGap"],
            gridRow: ["gridRowEnd", "gridRowStart"],
            gridRowGap: ["rowGap"],
            gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
            listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
            margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
            marker: ["markerEnd", "markerMid", "markerStart"],
            mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
            maskPosition: ["maskPositionX", "maskPositionY"],
            outline: ["outlineColor", "outlineStyle", "outlineWidth"],
            overflow: ["overflowX", "overflowY"],
            padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
            placeContent: ["alignContent", "justifyContent"],
            placeItems: ["alignItems", "justifyItems"],
            placeSelf: ["alignSelf", "justifySelf"],
            textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
            textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
            transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
            wordWrap: ["overflowWrap"]
          };
          var isUnitlessNumber = {
            animationIterationCount: true,
            aspectRatio: true,
            borderImageOutset: true,
            borderImageSlice: true,
            borderImageWidth: true,
            boxFlex: true,
            boxFlexGroup: true,
            boxOrdinalGroup: true,
            columnCount: true,
            columns: true,
            flex: true,
            flexGrow: true,
            flexPositive: true,
            flexShrink: true,
            flexNegative: true,
            flexOrder: true,
            gridArea: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowSpan: true,
            gridRowStart: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnSpan: true,
            gridColumnStart: true,
            fontWeight: true,
            lineClamp: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            tabSize: true,
            widows: true,
            zIndex: true,
            zoom: true,
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeDasharray: true,
            strokeDashoffset: true,
            strokeMiterlimit: true,
            strokeOpacity: true,
            strokeWidth: true
          };
          function prefixKey(prefix2, key) {
            return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
          }
          var prefixes = ["Webkit", "ms", "Moz", "O"];
          Object.keys(isUnitlessNumber).forEach(function(prop) {
            prefixes.forEach(function(prefix2) {
              isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
            });
          });
          function dangerousStyleValue(name16, value13, isCustomProperty) {
            var isEmpty2 = value13 == null || typeof value13 === "boolean" || value13 === "";
            if (isEmpty2) {
              return "";
            }
            if (!isCustomProperty && typeof value13 === "number" && value13 !== 0 && !(isUnitlessNumber.hasOwnProperty(name16) && isUnitlessNumber[name16])) {
              return value13 + "px";
            }
            {
              checkCSSPropertyStringCoercion(value13, name16);
            }
            return ("" + value13).trim();
          }
          var uppercasePattern = /([A-Z])/g;
          var msPattern = /^ms-/;
          function hyphenateStyleName(name16) {
            return name16.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
          }
          var warnValidStyle = function() {
          };
          {
            var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
            var msPattern$1 = /^-ms-/;
            var hyphenPattern = /-(.)/g;
            var badStyleValueWithSemicolonPattern = /;\s*$/;
            var warnedStyleNames = {};
            var warnedStyleValues = {};
            var warnedForNaNValue = false;
            var warnedForInfinityValue = false;
            var camelize = function(string13) {
              return string13.replace(hyphenPattern, function(_, character) {
                return character.toUpperCase();
              });
            };
            var warnHyphenatedStyleName = function(name16) {
              if (warnedStyleNames.hasOwnProperty(name16) && warnedStyleNames[name16]) {
                return;
              }
              warnedStyleNames[name16] = true;
              error3(
                "Unsupported style property %s. Did you mean %s?",
                name16,
                camelize(name16.replace(msPattern$1, "ms-"))
              );
            };
            var warnBadVendoredStyleName = function(name16) {
              if (warnedStyleNames.hasOwnProperty(name16) && warnedStyleNames[name16]) {
                return;
              }
              warnedStyleNames[name16] = true;
              error3("Unsupported vendor-prefixed style property %s. Did you mean %s?", name16, name16.charAt(0).toUpperCase() + name16.slice(1));
            };
            var warnStyleValueWithSemicolon = function(name16, value13) {
              if (warnedStyleValues.hasOwnProperty(value13) && warnedStyleValues[value13]) {
                return;
              }
              warnedStyleValues[value13] = true;
              error3(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name16, value13.replace(badStyleValueWithSemicolonPattern, ""));
            };
            var warnStyleValueIsNaN = function(name16, value13) {
              if (warnedForNaNValue) {
                return;
              }
              warnedForNaNValue = true;
              error3("`NaN` is an invalid value for the `%s` css style property.", name16);
            };
            var warnStyleValueIsInfinity = function(name16, value13) {
              if (warnedForInfinityValue) {
                return;
              }
              warnedForInfinityValue = true;
              error3("`Infinity` is an invalid value for the `%s` css style property.", name16);
            };
            warnValidStyle = function(name16, value13) {
              if (name16.indexOf("-") > -1) {
                warnHyphenatedStyleName(name16);
              } else if (badVendoredStyleNamePattern.test(name16)) {
                warnBadVendoredStyleName(name16);
              } else if (badStyleValueWithSemicolonPattern.test(value13)) {
                warnStyleValueWithSemicolon(name16, value13);
              }
              if (typeof value13 === "number") {
                if (isNaN(value13)) {
                  warnStyleValueIsNaN(name16, value13);
                } else if (!isFinite(value13)) {
                  warnStyleValueIsInfinity(name16, value13);
                }
              }
            };
          }
          var warnValidStyle$1 = warnValidStyle;
          function createDangerousStringForStyles(styles) {
            {
              var serialized = "";
              var delimiter = "";
              for (var styleName in styles) {
                if (!styles.hasOwnProperty(styleName)) {
                  continue;
                }
                var styleValue = styles[styleName];
                if (styleValue != null) {
                  var isCustomProperty = styleName.indexOf("--") === 0;
                  serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ":";
                  serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
                  delimiter = ";";
                }
              }
              return serialized || null;
            }
          }
          function setValueForStyles(node, styles) {
            var style2 = node.style;
            for (var styleName in styles) {
              if (!styles.hasOwnProperty(styleName)) {
                continue;
              }
              var isCustomProperty = styleName.indexOf("--") === 0;
              {
                if (!isCustomProperty) {
                  warnValidStyle$1(styleName, styles[styleName]);
                }
              }
              var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
              if (styleName === "float") {
                styleName = "cssFloat";
              }
              if (isCustomProperty) {
                style2.setProperty(styleName, styleValue);
              } else {
                style2[styleName] = styleValue;
              }
            }
          }
          function isValueEmpty(value13) {
            return value13 == null || typeof value13 === "boolean" || value13 === "";
          }
          function expandShorthandMap(styles) {
            var expanded = {};
            for (var key in styles) {
              var longhands = shorthandToLonghand[key] || [key];
              for (var i = 0; i < longhands.length; i++) {
                expanded[longhands[i]] = key;
              }
            }
            return expanded;
          }
          function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
            {
              if (!nextStyles) {
                return;
              }
              var expandedUpdates = expandShorthandMap(styleUpdates);
              var expandedStyles = expandShorthandMap(nextStyles);
              var warnedAbout = {};
              for (var key in expandedUpdates) {
                var originalKey = expandedUpdates[key];
                var correctOriginalKey = expandedStyles[key];
                if (correctOriginalKey && originalKey !== correctOriginalKey) {
                  var warningKey = originalKey + "," + correctOriginalKey;
                  if (warnedAbout[warningKey]) {
                    continue;
                  }
                  warnedAbout[warningKey] = true;
                  error3("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
                }
              }
            }
          }
          var omittedCloseTags = {
            area: true,
            base: true,
            br: true,
            col: true,
            embed: true,
            hr: true,
            img: true,
            input: true,
            keygen: true,
            link: true,
            meta: true,
            param: true,
            source: true,
            track: true,
            wbr: true
          };
          var voidElementTags = assign2({
            menuitem: true
          }, omittedCloseTags);
          var HTML = "__html";
          function assertValidProps(tag, props) {
            if (!props) {
              return;
            }
            if (voidElementTags[tag]) {
              if (props.children != null || props.dangerouslySetInnerHTML != null) {
                throw new Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              }
            }
            if (props.dangerouslySetInnerHTML != null) {
              if (props.children != null) {
                throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              }
              if (typeof props.dangerouslySetInnerHTML !== "object" || !(HTML in props.dangerouslySetInnerHTML)) {
                throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
              }
            }
            {
              if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
                error3("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
              }
            }
            if (props.style != null && typeof props.style !== "object") {
              throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
            }
          }
          function isCustomComponent(tagName, props) {
            if (tagName.indexOf("-") === -1) {
              return typeof props.is === "string";
            }
            switch (tagName) {
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph":
                return false;
              default:
                return true;
            }
          }
          var possibleStandardNames = {
            accept: "accept",
            acceptcharset: "acceptCharset",
            "accept-charset": "acceptCharset",
            accesskey: "accessKey",
            action: "action",
            allowfullscreen: "allowFullScreen",
            alt: "alt",
            as: "as",
            async: "async",
            autocapitalize: "autoCapitalize",
            autocomplete: "autoComplete",
            autocorrect: "autoCorrect",
            autofocus: "autoFocus",
            autoplay: "autoPlay",
            autosave: "autoSave",
            capture: "capture",
            cellpadding: "cellPadding",
            cellspacing: "cellSpacing",
            challenge: "challenge",
            charset: "charSet",
            checked: "checked",
            children: "children",
            cite: "cite",
            class: "className",
            classid: "classID",
            classname: "className",
            cols: "cols",
            colspan: "colSpan",
            content: "content",
            contenteditable: "contentEditable",
            contextmenu: "contextMenu",
            controls: "controls",
            controlslist: "controlsList",
            coords: "coords",
            crossorigin: "crossOrigin",
            dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
            data: "data",
            datetime: "dateTime",
            default: "default",
            defaultchecked: "defaultChecked",
            defaultvalue: "defaultValue",
            defer: "defer",
            dir: "dir",
            disabled: "disabled",
            disablepictureinpicture: "disablePictureInPicture",
            disableremoteplayback: "disableRemotePlayback",
            download: "download",
            draggable: "draggable",
            enctype: "encType",
            enterkeyhint: "enterKeyHint",
            for: "htmlFor",
            form: "form",
            formmethod: "formMethod",
            formaction: "formAction",
            formenctype: "formEncType",
            formnovalidate: "formNoValidate",
            formtarget: "formTarget",
            frameborder: "frameBorder",
            headers: "headers",
            height: "height",
            hidden: "hidden",
            high: "high",
            href: "href",
            hreflang: "hrefLang",
            htmlfor: "htmlFor",
            httpequiv: "httpEquiv",
            "http-equiv": "httpEquiv",
            icon: "icon",
            id: "id",
            imagesizes: "imageSizes",
            imagesrcset: "imageSrcSet",
            innerhtml: "innerHTML",
            inputmode: "inputMode",
            integrity: "integrity",
            is: "is",
            itemid: "itemID",
            itemprop: "itemProp",
            itemref: "itemRef",
            itemscope: "itemScope",
            itemtype: "itemType",
            keyparams: "keyParams",
            keytype: "keyType",
            kind: "kind",
            label: "label",
            lang: "lang",
            list: "list",
            loop: "loop",
            low: "low",
            manifest: "manifest",
            marginwidth: "marginWidth",
            marginheight: "marginHeight",
            max: "max",
            maxlength: "maxLength",
            media: "media",
            mediagroup: "mediaGroup",
            method: "method",
            min: "min",
            minlength: "minLength",
            multiple: "multiple",
            muted: "muted",
            name: "name",
            nomodule: "noModule",
            nonce: "nonce",
            novalidate: "noValidate",
            open: "open",
            optimum: "optimum",
            pattern: "pattern",
            placeholder: "placeholder",
            playsinline: "playsInline",
            poster: "poster",
            preload: "preload",
            profile: "profile",
            radiogroup: "radioGroup",
            readonly: "readOnly",
            referrerpolicy: "referrerPolicy",
            rel: "rel",
            required: "required",
            reversed: "reversed",
            role: "role",
            rows: "rows",
            rowspan: "rowSpan",
            sandbox: "sandbox",
            scope: "scope",
            scoped: "scoped",
            scrolling: "scrolling",
            seamless: "seamless",
            selected: "selected",
            shape: "shape",
            size: "size",
            sizes: "sizes",
            span: "span",
            spellcheck: "spellCheck",
            src: "src",
            srcdoc: "srcDoc",
            srclang: "srcLang",
            srcset: "srcSet",
            start: "start",
            step: "step",
            style: "style",
            summary: "summary",
            tabindex: "tabIndex",
            target: "target",
            title: "title",
            type: "type",
            usemap: "useMap",
            value: "value",
            width: "width",
            wmode: "wmode",
            wrap: "wrap",
            about: "about",
            accentheight: "accentHeight",
            "accent-height": "accentHeight",
            accumulate: "accumulate",
            additive: "additive",
            alignmentbaseline: "alignmentBaseline",
            "alignment-baseline": "alignmentBaseline",
            allowreorder: "allowReorder",
            alphabetic: "alphabetic",
            amplitude: "amplitude",
            arabicform: "arabicForm",
            "arabic-form": "arabicForm",
            ascent: "ascent",
            attributename: "attributeName",
            attributetype: "attributeType",
            autoreverse: "autoReverse",
            azimuth: "azimuth",
            basefrequency: "baseFrequency",
            baselineshift: "baselineShift",
            "baseline-shift": "baselineShift",
            baseprofile: "baseProfile",
            bbox: "bbox",
            begin: "begin",
            bias: "bias",
            by: "by",
            calcmode: "calcMode",
            capheight: "capHeight",
            "cap-height": "capHeight",
            clip: "clip",
            clippath: "clipPath",
            "clip-path": "clipPath",
            clippathunits: "clipPathUnits",
            cliprule: "clipRule",
            "clip-rule": "clipRule",
            color: "color",
            colorinterpolation: "colorInterpolation",
            "color-interpolation": "colorInterpolation",
            colorinterpolationfilters: "colorInterpolationFilters",
            "color-interpolation-filters": "colorInterpolationFilters",
            colorprofile: "colorProfile",
            "color-profile": "colorProfile",
            colorrendering: "colorRendering",
            "color-rendering": "colorRendering",
            contentscripttype: "contentScriptType",
            contentstyletype: "contentStyleType",
            cursor: "cursor",
            cx: "cx",
            cy: "cy",
            d: "d",
            datatype: "datatype",
            decelerate: "decelerate",
            descent: "descent",
            diffuseconstant: "diffuseConstant",
            direction: "direction",
            display: "display",
            divisor: "divisor",
            dominantbaseline: "dominantBaseline",
            "dominant-baseline": "dominantBaseline",
            dur: "dur",
            dx: "dx",
            dy: "dy",
            edgemode: "edgeMode",
            elevation: "elevation",
            enablebackground: "enableBackground",
            "enable-background": "enableBackground",
            end: "end",
            exponent: "exponent",
            externalresourcesrequired: "externalResourcesRequired",
            fill: "fill",
            fillopacity: "fillOpacity",
            "fill-opacity": "fillOpacity",
            fillrule: "fillRule",
            "fill-rule": "fillRule",
            filter: "filter",
            filterres: "filterRes",
            filterunits: "filterUnits",
            floodopacity: "floodOpacity",
            "flood-opacity": "floodOpacity",
            floodcolor: "floodColor",
            "flood-color": "floodColor",
            focusable: "focusable",
            fontfamily: "fontFamily",
            "font-family": "fontFamily",
            fontsize: "fontSize",
            "font-size": "fontSize",
            fontsizeadjust: "fontSizeAdjust",
            "font-size-adjust": "fontSizeAdjust",
            fontstretch: "fontStretch",
            "font-stretch": "fontStretch",
            fontstyle: "fontStyle",
            "font-style": "fontStyle",
            fontvariant: "fontVariant",
            "font-variant": "fontVariant",
            fontweight: "fontWeight",
            "font-weight": "fontWeight",
            format: "format",
            from: "from",
            fx: "fx",
            fy: "fy",
            g1: "g1",
            g2: "g2",
            glyphname: "glyphName",
            "glyph-name": "glyphName",
            glyphorientationhorizontal: "glyphOrientationHorizontal",
            "glyph-orientation-horizontal": "glyphOrientationHorizontal",
            glyphorientationvertical: "glyphOrientationVertical",
            "glyph-orientation-vertical": "glyphOrientationVertical",
            glyphref: "glyphRef",
            gradienttransform: "gradientTransform",
            gradientunits: "gradientUnits",
            hanging: "hanging",
            horizadvx: "horizAdvX",
            "horiz-adv-x": "horizAdvX",
            horizoriginx: "horizOriginX",
            "horiz-origin-x": "horizOriginX",
            ideographic: "ideographic",
            imagerendering: "imageRendering",
            "image-rendering": "imageRendering",
            in2: "in2",
            in: "in",
            inlist: "inlist",
            intercept: "intercept",
            k1: "k1",
            k2: "k2",
            k3: "k3",
            k4: "k4",
            k: "k",
            kernelmatrix: "kernelMatrix",
            kernelunitlength: "kernelUnitLength",
            kerning: "kerning",
            keypoints: "keyPoints",
            keysplines: "keySplines",
            keytimes: "keyTimes",
            lengthadjust: "lengthAdjust",
            letterspacing: "letterSpacing",
            "letter-spacing": "letterSpacing",
            lightingcolor: "lightingColor",
            "lighting-color": "lightingColor",
            limitingconeangle: "limitingConeAngle",
            local: "local",
            markerend: "markerEnd",
            "marker-end": "markerEnd",
            markerheight: "markerHeight",
            markermid: "markerMid",
            "marker-mid": "markerMid",
            markerstart: "markerStart",
            "marker-start": "markerStart",
            markerunits: "markerUnits",
            markerwidth: "markerWidth",
            mask: "mask",
            maskcontentunits: "maskContentUnits",
            maskunits: "maskUnits",
            mathematical: "mathematical",
            mode: "mode",
            numoctaves: "numOctaves",
            offset: "offset",
            opacity: "opacity",
            operator: "operator",
            order: "order",
            orient: "orient",
            orientation: "orientation",
            origin: "origin",
            overflow: "overflow",
            overlineposition: "overlinePosition",
            "overline-position": "overlinePosition",
            overlinethickness: "overlineThickness",
            "overline-thickness": "overlineThickness",
            paintorder: "paintOrder",
            "paint-order": "paintOrder",
            panose1: "panose1",
            "panose-1": "panose1",
            pathlength: "pathLength",
            patterncontentunits: "patternContentUnits",
            patterntransform: "patternTransform",
            patternunits: "patternUnits",
            pointerevents: "pointerEvents",
            "pointer-events": "pointerEvents",
            points: "points",
            pointsatx: "pointsAtX",
            pointsaty: "pointsAtY",
            pointsatz: "pointsAtZ",
            prefix: "prefix",
            preservealpha: "preserveAlpha",
            preserveaspectratio: "preserveAspectRatio",
            primitiveunits: "primitiveUnits",
            property: "property",
            r: "r",
            radius: "radius",
            refx: "refX",
            refy: "refY",
            renderingintent: "renderingIntent",
            "rendering-intent": "renderingIntent",
            repeatcount: "repeatCount",
            repeatdur: "repeatDur",
            requiredextensions: "requiredExtensions",
            requiredfeatures: "requiredFeatures",
            resource: "resource",
            restart: "restart",
            result: "result",
            results: "results",
            rotate: "rotate",
            rx: "rx",
            ry: "ry",
            scale: "scale",
            security: "security",
            seed: "seed",
            shaperendering: "shapeRendering",
            "shape-rendering": "shapeRendering",
            slope: "slope",
            spacing: "spacing",
            specularconstant: "specularConstant",
            specularexponent: "specularExponent",
            speed: "speed",
            spreadmethod: "spreadMethod",
            startoffset: "startOffset",
            stddeviation: "stdDeviation",
            stemh: "stemh",
            stemv: "stemv",
            stitchtiles: "stitchTiles",
            stopcolor: "stopColor",
            "stop-color": "stopColor",
            stopopacity: "stopOpacity",
            "stop-opacity": "stopOpacity",
            strikethroughposition: "strikethroughPosition",
            "strikethrough-position": "strikethroughPosition",
            strikethroughthickness: "strikethroughThickness",
            "strikethrough-thickness": "strikethroughThickness",
            string: "string",
            stroke: "stroke",
            strokedasharray: "strokeDasharray",
            "stroke-dasharray": "strokeDasharray",
            strokedashoffset: "strokeDashoffset",
            "stroke-dashoffset": "strokeDashoffset",
            strokelinecap: "strokeLinecap",
            "stroke-linecap": "strokeLinecap",
            strokelinejoin: "strokeLinejoin",
            "stroke-linejoin": "strokeLinejoin",
            strokemiterlimit: "strokeMiterlimit",
            "stroke-miterlimit": "strokeMiterlimit",
            strokewidth: "strokeWidth",
            "stroke-width": "strokeWidth",
            strokeopacity: "strokeOpacity",
            "stroke-opacity": "strokeOpacity",
            suppresscontenteditablewarning: "suppressContentEditableWarning",
            suppresshydrationwarning: "suppressHydrationWarning",
            surfacescale: "surfaceScale",
            systemlanguage: "systemLanguage",
            tablevalues: "tableValues",
            targetx: "targetX",
            targety: "targetY",
            textanchor: "textAnchor",
            "text-anchor": "textAnchor",
            textdecoration: "textDecoration",
            "text-decoration": "textDecoration",
            textlength: "textLength",
            textrendering: "textRendering",
            "text-rendering": "textRendering",
            to: "to",
            transform: "transform",
            typeof: "typeof",
            u1: "u1",
            u2: "u2",
            underlineposition: "underlinePosition",
            "underline-position": "underlinePosition",
            underlinethickness: "underlineThickness",
            "underline-thickness": "underlineThickness",
            unicode: "unicode",
            unicodebidi: "unicodeBidi",
            "unicode-bidi": "unicodeBidi",
            unicoderange: "unicodeRange",
            "unicode-range": "unicodeRange",
            unitsperem: "unitsPerEm",
            "units-per-em": "unitsPerEm",
            unselectable: "unselectable",
            valphabetic: "vAlphabetic",
            "v-alphabetic": "vAlphabetic",
            values: "values",
            vectoreffect: "vectorEffect",
            "vector-effect": "vectorEffect",
            version: "version",
            vertadvy: "vertAdvY",
            "vert-adv-y": "vertAdvY",
            vertoriginx: "vertOriginX",
            "vert-origin-x": "vertOriginX",
            vertoriginy: "vertOriginY",
            "vert-origin-y": "vertOriginY",
            vhanging: "vHanging",
            "v-hanging": "vHanging",
            videographic: "vIdeographic",
            "v-ideographic": "vIdeographic",
            viewbox: "viewBox",
            viewtarget: "viewTarget",
            visibility: "visibility",
            vmathematical: "vMathematical",
            "v-mathematical": "vMathematical",
            vocab: "vocab",
            widths: "widths",
            wordspacing: "wordSpacing",
            "word-spacing": "wordSpacing",
            writingmode: "writingMode",
            "writing-mode": "writingMode",
            x1: "x1",
            x2: "x2",
            x: "x",
            xchannelselector: "xChannelSelector",
            xheight: "xHeight",
            "x-height": "xHeight",
            xlinkactuate: "xlinkActuate",
            "xlink:actuate": "xlinkActuate",
            xlinkarcrole: "xlinkArcrole",
            "xlink:arcrole": "xlinkArcrole",
            xlinkhref: "xlinkHref",
            "xlink:href": "xlinkHref",
            xlinkrole: "xlinkRole",
            "xlink:role": "xlinkRole",
            xlinkshow: "xlinkShow",
            "xlink:show": "xlinkShow",
            xlinktitle: "xlinkTitle",
            "xlink:title": "xlinkTitle",
            xlinktype: "xlinkType",
            "xlink:type": "xlinkType",
            xmlbase: "xmlBase",
            "xml:base": "xmlBase",
            xmllang: "xmlLang",
            "xml:lang": "xmlLang",
            xmlns: "xmlns",
            "xml:space": "xmlSpace",
            xmlnsxlink: "xmlnsXlink",
            "xmlns:xlink": "xmlnsXlink",
            xmlspace: "xmlSpace",
            y1: "y1",
            y2: "y2",
            y: "y",
            ychannelselector: "yChannelSelector",
            z: "z",
            zoomandpan: "zoomAndPan"
          };
          var ariaProperties = {
            "aria-current": 0,
            "aria-description": 0,
            "aria-details": 0,
            "aria-disabled": 0,
            "aria-hidden": 0,
            "aria-invalid": 0,
            "aria-keyshortcuts": 0,
            "aria-label": 0,
            "aria-roledescription": 0,
            "aria-autocomplete": 0,
            "aria-checked": 0,
            "aria-expanded": 0,
            "aria-haspopup": 0,
            "aria-level": 0,
            "aria-modal": 0,
            "aria-multiline": 0,
            "aria-multiselectable": 0,
            "aria-orientation": 0,
            "aria-placeholder": 0,
            "aria-pressed": 0,
            "aria-readonly": 0,
            "aria-required": 0,
            "aria-selected": 0,
            "aria-sort": 0,
            "aria-valuemax": 0,
            "aria-valuemin": 0,
            "aria-valuenow": 0,
            "aria-valuetext": 0,
            "aria-atomic": 0,
            "aria-busy": 0,
            "aria-live": 0,
            "aria-relevant": 0,
            "aria-dropeffect": 0,
            "aria-grabbed": 0,
            "aria-activedescendant": 0,
            "aria-colcount": 0,
            "aria-colindex": 0,
            "aria-colspan": 0,
            "aria-controls": 0,
            "aria-describedby": 0,
            "aria-errormessage": 0,
            "aria-flowto": 0,
            "aria-labelledby": 0,
            "aria-owns": 0,
            "aria-posinset": 0,
            "aria-rowcount": 0,
            "aria-rowindex": 0,
            "aria-rowspan": 0,
            "aria-setsize": 0
          };
          var warnedProperties = {};
          var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          function validateProperty(tagName, name16) {
            {
              if (hasOwnProperty3.call(warnedProperties, name16) && warnedProperties[name16]) {
                return true;
              }
              if (rARIACamel.test(name16)) {
                var ariaName = "aria-" + name16.slice(4).toLowerCase();
                var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
                if (correctName == null) {
                  error3("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name16);
                  warnedProperties[name16] = true;
                  return true;
                }
                if (name16 !== correctName) {
                  error3("Invalid ARIA attribute `%s`. Did you mean `%s`?", name16, correctName);
                  warnedProperties[name16] = true;
                  return true;
                }
              }
              if (rARIA.test(name16)) {
                var lowerCasedName = name16.toLowerCase();
                var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
                if (standardName == null) {
                  warnedProperties[name16] = true;
                  return false;
                }
                if (name16 !== standardName) {
                  error3("Unknown ARIA attribute `%s`. Did you mean `%s`?", name16, standardName);
                  warnedProperties[name16] = true;
                  return true;
                }
              }
            }
            return true;
          }
          function warnInvalidARIAProps(type, props) {
            {
              var invalidProps = [];
              for (var key in props) {
                var isValid3 = validateProperty(type, key);
                if (!isValid3) {
                  invalidProps.push(key);
                }
              }
              var unknownPropString = invalidProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (invalidProps.length === 1) {
                error3("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              } else if (invalidProps.length > 1) {
                error3("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              }
            }
          }
          function validateProperties(type, props) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnInvalidARIAProps(type, props);
          }
          var didWarnValueNull = false;
          function validateProperties$1(type, props) {
            {
              if (type !== "input" && type !== "textarea" && type !== "select") {
                return;
              }
              if (props != null && props.value === null && !didWarnValueNull) {
                didWarnValueNull = true;
                if (type === "select" && props.multiple) {
                  error3("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
                } else {
                  error3("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
                }
              }
            }
          }
          var validateProperty$1 = function() {
          };
          {
            var warnedProperties$1 = {};
            var EVENT_NAME_REGEX = /^on./;
            var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
            var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
            var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
            validateProperty$1 = function(tagName, name16, value13, eventRegistry) {
              if (hasOwnProperty3.call(warnedProperties$1, name16) && warnedProperties$1[name16]) {
                return true;
              }
              var lowerCasedName = name16.toLowerCase();
              if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
                error3("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
                warnedProperties$1[name16] = true;
                return true;
              }
              if (eventRegistry != null) {
                var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;
                if (registrationNameDependencies2.hasOwnProperty(name16)) {
                  return true;
                }
                var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;
                if (registrationName != null) {
                  error3("Invalid event handler property `%s`. Did you mean `%s`?", name16, registrationName);
                  warnedProperties$1[name16] = true;
                  return true;
                }
                if (EVENT_NAME_REGEX.test(name16)) {
                  error3("Unknown event handler property `%s`. It will be ignored.", name16);
                  warnedProperties$1[name16] = true;
                  return true;
                }
              } else if (EVENT_NAME_REGEX.test(name16)) {
                if (INVALID_EVENT_NAME_REGEX.test(name16)) {
                  error3("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name16);
                }
                warnedProperties$1[name16] = true;
                return true;
              }
              if (rARIA$1.test(name16) || rARIACamel$1.test(name16)) {
                return true;
              }
              if (lowerCasedName === "innerhtml") {
                error3("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
                warnedProperties$1[name16] = true;
                return true;
              }
              if (lowerCasedName === "aria") {
                error3("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
                warnedProperties$1[name16] = true;
                return true;
              }
              if (lowerCasedName === "is" && value13 !== null && value13 !== void 0 && typeof value13 !== "string") {
                error3("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value13);
                warnedProperties$1[name16] = true;
                return true;
              }
              if (typeof value13 === "number" && isNaN(value13)) {
                error3("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name16);
                warnedProperties$1[name16] = true;
                return true;
              }
              var propertyInfo = getPropertyInfo(name16);
              var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
              if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                var standardName = possibleStandardNames[lowerCasedName];
                if (standardName !== name16) {
                  error3("Invalid DOM property `%s`. Did you mean `%s`?", name16, standardName);
                  warnedProperties$1[name16] = true;
                  return true;
                }
              } else if (!isReserved && name16 !== lowerCasedName) {
                error3("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name16, lowerCasedName);
                warnedProperties$1[name16] = true;
                return true;
              }
              if (typeof value13 === "boolean" && shouldRemoveAttributeWithWarning(name16, value13, propertyInfo, false)) {
                if (value13) {
                  error3('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value13, name16, name16, value13, name16);
                } else {
                  error3('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value13, name16, name16, value13, name16, name16, name16);
                }
                warnedProperties$1[name16] = true;
                return true;
              }
              if (isReserved) {
                return true;
              }
              if (shouldRemoveAttributeWithWarning(name16, value13, propertyInfo, false)) {
                warnedProperties$1[name16] = true;
                return false;
              }
              if ((value13 === "false" || value13 === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
                error3("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value13, name16, value13 === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name16, value13);
                warnedProperties$1[name16] = true;
                return true;
              }
              return true;
            };
          }
          var warnUnknownProperties = function(type, props, eventRegistry) {
            {
              var unknownProps = [];
              for (var key in props) {
                var isValid3 = validateProperty$1(type, key, props[key], eventRegistry);
                if (!isValid3) {
                  unknownProps.push(key);
                }
              }
              var unknownPropString = unknownProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (unknownProps.length === 1) {
                error3("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              } else if (unknownProps.length > 1) {
                error3("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              }
            }
          };
          function validateProperties$2(type, props, eventRegistry) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnUnknownProperties(type, props, eventRegistry);
          }
          var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
          var IS_NON_DELEGATED = 1 << 1;
          var IS_CAPTURE_PHASE = 1 << 2;
          var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
          var currentReplayingEvent = null;
          function setReplayingEvent(event) {
            {
              if (currentReplayingEvent !== null) {
                error3("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            currentReplayingEvent = event;
          }
          function resetReplayingEvent() {
            {
              if (currentReplayingEvent === null) {
                error3("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            currentReplayingEvent = null;
          }
          function isReplayingEvent(event) {
            return event === currentReplayingEvent;
          }
          function getEventTarget(nativeEvent) {
            var target5 = nativeEvent.target || nativeEvent.srcElement || window;
            if (target5.correspondingUseElement) {
              target5 = target5.correspondingUseElement;
            }
            return target5.nodeType === TEXT_NODE ? target5.parentNode : target5;
          }
          var restoreImpl = null;
          var restoreTarget = null;
          var restoreQueue = null;
          function restoreStateOfTarget(target5) {
            var internalInstance = getInstanceFromNode(target5);
            if (!internalInstance) {
              return;
            }
            if (typeof restoreImpl !== "function") {
              throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
            }
            var stateNode = internalInstance.stateNode;
            if (stateNode) {
              var _props = getFiberCurrentPropsFromNode(stateNode);
              restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
            }
          }
          function setRestoreImplementation(impl) {
            restoreImpl = impl;
          }
          function enqueueStateRestore(target5) {
            if (restoreTarget) {
              if (restoreQueue) {
                restoreQueue.push(target5);
              } else {
                restoreQueue = [target5];
              }
            } else {
              restoreTarget = target5;
            }
          }
          function needsStateRestore() {
            return restoreTarget !== null || restoreQueue !== null;
          }
          function restoreStateIfNeeded() {
            if (!restoreTarget) {
              return;
            }
            var target5 = restoreTarget;
            var queuedTargets = restoreQueue;
            restoreTarget = null;
            restoreQueue = null;
            restoreStateOfTarget(target5);
            if (queuedTargets) {
              for (var i = 0; i < queuedTargets.length; i++) {
                restoreStateOfTarget(queuedTargets[i]);
              }
            }
          }
          var batchedUpdatesImpl = function(fn, bookkeeping) {
            return fn(bookkeeping);
          };
          var flushSyncImpl = function() {
          };
          var isInsideEventHandler = false;
          function finishEventHandler() {
            var controlledComponentsHavePendingUpdates = needsStateRestore();
            if (controlledComponentsHavePendingUpdates) {
              flushSyncImpl();
              restoreStateIfNeeded();
            }
          }
          function batchedUpdates(fn, a, b) {
            if (isInsideEventHandler) {
              return fn(a, b);
            }
            isInsideEventHandler = true;
            try {
              return batchedUpdatesImpl(fn, a, b);
            } finally {
              isInsideEventHandler = false;
              finishEventHandler();
            }
          }
          function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {
            batchedUpdatesImpl = _batchedUpdatesImpl;
            flushSyncImpl = _flushSyncImpl;
          }
          function isInteractive(tag) {
            return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
          }
          function shouldPreventMouseEvent(name16, type, props) {
            switch (name16) {
              case "onClick":
              case "onClickCapture":
              case "onDoubleClick":
              case "onDoubleClickCapture":
              case "onMouseDown":
              case "onMouseDownCapture":
              case "onMouseMove":
              case "onMouseMoveCapture":
              case "onMouseUp":
              case "onMouseUpCapture":
              case "onMouseEnter":
                return !!(props.disabled && isInteractive(type));
              default:
                return false;
            }
          }
          function getListener(inst, registrationName) {
            var stateNode = inst.stateNode;
            if (stateNode === null) {
              return null;
            }
            var props = getFiberCurrentPropsFromNode(stateNode);
            if (props === null) {
              return null;
            }
            var listener = props[registrationName];
            if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
              return null;
            }
            if (listener && typeof listener !== "function") {
              throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
            }
            return listener;
          }
          var passiveBrowserEventsSupported = false;
          if (canUseDOM) {
            try {
              var options2 = {};
              Object.defineProperty(options2, "passive", {
                get: function() {
                  passiveBrowserEventsSupported = true;
                }
              });
              window.addEventListener("test", options2, options2);
              window.removeEventListener("test", options2, options2);
            } catch (e) {
              passiveBrowserEventsSupported = false;
            }
          }
          function invokeGuardedCallbackProd(name16, func11, context, a, b, c, d, e, f) {
            var funcArgs = Array.prototype.slice.call(arguments, 3);
            try {
              func11.apply(context, funcArgs);
            } catch (error4) {
              this.onError(error4);
            }
          }
          var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
          {
            if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
              var fakeNode = document.createElement("react");
              invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name16, func11, context, a, b, c, d, e, f) {
                if (typeof document === "undefined" || document === null) {
                  throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
                }
                var evt = document.createEvent("Event");
                var didCall = false;
                var didError = true;
                var windowEvent = window.event;
                var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
                function restoreAfterDispatch() {
                  fakeNode.removeEventListener(evtType, callCallback2, false);
                  if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                    window.event = windowEvent;
                  }
                }
                var funcArgs = Array.prototype.slice.call(arguments, 3);
                function callCallback2() {
                  didCall = true;
                  restoreAfterDispatch();
                  func11.apply(context, funcArgs);
                  didError = false;
                }
                var error4;
                var didSetError = false;
                var isCrossOriginError = false;
                function handleWindowError(event) {
                  error4 = event.error;
                  didSetError = true;
                  if (error4 === null && event.colno === 0 && event.lineno === 0) {
                    isCrossOriginError = true;
                  }
                  if (event.defaultPrevented) {
                    if (error4 != null && typeof error4 === "object") {
                      try {
                        error4._suppressLogging = true;
                      } catch (inner) {
                      }
                    }
                  }
                }
                var evtType = "react-" + (name16 ? name16 : "invokeguardedcallback");
                window.addEventListener("error", handleWindowError);
                fakeNode.addEventListener(evtType, callCallback2, false);
                evt.initEvent(evtType, false, false);
                fakeNode.dispatchEvent(evt);
                if (windowEventDescriptor) {
                  Object.defineProperty(window, "event", windowEventDescriptor);
                }
                if (didCall && didError) {
                  if (!didSetError) {
                    error4 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`);
                  } else if (isCrossOriginError) {
                    error4 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.");
                  }
                  this.onError(error4);
                }
                window.removeEventListener("error", handleWindowError);
                if (!didCall) {
                  restoreAfterDispatch();
                  return invokeGuardedCallbackProd.apply(this, arguments);
                }
              };
            }
          }
          var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
          var hasError = false;
          var caughtError = null;
          var hasRethrowError = false;
          var rethrowError = null;
          var reporter = {
            onError: function(error4) {
              hasError = true;
              caughtError = error4;
            }
          };
          function invokeGuardedCallback(name16, func11, context, a, b, c, d, e, f) {
            hasError = false;
            caughtError = null;
            invokeGuardedCallbackImpl$1.apply(reporter, arguments);
          }
          function invokeGuardedCallbackAndCatchFirstError(name16, func11, context, a, b, c, d, e, f) {
            invokeGuardedCallback.apply(this, arguments);
            if (hasError) {
              var error4 = clearCaughtError();
              if (!hasRethrowError) {
                hasRethrowError = true;
                rethrowError = error4;
              }
            }
          }
          function rethrowCaughtError() {
            if (hasRethrowError) {
              var error4 = rethrowError;
              hasRethrowError = false;
              rethrowError = null;
              throw error4;
            }
          }
          function hasCaughtError() {
            return hasError;
          }
          function clearCaughtError() {
            if (hasError) {
              var error4 = caughtError;
              hasError = false;
              caughtError = null;
              return error4;
            } else {
              throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          function get3(key) {
            return key._reactInternals;
          }
          function has(key) {
            return key._reactInternals !== void 0;
          }
          function set(key, value13) {
            key._reactInternals = value13;
          }
          var NoFlags = 0;
          var PerformedWork = 1;
          var Placement = 2;
          var Update = 4;
          var ChildDeletion = 16;
          var ContentReset = 32;
          var Callback = 64;
          var DidCapture = 128;
          var ForceClientRender = 256;
          var Ref = 512;
          var Snapshot = 1024;
          var Passive = 2048;
          var Hydrating = 4096;
          var Visibility = 8192;
          var StoreConsistency = 16384;
          var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency;
          var HostEffectMask = 32767;
          var Incomplete = 32768;
          var ShouldCapture = 65536;
          var ForceUpdateForLegacySuspense = 131072;
          var Forked = 1048576;
          var RefStatic = 2097152;
          var LayoutStatic = 4194304;
          var PassiveStatic = 8388608;
          var MountLayoutDev = 16777216;
          var MountPassiveDev = 33554432;
          var BeforeMutationMask = Update | Snapshot | 0;
          var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;
          var LayoutMask = Update | Callback | Ref | Visibility;
          var PassiveMask = Passive | ChildDeletion;
          var StaticMask = LayoutStatic | PassiveStatic | RefStatic;
          var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
          function getNearestMountedFiber(fiber) {
            var node = fiber;
            var nearestMounted = fiber;
            if (!fiber.alternate) {
              var nextNode = node;
              do {
                node = nextNode;
                if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
                  nearestMounted = node.return;
                }
                nextNode = node.return;
              } while (nextNode);
            } else {
              while (node.return) {
                node = node.return;
              }
            }
            if (node.tag === HostRoot) {
              return nearestMounted;
            }
            return null;
          }
          function getSuspenseInstanceFromFiber(fiber) {
            if (fiber.tag === SuspenseComponent) {
              var suspenseState = fiber.memoizedState;
              if (suspenseState === null) {
                var current2 = fiber.alternate;
                if (current2 !== null) {
                  suspenseState = current2.memoizedState;
                }
              }
              if (suspenseState !== null) {
                return suspenseState.dehydrated;
              }
            }
            return null;
          }
          function getContainerFromFiber(fiber) {
            return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
          }
          function isFiberMounted(fiber) {
            return getNearestMountedFiber(fiber) === fiber;
          }
          function isMounted(component2) {
            {
              var owner = ReactCurrentOwner.current;
              if (owner !== null && owner.tag === ClassComponent) {
                var ownerFiber = owner;
                var instance = ownerFiber.stateNode;
                if (!instance._warnedAboutRefsInRender) {
                  error3("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromFiber(ownerFiber) || "A component");
                }
                instance._warnedAboutRefsInRender = true;
              }
            }
            var fiber = get3(component2);
            if (!fiber) {
              return false;
            }
            return getNearestMountedFiber(fiber) === fiber;
          }
          function assertIsMounted(fiber) {
            if (getNearestMountedFiber(fiber) !== fiber) {
              throw new Error("Unable to find node on an unmounted component.");
            }
          }
          function findCurrentFiberUsingSlowPath(fiber) {
            var alternate = fiber.alternate;
            if (!alternate) {
              var nearestMounted = getNearestMountedFiber(fiber);
              if (nearestMounted === null) {
                throw new Error("Unable to find node on an unmounted component.");
              }
              if (nearestMounted !== fiber) {
                return null;
              }
              return fiber;
            }
            var a = fiber;
            var b = alternate;
            while (true) {
              var parentA = a.return;
              if (parentA === null) {
                break;
              }
              var parentB = parentA.alternate;
              if (parentB === null) {
                var nextParent = parentA.return;
                if (nextParent !== null) {
                  a = b = nextParent;
                  continue;
                }
                break;
              }
              if (parentA.child === parentB.child) {
                var child = parentA.child;
                while (child) {
                  if (child === a) {
                    assertIsMounted(parentA);
                    return fiber;
                  }
                  if (child === b) {
                    assertIsMounted(parentA);
                    return alternate;
                  }
                  child = child.sibling;
                }
                throw new Error("Unable to find node on an unmounted component.");
              }
              if (a.return !== b.return) {
                a = parentA;
                b = parentB;
              } else {
                var didFindChild = false;
                var _child = parentA.child;
                while (_child) {
                  if (_child === a) {
                    didFindChild = true;
                    a = parentA;
                    b = parentB;
                    break;
                  }
                  if (_child === b) {
                    didFindChild = true;
                    b = parentA;
                    a = parentB;
                    break;
                  }
                  _child = _child.sibling;
                }
                if (!didFindChild) {
                  _child = parentB.child;
                  while (_child) {
                    if (_child === a) {
                      didFindChild = true;
                      a = parentB;
                      b = parentA;
                      break;
                    }
                    if (_child === b) {
                      didFindChild = true;
                      b = parentB;
                      a = parentA;
                      break;
                    }
                    _child = _child.sibling;
                  }
                  if (!didFindChild) {
                    throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
                  }
                }
              }
              if (a.alternate !== b) {
                throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            if (a.tag !== HostRoot) {
              throw new Error("Unable to find node on an unmounted component.");
            }
            if (a.stateNode.current === a) {
              return fiber;
            }
            return alternate;
          }
          function findCurrentHostFiber(parent2) {
            var currentParent = findCurrentFiberUsingSlowPath(parent2);
            return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
          }
          function findCurrentHostFiberImpl(node) {
            if (node.tag === HostComponent || node.tag === HostText) {
              return node;
            }
            var child = node.child;
            while (child !== null) {
              var match = findCurrentHostFiberImpl(child);
              if (match !== null) {
                return match;
              }
              child = child.sibling;
            }
            return null;
          }
          function findCurrentHostFiberWithNoPortals(parent2) {
            var currentParent = findCurrentFiberUsingSlowPath(parent2);
            return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
          }
          function findCurrentHostFiberWithNoPortalsImpl(node) {
            if (node.tag === HostComponent || node.tag === HostText) {
              return node;
            }
            var child = node.child;
            while (child !== null) {
              if (child.tag !== HostPortal) {
                var match = findCurrentHostFiberWithNoPortalsImpl(child);
                if (match !== null) {
                  return match;
                }
              }
              child = child.sibling;
            }
            return null;
          }
          var scheduleCallback = Scheduler.unstable_scheduleCallback;
          var cancelCallback = Scheduler.unstable_cancelCallback;
          var shouldYield = Scheduler.unstable_shouldYield;
          var requestPaint = Scheduler.unstable_requestPaint;
          var now2 = Scheduler.unstable_now;
          var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
          var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
          var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
          var NormalPriority = Scheduler.unstable_NormalPriority;
          var LowPriority = Scheduler.unstable_LowPriority;
          var IdlePriority = Scheduler.unstable_IdlePriority;
          var unstable_yieldValue = Scheduler.unstable_yieldValue;
          var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
          var rendererID = null;
          var injectedHook = null;
          var injectedProfilingHooks = null;
          var hasLoggedError = false;
          var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
          function injectInternals(internals) {
            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
              return false;
            }
            var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (hook.isDisabled) {
              return true;
            }
            if (!hook.supportsFiber) {
              {
                error3("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools");
              }
              return true;
            }
            try {
              if (enableSchedulingProfiler) {
                internals = assign2({}, internals, {
                  getLaneLabelMap,
                  injectProfilingHooks
                });
              }
              rendererID = hook.inject(internals);
              injectedHook = hook;
            } catch (err) {
              {
                error3("React instrumentation encountered an error: %s.", err);
              }
            }
            if (hook.checkDCE) {
              return true;
            } else {
              return false;
            }
          }
          function onScheduleRoot(root2, children) {
            {
              if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function") {
                try {
                  injectedHook.onScheduleFiberRoot(rendererID, root2, children);
                } catch (err) {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error3("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onCommitRoot(root2, eventPriority) {
            if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
              try {
                var didError = (root2.current.flags & DidCapture) === DidCapture;
                if (enableProfilerTimer) {
                  var schedulerPriority;
                  switch (eventPriority) {
                    case DiscreteEventPriority:
                      schedulerPriority = ImmediatePriority;
                      break;
                    case ContinuousEventPriority:
                      schedulerPriority = UserBlockingPriority;
                      break;
                    case DefaultEventPriority:
                      schedulerPriority = NormalPriority;
                      break;
                    case IdleEventPriority:
                      schedulerPriority = IdlePriority;
                      break;
                    default:
                      schedulerPriority = NormalPriority;
                      break;
                  }
                  injectedHook.onCommitFiberRoot(rendererID, root2, schedulerPriority, didError);
                } else {
                  injectedHook.onCommitFiberRoot(rendererID, root2, void 0, didError);
                }
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error3("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onPostCommitRoot(root2) {
            if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function") {
              try {
                injectedHook.onPostCommitFiberRoot(rendererID, root2);
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error3("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function onCommitUnmount(fiber) {
            if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
              try {
                injectedHook.onCommitFiberUnmount(rendererID, fiber);
              } catch (err) {
                {
                  if (!hasLoggedError) {
                    hasLoggedError = true;
                    error3("React instrumentation encountered an error: %s", err);
                  }
                }
              }
            }
          }
          function setIsStrictModeForDevtools(newIsStrictMode) {
            {
              if (typeof unstable_yieldValue === "function") {
                unstable_setDisableYieldValue(newIsStrictMode);
                setSuppressWarning(newIsStrictMode);
              }
              if (injectedHook && typeof injectedHook.setStrictMode === "function") {
                try {
                  injectedHook.setStrictMode(rendererID, newIsStrictMode);
                } catch (err) {
                  {
                    if (!hasLoggedError) {
                      hasLoggedError = true;
                      error3("React instrumentation encountered an error: %s", err);
                    }
                  }
                }
              }
            }
          }
          function injectProfilingHooks(profilingHooks) {
            injectedProfilingHooks = profilingHooks;
          }
          function getLaneLabelMap() {
            {
              var map16 = /* @__PURE__ */ new Map();
              var lane = 1;
              for (var index6 = 0; index6 < TotalLanes; index6++) {
                var label4 = getLabelForLane(lane);
                map16.set(lane, label4);
                lane *= 2;
              }
              return map16;
            }
          }
          function markCommitStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === "function") {
                injectedProfilingHooks.markCommitStarted(lanes);
              }
            }
          }
          function markCommitStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === "function") {
                injectedProfilingHooks.markCommitStopped();
              }
            }
          }
          function markComponentRenderStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === "function") {
                injectedProfilingHooks.markComponentRenderStarted(fiber);
              }
            }
          }
          function markComponentRenderStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === "function") {
                injectedProfilingHooks.markComponentRenderStopped();
              }
            }
          }
          function markComponentPassiveEffectMountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === "function") {
                injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
              }
            }
          }
          function markComponentPassiveEffectMountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === "function") {
                injectedProfilingHooks.markComponentPassiveEffectMountStopped();
              }
            }
          }
          function markComponentPassiveEffectUnmountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === "function") {
                injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
              }
            }
          }
          function markComponentPassiveEffectUnmountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === "function") {
                injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
              }
            }
          }
          function markComponentLayoutEffectMountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === "function") {
                injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
              }
            }
          }
          function markComponentLayoutEffectMountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === "function") {
                injectedProfilingHooks.markComponentLayoutEffectMountStopped();
              }
            }
          }
          function markComponentLayoutEffectUnmountStarted(fiber) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === "function") {
                injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
              }
            }
          }
          function markComponentLayoutEffectUnmountStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === "function") {
                injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
              }
            }
          }
          function markComponentErrored(fiber, thrownValue, lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === "function") {
                injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
              }
            }
          }
          function markComponentSuspended(fiber, wakeable, lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === "function") {
                injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
              }
            }
          }
          function markLayoutEffectsStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === "function") {
                injectedProfilingHooks.markLayoutEffectsStarted(lanes);
              }
            }
          }
          function markLayoutEffectsStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === "function") {
                injectedProfilingHooks.markLayoutEffectsStopped();
              }
            }
          }
          function markPassiveEffectsStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === "function") {
                injectedProfilingHooks.markPassiveEffectsStarted(lanes);
              }
            }
          }
          function markPassiveEffectsStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === "function") {
                injectedProfilingHooks.markPassiveEffectsStopped();
              }
            }
          }
          function markRenderStarted(lanes) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === "function") {
                injectedProfilingHooks.markRenderStarted(lanes);
              }
            }
          }
          function markRenderYielded() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === "function") {
                injectedProfilingHooks.markRenderYielded();
              }
            }
          }
          function markRenderStopped() {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === "function") {
                injectedProfilingHooks.markRenderStopped();
              }
            }
          }
          function markRenderScheduled(lane) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === "function") {
                injectedProfilingHooks.markRenderScheduled(lane);
              }
            }
          }
          function markForceUpdateScheduled(fiber, lane) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === "function") {
                injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
              }
            }
          }
          function markStateUpdateScheduled(fiber, lane) {
            {
              if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === "function") {
                injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
              }
            }
          }
          var NoMode = 0;
          var ConcurrentMode = 1;
          var ProfileMode = 2;
          var StrictLegacyMode = 8;
          var StrictEffectsMode = 16;
          var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
          var log5 = Math.log;
          var LN2 = Math.LN2;
          function clz32Fallback(x) {
            var asUint = x >>> 0;
            if (asUint === 0) {
              return 32;
            }
            return 31 - (log5(asUint) / LN2 | 0) | 0;
          }
          var TotalLanes = 31;
          var NoLanes = 0;
          var NoLane = 0;
          var SyncLane = 1;
          var InputContinuousHydrationLane = 2;
          var InputContinuousLane = 4;
          var DefaultHydrationLane = 8;
          var DefaultLane = 16;
          var TransitionHydrationLane = 32;
          var TransitionLanes = 4194240;
          var TransitionLane1 = 64;
          var TransitionLane2 = 128;
          var TransitionLane3 = 256;
          var TransitionLane4 = 512;
          var TransitionLane5 = 1024;
          var TransitionLane6 = 2048;
          var TransitionLane7 = 4096;
          var TransitionLane8 = 8192;
          var TransitionLane9 = 16384;
          var TransitionLane10 = 32768;
          var TransitionLane11 = 65536;
          var TransitionLane12 = 131072;
          var TransitionLane13 = 262144;
          var TransitionLane14 = 524288;
          var TransitionLane15 = 1048576;
          var TransitionLane16 = 2097152;
          var RetryLanes = 130023424;
          var RetryLane1 = 4194304;
          var RetryLane2 = 8388608;
          var RetryLane3 = 16777216;
          var RetryLane4 = 33554432;
          var RetryLane5 = 67108864;
          var SomeRetryLane = RetryLane1;
          var SelectiveHydrationLane = 134217728;
          var NonIdleLanes = 268435455;
          var IdleHydrationLane = 268435456;
          var IdleLane = 536870912;
          var OffscreenLane = 1073741824;
          function getLabelForLane(lane) {
            {
              if (lane & SyncLane) {
                return "Sync";
              }
              if (lane & InputContinuousHydrationLane) {
                return "InputContinuousHydration";
              }
              if (lane & InputContinuousLane) {
                return "InputContinuous";
              }
              if (lane & DefaultHydrationLane) {
                return "DefaultHydration";
              }
              if (lane & DefaultLane) {
                return "Default";
              }
              if (lane & TransitionHydrationLane) {
                return "TransitionHydration";
              }
              if (lane & TransitionLanes) {
                return "Transition";
              }
              if (lane & RetryLanes) {
                return "Retry";
              }
              if (lane & SelectiveHydrationLane) {
                return "SelectiveHydration";
              }
              if (lane & IdleHydrationLane) {
                return "IdleHydration";
              }
              if (lane & IdleLane) {
                return "Idle";
              }
              if (lane & OffscreenLane) {
                return "Offscreen";
              }
            }
          }
          var NoTimestamp = -1;
          var nextTransitionLane = TransitionLane1;
          var nextRetryLane = RetryLane1;
          function getHighestPriorityLanes(lanes) {
            switch (getHighestPriorityLane(lanes)) {
              case SyncLane:
                return SyncLane;
              case InputContinuousHydrationLane:
                return InputContinuousHydrationLane;
              case InputContinuousLane:
                return InputContinuousLane;
              case DefaultHydrationLane:
                return DefaultHydrationLane;
              case DefaultLane:
                return DefaultLane;
              case TransitionHydrationLane:
                return TransitionHydrationLane;
              case TransitionLane1:
              case TransitionLane2:
              case TransitionLane3:
              case TransitionLane4:
              case TransitionLane5:
              case TransitionLane6:
              case TransitionLane7:
              case TransitionLane8:
              case TransitionLane9:
              case TransitionLane10:
              case TransitionLane11:
              case TransitionLane12:
              case TransitionLane13:
              case TransitionLane14:
              case TransitionLane15:
              case TransitionLane16:
                return lanes & TransitionLanes;
              case RetryLane1:
              case RetryLane2:
              case RetryLane3:
              case RetryLane4:
              case RetryLane5:
                return lanes & RetryLanes;
              case SelectiveHydrationLane:
                return SelectiveHydrationLane;
              case IdleHydrationLane:
                return IdleHydrationLane;
              case IdleLane:
                return IdleLane;
              case OffscreenLane:
                return OffscreenLane;
              default:
                {
                  error3("Should have found matching lanes. This is a bug in React.");
                }
                return lanes;
            }
          }
          function getNextLanes(root2, wipLanes) {
            var pendingLanes = root2.pendingLanes;
            if (pendingLanes === NoLanes) {
              return NoLanes;
            }
            var nextLanes = NoLanes;
            var suspendedLanes = root2.suspendedLanes;
            var pingedLanes = root2.pingedLanes;
            var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
            if (nonIdlePendingLanes !== NoLanes) {
              var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
              if (nonIdleUnblockedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
              } else {
                var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
                if (nonIdlePingedLanes !== NoLanes) {
                  nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
                }
              }
            } else {
              var unblockedLanes = pendingLanes & ~suspendedLanes;
              if (unblockedLanes !== NoLanes) {
                nextLanes = getHighestPriorityLanes(unblockedLanes);
              } else {
                if (pingedLanes !== NoLanes) {
                  nextLanes = getHighestPriorityLanes(pingedLanes);
                }
              }
            }
            if (nextLanes === NoLanes) {
              return NoLanes;
            }
            if (wipLanes !== NoLanes && wipLanes !== nextLanes && (wipLanes & suspendedLanes) === NoLanes) {
              var nextLane = getHighestPriorityLane(nextLanes);
              var wipLane = getHighestPriorityLane(wipLanes);
              if (nextLane >= wipLane || nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {
                return wipLanes;
              }
            }
            if ((nextLanes & InputContinuousLane) !== NoLanes) {
              nextLanes |= pendingLanes & DefaultLane;
            }
            var entangledLanes = root2.entangledLanes;
            if (entangledLanes !== NoLanes) {
              var entanglements = root2.entanglements;
              var lanes = nextLanes & entangledLanes;
              while (lanes > 0) {
                var index6 = pickArbitraryLaneIndex(lanes);
                var lane = 1 << index6;
                nextLanes |= entanglements[index6];
                lanes &= ~lane;
              }
            }
            return nextLanes;
          }
          function getMostRecentEventTime(root2, lanes) {
            var eventTimes = root2.eventTimes;
            var mostRecentEventTime = NoTimestamp;
            while (lanes > 0) {
              var index6 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index6;
              var eventTime = eventTimes[index6];
              if (eventTime > mostRecentEventTime) {
                mostRecentEventTime = eventTime;
              }
              lanes &= ~lane;
            }
            return mostRecentEventTime;
          }
          function computeExpirationTime(lane, currentTime2) {
            switch (lane) {
              case SyncLane:
              case InputContinuousHydrationLane:
              case InputContinuousLane:
                return currentTime2 + 250;
              case DefaultHydrationLane:
              case DefaultLane:
              case TransitionHydrationLane:
              case TransitionLane1:
              case TransitionLane2:
              case TransitionLane3:
              case TransitionLane4:
              case TransitionLane5:
              case TransitionLane6:
              case TransitionLane7:
              case TransitionLane8:
              case TransitionLane9:
              case TransitionLane10:
              case TransitionLane11:
              case TransitionLane12:
              case TransitionLane13:
              case TransitionLane14:
              case TransitionLane15:
              case TransitionLane16:
                return currentTime2 + 5e3;
              case RetryLane1:
              case RetryLane2:
              case RetryLane3:
              case RetryLane4:
              case RetryLane5:
                return NoTimestamp;
              case SelectiveHydrationLane:
              case IdleHydrationLane:
              case IdleLane:
              case OffscreenLane:
                return NoTimestamp;
              default:
                {
                  error3("Should have found matching lanes. This is a bug in React.");
                }
                return NoTimestamp;
            }
          }
          function markStarvedLanesAsExpired(root2, currentTime2) {
            var pendingLanes = root2.pendingLanes;
            var suspendedLanes = root2.suspendedLanes;
            var pingedLanes = root2.pingedLanes;
            var expirationTimes = root2.expirationTimes;
            var lanes = pendingLanes;
            while (lanes > 0) {
              var index6 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index6;
              var expirationTime = expirationTimes[index6];
              if (expirationTime === NoTimestamp) {
                if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
                  expirationTimes[index6] = computeExpirationTime(lane, currentTime2);
                }
              } else if (expirationTime <= currentTime2) {
                root2.expiredLanes |= lane;
              }
              lanes &= ~lane;
            }
          }
          function getHighestPriorityPendingLanes(root2) {
            return getHighestPriorityLanes(root2.pendingLanes);
          }
          function getLanesToRetrySynchronouslyOnError(root2) {
            var everythingButOffscreen = root2.pendingLanes & ~OffscreenLane;
            if (everythingButOffscreen !== NoLanes) {
              return everythingButOffscreen;
            }
            if (everythingButOffscreen & OffscreenLane) {
              return OffscreenLane;
            }
            return NoLanes;
          }
          function includesSyncLane(lanes) {
            return (lanes & SyncLane) !== NoLanes;
          }
          function includesNonIdleWork(lanes) {
            return (lanes & NonIdleLanes) !== NoLanes;
          }
          function includesOnlyRetries(lanes) {
            return (lanes & RetryLanes) === lanes;
          }
          function includesOnlyNonUrgentLanes(lanes) {
            var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
            return (lanes & UrgentLanes) === NoLanes;
          }
          function includesOnlyTransitions(lanes) {
            return (lanes & TransitionLanes) === lanes;
          }
          function includesBlockingLane(root2, lanes) {
            var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
            return (lanes & SyncDefaultLanes) !== NoLanes;
          }
          function includesExpiredLane(root2, lanes) {
            return (lanes & root2.expiredLanes) !== NoLanes;
          }
          function isTransitionLane(lane) {
            return (lane & TransitionLanes) !== NoLanes;
          }
          function claimNextTransitionLane() {
            var lane = nextTransitionLane;
            nextTransitionLane <<= 1;
            if ((nextTransitionLane & TransitionLanes) === NoLanes) {
              nextTransitionLane = TransitionLane1;
            }
            return lane;
          }
          function claimNextRetryLane() {
            var lane = nextRetryLane;
            nextRetryLane <<= 1;
            if ((nextRetryLane & RetryLanes) === NoLanes) {
              nextRetryLane = RetryLane1;
            }
            return lane;
          }
          function getHighestPriorityLane(lanes) {
            return lanes & -lanes;
          }
          function pickArbitraryLane(lanes) {
            return getHighestPriorityLane(lanes);
          }
          function pickArbitraryLaneIndex(lanes) {
            return 31 - clz32(lanes);
          }
          function laneToIndex(lane) {
            return pickArbitraryLaneIndex(lane);
          }
          function includesSomeLane(a, b) {
            return (a & b) !== NoLanes;
          }
          function isSubsetOfLanes(set2, subset) {
            return (set2 & subset) === subset;
          }
          function mergeLanes(a, b) {
            return a | b;
          }
          function removeLanes(set2, subset) {
            return set2 & ~subset;
          }
          function intersectLanes(a, b) {
            return a & b;
          }
          function laneToLanes(lane) {
            return lane;
          }
          function higherPriorityLane(a, b) {
            return a !== NoLane && a < b ? a : b;
          }
          function createLaneMap(initial) {
            var laneMap = [];
            for (var i = 0; i < TotalLanes; i++) {
              laneMap.push(initial);
            }
            return laneMap;
          }
          function markRootUpdated(root2, updateLane, eventTime) {
            root2.pendingLanes |= updateLane;
            if (updateLane !== IdleLane) {
              root2.suspendedLanes = NoLanes;
              root2.pingedLanes = NoLanes;
            }
            var eventTimes = root2.eventTimes;
            var index6 = laneToIndex(updateLane);
            eventTimes[index6] = eventTime;
          }
          function markRootSuspended(root2, suspendedLanes) {
            root2.suspendedLanes |= suspendedLanes;
            root2.pingedLanes &= ~suspendedLanes;
            var expirationTimes = root2.expirationTimes;
            var lanes = suspendedLanes;
            while (lanes > 0) {
              var index6 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index6;
              expirationTimes[index6] = NoTimestamp;
              lanes &= ~lane;
            }
          }
          function markRootPinged(root2, pingedLanes, eventTime) {
            root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
          }
          function markRootFinished(root2, remainingLanes) {
            var noLongerPendingLanes = root2.pendingLanes & ~remainingLanes;
            root2.pendingLanes = remainingLanes;
            root2.suspendedLanes = NoLanes;
            root2.pingedLanes = NoLanes;
            root2.expiredLanes &= remainingLanes;
            root2.mutableReadLanes &= remainingLanes;
            root2.entangledLanes &= remainingLanes;
            var entanglements = root2.entanglements;
            var eventTimes = root2.eventTimes;
            var expirationTimes = root2.expirationTimes;
            var lanes = noLongerPendingLanes;
            while (lanes > 0) {
              var index6 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index6;
              entanglements[index6] = NoLanes;
              eventTimes[index6] = NoTimestamp;
              expirationTimes[index6] = NoTimestamp;
              lanes &= ~lane;
            }
          }
          function markRootEntangled(root2, entangledLanes) {
            var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
            var entanglements = root2.entanglements;
            var lanes = rootEntangledLanes;
            while (lanes) {
              var index6 = pickArbitraryLaneIndex(lanes);
              var lane = 1 << index6;
              if (lane & entangledLanes | entanglements[index6] & entangledLanes) {
                entanglements[index6] |= entangledLanes;
              }
              lanes &= ~lane;
            }
          }
          function getBumpedLaneForHydration(root2, renderLanes2) {
            var renderLane = getHighestPriorityLane(renderLanes2);
            var lane;
            switch (renderLane) {
              case InputContinuousLane:
                lane = InputContinuousHydrationLane;
                break;
              case DefaultLane:
                lane = DefaultHydrationLane;
                break;
              case TransitionLane1:
              case TransitionLane2:
              case TransitionLane3:
              case TransitionLane4:
              case TransitionLane5:
              case TransitionLane6:
              case TransitionLane7:
              case TransitionLane8:
              case TransitionLane9:
              case TransitionLane10:
              case TransitionLane11:
              case TransitionLane12:
              case TransitionLane13:
              case TransitionLane14:
              case TransitionLane15:
              case TransitionLane16:
              case RetryLane1:
              case RetryLane2:
              case RetryLane3:
              case RetryLane4:
              case RetryLane5:
                lane = TransitionHydrationLane;
                break;
              case IdleLane:
                lane = IdleHydrationLane;
                break;
              default:
                lane = NoLane;
                break;
            }
            if ((lane & (root2.suspendedLanes | renderLanes2)) !== NoLane) {
              return NoLane;
            }
            return lane;
          }
          function addFiberToLanesMap(root2, fiber, lanes) {
            if (!isDevToolsPresent) {
              return;
            }
            var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;
            while (lanes > 0) {
              var index6 = laneToIndex(lanes);
              var lane = 1 << index6;
              var updaters = pendingUpdatersLaneMap[index6];
              updaters.add(fiber);
              lanes &= ~lane;
            }
          }
          function movePendingFibersToMemoized(root2, lanes) {
            if (!isDevToolsPresent) {
              return;
            }
            var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;
            var memoizedUpdaters = root2.memoizedUpdaters;
            while (lanes > 0) {
              var index6 = laneToIndex(lanes);
              var lane = 1 << index6;
              var updaters = pendingUpdatersLaneMap[index6];
              if (updaters.size > 0) {
                updaters.forEach(function(fiber) {
                  var alternate = fiber.alternate;
                  if (alternate === null || !memoizedUpdaters.has(alternate)) {
                    memoizedUpdaters.add(fiber);
                  }
                });
                updaters.clear();
              }
              lanes &= ~lane;
            }
          }
          function getTransitionsForLanes(root2, lanes) {
            {
              return null;
            }
          }
          var DiscreteEventPriority = SyncLane;
          var ContinuousEventPriority = InputContinuousLane;
          var DefaultEventPriority = DefaultLane;
          var IdleEventPriority = IdleLane;
          var currentUpdatePriority = NoLane;
          function getCurrentUpdatePriority() {
            return currentUpdatePriority;
          }
          function setCurrentUpdatePriority(newPriority) {
            currentUpdatePriority = newPriority;
          }
          function runWithPriority(priority, fn) {
            var previousPriority = currentUpdatePriority;
            try {
              currentUpdatePriority = priority;
              return fn();
            } finally {
              currentUpdatePriority = previousPriority;
            }
          }
          function higherEventPriority(a, b) {
            return a !== 0 && a < b ? a : b;
          }
          function lowerEventPriority(a, b) {
            return a === 0 || a > b ? a : b;
          }
          function isHigherEventPriority(a, b) {
            return a !== 0 && a < b;
          }
          function lanesToEventPriority(lanes) {
            var lane = getHighestPriorityLane(lanes);
            if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
              return DiscreteEventPriority;
            }
            if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
              return ContinuousEventPriority;
            }
            if (includesNonIdleWork(lane)) {
              return DefaultEventPriority;
            }
            return IdleEventPriority;
          }
          function isRootDehydrated(root2) {
            var currentState = root2.current.memoizedState;
            return currentState.isDehydrated;
          }
          var _attemptSynchronousHydration;
          function setAttemptSynchronousHydration(fn) {
            _attemptSynchronousHydration = fn;
          }
          function attemptSynchronousHydration(fiber) {
            _attemptSynchronousHydration(fiber);
          }
          var attemptContinuousHydration;
          function setAttemptContinuousHydration(fn) {
            attemptContinuousHydration = fn;
          }
          var attemptHydrationAtCurrentPriority;
          function setAttemptHydrationAtCurrentPriority(fn) {
            attemptHydrationAtCurrentPriority = fn;
          }
          var getCurrentUpdatePriority$1;
          function setGetCurrentUpdatePriority(fn) {
            getCurrentUpdatePriority$1 = fn;
          }
          var attemptHydrationAtPriority;
          function setAttemptHydrationAtPriority(fn) {
            attemptHydrationAtPriority = fn;
          }
          var hasScheduledReplayAttempt = false;
          var queuedDiscreteEvents = [];
          var queuedFocus = null;
          var queuedDrag = null;
          var queuedMouse = null;
          var queuedPointers = /* @__PURE__ */ new Map();
          var queuedPointerCaptures = /* @__PURE__ */ new Map();
          var queuedExplicitHydrationTargets = [];
          var discreteReplayableEvents = [
            "mousedown",
            "mouseup",
            "touchcancel",
            "touchend",
            "touchstart",
            "auxclick",
            "dblclick",
            "pointercancel",
            "pointerdown",
            "pointerup",
            "dragend",
            "dragstart",
            "drop",
            "compositionend",
            "compositionstart",
            "keydown",
            "keypress",
            "keyup",
            "input",
            "textInput",
            "copy",
            "cut",
            "paste",
            "click",
            "change",
            "contextmenu",
            "reset",
            "submit"
          ];
          function isDiscreteEventThatRequiresHydration(eventType) {
            return discreteReplayableEvents.indexOf(eventType) > -1;
          }
          function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            return {
              blockedOn,
              domEventName,
              eventSystemFlags,
              nativeEvent,
              targetContainers: [targetContainer]
            };
          }
          function clearIfContinuousEvent(domEventName, nativeEvent) {
            switch (domEventName) {
              case "focusin":
              case "focusout":
                queuedFocus = null;
                break;
              case "dragenter":
              case "dragleave":
                queuedDrag = null;
                break;
              case "mouseover":
              case "mouseout":
                queuedMouse = null;
                break;
              case "pointerover":
              case "pointerout": {
                var pointerId = nativeEvent.pointerId;
                queuedPointers.delete(pointerId);
                break;
              }
              case "gotpointercapture":
              case "lostpointercapture": {
                var _pointerId = nativeEvent.pointerId;
                queuedPointerCaptures.delete(_pointerId);
                break;
              }
            }
          }
          function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
              var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
              if (blockedOn !== null) {
                var _fiber2 = getInstanceFromNode(blockedOn);
                if (_fiber2 !== null) {
                  attemptContinuousHydration(_fiber2);
                }
              }
              return queuedEvent;
            }
            existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
            var targetContainers = existingQueuedEvent.targetContainers;
            if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
              targetContainers.push(targetContainer);
            }
            return existingQueuedEvent;
          }
          function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            switch (domEventName) {
              case "focusin": {
                var focusEvent = nativeEvent;
                queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
                return true;
              }
              case "dragenter": {
                var dragEvent = nativeEvent;
                queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
                return true;
              }
              case "mouseover": {
                var mouseEvent = nativeEvent;
                queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
                return true;
              }
              case "pointerover": {
                var pointerEvent = nativeEvent;
                var pointerId = pointerEvent.pointerId;
                queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
                return true;
              }
              case "gotpointercapture": {
                var _pointerEvent = nativeEvent;
                var _pointerId2 = _pointerEvent.pointerId;
                queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
                return true;
              }
            }
            return false;
          }
          function attemptExplicitHydrationTarget(queuedTarget) {
            var targetInst = getClosestInstanceFromNode(queuedTarget.target);
            if (targetInst !== null) {
              var nearestMounted = getNearestMountedFiber(targetInst);
              if (nearestMounted !== null) {
                var tag = nearestMounted.tag;
                if (tag === SuspenseComponent) {
                  var instance = getSuspenseInstanceFromFiber(nearestMounted);
                  if (instance !== null) {
                    queuedTarget.blockedOn = instance;
                    attemptHydrationAtPriority(queuedTarget.priority, function() {
                      attemptHydrationAtCurrentPriority(nearestMounted);
                    });
                    return;
                  }
                } else if (tag === HostRoot) {
                  var root2 = nearestMounted.stateNode;
                  if (isRootDehydrated(root2)) {
                    queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                    return;
                  }
                }
              }
            }
            queuedTarget.blockedOn = null;
          }
          function queueExplicitHydrationTarget(target5) {
            var updatePriority = getCurrentUpdatePriority$1();
            var queuedTarget = {
              blockedOn: null,
              target: target5,
              priority: updatePriority
            };
            var i = 0;
            for (; i < queuedExplicitHydrationTargets.length; i++) {
              if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i].priority)) {
                break;
              }
            }
            queuedExplicitHydrationTargets.splice(i, 0, queuedTarget);
            if (i === 0) {
              attemptExplicitHydrationTarget(queuedTarget);
            }
          }
          function attemptReplayContinuousQueuedEvent(queuedEvent) {
            if (queuedEvent.blockedOn !== null) {
              return false;
            }
            var targetContainers = queuedEvent.targetContainers;
            while (targetContainers.length > 0) {
              var targetContainer = targetContainers[0];
              var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
              if (nextBlockedOn === null) {
                {
                  var nativeEvent = queuedEvent.nativeEvent;
                  var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
                  setReplayingEvent(nativeEventClone);
                  nativeEvent.target.dispatchEvent(nativeEventClone);
                  resetReplayingEvent();
                }
              } else {
                var _fiber3 = getInstanceFromNode(nextBlockedOn);
                if (_fiber3 !== null) {
                  attemptContinuousHydration(_fiber3);
                }
                queuedEvent.blockedOn = nextBlockedOn;
                return false;
              }
              targetContainers.shift();
            }
            return true;
          }
          function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map16) {
            if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
              map16.delete(key);
            }
          }
          function replayUnblockedEvents() {
            hasScheduledReplayAttempt = false;
            if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
              queuedFocus = null;
            }
            if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
              queuedDrag = null;
            }
            if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
              queuedMouse = null;
            }
            queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
            queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
          }
          function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
            if (queuedEvent.blockedOn === unblocked) {
              queuedEvent.blockedOn = null;
              if (!hasScheduledReplayAttempt) {
                hasScheduledReplayAttempt = true;
                Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
              }
            }
          }
          function retryIfBlockedOn(unblocked) {
            if (queuedDiscreteEvents.length > 0) {
              scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
              for (var i = 1; i < queuedDiscreteEvents.length; i++) {
                var queuedEvent = queuedDiscreteEvents[i];
                if (queuedEvent.blockedOn === unblocked) {
                  queuedEvent.blockedOn = null;
                }
              }
            }
            if (queuedFocus !== null) {
              scheduleCallbackIfUnblocked(queuedFocus, unblocked);
            }
            if (queuedDrag !== null) {
              scheduleCallbackIfUnblocked(queuedDrag, unblocked);
            }
            if (queuedMouse !== null) {
              scheduleCallbackIfUnblocked(queuedMouse, unblocked);
            }
            var unblock = function(queuedEvent2) {
              return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
            };
            queuedPointers.forEach(unblock);
            queuedPointerCaptures.forEach(unblock);
            for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
              var queuedTarget = queuedExplicitHydrationTargets[_i];
              if (queuedTarget.blockedOn === unblocked) {
                queuedTarget.blockedOn = null;
              }
            }
            while (queuedExplicitHydrationTargets.length > 0) {
              var nextExplicitTarget = queuedExplicitHydrationTargets[0];
              if (nextExplicitTarget.blockedOn !== null) {
                break;
              } else {
                attemptExplicitHydrationTarget(nextExplicitTarget);
                if (nextExplicitTarget.blockedOn === null) {
                  queuedExplicitHydrationTargets.shift();
                }
              }
            }
          }
          var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
          var _enabled = true;
          function setEnabled(enabled) {
            _enabled = !!enabled;
          }
          function isEnabled2() {
            return _enabled;
          }
          function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
            var eventPriority = getEventPriority(domEventName);
            var listenerWrapper;
            switch (eventPriority) {
              case DiscreteEventPriority:
                listenerWrapper = dispatchDiscreteEvent;
                break;
              case ContinuousEventPriority:
                listenerWrapper = dispatchContinuousEvent;
                break;
              case DefaultEventPriority:
              default:
                listenerWrapper = dispatchEvent;
                break;
            }
            return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
          }
          function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = null;
            try {
              setCurrentUpdatePriority(DiscreteEventPriority);
              dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig.transition = prevTransition;
            }
          }
          function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig.transition;
            ReactCurrentBatchConfig.transition = null;
            try {
              setCurrentUpdatePriority(ContinuousEventPriority);
              dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig.transition = prevTransition;
            }
          }
          function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            if (!_enabled) {
              return;
            }
            {
              dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);
            }
          }
          function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (blockedOn === null) {
              dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
              clearIfContinuousEvent(domEventName, nativeEvent);
              return;
            }
            if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
              nativeEvent.stopPropagation();
              return;
            }
            clearIfContinuousEvent(domEventName, nativeEvent);
            if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {
              while (blockedOn !== null) {
                var fiber = getInstanceFromNode(blockedOn);
                if (fiber !== null) {
                  attemptSynchronousHydration(fiber);
                }
                var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
                if (nextBlockedOn === null) {
                  dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
                }
                if (nextBlockedOn === blockedOn) {
                  break;
                }
                blockedOn = nextBlockedOn;
              }
              if (blockedOn !== null) {
                nativeEvent.stopPropagation();
              }
              return;
            }
            dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
          }
          var return_targetInst = null;
          function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
            return_targetInst = null;
            var nativeEventTarget = getEventTarget(nativeEvent);
            var targetInst = getClosestInstanceFromNode(nativeEventTarget);
            if (targetInst !== null) {
              var nearestMounted = getNearestMountedFiber(targetInst);
              if (nearestMounted === null) {
                targetInst = null;
              } else {
                var tag = nearestMounted.tag;
                if (tag === SuspenseComponent) {
                  var instance = getSuspenseInstanceFromFiber(nearestMounted);
                  if (instance !== null) {
                    return instance;
                  }
                  targetInst = null;
                } else if (tag === HostRoot) {
                  var root2 = nearestMounted.stateNode;
                  if (isRootDehydrated(root2)) {
                    return getContainerFromFiber(nearestMounted);
                  }
                  targetInst = null;
                } else if (nearestMounted !== targetInst) {
                  targetInst = null;
                }
              }
            }
            return_targetInst = targetInst;
            return null;
          }
          function getEventPriority(domEventName) {
            switch (domEventName) {
              case "cancel":
              case "click":
              case "close":
              case "contextmenu":
              case "copy":
              case "cut":
              case "auxclick":
              case "dblclick":
              case "dragend":
              case "dragstart":
              case "drop":
              case "focusin":
              case "focusout":
              case "input":
              case "invalid":
              case "keydown":
              case "keypress":
              case "keyup":
              case "mousedown":
              case "mouseup":
              case "paste":
              case "pause":
              case "play":
              case "pointercancel":
              case "pointerdown":
              case "pointerup":
              case "ratechange":
              case "reset":
              case "resize":
              case "seeked":
              case "submit":
              case "touchcancel":
              case "touchend":
              case "touchstart":
              case "volumechange":
              case "change":
              case "selectionchange":
              case "textInput":
              case "compositionstart":
              case "compositionend":
              case "compositionupdate":
              case "beforeblur":
              case "afterblur":
              case "beforeinput":
              case "blur":
              case "fullscreenchange":
              case "focus":
              case "hashchange":
              case "popstate":
              case "select":
              case "selectstart":
                return DiscreteEventPriority;
              case "drag":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "mousemove":
              case "mouseout":
              case "mouseover":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "scroll":
              case "toggle":
              case "touchmove":
              case "wheel":
              case "mouseenter":
              case "mouseleave":
              case "pointerenter":
              case "pointerleave":
                return ContinuousEventPriority;
              case "message": {
                var schedulerPriority = getCurrentPriorityLevel();
                switch (schedulerPriority) {
                  case ImmediatePriority:
                    return DiscreteEventPriority;
                  case UserBlockingPriority:
                    return ContinuousEventPriority;
                  case NormalPriority:
                  case LowPriority:
                    return DefaultEventPriority;
                  case IdlePriority:
                    return IdleEventPriority;
                  default:
                    return DefaultEventPriority;
                }
              }
              default:
                return DefaultEventPriority;
            }
          }
          function addEventBubbleListener(target5, eventType, listener) {
            target5.addEventListener(eventType, listener, false);
            return listener;
          }
          function addEventCaptureListener(target5, eventType, listener) {
            target5.addEventListener(eventType, listener, true);
            return listener;
          }
          function addEventCaptureListenerWithPassiveFlag(target5, eventType, listener, passive) {
            target5.addEventListener(eventType, listener, {
              capture: true,
              passive
            });
            return listener;
          }
          function addEventBubbleListenerWithPassiveFlag(target5, eventType, listener, passive) {
            target5.addEventListener(eventType, listener, {
              passive
            });
            return listener;
          }
          var root = null;
          var startText = null;
          var fallbackText = null;
          function initialize(nativeEventTarget) {
            root = nativeEventTarget;
            startText = getText();
            return true;
          }
          function reset2() {
            root = null;
            startText = null;
            fallbackText = null;
          }
          function getData() {
            if (fallbackText) {
              return fallbackText;
            }
            var start2;
            var startValue = startText;
            var startLength = startValue.length;
            var end;
            var endValue = getText();
            var endLength = endValue.length;
            for (start2 = 0; start2 < startLength; start2++) {
              if (startValue[start2] !== endValue[start2]) {
                break;
              }
            }
            var minEnd = startLength - start2;
            for (end = 1; end <= minEnd; end++) {
              if (startValue[startLength - end] !== endValue[endLength - end]) {
                break;
              }
            }
            var sliceTail = end > 1 ? 1 - end : void 0;
            fallbackText = endValue.slice(start2, sliceTail);
            return fallbackText;
          }
          function getText() {
            if ("value" in root) {
              return root.value;
            }
            return root.textContent;
          }
          function getEventCharCode(nativeEvent) {
            var charCode;
            var keyCode = nativeEvent.keyCode;
            if ("charCode" in nativeEvent) {
              charCode = nativeEvent.charCode;
              if (charCode === 0 && keyCode === 13) {
                charCode = 13;
              }
            } else {
              charCode = keyCode;
            }
            if (charCode === 10) {
              charCode = 13;
            }
            if (charCode >= 32 || charCode === 13) {
              return charCode;
            }
            return 0;
          }
          function functionThatReturnsTrue() {
            return true;
          }
          function functionThatReturnsFalse() {
            return false;
          }
          function createSyntheticEvent(Interface) {
            function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
              this._reactName = reactName;
              this._targetInst = targetInst;
              this.type = reactEventType;
              this.nativeEvent = nativeEvent;
              this.target = nativeEventTarget;
              this.currentTarget = null;
              for (var _propName in Interface) {
                if (!Interface.hasOwnProperty(_propName)) {
                  continue;
                }
                var normalize = Interface[_propName];
                if (normalize) {
                  this[_propName] = normalize(nativeEvent);
                } else {
                  this[_propName] = nativeEvent[_propName];
                }
              }
              var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
              if (defaultPrevented) {
                this.isDefaultPrevented = functionThatReturnsTrue;
              } else {
                this.isDefaultPrevented = functionThatReturnsFalse;
              }
              this.isPropagationStopped = functionThatReturnsFalse;
              return this;
            }
            assign2(SyntheticBaseEvent.prototype, {
              preventDefault: function() {
                this.defaultPrevented = true;
                var event = this.nativeEvent;
                if (!event) {
                  return;
                }
                if (event.preventDefault) {
                  event.preventDefault();
                } else if (typeof event.returnValue !== "unknown") {
                  event.returnValue = false;
                }
                this.isDefaultPrevented = functionThatReturnsTrue;
              },
              stopPropagation: function() {
                var event = this.nativeEvent;
                if (!event) {
                  return;
                }
                if (event.stopPropagation) {
                  event.stopPropagation();
                } else if (typeof event.cancelBubble !== "unknown") {
                  event.cancelBubble = true;
                }
                this.isPropagationStopped = functionThatReturnsTrue;
              },
              persist: function() {
              },
              isPersistent: functionThatReturnsTrue
            });
            return SyntheticBaseEvent;
          }
          var EventInterface = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function(event) {
              return event.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0
          };
          var SyntheticEvent = createSyntheticEvent(EventInterface);
          var UIEventInterface = assign2({}, EventInterface, {
            view: 0,
            detail: 0
          });
          var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
          var lastMovementX;
          var lastMovementY;
          var lastMouseEvent;
          function updateMouseMovementPolyfillState(event) {
            if (event !== lastMouseEvent) {
              if (lastMouseEvent && event.type === "mousemove") {
                lastMovementX = event.screenX - lastMouseEvent.screenX;
                lastMovementY = event.screenY - lastMouseEvent.screenY;
              } else {
                lastMovementX = 0;
                lastMovementY = 0;
              }
              lastMouseEvent = event;
            }
          }
          var MouseEventInterface = assign2({}, UIEventInterface, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: getEventModifierState,
            button: 0,
            buttons: 0,
            relatedTarget: function(event) {
              if (event.relatedTarget === void 0)
                return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
              return event.relatedTarget;
            },
            movementX: function(event) {
              if ("movementX" in event) {
                return event.movementX;
              }
              updateMouseMovementPolyfillState(event);
              return lastMovementX;
            },
            movementY: function(event) {
              if ("movementY" in event) {
                return event.movementY;
              }
              return lastMovementY;
            }
          });
          var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
          var DragEventInterface = assign2({}, MouseEventInterface, {
            dataTransfer: 0
          });
          var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
          var FocusEventInterface = assign2({}, UIEventInterface, {
            relatedTarget: 0
          });
          var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
          var AnimationEventInterface = assign2({}, EventInterface, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          });
          var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
          var ClipboardEventInterface = assign2({}, EventInterface, {
            clipboardData: function(event) {
              return "clipboardData" in event ? event.clipboardData : window.clipboardData;
            }
          });
          var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
          var CompositionEventInterface = assign2({}, EventInterface, {
            data: 0
          });
          var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
          var SyntheticInputEvent = SyntheticCompositionEvent;
          var normalizeKey = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
          };
          var translateToKey = {
            "8": "Backspace",
            "9": "Tab",
            "12": "Clear",
            "13": "Enter",
            "16": "Shift",
            "17": "Control",
            "18": "Alt",
            "19": "Pause",
            "20": "CapsLock",
            "27": "Escape",
            "32": " ",
            "33": "PageUp",
            "34": "PageDown",
            "35": "End",
            "36": "Home",
            "37": "ArrowLeft",
            "38": "ArrowUp",
            "39": "ArrowRight",
            "40": "ArrowDown",
            "45": "Insert",
            "46": "Delete",
            "112": "F1",
            "113": "F2",
            "114": "F3",
            "115": "F4",
            "116": "F5",
            "117": "F6",
            "118": "F7",
            "119": "F8",
            "120": "F9",
            "121": "F10",
            "122": "F11",
            "123": "F12",
            "144": "NumLock",
            "145": "ScrollLock",
            "224": "Meta"
          };
          function getEventKey(nativeEvent) {
            if (nativeEvent.key) {
              var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
              if (key !== "Unidentified") {
                return key;
              }
            }
            if (nativeEvent.type === "keypress") {
              var charCode = getEventCharCode(nativeEvent);
              return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
            }
            if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
              return translateToKey[nativeEvent.keyCode] || "Unidentified";
            }
            return "";
          }
          var modifierKeyToProp = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey"
          };
          function modifierStateGetter(keyArg) {
            var syntheticEvent = this;
            var nativeEvent = syntheticEvent.nativeEvent;
            if (nativeEvent.getModifierState) {
              return nativeEvent.getModifierState(keyArg);
            }
            var keyProp = modifierKeyToProp[keyArg];
            return keyProp ? !!nativeEvent[keyProp] : false;
          }
          function getEventModifierState(nativeEvent) {
            return modifierStateGetter;
          }
          var KeyboardEventInterface = assign2({}, UIEventInterface, {
            key: getEventKey,
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: getEventModifierState,
            charCode: function(event) {
              if (event.type === "keypress") {
                return getEventCharCode(event);
              }
              return 0;
            },
            keyCode: function(event) {
              if (event.type === "keydown" || event.type === "keyup") {
                return event.keyCode;
              }
              return 0;
            },
            which: function(event) {
              if (event.type === "keypress") {
                return getEventCharCode(event);
              }
              if (event.type === "keydown" || event.type === "keyup") {
                return event.keyCode;
              }
              return 0;
            }
          });
          var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
          var PointerEventInterface = assign2({}, MouseEventInterface, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
          });
          var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
          var TouchEventInterface = assign2({}, UIEventInterface, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: getEventModifierState
          });
          var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
          var TransitionEventInterface = assign2({}, EventInterface, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0
          });
          var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
          var WheelEventInterface = assign2({}, MouseEventInterface, {
            deltaX: function(event) {
              return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
            },
            deltaY: function(event) {
              return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
            },
            deltaZ: 0,
            deltaMode: 0
          });
          var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
          var END_KEYCODES = [9, 13, 27, 32];
          var START_KEYCODE = 229;
          var canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
          var documentMode = null;
          if (canUseDOM && "documentMode" in document) {
            documentMode = document.documentMode;
          }
          var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode;
          var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
          var SPACEBAR_CODE = 32;
          var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
          function registerEvents2() {
            registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
            registerTwoPhaseEvent("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
            registerTwoPhaseEvent("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
            registerTwoPhaseEvent("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
          }
          var hasSpaceKeypress = false;
          function isKeypressCommand(nativeEvent) {
            return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey);
          }
          function getCompositionEventType(domEventName) {
            switch (domEventName) {
              case "compositionstart":
                return "onCompositionStart";
              case "compositionend":
                return "onCompositionEnd";
              case "compositionupdate":
                return "onCompositionUpdate";
            }
          }
          function isFallbackCompositionStart(domEventName, nativeEvent) {
            return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
          }
          function isFallbackCompositionEnd(domEventName, nativeEvent) {
            switch (domEventName) {
              case "keyup":
                return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
              case "keydown":
                return nativeEvent.keyCode !== START_KEYCODE;
              case "keypress":
              case "mousedown":
              case "focusout":
                return true;
              default:
                return false;
            }
          }
          function getDataFromCustomEvent(nativeEvent) {
            var detail = nativeEvent.detail;
            if (typeof detail === "object" && "data" in detail) {
              return detail.data;
            }
            return null;
          }
          function isUsingKoreanIME(nativeEvent) {
            return nativeEvent.locale === "ko";
          }
          var isComposing = false;
          function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
            var eventType;
            var fallbackData;
            if (canUseCompositionEvent) {
              eventType = getCompositionEventType(domEventName);
            } else if (!isComposing) {
              if (isFallbackCompositionStart(domEventName, nativeEvent)) {
                eventType = "onCompositionStart";
              }
            } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
              eventType = "onCompositionEnd";
            }
            if (!eventType) {
              return null;
            }
            if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
              if (!isComposing && eventType === "onCompositionStart") {
                isComposing = initialize(nativeEventTarget);
              } else if (eventType === "onCompositionEnd") {
                if (isComposing) {
                  fallbackData = getData();
                }
              }
            }
            var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
            if (listeners.length > 0) {
              var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              if (fallbackData) {
                event.data = fallbackData;
              } else {
                var customData = getDataFromCustomEvent(nativeEvent);
                if (customData !== null) {
                  event.data = customData;
                }
              }
            }
          }
          function getNativeBeforeInputChars(domEventName, nativeEvent) {
            switch (domEventName) {
              case "compositionend":
                return getDataFromCustomEvent(nativeEvent);
              case "keypress":
                var which = nativeEvent.which;
                if (which !== SPACEBAR_CODE) {
                  return null;
                }
                hasSpaceKeypress = true;
                return SPACEBAR_CHAR;
              case "textInput":
                var chars = nativeEvent.data;
                if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
                  return null;
                }
                return chars;
              default:
                return null;
            }
          }
          function getFallbackBeforeInputChars(domEventName, nativeEvent) {
            if (isComposing) {
              if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
                var chars = getData();
                reset2();
                isComposing = false;
                return chars;
              }
              return null;
            }
            switch (domEventName) {
              case "paste":
                return null;
              case "keypress":
                if (!isKeypressCommand(nativeEvent)) {
                  if (nativeEvent.char && nativeEvent.char.length > 1) {
                    return nativeEvent.char;
                  } else if (nativeEvent.which) {
                    return String.fromCharCode(nativeEvent.which);
                  }
                }
                return null;
              case "compositionend":
                return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
              default:
                return null;
            }
          }
          function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
            var chars;
            if (canUseTextInputEvent) {
              chars = getNativeBeforeInputChars(domEventName, nativeEvent);
            } else {
              chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
            }
            if (!chars) {
              return null;
            }
            var listeners = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
            if (listeners.length > 0) {
              var event = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget);
              dispatchQueue.push({
                event,
                listeners
              });
              event.data = chars;
            }
          }
          function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          }
          var supportedInputTypes = {
            color: true,
            date: true,
            datetime: true,
            "datetime-local": true,
            email: true,
            month: true,
            number: true,
            password: true,
            range: true,
            search: true,
            tel: true,
            text: true,
            time: true,
            url: true,
            week: true
          };
          function isTextInputElement(elem3) {
            var nodeName = elem3 && elem3.nodeName && elem3.nodeName.toLowerCase();
            if (nodeName === "input") {
              return !!supportedInputTypes[elem3.type];
            }
            if (nodeName === "textarea") {
              return true;
            }
            return false;
          }
          function isEventSupported(eventNameSuffix) {
            if (!canUseDOM) {
              return false;
            }
            var eventName = "on" + eventNameSuffix;
            var isSupported = eventName in document;
            if (!isSupported) {
              var element = document.createElement("div");
              element.setAttribute(eventName, "return;");
              isSupported = typeof element[eventName] === "function";
            }
            return isSupported;
          }
          function registerEvents$1() {
            registerTwoPhaseEvent("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
          }
          function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target5) {
            enqueueStateRestore(target5);
            var listeners = accumulateTwoPhaseListeners(inst, "onChange");
            if (listeners.length > 0) {
              var event = new SyntheticEvent("onChange", "change", null, nativeEvent, target5);
              dispatchQueue.push({
                event,
                listeners
              });
            }
          }
          var activeElement = null;
          var activeElementInst = null;
          function shouldUseChangeEvent(elem3) {
            var nodeName = elem3.nodeName && elem3.nodeName.toLowerCase();
            return nodeName === "select" || nodeName === "input" && elem3.type === "file";
          }
          function manualDispatchChangeEvent(nativeEvent) {
            var dispatchQueue = [];
            createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
            batchedUpdates(runEventInBatch, dispatchQueue);
          }
          function runEventInBatch(dispatchQueue) {
            processDispatchQueue(dispatchQueue, 0);
          }
          function getInstIfValueChanged(targetInst) {
            var targetNode = getNodeFromInstance(targetInst);
            if (updateValueIfChanged(targetNode)) {
              return targetInst;
            }
          }
          function getTargetInstForChangeEvent(domEventName, targetInst) {
            if (domEventName === "change") {
              return targetInst;
            }
          }
          var isInputEventSupported = false;
          if (canUseDOM) {
            isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9);
          }
          function startWatchingForValueChange(target5, targetInst) {
            activeElement = target5;
            activeElementInst = targetInst;
            activeElement.attachEvent("onpropertychange", handlePropertyChange);
          }
          function stopWatchingForValueChange() {
            if (!activeElement) {
              return;
            }
            activeElement.detachEvent("onpropertychange", handlePropertyChange);
            activeElement = null;
            activeElementInst = null;
          }
          function handlePropertyChange(nativeEvent) {
            if (nativeEvent.propertyName !== "value") {
              return;
            }
            if (getInstIfValueChanged(activeElementInst)) {
              manualDispatchChangeEvent(nativeEvent);
            }
          }
          function handleEventsForInputEventPolyfill(domEventName, target5, targetInst) {
            if (domEventName === "focusin") {
              stopWatchingForValueChange();
              startWatchingForValueChange(target5, targetInst);
            } else if (domEventName === "focusout") {
              stopWatchingForValueChange();
            }
          }
          function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
            if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown") {
              return getInstIfValueChanged(activeElementInst);
            }
          }
          function shouldUseClickEvent(elem3) {
            var nodeName = elem3.nodeName;
            return nodeName && nodeName.toLowerCase() === "input" && (elem3.type === "checkbox" || elem3.type === "radio");
          }
          function getTargetInstForClickEvent(domEventName, targetInst) {
            if (domEventName === "click") {
              return getInstIfValueChanged(targetInst);
            }
          }
          function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
            if (domEventName === "input" || domEventName === "change") {
              return getInstIfValueChanged(targetInst);
            }
          }
          function handleControlledInputBlur(node) {
            var state3 = node._wrapperState;
            if (!state3 || !state3.controlled || node.type !== "number") {
              return;
            }
            {
              setDefaultValue4(node, "number", node.value);
            }
          }
          function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
            var getTargetInstFunc, handleEventFunc;
            if (shouldUseChangeEvent(targetNode)) {
              getTargetInstFunc = getTargetInstForChangeEvent;
            } else if (isTextInputElement(targetNode)) {
              if (isInputEventSupported) {
                getTargetInstFunc = getTargetInstForInputOrChangeEvent;
              } else {
                getTargetInstFunc = getTargetInstForInputEventPolyfill;
                handleEventFunc = handleEventsForInputEventPolyfill;
              }
            } else if (shouldUseClickEvent(targetNode)) {
              getTargetInstFunc = getTargetInstForClickEvent;
            }
            if (getTargetInstFunc) {
              var inst = getTargetInstFunc(domEventName, targetInst);
              if (inst) {
                createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
                return;
              }
            }
            if (handleEventFunc) {
              handleEventFunc(domEventName, targetNode, targetInst);
            }
            if (domEventName === "focusout") {
              handleControlledInputBlur(targetNode);
            }
          }
          function registerEvents$2() {
            registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
            registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
            registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
            registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
          }
          function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var isOverEvent = domEventName === "mouseover" || domEventName === "pointerover";
            var isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
            if (isOverEvent && !isReplayingEvent(nativeEvent)) {
              var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
              if (related) {
                if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
                  return;
                }
              }
            }
            if (!isOutEvent && !isOverEvent) {
              return;
            }
            var win;
            if (nativeEventTarget.window === nativeEventTarget) {
              win = nativeEventTarget;
            } else {
              var doc = nativeEventTarget.ownerDocument;
              if (doc) {
                win = doc.defaultView || doc.parentWindow;
              } else {
                win = window;
              }
            }
            var from3;
            var to;
            if (isOutEvent) {
              var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
              from3 = targetInst;
              to = _related ? getClosestInstanceFromNode(_related) : null;
              if (to !== null) {
                var nearestMounted = getNearestMountedFiber(to);
                if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {
                  to = null;
                }
              }
            } else {
              from3 = null;
              to = targetInst;
            }
            if (from3 === to) {
              return;
            }
            var SyntheticEventCtor = SyntheticMouseEvent;
            var leaveEventType = "onMouseLeave";
            var enterEventType = "onMouseEnter";
            var eventTypePrefix = "mouse";
            if (domEventName === "pointerout" || domEventName === "pointerover") {
              SyntheticEventCtor = SyntheticPointerEvent;
              leaveEventType = "onPointerLeave";
              enterEventType = "onPointerEnter";
              eventTypePrefix = "pointer";
            }
            var fromNode = from3 == null ? win : getNodeFromInstance(from3);
            var toNode = to == null ? win : getNodeFromInstance(to);
            var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + "leave", from3, nativeEvent, nativeEventTarget);
            leave.target = fromNode;
            leave.relatedTarget = toNode;
            var enter = null;
            var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
            if (nativeTargetInst === targetInst) {
              var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + "enter", to, nativeEvent, nativeEventTarget);
              enterEvent.target = toNode;
              enterEvent.relatedTarget = fromNode;
              enter = enterEvent;
            }
            accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from3, to);
          }
          function is(x, y) {
            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is;
          function shallowEqual(objA, objB) {
            if (objectIs(objA, objB)) {
              return true;
            }
            if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
              return false;
            }
            var keysA = Object.keys(objA);
            var keysB = Object.keys(objB);
            if (keysA.length !== keysB.length) {
              return false;
            }
            for (var i = 0; i < keysA.length; i++) {
              var currentKey = keysA[i];
              if (!hasOwnProperty3.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {
                return false;
              }
            }
            return true;
          }
          function getLeafNode(node) {
            while (node && node.firstChild) {
              node = node.firstChild;
            }
            return node;
          }
          function getSiblingNode(node) {
            while (node) {
              if (node.nextSibling) {
                return node.nextSibling;
              }
              node = node.parentNode;
            }
          }
          function getNodeForCharacterOffset(root2, offset) {
            var node = getLeafNode(root2);
            var nodeStart = 0;
            var nodeEnd = 0;
            while (node) {
              if (node.nodeType === TEXT_NODE) {
                nodeEnd = nodeStart + node.textContent.length;
                if (nodeStart <= offset && nodeEnd >= offset) {
                  return {
                    node,
                    offset: offset - nodeStart
                  };
                }
                nodeStart = nodeEnd;
              }
              node = getLeafNode(getSiblingNode(node));
            }
          }
          function getOffsets(outerNode) {
            var ownerDocument = outerNode.ownerDocument;
            var win = ownerDocument && ownerDocument.defaultView || window;
            var selection = win.getSelection && win.getSelection();
            if (!selection || selection.rangeCount === 0) {
              return null;
            }
            var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;
            try {
              anchorNode.nodeType;
              focusNode.nodeType;
            } catch (e) {
              return null;
            }
            return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
          }
          function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
            var length7 = 0;
            var start2 = -1;
            var end = -1;
            var indexWithinAnchor = 0;
            var indexWithinFocus = 0;
            var node = outerNode;
            var parentNode = null;
            outer:
              while (true) {
                var next = null;
                while (true) {
                  if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
                    start2 = length7 + anchorOffset;
                  }
                  if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
                    end = length7 + focusOffset;
                  }
                  if (node.nodeType === TEXT_NODE) {
                    length7 += node.nodeValue.length;
                  }
                  if ((next = node.firstChild) === null) {
                    break;
                  }
                  parentNode = node;
                  node = next;
                }
                while (true) {
                  if (node === outerNode) {
                    break outer;
                  }
                  if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
                    start2 = length7;
                  }
                  if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
                    end = length7;
                  }
                  if ((next = node.nextSibling) !== null) {
                    break;
                  }
                  node = parentNode;
                  parentNode = node.parentNode;
                }
                node = next;
              }
            if (start2 === -1 || end === -1) {
              return null;
            }
            return {
              start: start2,
              end
            };
          }
          function setOffsets(node, offsets) {
            var doc = node.ownerDocument || document;
            var win = doc && doc.defaultView || window;
            if (!win.getSelection) {
              return;
            }
            var selection = win.getSelection();
            var length7 = node.textContent.length;
            var start2 = Math.min(offsets.start, length7);
            var end = offsets.end === void 0 ? start2 : Math.min(offsets.end, length7);
            if (!selection.extend && start2 > end) {
              var temp = end;
              end = start2;
              start2 = temp;
            }
            var startMarker = getNodeForCharacterOffset(node, start2);
            var endMarker = getNodeForCharacterOffset(node, end);
            if (startMarker && endMarker) {
              if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
                return;
              }
              var range3 = doc.createRange();
              range3.setStart(startMarker.node, startMarker.offset);
              selection.removeAllRanges();
              if (start2 > end) {
                selection.addRange(range3);
                selection.extend(endMarker.node, endMarker.offset);
              } else {
                range3.setEnd(endMarker.node, endMarker.offset);
                selection.addRange(range3);
              }
            }
          }
          function isTextNode(node) {
            return node && node.nodeType === TEXT_NODE;
          }
          function containsNode(outerNode, innerNode) {
            if (!outerNode || !innerNode) {
              return false;
            } else if (outerNode === innerNode) {
              return true;
            } else if (isTextNode(outerNode)) {
              return false;
            } else if (isTextNode(innerNode)) {
              return containsNode(outerNode, innerNode.parentNode);
            } else if ("contains" in outerNode) {
              return outerNode.contains(innerNode);
            } else if (outerNode.compareDocumentPosition) {
              return !!(outerNode.compareDocumentPosition(innerNode) & 16);
            } else {
              return false;
            }
          }
          function isInDocument(node) {
            return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
          }
          function isSameOriginFrame(iframe) {
            try {
              return typeof iframe.contentWindow.location.href === "string";
            } catch (err) {
              return false;
            }
          }
          function getActiveElementDeep() {
            var win = window;
            var element = getActiveElement();
            while (element instanceof win.HTMLIFrameElement) {
              if (isSameOriginFrame(element)) {
                win = element.contentWindow;
              } else {
                return element;
              }
              element = getActiveElement(win.document);
            }
            return element;
          }
          function hasSelectionCapabilities(elem3) {
            var nodeName = elem3 && elem3.nodeName && elem3.nodeName.toLowerCase();
            return nodeName && (nodeName === "input" && (elem3.type === "text" || elem3.type === "search" || elem3.type === "tel" || elem3.type === "url" || elem3.type === "password") || nodeName === "textarea" || elem3.contentEditable === "true");
          }
          function getSelectionInformation() {
            var focusedElem = getActiveElementDeep();
            return {
              focusedElem,
              selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
            };
          }
          function restoreSelection(priorSelectionInformation) {
            var curFocusedElem = getActiveElementDeep();
            var priorFocusedElem = priorSelectionInformation.focusedElem;
            var priorSelectionRange = priorSelectionInformation.selectionRange;
            if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
              if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
                setSelection(priorFocusedElem, priorSelectionRange);
              }
              var ancestors = [];
              var ancestor = priorFocusedElem;
              while (ancestor = ancestor.parentNode) {
                if (ancestor.nodeType === ELEMENT_NODE) {
                  ancestors.push({
                    element: ancestor,
                    left: ancestor.scrollLeft,
                    top: ancestor.scrollTop
                  });
                }
              }
              if (typeof priorFocusedElem.focus === "function") {
                priorFocusedElem.focus();
              }
              for (var i = 0; i < ancestors.length; i++) {
                var info = ancestors[i];
                info.element.scrollLeft = info.left;
                info.element.scrollTop = info.top;
              }
            }
          }
          function getSelection(input) {
            var selection;
            if ("selectionStart" in input) {
              selection = {
                start: input.selectionStart,
                end: input.selectionEnd
              };
            } else {
              selection = getOffsets(input);
            }
            return selection || {
              start: 0,
              end: 0
            };
          }
          function setSelection(input, offsets) {
            var start2 = offsets.start;
            var end = offsets.end;
            if (end === void 0) {
              end = start2;
            }
            if ("selectionStart" in input) {
              input.selectionStart = start2;
              input.selectionEnd = Math.min(end, input.value.length);
            } else {
              setOffsets(input, offsets);
            }
          }
          var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && document.documentMode <= 11;
          function registerEvents$3() {
            registerTwoPhaseEvent("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
          }
          var activeElement$1 = null;
          var activeElementInst$1 = null;
          var lastSelection = null;
          var mouseDown = false;
          function getSelection$1(node) {
            if ("selectionStart" in node && hasSelectionCapabilities(node)) {
              return {
                start: node.selectionStart,
                end: node.selectionEnd
              };
            } else {
              var win = node.ownerDocument && node.ownerDocument.defaultView || window;
              var selection = win.getSelection();
              return {
                anchorNode: selection.anchorNode,
                anchorOffset: selection.anchorOffset,
                focusNode: selection.focusNode,
                focusOffset: selection.focusOffset
              };
            }
          }
          function getEventTargetDocument(eventTarget) {
            return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
          }
          function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
            var doc = getEventTargetDocument(nativeEventTarget);
            if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
              return;
            }
            var currentSelection = getSelection$1(activeElement$1);
            if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
              lastSelection = currentSelection;
              var listeners = accumulateTwoPhaseListeners(activeElementInst$1, "onSelect");
              if (listeners.length > 0) {
                var event = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                  event,
                  listeners
                });
                event.target = activeElement$1;
              }
            }
          }
          function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
            switch (domEventName) {
              case "focusin":
                if (isTextInputElement(targetNode) || targetNode.contentEditable === "true") {
                  activeElement$1 = targetNode;
                  activeElementInst$1 = targetInst;
                  lastSelection = null;
                }
                break;
              case "focusout":
                activeElement$1 = null;
                activeElementInst$1 = null;
                lastSelection = null;
                break;
              case "mousedown":
                mouseDown = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                mouseDown = false;
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                break;
              case "selectionchange":
                if (skipSelectionChangeEvent) {
                  break;
                }
              case "keydown":
              case "keyup":
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            }
          }
          function makePrefixMap(styleProp, eventName) {
            var prefixes2 = {};
            prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();
            prefixes2["Webkit" + styleProp] = "webkit" + eventName;
            prefixes2["Moz" + styleProp] = "moz" + eventName;
            return prefixes2;
          }
          var vendorPrefixes = {
            animationend: makePrefixMap("Animation", "AnimationEnd"),
            animationiteration: makePrefixMap("Animation", "AnimationIteration"),
            animationstart: makePrefixMap("Animation", "AnimationStart"),
            transitionend: makePrefixMap("Transition", "TransitionEnd")
          };
          var prefixedEventNames = {};
          var style = {};
          if (canUseDOM) {
            style = document.createElement("div").style;
            if (!("AnimationEvent" in window)) {
              delete vendorPrefixes.animationend.animation;
              delete vendorPrefixes.animationiteration.animation;
              delete vendorPrefixes.animationstart.animation;
            }
            if (!("TransitionEvent" in window)) {
              delete vendorPrefixes.transitionend.transition;
            }
          }
          function getVendorPrefixedEventName(eventName) {
            if (prefixedEventNames[eventName]) {
              return prefixedEventNames[eventName];
            } else if (!vendorPrefixes[eventName]) {
              return eventName;
            }
            var prefixMap = vendorPrefixes[eventName];
            for (var styleProp in prefixMap) {
              if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
                return prefixedEventNames[eventName] = prefixMap[styleProp];
              }
            }
            return eventName;
          }
          var ANIMATION_END = getVendorPrefixedEventName("animationend");
          var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
          var ANIMATION_START = getVendorPrefixedEventName("animationstart");
          var TRANSITION_END = getVendorPrefixedEventName("transitionend");
          var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
          var simpleEventPluginEvents = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
          function registerSimpleEvent(domEventName, reactName) {
            topLevelEventsToReactNames.set(domEventName, reactName);
            registerTwoPhaseEvent(reactName, [domEventName]);
          }
          function registerSimpleEvents() {
            for (var i = 0; i < simpleEventPluginEvents.length; i++) {
              var eventName = simpleEventPluginEvents[i];
              var domEventName = eventName.toLowerCase();
              var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);
              registerSimpleEvent(domEventName, "on" + capitalizedEvent);
            }
            registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
            registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
            registerSimpleEvent(ANIMATION_START, "onAnimationStart");
            registerSimpleEvent("dblclick", "onDoubleClick");
            registerSimpleEvent("focusin", "onFocus");
            registerSimpleEvent("focusout", "onBlur");
            registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
          }
          function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            var reactName = topLevelEventsToReactNames.get(domEventName);
            if (reactName === void 0) {
              return;
            }
            var SyntheticEventCtor = SyntheticEvent;
            var reactEventType = domEventName;
            switch (domEventName) {
              case "keypress":
                if (getEventCharCode(nativeEvent) === 0) {
                  return;
                }
              case "keydown":
              case "keyup":
                SyntheticEventCtor = SyntheticKeyboardEvent;
                break;
              case "focusin":
                reactEventType = "focus";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "focusout":
                reactEventType = "blur";
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "beforeblur":
              case "afterblur":
                SyntheticEventCtor = SyntheticFocusEvent;
                break;
              case "click":
                if (nativeEvent.button === 2) {
                  return;
                }
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                SyntheticEventCtor = SyntheticMouseEvent;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                SyntheticEventCtor = SyntheticDragEvent;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                SyntheticEventCtor = SyntheticTouchEvent;
                break;
              case ANIMATION_END:
              case ANIMATION_ITERATION:
              case ANIMATION_START:
                SyntheticEventCtor = SyntheticAnimationEvent;
                break;
              case TRANSITION_END:
                SyntheticEventCtor = SyntheticTransitionEvent;
                break;
              case "scroll":
                SyntheticEventCtor = SyntheticUIEvent;
                break;
              case "wheel":
                SyntheticEventCtor = SyntheticWheelEvent;
                break;
              case "copy":
              case "cut":
              case "paste":
                SyntheticEventCtor = SyntheticClipboardEvent;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                SyntheticEventCtor = SyntheticPointerEvent;
                break;
            }
            var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
            {
              var accumulateTargetOnly = !inCapturePhase && domEventName === "scroll";
              var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
              if (_listeners.length > 0) {
                var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
                dispatchQueue.push({
                  event: _event,
                  listeners: _listeners
                });
              }
            }
          }
          registerSimpleEvents();
          registerEvents$2();
          registerEvents$1();
          registerEvents$3();
          registerEvents2();
          function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
            extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
            if (shouldProcessPolyfillPlugins) {
              extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
              extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
            }
          }
          var mediaEventTypes = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"];
          var nonDelegatedEvents = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(mediaEventTypes));
          function executeDispatch(event, listener, currentTarget) {
            var type = event.type || "unknown-event";
            event.currentTarget = currentTarget;
            invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event);
            event.currentTarget = null;
          }
          function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
            var previousInstance;
            if (inCapturePhase) {
              for (var i = dispatchListeners.length - 1; i >= 0; i--) {
                var _dispatchListeners$i = dispatchListeners[i], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
                if (instance !== previousInstance && event.isPropagationStopped()) {
                  return;
                }
                executeDispatch(event, listener, currentTarget);
                previousInstance = instance;
              }
            } else {
              for (var _i = 0; _i < dispatchListeners.length; _i++) {
                var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
                if (_instance !== previousInstance && event.isPropagationStopped()) {
                  return;
                }
                executeDispatch(event, _listener, _currentTarget);
                previousInstance = _instance;
              }
            }
          }
          function processDispatchQueue(dispatchQueue, eventSystemFlags) {
            var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
            for (var i = 0; i < dispatchQueue.length; i++) {
              var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
              processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
            }
            rethrowCaughtError();
          }
          function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
            var nativeEventTarget = getEventTarget(nativeEvent);
            var dispatchQueue = [];
            extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
            processDispatchQueue(dispatchQueue, eventSystemFlags);
          }
          function listenToNonDelegatedEvent(domEventName, targetElement) {
            {
              if (!nonDelegatedEvents.has(domEventName)) {
                error3('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
              }
            }
            var isCapturePhaseListener = false;
            var listenerSet = getEventListenerSet(targetElement);
            var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
            if (!listenerSet.has(listenerSetKey)) {
              addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
              listenerSet.add(listenerSetKey);
            }
          }
          function listenToNativeEvent(domEventName, isCapturePhaseListener, target5) {
            {
              if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {
                error3('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
              }
            }
            var eventSystemFlags = 0;
            if (isCapturePhaseListener) {
              eventSystemFlags |= IS_CAPTURE_PHASE;
            }
            addTrappedEventListener(target5, domEventName, eventSystemFlags, isCapturePhaseListener);
          }
          var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
          function listenToAllSupportedEvents(rootContainerElement) {
            if (!rootContainerElement[listeningMarker]) {
              rootContainerElement[listeningMarker] = true;
              allNativeEvents.forEach(function(domEventName) {
                if (domEventName !== "selectionchange") {
                  if (!nonDelegatedEvents.has(domEventName)) {
                    listenToNativeEvent(domEventName, false, rootContainerElement);
                  }
                  listenToNativeEvent(domEventName, true, rootContainerElement);
                }
              });
              var ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
              if (ownerDocument !== null) {
                if (!ownerDocument[listeningMarker]) {
                  ownerDocument[listeningMarker] = true;
                  listenToNativeEvent("selectionchange", false, ownerDocument);
                }
              }
            }
          }
          function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
            var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
            var isPassiveListener = void 0;
            if (passiveBrowserEventsSupported) {
              if (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") {
                isPassiveListener = true;
              }
            }
            targetContainer = targetContainer;
            var unsubscribeListener;
            if (isCapturePhaseListener) {
              if (isPassiveListener !== void 0) {
                unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
              } else {
                unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
              }
            } else {
              if (isPassiveListener !== void 0) {
                unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
              } else {
                unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
              }
            }
          }
          function isMatchingRootContainer(grandContainer, targetContainer) {
            return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
          }
          function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
            var ancestorInst = targetInst;
            if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
              var targetContainerNode = targetContainer;
              if (targetInst !== null) {
                var node = targetInst;
                mainLoop:
                  while (true) {
                    if (node === null) {
                      return;
                    }
                    var nodeTag = node.tag;
                    if (nodeTag === HostRoot || nodeTag === HostPortal) {
                      var container = node.stateNode.containerInfo;
                      if (isMatchingRootContainer(container, targetContainerNode)) {
                        break;
                      }
                      if (nodeTag === HostPortal) {
                        var grandNode = node.return;
                        while (grandNode !== null) {
                          var grandTag = grandNode.tag;
                          if (grandTag === HostRoot || grandTag === HostPortal) {
                            var grandContainer = grandNode.stateNode.containerInfo;
                            if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                              return;
                            }
                          }
                          grandNode = grandNode.return;
                        }
                      }
                      while (container !== null) {
                        var parentNode = getClosestInstanceFromNode(container);
                        if (parentNode === null) {
                          return;
                        }
                        var parentTag = parentNode.tag;
                        if (parentTag === HostComponent || parentTag === HostText) {
                          node = ancestorInst = parentNode;
                          continue mainLoop;
                        }
                        container = container.parentNode;
                      }
                    }
                    node = node.return;
                  }
              }
            }
            batchedUpdates(function() {
              return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
            });
          }
          function createDispatchListener(instance, listener, currentTarget) {
            return {
              instance,
              listener,
              currentTarget
            };
          }
          function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {
            var captureName = reactName !== null ? reactName + "Capture" : null;
            var reactEventName = inCapturePhase ? captureName : reactName;
            var listeners = [];
            var instance = targetFiber;
            var lastHostComponent = null;
            while (instance !== null) {
              var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;
              if (tag === HostComponent && stateNode !== null) {
                lastHostComponent = stateNode;
                if (reactEventName !== null) {
                  var listener = getListener(instance, reactEventName);
                  if (listener != null) {
                    listeners.push(createDispatchListener(instance, listener, lastHostComponent));
                  }
                }
              }
              if (accumulateTargetOnly) {
                break;
              }
              instance = instance.return;
            }
            return listeners;
          }
          function accumulateTwoPhaseListeners(targetFiber, reactName) {
            var captureName = reactName + "Capture";
            var listeners = [];
            var instance = targetFiber;
            while (instance !== null) {
              var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;
              if (tag === HostComponent && stateNode !== null) {
                var currentTarget = stateNode;
                var captureListener = getListener(instance, captureName);
                if (captureListener != null) {
                  listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                }
                var bubbleListener = getListener(instance, reactName);
                if (bubbleListener != null) {
                  listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                }
              }
              instance = instance.return;
            }
            return listeners;
          }
          function getParent(inst) {
            if (inst === null) {
              return null;
            }
            do {
              inst = inst.return;
            } while (inst && inst.tag !== HostComponent);
            if (inst) {
              return inst;
            }
            return null;
          }
          function getLowestCommonAncestor(instA, instB) {
            var nodeA = instA;
            var nodeB = instB;
            var depthA = 0;
            for (var tempA = nodeA; tempA; tempA = getParent(tempA)) {
              depthA++;
            }
            var depthB = 0;
            for (var tempB = nodeB; tempB; tempB = getParent(tempB)) {
              depthB++;
            }
            while (depthA - depthB > 0) {
              nodeA = getParent(nodeA);
              depthA--;
            }
            while (depthB - depthA > 0) {
              nodeB = getParent(nodeB);
              depthB--;
            }
            var depth = depthA;
            while (depth--) {
              if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
                return nodeA;
              }
              nodeA = getParent(nodeA);
              nodeB = getParent(nodeB);
            }
            return null;
          }
          function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target5, common, inCapturePhase) {
            var registrationName = event._reactName;
            var listeners = [];
            var instance = target5;
            while (instance !== null) {
              if (instance === common) {
                break;
              }
              var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
              if (alternate !== null && alternate === common) {
                break;
              }
              if (tag === HostComponent && stateNode !== null) {
                var currentTarget = stateNode;
                if (inCapturePhase) {
                  var captureListener = getListener(instance, registrationName);
                  if (captureListener != null) {
                    listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
                  }
                } else if (!inCapturePhase) {
                  var bubbleListener = getListener(instance, registrationName);
                  if (bubbleListener != null) {
                    listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
                  }
                }
              }
              instance = instance.return;
            }
            if (listeners.length !== 0) {
              dispatchQueue.push({
                event,
                listeners
              });
            }
          }
          function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from3, to) {
            var common = from3 && to ? getLowestCommonAncestor(from3, to) : null;
            if (from3 !== null) {
              accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from3, common, false);
            }
            if (to !== null && enterEvent !== null) {
              accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);
            }
          }
          function getListenerSetKey(domEventName, capture) {
            return domEventName + "__" + (capture ? "capture" : "bubble");
          }
          var didWarnInvalidHydration = false;
          var DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML";
          var SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning";
          var SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning";
          var AUTOFOCUS = "autoFocus";
          var CHILDREN = "children";
          var STYLE = "style";
          var HTML$1 = "__html";
          var warnedUnknownTags;
          var validatePropertiesInDevelopment;
          var warnForPropDifference;
          var warnForExtraAttributes;
          var warnForInvalidEventListener;
          var canDiffStyleForHydrationWarning;
          var normalizeHTML;
          {
            warnedUnknownTags = {
              dialog: true,
              webview: true
            };
            validatePropertiesInDevelopment = function(type, props) {
              validateProperties(type, props);
              validateProperties$1(type, props);
              validateProperties$2(type, props, {
                registrationNameDependencies,
                possibleRegistrationNames
              });
            };
            canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;
            warnForPropDifference = function(propName, serverValue, clientValue) {
              if (didWarnInvalidHydration) {
                return;
              }
              var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
              var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
              if (normalizedServerValue === normalizedClientValue) {
                return;
              }
              didWarnInvalidHydration = true;
              error3("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
            };
            warnForExtraAttributes = function(attributeNames) {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              var names = [];
              attributeNames.forEach(function(name16) {
                names.push(name16);
              });
              error3("Extra attributes from the server: %s", names);
            };
            warnForInvalidEventListener = function(registrationName, listener) {
              if (listener === false) {
                error3("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
              } else {
                error3("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
              }
            };
            normalizeHTML = function(parent2, html) {
              var testElement = parent2.namespaceURI === HTML_NAMESPACE ? parent2.ownerDocument.createElement(parent2.tagName) : parent2.ownerDocument.createElementNS(parent2.namespaceURI, parent2.tagName);
              testElement.innerHTML = html;
              return testElement.innerHTML;
            };
          }
          var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
          var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
          function normalizeMarkupForTextOrAttribute(markup) {
            {
              checkHtmlStringCoercion(markup);
            }
            var markupString = typeof markup === "string" ? markup : "" + markup;
            return markupString.replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
          }
          function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {
            var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
            var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
            if (normalizedServerText === normalizedClientText) {
              return;
            }
            if (shouldWarnDev) {
              {
                if (!didWarnInvalidHydration) {
                  didWarnInvalidHydration = true;
                  error3('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
                }
              }
            }
            if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
              throw new Error("Text content does not match server-rendered HTML.");
            }
          }
          function getOwnerDocumentFromRootContainer(rootContainerElement) {
            return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
          }
          function noop13() {
          }
          function trapClickOnNonInteractiveElement(node) {
            node.onclick = noop13;
          }
          function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
            for (var propKey in nextProps) {
              if (!nextProps.hasOwnProperty(propKey)) {
                continue;
              }
              var nextProp = nextProps[propKey];
              if (propKey === STYLE) {
                {
                  if (nextProp) {
                    Object.freeze(nextProp);
                  }
                }
                setValueForStyles(domElement, nextProp);
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  setInnerHTML(domElement, nextHtml);
                }
              } else if (propKey === CHILDREN) {
                if (typeof nextProp === "string") {
                  var canSetTextContent = tag !== "textarea" || nextProp !== "";
                  if (canSetTextContent) {
                    setTextContent(domElement, nextProp);
                  }
                } else if (typeof nextProp === "number") {
                  setTextContent(domElement, "" + nextProp);
                }
              } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (propKey === AUTOFOCUS)
                ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
              } else if (nextProp != null) {
                setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
              }
            }
          }
          function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
            for (var i = 0; i < updatePayload.length; i += 2) {
              var propKey = updatePayload[i];
              var propValue = updatePayload[i + 1];
              if (propKey === STYLE) {
                setValueForStyles(domElement, propValue);
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                setInnerHTML(domElement, propValue);
              } else if (propKey === CHILDREN) {
                setTextContent(domElement, propValue);
              } else {
                setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
              }
            }
          }
          function createElement21(type, props, rootContainerElement, parentNamespace) {
            var isCustomComponentTag;
            var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
            var domElement;
            var namespaceURI = parentNamespace;
            if (namespaceURI === HTML_NAMESPACE) {
              namespaceURI = getIntrinsicNamespace(type);
            }
            if (namespaceURI === HTML_NAMESPACE) {
              {
                isCustomComponentTag = isCustomComponent(type, props);
                if (!isCustomComponentTag && type !== type.toLowerCase()) {
                  error3("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
                }
              }
              if (type === "script") {
                var div2 = ownerDocument.createElement("div");
                div2.innerHTML = "<script><\/script>";
                var firstChild = div2.firstChild;
                domElement = div2.removeChild(firstChild);
              } else if (typeof props.is === "string") {
                domElement = ownerDocument.createElement(type, {
                  is: props.is
                });
              } else {
                domElement = ownerDocument.createElement(type);
                if (type === "select") {
                  var node = domElement;
                  if (props.multiple) {
                    node.multiple = true;
                  } else if (props.size) {
                    node.size = props.size;
                  }
                }
              }
            } else {
              domElement = ownerDocument.createElementNS(namespaceURI, type);
            }
            {
              if (namespaceURI === HTML_NAMESPACE) {
                if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !hasOwnProperty3.call(warnedUnknownTags, type)) {
                  warnedUnknownTags[type] = true;
                  error3("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type);
                }
              }
            }
            return domElement;
          }
          function createTextNode(text5, rootContainerElement) {
            return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text5);
          }
          function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
            var isCustomComponentTag = isCustomComponent(tag, rawProps);
            {
              validatePropertiesInDevelopment(tag, rawProps);
            }
            var props;
            switch (tag) {
              case "dialog":
                listenToNonDelegatedEvent("cancel", domElement);
                listenToNonDelegatedEvent("close", domElement);
                props = rawProps;
                break;
              case "iframe":
              case "object":
              case "embed":
                listenToNonDelegatedEvent("load", domElement);
                props = rawProps;
                break;
              case "video":
              case "audio":
                for (var i = 0; i < mediaEventTypes.length; i++) {
                  listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
                }
                props = rawProps;
                break;
              case "source":
                listenToNonDelegatedEvent("error", domElement);
                props = rawProps;
                break;
              case "img":
              case "image":
              case "link":
                listenToNonDelegatedEvent("error", domElement);
                listenToNonDelegatedEvent("load", domElement);
                props = rawProps;
                break;
              case "details":
                listenToNonDelegatedEvent("toggle", domElement);
                props = rawProps;
                break;
              case "input":
                initWrapperState(domElement, rawProps);
                props = getHostProps(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "option":
                validateProps2(domElement, rawProps);
                props = rawProps;
                break;
              case "select":
                initWrapperState$1(domElement, rawProps);
                props = getHostProps$1(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "textarea":
                initWrapperState$2(domElement, rawProps);
                props = getHostProps$2(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              default:
                props = rawProps;
            }
            assertValidProps(tag, props);
            setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
            switch (tag) {
              case "input":
                track(domElement);
                postMountWrapper(domElement, rawProps, false);
                break;
              case "textarea":
                track(domElement);
                postMountWrapper$3(domElement);
                break;
              case "option":
                postMountWrapper$1(domElement, rawProps);
                break;
              case "select":
                postMountWrapper$2(domElement, rawProps);
                break;
              default:
                if (typeof props.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
          }
          function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
            {
              validatePropertiesInDevelopment(tag, nextRawProps);
            }
            var updatePayload = null;
            var lastProps;
            var nextProps;
            switch (tag) {
              case "input":
                lastProps = getHostProps(domElement, lastRawProps);
                nextProps = getHostProps(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "select":
                lastProps = getHostProps$1(domElement, lastRawProps);
                nextProps = getHostProps$1(domElement, nextRawProps);
                updatePayload = [];
                break;
              case "textarea":
                lastProps = getHostProps$2(domElement, lastRawProps);
                nextProps = getHostProps$2(domElement, nextRawProps);
                updatePayload = [];
                break;
              default:
                lastProps = lastRawProps;
                nextProps = nextRawProps;
                if (typeof lastProps.onClick !== "function" && typeof nextProps.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
            assertValidProps(tag, nextProps);
            var propKey;
            var styleName;
            var styleUpdates = null;
            for (propKey in lastProps) {
              if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
                continue;
              }
              if (propKey === STYLE) {
                var lastStyle = lastProps[propKey];
                for (styleName in lastStyle) {
                  if (lastStyle.hasOwnProperty(styleName)) {
                    if (!styleUpdates) {
                      styleUpdates = {};
                    }
                    styleUpdates[styleName] = "";
                  }
                }
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN)
                ;
              else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (propKey === AUTOFOCUS)
                ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (!updatePayload) {
                  updatePayload = [];
                }
              } else {
                (updatePayload = updatePayload || []).push(propKey, null);
              }
            }
            for (propKey in nextProps) {
              var nextProp = nextProps[propKey];
              var lastProp = lastProps != null ? lastProps[propKey] : void 0;
              if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
                continue;
              }
              if (propKey === STYLE) {
                {
                  if (nextProp) {
                    Object.freeze(nextProp);
                  }
                }
                if (lastProp) {
                  for (styleName in lastProp) {
                    if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                      if (!styleUpdates) {
                        styleUpdates = {};
                      }
                      styleUpdates[styleName] = "";
                    }
                  }
                  for (styleName in nextProp) {
                    if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                      if (!styleUpdates) {
                        styleUpdates = {};
                      }
                      styleUpdates[styleName] = nextProp[styleName];
                    }
                  }
                } else {
                  if (!styleUpdates) {
                    if (!updatePayload) {
                      updatePayload = [];
                    }
                    updatePayload.push(propKey, styleUpdates);
                  }
                  styleUpdates = nextProp;
                }
              } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                var lastHtml = lastProp ? lastProp[HTML$1] : void 0;
                if (nextHtml != null) {
                  if (lastHtml !== nextHtml) {
                    (updatePayload = updatePayload || []).push(propKey, nextHtml);
                  }
                }
              } else if (propKey === CHILDREN) {
                if (typeof nextProp === "string" || typeof nextProp === "number") {
                  (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
                }
              } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
                ;
              else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
                if (!updatePayload && lastProp !== nextProp) {
                  updatePayload = [];
                }
              } else {
                (updatePayload = updatePayload || []).push(propKey, nextProp);
              }
            }
            if (styleUpdates) {
              {
                validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
              }
              (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
            }
            return updatePayload;
          }
          function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
            if (tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null) {
              updateChecked(domElement, nextRawProps);
            }
            var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
            var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
            updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
            switch (tag) {
              case "input":
                updateWrapper(domElement, nextRawProps);
                break;
              case "textarea":
                updateWrapper$1(domElement, nextRawProps);
                break;
              case "select":
                postUpdateWrapper(domElement, nextRawProps);
                break;
            }
          }
          function getPossibleStandardName(propName) {
            {
              var lowerCasedName = propName.toLowerCase();
              if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                return null;
              }
              return possibleStandardNames[lowerCasedName] || null;
            }
          }
          function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement, isConcurrentMode, shouldWarnDev) {
            var isCustomComponentTag;
            var extraAttributeNames;
            {
              isCustomComponentTag = isCustomComponent(tag, rawProps);
              validatePropertiesInDevelopment(tag, rawProps);
            }
            switch (tag) {
              case "dialog":
                listenToNonDelegatedEvent("cancel", domElement);
                listenToNonDelegatedEvent("close", domElement);
                break;
              case "iframe":
              case "object":
              case "embed":
                listenToNonDelegatedEvent("load", domElement);
                break;
              case "video":
              case "audio":
                for (var i = 0; i < mediaEventTypes.length; i++) {
                  listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
                }
                break;
              case "source":
                listenToNonDelegatedEvent("error", domElement);
                break;
              case "img":
              case "image":
              case "link":
                listenToNonDelegatedEvent("error", domElement);
                listenToNonDelegatedEvent("load", domElement);
                break;
              case "details":
                listenToNonDelegatedEvent("toggle", domElement);
                break;
              case "input":
                initWrapperState(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "option":
                validateProps2(domElement, rawProps);
                break;
              case "select":
                initWrapperState$1(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
              case "textarea":
                initWrapperState$2(domElement, rawProps);
                listenToNonDelegatedEvent("invalid", domElement);
                break;
            }
            assertValidProps(tag, rawProps);
            {
              extraAttributeNames = /* @__PURE__ */ new Set();
              var attributes = domElement.attributes;
              for (var _i = 0; _i < attributes.length; _i++) {
                var name16 = attributes[_i].name.toLowerCase();
                switch (name16) {
                  case "value":
                    break;
                  case "checked":
                    break;
                  case "selected":
                    break;
                  default:
                    extraAttributeNames.add(attributes[_i].name);
                }
              }
            }
            var updatePayload = null;
            for (var propKey in rawProps) {
              if (!rawProps.hasOwnProperty(propKey)) {
                continue;
              }
              var nextProp = rawProps[propKey];
              if (propKey === CHILDREN) {
                if (typeof nextProp === "string") {
                  if (domElement.textContent !== nextProp) {
                    if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                      checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                    }
                    updatePayload = [CHILDREN, nextProp];
                  }
                } else if (typeof nextProp === "number") {
                  if (domElement.textContent !== "" + nextProp) {
                    if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                      checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                    }
                    updatePayload = [CHILDREN, "" + nextProp];
                  }
                }
              } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
                if (nextProp != null) {
                  if (typeof nextProp !== "function") {
                    warnForInvalidEventListener(propKey, nextProp);
                  }
                  if (propKey === "onScroll") {
                    listenToNonDelegatedEvent("scroll", domElement);
                  }
                }
              } else if (shouldWarnDev && true && typeof isCustomComponentTag === "boolean") {
                var serverValue = void 0;
                var propertyInfo = isCustomComponentTag && enableCustomElementPropertySupport ? null : getPropertyInfo(propKey);
                if (rawProps[SUPPRESS_HYDRATION_WARNING] === true)
                  ;
                else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || propKey === "value" || propKey === "checked" || propKey === "selected")
                  ;
                else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                  var serverHTML = domElement.innerHTML;
                  var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                  if (nextHtml != null) {
                    var expectedHTML = normalizeHTML(domElement, nextHtml);
                    if (expectedHTML !== serverHTML) {
                      warnForPropDifference(propKey, serverHTML, expectedHTML);
                    }
                  }
                } else if (propKey === STYLE) {
                  extraAttributeNames.delete(propKey);
                  if (canDiffStyleForHydrationWarning) {
                    var expectedStyle = createDangerousStringForStyles(nextProp);
                    serverValue = domElement.getAttribute("style");
                    if (expectedStyle !== serverValue) {
                      warnForPropDifference(propKey, serverValue, expectedStyle);
                    }
                  }
                } else if (isCustomComponentTag && !enableCustomElementPropertySupport) {
                  extraAttributeNames.delete(propKey.toLowerCase());
                  serverValue = getValueForAttribute(domElement, propKey, nextProp);
                  if (nextProp !== serverValue) {
                    warnForPropDifference(propKey, serverValue, nextProp);
                  }
                } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
                  var isMismatchDueToBadCasing = false;
                  if (propertyInfo !== null) {
                    extraAttributeNames.delete(propertyInfo.attributeName);
                    serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
                  } else {
                    var ownNamespace = parentNamespace;
                    if (ownNamespace === HTML_NAMESPACE) {
                      ownNamespace = getIntrinsicNamespace(tag);
                    }
                    if (ownNamespace === HTML_NAMESPACE) {
                      extraAttributeNames.delete(propKey.toLowerCase());
                    } else {
                      var standardName = getPossibleStandardName(propKey);
                      if (standardName !== null && standardName !== propKey) {
                        isMismatchDueToBadCasing = true;
                        extraAttributeNames.delete(standardName);
                      }
                      extraAttributeNames.delete(propKey);
                    }
                    serverValue = getValueForAttribute(domElement, propKey, nextProp);
                  }
                  var dontWarnCustomElement = enableCustomElementPropertySupport;
                  if (!dontWarnCustomElement && nextProp !== serverValue && !isMismatchDueToBadCasing) {
                    warnForPropDifference(propKey, serverValue, nextProp);
                  }
                }
              }
            }
            {
              if (shouldWarnDev) {
                if (extraAttributeNames.size > 0 && rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                  warnForExtraAttributes(extraAttributeNames);
                }
              }
            }
            switch (tag) {
              case "input":
                track(domElement);
                postMountWrapper(domElement, rawProps, true);
                break;
              case "textarea":
                track(domElement);
                postMountWrapper$3(domElement);
                break;
              case "select":
              case "option":
                break;
              default:
                if (typeof rawProps.onClick === "function") {
                  trapClickOnNonInteractiveElement(domElement);
                }
                break;
            }
            return updatePayload;
          }
          function diffHydratedText(textNode, text5, isConcurrentMode) {
            var isDifferent = textNode.nodeValue !== text5;
            return isDifferent;
          }
          function warnForDeletedHydratableElement(parentNode, child) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error3("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
            }
          }
          function warnForDeletedHydratableText(parentNode, child) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error3('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
            }
          }
          function warnForInsertedHydratedElement(parentNode, tag, props) {
            {
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error3("Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
            }
          }
          function warnForInsertedHydratedText(parentNode, text5) {
            {
              if (text5 === "") {
                return;
              }
              if (didWarnInvalidHydration) {
                return;
              }
              didWarnInvalidHydration = true;
              error3('Expected server HTML to contain a matching text node for "%s" in <%s>.', text5, parentNode.nodeName.toLowerCase());
            }
          }
          function restoreControlledState$3(domElement, tag, props) {
            switch (tag) {
              case "input":
                restoreControlledState(domElement, props);
                return;
              case "textarea":
                restoreControlledState$2(domElement, props);
                return;
              case "select":
                restoreControlledState$1(domElement, props);
                return;
            }
          }
          var validateDOMNesting = function() {
          };
          var updatedAncestorInfo = function() {
          };
          {
            var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"];
            var inScopeTags = [
              "applet",
              "caption",
              "html",
              "table",
              "td",
              "th",
              "marquee",
              "object",
              "template",
              "foreignObject",
              "desc",
              "title"
            ];
            var buttonScopeTags = inScopeTags.concat(["button"]);
            var impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
            var emptyAncestorInfo = {
              current: null,
              formTag: null,
              aTagInScope: null,
              buttonTagInScope: null,
              nobrTagInScope: null,
              pTagInButtonScope: null,
              listItemTagAutoclosing: null,
              dlItemTagAutoclosing: null
            };
            updatedAncestorInfo = function(oldInfo, tag) {
              var ancestorInfo = assign2({}, oldInfo || emptyAncestorInfo);
              var info = {
                tag
              };
              if (inScopeTags.indexOf(tag) !== -1) {
                ancestorInfo.aTagInScope = null;
                ancestorInfo.buttonTagInScope = null;
                ancestorInfo.nobrTagInScope = null;
              }
              if (buttonScopeTags.indexOf(tag) !== -1) {
                ancestorInfo.pTagInButtonScope = null;
              }
              if (specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p") {
                ancestorInfo.listItemTagAutoclosing = null;
                ancestorInfo.dlItemTagAutoclosing = null;
              }
              ancestorInfo.current = info;
              if (tag === "form") {
                ancestorInfo.formTag = info;
              }
              if (tag === "a") {
                ancestorInfo.aTagInScope = info;
              }
              if (tag === "button") {
                ancestorInfo.buttonTagInScope = info;
              }
              if (tag === "nobr") {
                ancestorInfo.nobrTagInScope = info;
              }
              if (tag === "p") {
                ancestorInfo.pTagInButtonScope = info;
              }
              if (tag === "li") {
                ancestorInfo.listItemTagAutoclosing = info;
              }
              if (tag === "dd" || tag === "dt") {
                ancestorInfo.dlItemTagAutoclosing = info;
              }
              return ancestorInfo;
            };
            var isTagValidWithParent = function(tag, parentTag) {
              switch (parentTag) {
                case "select":
                  return tag === "option" || tag === "optgroup" || tag === "#text";
                case "optgroup":
                  return tag === "option" || tag === "#text";
                case "option":
                  return tag === "#text";
                case "tr":
                  return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
                case "tbody":
                case "thead":
                case "tfoot":
                  return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
                case "colgroup":
                  return tag === "col" || tag === "template";
                case "table":
                  return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
                case "head":
                  return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
                case "html":
                  return tag === "head" || tag === "body" || tag === "frameset";
                case "frameset":
                  return tag === "frame";
                case "#document":
                  return tag === "html";
              }
              switch (tag) {
                case "h1":
                case "h2":
                case "h3":
                case "h4":
                case "h5":
                case "h6":
                  return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
                case "rp":
                case "rt":
                  return impliedEndTags.indexOf(parentTag) === -1;
                case "body":
                case "caption":
                case "col":
                case "colgroup":
                case "frameset":
                case "frame":
                case "head":
                case "html":
                case "tbody":
                case "td":
                case "tfoot":
                case "th":
                case "thead":
                case "tr":
                  return parentTag == null;
              }
              return true;
            };
            var findInvalidAncestorForTag = function(tag, ancestorInfo) {
              switch (tag) {
                case "address":
                case "article":
                case "aside":
                case "blockquote":
                case "center":
                case "details":
                case "dialog":
                case "dir":
                case "div":
                case "dl":
                case "fieldset":
                case "figcaption":
                case "figure":
                case "footer":
                case "header":
                case "hgroup":
                case "main":
                case "menu":
                case "nav":
                case "ol":
                case "p":
                case "section":
                case "summary":
                case "ul":
                case "pre":
                case "listing":
                case "table":
                case "hr":
                case "xmp":
                case "h1":
                case "h2":
                case "h3":
                case "h4":
                case "h5":
                case "h6":
                  return ancestorInfo.pTagInButtonScope;
                case "form":
                  return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
                case "li":
                  return ancestorInfo.listItemTagAutoclosing;
                case "dd":
                case "dt":
                  return ancestorInfo.dlItemTagAutoclosing;
                case "button":
                  return ancestorInfo.buttonTagInScope;
                case "a":
                  return ancestorInfo.aTagInScope;
                case "nobr":
                  return ancestorInfo.nobrTagInScope;
              }
              return null;
            };
            var didWarn$1 = {};
            validateDOMNesting = function(childTag, childText, ancestorInfo) {
              ancestorInfo = ancestorInfo || emptyAncestorInfo;
              var parentInfo = ancestorInfo.current;
              var parentTag = parentInfo && parentInfo.tag;
              if (childText != null) {
                if (childTag != null) {
                  error3("validateDOMNesting: when childText is passed, childTag should be null");
                }
                childTag = "#text";
              }
              var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
              var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
              var invalidParentOrAncestor = invalidParent || invalidAncestor;
              if (!invalidParentOrAncestor) {
                return;
              }
              var ancestorTag = invalidParentOrAncestor.tag;
              var warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag;
              if (didWarn$1[warnKey]) {
                return;
              }
              didWarn$1[warnKey] = true;
              var tagDisplayName = childTag;
              var whitespaceInfo = "";
              if (childTag === "#text") {
                if (/\S/.test(childText)) {
                  tagDisplayName = "Text nodes";
                } else {
                  tagDisplayName = "Whitespace text nodes";
                  whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.";
                }
              } else {
                tagDisplayName = "<" + childTag + ">";
              }
              if (invalidParent) {
                var info = "";
                if (ancestorTag === "table" && childTag === "tr") {
                  info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser.";
                }
                error3("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info);
              } else {
                error3("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
              }
            };
          }
          var SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
          var SUSPENSE_START_DATA = "$";
          var SUSPENSE_END_DATA = "/$";
          var SUSPENSE_PENDING_START_DATA = "$?";
          var SUSPENSE_FALLBACK_START_DATA = "$!";
          var STYLE$1 = "style";
          var eventsEnabled = null;
          var selectionInformation = null;
          function getRootHostContext(rootContainerInstance) {
            var type;
            var namespace;
            var nodeType = rootContainerInstance.nodeType;
            switch (nodeType) {
              case DOCUMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE: {
                type = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
                var root2 = rootContainerInstance.documentElement;
                namespace = root2 ? root2.namespaceURI : getChildNamespace(null, "");
                break;
              }
              default: {
                var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
                var ownNamespace = container.namespaceURI || null;
                type = container.tagName;
                namespace = getChildNamespace(ownNamespace, type);
                break;
              }
            }
            {
              var validatedTag = type.toLowerCase();
              var ancestorInfo = updatedAncestorInfo(null, validatedTag);
              return {
                namespace,
                ancestorInfo
              };
            }
          }
          function getChildHostContext(parentHostContext, type, rootContainerInstance) {
            {
              var parentHostContextDev = parentHostContext;
              var namespace = getChildNamespace(parentHostContextDev.namespace, type);
              var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
              return {
                namespace,
                ancestorInfo
              };
            }
          }
          function getPublicInstance(instance) {
            return instance;
          }
          function prepareForCommit(containerInfo) {
            eventsEnabled = isEnabled2();
            selectionInformation = getSelectionInformation();
            var activeInstance = null;
            setEnabled(false);
            return activeInstance;
          }
          function resetAfterCommit(containerInfo) {
            restoreSelection(selectionInformation);
            setEnabled(eventsEnabled);
            eventsEnabled = null;
            selectionInformation = null;
          }
          function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
            var parentNamespace;
            {
              var hostContextDev = hostContext;
              validateDOMNesting(type, null, hostContextDev.ancestorInfo);
              if (typeof props.children === "string" || typeof props.children === "number") {
                var string13 = "" + props.children;
                var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                validateDOMNesting(null, string13, ownAncestorInfo);
              }
              parentNamespace = hostContextDev.namespace;
            }
            var domElement = createElement21(type, props, rootContainerInstance, parentNamespace);
            precacheFiberNode(internalInstanceHandle, domElement);
            updateFiberProps(domElement, props);
            return domElement;
          }
          function appendInitialChild(parentInstance, child) {
            parentInstance.appendChild(child);
          }
          function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
            setInitialProperties(domElement, type, props, rootContainerInstance);
            switch (type) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                return !!props.autoFocus;
              case "img":
                return true;
              default:
                return false;
            }
          }
          function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
            {
              var hostContextDev = hostContext;
              if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === "string" || typeof newProps.children === "number")) {
                var string13 = "" + newProps.children;
                var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
                validateDOMNesting(null, string13, ownAncestorInfo);
              }
            }
            return diffProperties(domElement, type, oldProps, newProps);
          }
          function shouldSetTextContent(type, props) {
            return type === "textarea" || type === "noscript" || typeof props.children === "string" || typeof props.children === "number" || typeof props.dangerouslySetInnerHTML === "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
          }
          function createTextInstance(text5, rootContainerInstance, hostContext, internalInstanceHandle) {
            {
              var hostContextDev = hostContext;
              validateDOMNesting(null, text5, hostContextDev.ancestorInfo);
            }
            var textNode = createTextNode(text5, rootContainerInstance);
            precacheFiberNode(internalInstanceHandle, textNode);
            return textNode;
          }
          function getCurrentEventPriority() {
            var currentEvent = window.event;
            if (currentEvent === void 0) {
              return DefaultEventPriority;
            }
            return getEventPriority(currentEvent.type);
          }
          var scheduleTimeout = typeof setTimeout === "function" ? setTimeout : void 0;
          var cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : void 0;
          var noTimeout = -1;
          var localPromise = typeof Promise === "function" ? Promise : void 0;
          var scheduleMicrotask = typeof queueMicrotask === "function" ? queueMicrotask : typeof localPromise !== "undefined" ? function(callback) {
            return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
          } : scheduleTimeout;
          function handleErrorInNextTick(error4) {
            setTimeout(function() {
              throw error4;
            });
          }
          function commitMount(domElement, type, newProps, internalInstanceHandle) {
            switch (type) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                if (newProps.autoFocus) {
                  domElement.focus();
                }
                return;
              case "img": {
                if (newProps.src) {
                  domElement.src = newProps.src;
                }
                return;
              }
            }
          }
          function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
            updateProperties(domElement, updatePayload, type, oldProps, newProps);
            updateFiberProps(domElement, newProps);
          }
          function resetTextContent(domElement) {
            setTextContent(domElement, "");
          }
          function commitTextUpdate(textInstance, oldText, newText) {
            textInstance.nodeValue = newText;
          }
          function appendChild(parentInstance, child) {
            parentInstance.appendChild(child);
          }
          function appendChildToContainer(container, child) {
            var parentNode;
            if (container.nodeType === COMMENT_NODE) {
              parentNode = container.parentNode;
              parentNode.insertBefore(child, container);
            } else {
              parentNode = container;
              parentNode.appendChild(child);
            }
            var reactRootContainer = container._reactRootContainer;
            if ((reactRootContainer === null || reactRootContainer === void 0) && parentNode.onclick === null) {
              trapClickOnNonInteractiveElement(parentNode);
            }
          }
          function insertBefore(parentInstance, child, beforeChild) {
            parentInstance.insertBefore(child, beforeChild);
          }
          function insertInContainerBefore(container, child, beforeChild) {
            if (container.nodeType === COMMENT_NODE) {
              container.parentNode.insertBefore(child, beforeChild);
            } else {
              container.insertBefore(child, beforeChild);
            }
          }
          function removeChild(parentInstance, child) {
            parentInstance.removeChild(child);
          }
          function removeChildFromContainer(container, child) {
            if (container.nodeType === COMMENT_NODE) {
              container.parentNode.removeChild(child);
            } else {
              container.removeChild(child);
            }
          }
          function clearSuspenseBoundary(parentInstance, suspenseInstance) {
            var node = suspenseInstance;
            var depth = 0;
            do {
              var nextNode = node.nextSibling;
              parentInstance.removeChild(node);
              if (nextNode && nextNode.nodeType === COMMENT_NODE) {
                var data = nextNode.data;
                if (data === SUSPENSE_END_DATA) {
                  if (depth === 0) {
                    parentInstance.removeChild(nextNode);
                    retryIfBlockedOn(suspenseInstance);
                    return;
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {
                  depth++;
                }
              }
              node = nextNode;
            } while (node);
            retryIfBlockedOn(suspenseInstance);
          }
          function clearSuspenseBoundaryFromContainer(container, suspenseInstance) {
            if (container.nodeType === COMMENT_NODE) {
              clearSuspenseBoundary(container.parentNode, suspenseInstance);
            } else if (container.nodeType === ELEMENT_NODE) {
              clearSuspenseBoundary(container, suspenseInstance);
            }
            retryIfBlockedOn(container);
          }
          function hideInstance(instance) {
            instance = instance;
            var style2 = instance.style;
            if (typeof style2.setProperty === "function") {
              style2.setProperty("display", "none", "important");
            } else {
              style2.display = "none";
            }
          }
          function hideTextInstance(textInstance) {
            textInstance.nodeValue = "";
          }
          function unhideInstance(instance, props) {
            instance = instance;
            var styleProp = props[STYLE$1];
            var display = styleProp !== void 0 && styleProp !== null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
            instance.style.display = dangerousStyleValue("display", display);
          }
          function unhideTextInstance(textInstance, text5) {
            textInstance.nodeValue = text5;
          }
          function clearContainer(container) {
            if (container.nodeType === ELEMENT_NODE) {
              container.textContent = "";
            } else if (container.nodeType === DOCUMENT_NODE) {
              if (container.documentElement) {
                container.removeChild(container.documentElement);
              }
            }
          }
          function canHydrateInstance(instance, type, props) {
            if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
              return null;
            }
            return instance;
          }
          function canHydrateTextInstance(instance, text5) {
            if (text5 === "" || instance.nodeType !== TEXT_NODE) {
              return null;
            }
            return instance;
          }
          function canHydrateSuspenseInstance(instance) {
            if (instance.nodeType !== COMMENT_NODE) {
              return null;
            }
            return instance;
          }
          function isSuspenseInstancePending(instance) {
            return instance.data === SUSPENSE_PENDING_START_DATA;
          }
          function isSuspenseInstanceFallback(instance) {
            return instance.data === SUSPENSE_FALLBACK_START_DATA;
          }
          function getSuspenseInstanceFallbackErrorDetails(instance) {
            var dataset = instance.nextSibling && instance.nextSibling.dataset;
            var digest, message2, stack;
            if (dataset) {
              digest = dataset.dgst;
              {
                message2 = dataset.msg;
                stack = dataset.stck;
              }
            }
            {
              return {
                message: message2,
                digest,
                stack
              };
            }
          }
          function registerSuspenseInstanceRetry(instance, callback) {
            instance._reactRetry = callback;
          }
          function getNextHydratable(node) {
            for (; node != null; node = node.nextSibling) {
              var nodeType = node.nodeType;
              if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
                break;
              }
              if (nodeType === COMMENT_NODE) {
                var nodeData = node.data;
                if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {
                  break;
                }
                if (nodeData === SUSPENSE_END_DATA) {
                  return null;
                }
              }
            }
            return node;
          }
          function getNextHydratableSibling(instance) {
            return getNextHydratable(instance.nextSibling);
          }
          function getFirstHydratableChild(parentInstance) {
            return getNextHydratable(parentInstance.firstChild);
          }
          function getFirstHydratableChildWithinContainer(parentContainer) {
            return getNextHydratable(parentContainer.firstChild);
          }
          function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {
            return getNextHydratable(parentInstance.nextSibling);
          }
          function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {
            precacheFiberNode(internalInstanceHandle, instance);
            updateFiberProps(instance, props);
            var parentNamespace;
            {
              var hostContextDev = hostContext;
              parentNamespace = hostContextDev.namespace;
            }
            var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
            return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);
          }
          function hydrateTextInstance(textInstance, text5, internalInstanceHandle, shouldWarnDev) {
            precacheFiberNode(internalInstanceHandle, textInstance);
            var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
            return diffHydratedText(textInstance, text5);
          }
          function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {
            precacheFiberNode(internalInstanceHandle, suspenseInstance);
          }
          function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
            var node = suspenseInstance.nextSibling;
            var depth = 0;
            while (node) {
              if (node.nodeType === COMMENT_NODE) {
                var data = node.data;
                if (data === SUSPENSE_END_DATA) {
                  if (depth === 0) {
                    return getNextHydratableSibling(node);
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                  depth++;
                }
              }
              node = node.nextSibling;
            }
            return null;
          }
          function getParentSuspenseInstance(targetInstance) {
            var node = targetInstance.previousSibling;
            var depth = 0;
            while (node) {
              if (node.nodeType === COMMENT_NODE) {
                var data = node.data;
                if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
                  if (depth === 0) {
                    return node;
                  } else {
                    depth--;
                  }
                } else if (data === SUSPENSE_END_DATA) {
                  depth++;
                }
              }
              node = node.previousSibling;
            }
            return null;
          }
          function commitHydratedContainer(container) {
            retryIfBlockedOn(container);
          }
          function commitHydratedSuspenseInstance(suspenseInstance) {
            retryIfBlockedOn(suspenseInstance);
          }
          function shouldDeleteUnhydratedTailInstances(parentType) {
            return parentType !== "head" && parentType !== "body";
          }
          function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text5, isConcurrentMode) {
            var shouldWarnDev = true;
            checkForUnmatchedText(textInstance.nodeValue, text5, isConcurrentMode, shouldWarnDev);
          }
          function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text5, isConcurrentMode) {
            if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
              var shouldWarnDev = true;
              checkForUnmatchedText(textInstance.nodeValue, text5, isConcurrentMode, shouldWarnDev);
            }
          }
          function didNotHydrateInstanceWithinContainer(parentContainer, instance) {
            {
              if (instance.nodeType === ELEMENT_NODE) {
                warnForDeletedHydratableElement(parentContainer, instance);
              } else if (instance.nodeType === COMMENT_NODE)
                ;
              else {
                warnForDeletedHydratableText(parentContainer, instance);
              }
            }
          }
          function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {
            {
              var parentNode = parentInstance.parentNode;
              if (parentNode !== null) {
                if (instance.nodeType === ELEMENT_NODE) {
                  warnForDeletedHydratableElement(parentNode, instance);
                } else if (instance.nodeType === COMMENT_NODE)
                  ;
                else {
                  warnForDeletedHydratableText(parentNode, instance);
                }
              }
            }
          }
          function didNotHydrateInstance(parentType, parentProps, parentInstance, instance, isConcurrentMode) {
            {
              if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                if (instance.nodeType === ELEMENT_NODE) {
                  warnForDeletedHydratableElement(parentInstance, instance);
                } else if (instance.nodeType === COMMENT_NODE)
                  ;
                else {
                  warnForDeletedHydratableText(parentInstance, instance);
                }
              }
            }
          }
          function didNotFindHydratableInstanceWithinContainer(parentContainer, type, props) {
            {
              warnForInsertedHydratedElement(parentContainer, type);
            }
          }
          function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text5) {
            {
              warnForInsertedHydratedText(parentContainer, text5);
            }
          }
          function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props) {
            {
              var parentNode = parentInstance.parentNode;
              if (parentNode !== null)
                warnForInsertedHydratedElement(parentNode, type);
            }
          }
          function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text5) {
            {
              var parentNode = parentInstance.parentNode;
              if (parentNode !== null)
                warnForInsertedHydratedText(parentNode, text5);
            }
          }
          function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props, isConcurrentMode) {
            {
              if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                warnForInsertedHydratedElement(parentInstance, type);
              }
            }
          }
          function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text5, isConcurrentMode) {
            {
              if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
                warnForInsertedHydratedText(parentInstance, text5);
              }
            }
          }
          function errorHydratingContainer(parentContainer) {
            {
              error3("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", parentContainer.nodeName.toLowerCase());
            }
          }
          function preparePortalMount(portalInstance) {
            listenToAllSupportedEvents(portalInstance);
          }
          var randomKey = Math.random().toString(36).slice(2);
          var internalInstanceKey = "__reactFiber$" + randomKey;
          var internalPropsKey = "__reactProps$" + randomKey;
          var internalContainerInstanceKey = "__reactContainer$" + randomKey;
          var internalEventHandlersKey = "__reactEvents$" + randomKey;
          var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
          var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
          function detachDeletedInstance(node) {
            delete node[internalInstanceKey];
            delete node[internalPropsKey];
            delete node[internalEventHandlersKey];
            delete node[internalEventHandlerListenersKey];
            delete node[internalEventHandlesSetKey];
          }
          function precacheFiberNode(hostInst, node) {
            node[internalInstanceKey] = hostInst;
          }
          function markContainerAsRoot(hostRoot, node) {
            node[internalContainerInstanceKey] = hostRoot;
          }
          function unmarkContainerAsRoot(node) {
            node[internalContainerInstanceKey] = null;
          }
          function isContainerMarkedAsRoot(node) {
            return !!node[internalContainerInstanceKey];
          }
          function getClosestInstanceFromNode(targetNode) {
            var targetInst = targetNode[internalInstanceKey];
            if (targetInst) {
              return targetInst;
            }
            var parentNode = targetNode.parentNode;
            while (parentNode) {
              targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
              if (targetInst) {
                var alternate = targetInst.alternate;
                if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
                  var suspenseInstance = getParentSuspenseInstance(targetNode);
                  while (suspenseInstance !== null) {
                    var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                    if (targetSuspenseInst) {
                      return targetSuspenseInst;
                    }
                    suspenseInstance = getParentSuspenseInstance(suspenseInstance);
                  }
                }
                return targetInst;
              }
              targetNode = parentNode;
              parentNode = targetNode.parentNode;
            }
            return null;
          }
          function getInstanceFromNode(node) {
            var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
            if (inst) {
              if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
                return inst;
              } else {
                return null;
              }
            }
            return null;
          }
          function getNodeFromInstance(inst) {
            if (inst.tag === HostComponent || inst.tag === HostText) {
              return inst.stateNode;
            }
            throw new Error("getNodeFromInstance: Invalid argument.");
          }
          function getFiberCurrentPropsFromNode(node) {
            return node[internalPropsKey] || null;
          }
          function updateFiberProps(node, props) {
            node[internalPropsKey] = props;
          }
          function getEventListenerSet(node) {
            var elementListenerSet = node[internalEventHandlersKey];
            if (elementListenerSet === void 0) {
              elementListenerSet = node[internalEventHandlersKey] = /* @__PURE__ */ new Set();
            }
            return elementListenerSet;
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame$1.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes3(typeSpecs, values2, location2, componentName, element) {
            {
              var has2 = Function.call.bind(hasOwnProperty3);
              for (var typeSpecName in typeSpecs) {
                if (has2(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error3("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error3("Failed %s type: %s", location2, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          var valueStack = [];
          var fiberStack;
          {
            fiberStack = [];
          }
          var index5 = -1;
          function createCursor(defaultValue4) {
            return {
              current: defaultValue4
            };
          }
          function pop(cursor, fiber) {
            if (index5 < 0) {
              {
                error3("Unexpected pop.");
              }
              return;
            }
            {
              if (fiber !== fiberStack[index5]) {
                error3("Unexpected Fiber popped.");
              }
            }
            cursor.current = valueStack[index5];
            valueStack[index5] = null;
            {
              fiberStack[index5] = null;
            }
            index5--;
          }
          function push3(cursor, value13, fiber) {
            index5++;
            valueStack[index5] = cursor.current;
            {
              fiberStack[index5] = fiber;
            }
            cursor.current = value13;
          }
          var warnedAboutMissingGetChildContext;
          {
            warnedAboutMissingGetChildContext = {};
          }
          var emptyContextObject = {};
          {
            Object.freeze(emptyContextObject);
          }
          var contextStackCursor = createCursor(emptyContextObject);
          var didPerformWorkStackCursor = createCursor(false);
          var previousContext = emptyContextObject;
          function getUnmaskedContext(workInProgress2, Component2, didPushOwnContextIfProvider) {
            {
              if (didPushOwnContextIfProvider && isContextProvider(Component2)) {
                return previousContext;
              }
              return contextStackCursor.current;
            }
          }
          function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
            {
              var instance = workInProgress2.stateNode;
              instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
              instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
            }
          }
          function getMaskedContext(workInProgress2, unmaskedContext) {
            {
              var type = workInProgress2.type;
              var contextTypes = type.contextTypes;
              if (!contextTypes) {
                return emptyContextObject;
              }
              var instance = workInProgress2.stateNode;
              if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
                return instance.__reactInternalMemoizedMaskedChildContext;
              }
              var context = {};
              for (var key in contextTypes) {
                context[key] = unmaskedContext[key];
              }
              {
                var name16 = getComponentNameFromFiber(workInProgress2) || "Unknown";
                checkPropTypes3(contextTypes, context, "context", name16);
              }
              if (instance) {
                cacheContext(workInProgress2, unmaskedContext, context);
              }
              return context;
            }
          }
          function hasContextChanged() {
            {
              return didPerformWorkStackCursor.current;
            }
          }
          function isContextProvider(type) {
            {
              var childContextTypes = type.childContextTypes;
              return childContextTypes !== null && childContextTypes !== void 0;
            }
          }
          function popContext(fiber) {
            {
              pop(didPerformWorkStackCursor, fiber);
              pop(contextStackCursor, fiber);
            }
          }
          function popTopLevelContextObject(fiber) {
            {
              pop(didPerformWorkStackCursor, fiber);
              pop(contextStackCursor, fiber);
            }
          }
          function pushTopLevelContextObject(fiber, context, didChange) {
            {
              if (contextStackCursor.current !== emptyContextObject) {
                throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
              }
              push3(contextStackCursor, context, fiber);
              push3(didPerformWorkStackCursor, didChange, fiber);
            }
          }
          function processChildContext(fiber, type, parentContext) {
            {
              var instance = fiber.stateNode;
              var childContextTypes = type.childContextTypes;
              if (typeof instance.getChildContext !== "function") {
                {
                  var componentName = getComponentNameFromFiber(fiber) || "Unknown";
                  if (!warnedAboutMissingGetChildContext[componentName]) {
                    warnedAboutMissingGetChildContext[componentName] = true;
                    error3("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                  }
                }
                return parentContext;
              }
              var childContext = instance.getChildContext();
              for (var contextKey in childContext) {
                if (!(contextKey in childContextTypes)) {
                  throw new Error((getComponentNameFromFiber(fiber) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
                }
              }
              {
                var name16 = getComponentNameFromFiber(fiber) || "Unknown";
                checkPropTypes3(childContextTypes, childContext, "child context", name16);
              }
              return assign2({}, parentContext, childContext);
            }
          }
          function pushContextProvider(workInProgress2) {
            {
              var instance = workInProgress2.stateNode;
              var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
              previousContext = contextStackCursor.current;
              push3(contextStackCursor, memoizedMergedChildContext, workInProgress2);
              push3(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
              return true;
            }
          }
          function invalidateContextProvider(workInProgress2, type, didChange) {
            {
              var instance = workInProgress2.stateNode;
              if (!instance) {
                throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
              }
              if (didChange) {
                var mergedContext = processChildContext(workInProgress2, type, previousContext);
                instance.__reactInternalMemoizedMergedChildContext = mergedContext;
                pop(didPerformWorkStackCursor, workInProgress2);
                pop(contextStackCursor, workInProgress2);
                push3(contextStackCursor, mergedContext, workInProgress2);
                push3(didPerformWorkStackCursor, didChange, workInProgress2);
              } else {
                pop(didPerformWorkStackCursor, workInProgress2);
                push3(didPerformWorkStackCursor, didChange, workInProgress2);
              }
            }
          }
          function findCurrentUnmaskedContext(fiber) {
            {
              if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
                throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
              }
              var node = fiber;
              do {
                switch (node.tag) {
                  case HostRoot:
                    return node.stateNode.context;
                  case ClassComponent: {
                    var Component2 = node.type;
                    if (isContextProvider(Component2)) {
                      return node.stateNode.__reactInternalMemoizedMergedChildContext;
                    }
                    break;
                  }
                }
                node = node.return;
              } while (node !== null);
              throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          var LegacyRoot = 0;
          var ConcurrentRoot = 1;
          var syncQueue = null;
          var includesLegacySyncCallbacks = false;
          var isFlushingSyncQueue = false;
          function scheduleSyncCallback(callback) {
            if (syncQueue === null) {
              syncQueue = [callback];
            } else {
              syncQueue.push(callback);
            }
          }
          function scheduleLegacySyncCallback(callback) {
            includesLegacySyncCallbacks = true;
            scheduleSyncCallback(callback);
          }
          function flushSyncCallbacksOnlyInLegacyMode() {
            if (includesLegacySyncCallbacks) {
              flushSyncCallbacks();
            }
          }
          function flushSyncCallbacks() {
            if (!isFlushingSyncQueue && syncQueue !== null) {
              isFlushingSyncQueue = true;
              var i = 0;
              var previousUpdatePriority = getCurrentUpdatePriority();
              try {
                var isSync = true;
                var queue = syncQueue;
                setCurrentUpdatePriority(DiscreteEventPriority);
                for (; i < queue.length; i++) {
                  var callback = queue[i];
                  do {
                    callback = callback(isSync);
                  } while (callback !== null);
                }
                syncQueue = null;
                includesLegacySyncCallbacks = false;
              } catch (error4) {
                if (syncQueue !== null) {
                  syncQueue = syncQueue.slice(i + 1);
                }
                scheduleCallback(ImmediatePriority, flushSyncCallbacks);
                throw error4;
              } finally {
                setCurrentUpdatePriority(previousUpdatePriority);
                isFlushingSyncQueue = false;
              }
            }
            return null;
          }
          var forkStack = [];
          var forkStackIndex = 0;
          var treeForkProvider = null;
          var treeForkCount = 0;
          var idStack = [];
          var idStackIndex = 0;
          var treeContextProvider = null;
          var treeContextId = 1;
          var treeContextOverflow = "";
          function isForkedChild(workInProgress2) {
            warnIfNotHydrating();
            return (workInProgress2.flags & Forked) !== NoFlags;
          }
          function getForksAtLevel(workInProgress2) {
            warnIfNotHydrating();
            return treeForkCount;
          }
          function getTreeId() {
            var overflow = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            var id2 = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
            return id2.toString(32) + overflow;
          }
          function pushTreeFork(workInProgress2, totalChildren) {
            warnIfNotHydrating();
            forkStack[forkStackIndex++] = treeForkCount;
            forkStack[forkStackIndex++] = treeForkProvider;
            treeForkProvider = workInProgress2;
            treeForkCount = totalChildren;
          }
          function pushTreeId(workInProgress2, totalChildren, index6) {
            warnIfNotHydrating();
            idStack[idStackIndex++] = treeContextId;
            idStack[idStackIndex++] = treeContextOverflow;
            idStack[idStackIndex++] = treeContextProvider;
            treeContextProvider = workInProgress2;
            var baseIdWithLeadingBit = treeContextId;
            var baseOverflow = treeContextOverflow;
            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
            var slot = index6 + 1;
            var length7 = getBitLength(totalChildren) + baseLength;
            if (length7 > 30) {
              var numberOfOverflowBits = baseLength - baseLength % 5;
              var newOverflowBits = (1 << numberOfOverflowBits) - 1;
              var newOverflow = (baseId & newOverflowBits).toString(32);
              var restOfBaseId = baseId >> numberOfOverflowBits;
              var restOfBaseLength = baseLength - numberOfOverflowBits;
              var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
              var restOfNewBits = slot << restOfBaseLength;
              var id2 = restOfNewBits | restOfBaseId;
              var overflow = newOverflow + baseOverflow;
              treeContextId = 1 << restOfLength | id2;
              treeContextOverflow = overflow;
            } else {
              var newBits = slot << baseLength;
              var _id = newBits | baseId;
              var _overflow = baseOverflow;
              treeContextId = 1 << length7 | _id;
              treeContextOverflow = _overflow;
            }
          }
          function pushMaterializedTreeId(workInProgress2) {
            warnIfNotHydrating();
            var returnFiber = workInProgress2.return;
            if (returnFiber !== null) {
              var numberOfForks = 1;
              var slotIndex = 0;
              pushTreeFork(workInProgress2, numberOfForks);
              pushTreeId(workInProgress2, numberOfForks, slotIndex);
            }
          }
          function getBitLength(number8) {
            return 32 - clz32(number8);
          }
          function getLeadingBit(id2) {
            return 1 << getBitLength(id2) - 1;
          }
          function popTreeContext(workInProgress2) {
            while (workInProgress2 === treeForkProvider) {
              treeForkProvider = forkStack[--forkStackIndex];
              forkStack[forkStackIndex] = null;
              treeForkCount = forkStack[--forkStackIndex];
              forkStack[forkStackIndex] = null;
            }
            while (workInProgress2 === treeContextProvider) {
              treeContextProvider = idStack[--idStackIndex];
              idStack[idStackIndex] = null;
              treeContextOverflow = idStack[--idStackIndex];
              idStack[idStackIndex] = null;
              treeContextId = idStack[--idStackIndex];
              idStack[idStackIndex] = null;
            }
          }
          function getSuspendedTreeContext() {
            warnIfNotHydrating();
            if (treeContextProvider !== null) {
              return {
                id: treeContextId,
                overflow: treeContextOverflow
              };
            } else {
              return null;
            }
          }
          function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
            warnIfNotHydrating();
            idStack[idStackIndex++] = treeContextId;
            idStack[idStackIndex++] = treeContextOverflow;
            idStack[idStackIndex++] = treeContextProvider;
            treeContextId = suspendedContext.id;
            treeContextOverflow = suspendedContext.overflow;
            treeContextProvider = workInProgress2;
          }
          function warnIfNotHydrating() {
            {
              if (!getIsHydrating()) {
                error3("Expected to be hydrating. This is a bug in React. Please file an issue.");
              }
            }
          }
          var hydrationParentFiber = null;
          var nextHydratableInstance = null;
          var isHydrating = false;
          var didSuspendOrErrorDEV = false;
          var hydrationErrors = null;
          function warnIfHydrating() {
            {
              if (isHydrating) {
                error3("We should not be hydrating here. This is a bug in React. Please file a bug.");
              }
            }
          }
          function markDidThrowWhileHydratingDEV() {
            {
              didSuspendOrErrorDEV = true;
            }
          }
          function didSuspendOrErrorWhileHydratingDEV() {
            {
              return didSuspendOrErrorDEV;
            }
          }
          function enterHydrationState(fiber) {
            var parentInstance = fiber.stateNode.containerInfo;
            nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);
            hydrationParentFiber = fiber;
            isHydrating = true;
            hydrationErrors = null;
            didSuspendOrErrorDEV = false;
            return true;
          }
          function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
            nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
            hydrationParentFiber = fiber;
            isHydrating = true;
            hydrationErrors = null;
            didSuspendOrErrorDEV = false;
            if (treeContext !== null) {
              restoreSuspendedTreeContext(fiber, treeContext);
            }
            return true;
          }
          function warnUnhydratedInstance(returnFiber, instance) {
            {
              switch (returnFiber.tag) {
                case HostRoot: {
                  didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);
                  break;
                }
                case HostComponent: {
                  var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotHydrateInstance(
                    returnFiber.type,
                    returnFiber.memoizedProps,
                    returnFiber.stateNode,
                    instance,
                    isConcurrentMode
                  );
                  break;
                }
                case SuspenseComponent: {
                  var suspenseState = returnFiber.memoizedState;
                  if (suspenseState.dehydrated !== null)
                    didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);
                  break;
                }
              }
            }
          }
          function deleteHydratableInstance(returnFiber, instance) {
            warnUnhydratedInstance(returnFiber, instance);
            var childToDelete = createFiberFromHostInstanceForDeletion();
            childToDelete.stateNode = instance;
            childToDelete.return = returnFiber;
            var deletions = returnFiber.deletions;
            if (deletions === null) {
              returnFiber.deletions = [childToDelete];
              returnFiber.flags |= ChildDeletion;
            } else {
              deletions.push(childToDelete);
            }
          }
          function warnNonhydratedInstance(returnFiber, fiber) {
            {
              if (didSuspendOrErrorDEV) {
                return;
              }
              switch (returnFiber.tag) {
                case HostRoot: {
                  var parentContainer = returnFiber.stateNode.containerInfo;
                  switch (fiber.tag) {
                    case HostComponent:
                      var type = fiber.type;
                      var props = fiber.pendingProps;
                      didNotFindHydratableInstanceWithinContainer(parentContainer, type);
                      break;
                    case HostText:
                      var text5 = fiber.pendingProps;
                      didNotFindHydratableTextInstanceWithinContainer(parentContainer, text5);
                      break;
                  }
                  break;
                }
                case HostComponent: {
                  var parentType = returnFiber.type;
                  var parentProps = returnFiber.memoizedProps;
                  var parentInstance = returnFiber.stateNode;
                  switch (fiber.tag) {
                    case HostComponent: {
                      var _type = fiber.type;
                      var _props = fiber.pendingProps;
                      var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                      didNotFindHydratableInstance(
                        parentType,
                        parentProps,
                        parentInstance,
                        _type,
                        _props,
                        isConcurrentMode
                      );
                      break;
                    }
                    case HostText: {
                      var _text = fiber.pendingProps;
                      var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                      didNotFindHydratableTextInstance(
                        parentType,
                        parentProps,
                        parentInstance,
                        _text,
                        _isConcurrentMode
                      );
                      break;
                    }
                  }
                  break;
                }
                case SuspenseComponent: {
                  var suspenseState = returnFiber.memoizedState;
                  var _parentInstance = suspenseState.dehydrated;
                  if (_parentInstance !== null)
                    switch (fiber.tag) {
                      case HostComponent:
                        var _type2 = fiber.type;
                        var _props2 = fiber.pendingProps;
                        didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);
                        break;
                      case HostText:
                        var _text2 = fiber.pendingProps;
                        didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                        break;
                    }
                  break;
                }
                default:
                  return;
              }
            }
          }
          function insertNonHydratedInstance(returnFiber, fiber) {
            fiber.flags = fiber.flags & ~Hydrating | Placement;
            warnNonhydratedInstance(returnFiber, fiber);
          }
          function tryHydrate(fiber, nextInstance) {
            switch (fiber.tag) {
              case HostComponent: {
                var type = fiber.type;
                var props = fiber.pendingProps;
                var instance = canHydrateInstance(nextInstance, type);
                if (instance !== null) {
                  fiber.stateNode = instance;
                  hydrationParentFiber = fiber;
                  nextHydratableInstance = getFirstHydratableChild(instance);
                  return true;
                }
                return false;
              }
              case HostText: {
                var text5 = fiber.pendingProps;
                var textInstance = canHydrateTextInstance(nextInstance, text5);
                if (textInstance !== null) {
                  fiber.stateNode = textInstance;
                  hydrationParentFiber = fiber;
                  nextHydratableInstance = null;
                  return true;
                }
                return false;
              }
              case SuspenseComponent: {
                var suspenseInstance = canHydrateSuspenseInstance(nextInstance);
                if (suspenseInstance !== null) {
                  var suspenseState = {
                    dehydrated: suspenseInstance,
                    treeContext: getSuspendedTreeContext(),
                    retryLane: OffscreenLane
                  };
                  fiber.memoizedState = suspenseState;
                  var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
                  dehydratedFragment.return = fiber;
                  fiber.child = dehydratedFragment;
                  hydrationParentFiber = fiber;
                  nextHydratableInstance = null;
                  return true;
                }
                return false;
              }
              default:
                return false;
            }
          }
          function shouldClientRenderOnMismatch(fiber) {
            return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;
          }
          function throwOnHydrationMismatch(fiber) {
            throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
          }
          function tryToClaimNextHydratableInstance(fiber) {
            if (!isHydrating) {
              return;
            }
            var nextInstance = nextHydratableInstance;
            if (!nextInstance) {
              if (shouldClientRenderOnMismatch(fiber)) {
                warnNonhydratedInstance(hydrationParentFiber, fiber);
                throwOnHydrationMismatch();
              }
              insertNonHydratedInstance(hydrationParentFiber, fiber);
              isHydrating = false;
              hydrationParentFiber = fiber;
              return;
            }
            var firstAttemptedInstance = nextInstance;
            if (!tryHydrate(fiber, nextInstance)) {
              if (shouldClientRenderOnMismatch(fiber)) {
                warnNonhydratedInstance(hydrationParentFiber, fiber);
                throwOnHydrationMismatch();
              }
              nextInstance = getNextHydratableSibling(firstAttemptedInstance);
              var prevHydrationParentFiber = hydrationParentFiber;
              if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
                insertNonHydratedInstance(hydrationParentFiber, fiber);
                isHydrating = false;
                hydrationParentFiber = fiber;
                return;
              }
              deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
            }
          }
          function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
            var instance = fiber.stateNode;
            var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
            var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);
            fiber.updateQueue = updatePayload;
            if (updatePayload !== null) {
              return true;
            }
            return false;
          }
          function prepareToHydrateHostTextInstance(fiber) {
            var textInstance = fiber.stateNode;
            var textContent = fiber.memoizedProps;
            var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
            if (shouldUpdate) {
              var returnFiber = hydrationParentFiber;
              if (returnFiber !== null) {
                switch (returnFiber.tag) {
                  case HostRoot: {
                    var parentContainer = returnFiber.stateNode.containerInfo;
                    var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotMatchHydratedContainerTextInstance(
                      parentContainer,
                      textInstance,
                      textContent,
                      isConcurrentMode
                    );
                    break;
                  }
                  case HostComponent: {
                    var parentType = returnFiber.type;
                    var parentProps = returnFiber.memoizedProps;
                    var parentInstance = returnFiber.stateNode;
                    var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;
                    didNotMatchHydratedTextInstance(
                      parentType,
                      parentProps,
                      parentInstance,
                      textInstance,
                      textContent,
                      _isConcurrentMode2
                    );
                    break;
                  }
                }
              }
            }
            return shouldUpdate;
          }
          function prepareToHydrateHostSuspenseInstance(fiber) {
            var suspenseState = fiber.memoizedState;
            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
            if (!suspenseInstance) {
              throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
            }
            hydrateSuspenseInstance(suspenseInstance, fiber);
          }
          function skipPastDehydratedSuspenseInstance(fiber) {
            var suspenseState = fiber.memoizedState;
            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
            if (!suspenseInstance) {
              throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
            }
            return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
          }
          function popToNextHostParent(fiber) {
            var parent2 = fiber.return;
            while (parent2 !== null && parent2.tag !== HostComponent && parent2.tag !== HostRoot && parent2.tag !== SuspenseComponent) {
              parent2 = parent2.return;
            }
            hydrationParentFiber = parent2;
          }
          function popHydrationState(fiber) {
            if (fiber !== hydrationParentFiber) {
              return false;
            }
            if (!isHydrating) {
              popToNextHostParent(fiber);
              isHydrating = true;
              return false;
            }
            if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {
              var nextInstance = nextHydratableInstance;
              if (nextInstance) {
                if (shouldClientRenderOnMismatch(fiber)) {
                  warnIfUnhydratedTailNodes(fiber);
                  throwOnHydrationMismatch();
                } else {
                  while (nextInstance) {
                    deleteHydratableInstance(fiber, nextInstance);
                    nextInstance = getNextHydratableSibling(nextInstance);
                  }
                }
              }
            }
            popToNextHostParent(fiber);
            if (fiber.tag === SuspenseComponent) {
              nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
            } else {
              nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
            }
            return true;
          }
          function hasUnhydratedTailNodes() {
            return isHydrating && nextHydratableInstance !== null;
          }
          function warnIfUnhydratedTailNodes(fiber) {
            var nextInstance = nextHydratableInstance;
            while (nextInstance) {
              warnUnhydratedInstance(fiber, nextInstance);
              nextInstance = getNextHydratableSibling(nextInstance);
            }
          }
          function resetHydrationState() {
            hydrationParentFiber = null;
            nextHydratableInstance = null;
            isHydrating = false;
            didSuspendOrErrorDEV = false;
          }
          function upgradeHydrationErrorsToRecoverable() {
            if (hydrationErrors !== null) {
              queueRecoverableErrors(hydrationErrors);
              hydrationErrors = null;
            }
          }
          function getIsHydrating() {
            return isHydrating;
          }
          function queueHydrationError(error4) {
            if (hydrationErrors === null) {
              hydrationErrors = [error4];
            } else {
              hydrationErrors.push(error4);
            }
          }
          var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
          var NoTransition = null;
          function requestCurrentTransition() {
            return ReactCurrentBatchConfig$1.transition;
          }
          var ReactStrictModeWarnings = {
            recordUnsafeLifecycleWarnings: function(fiber, instance) {
            },
            flushPendingUnsafeLifecycleWarnings: function() {
            },
            recordLegacyContextWarning: function(fiber, instance) {
            },
            flushLegacyContextWarning: function() {
            },
            discardPendingWarnings: function() {
            }
          };
          {
            var findStrictRoot = function(fiber) {
              var maybeStrictRoot = null;
              var node = fiber;
              while (node !== null) {
                if (node.mode & StrictLegacyMode) {
                  maybeStrictRoot = node;
                }
                node = node.return;
              }
              return maybeStrictRoot;
            };
            var setToSortedString = function(set2) {
              var array2 = [];
              set2.forEach(function(value13) {
                array2.push(value13);
              });
              return array2.sort().join(", ");
            };
            var pendingComponentWillMountWarnings = [];
            var pendingUNSAFE_ComponentWillMountWarnings = [];
            var pendingComponentWillReceivePropsWarnings = [];
            var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
            var pendingComponentWillUpdateWarnings = [];
            var pendingUNSAFE_ComponentWillUpdateWarnings = [];
            var didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
              if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
                return;
              }
              if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                pendingComponentWillMountWarnings.push(fiber);
              }
              if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === "function") {
                pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
              }
              if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                pendingComponentWillReceivePropsWarnings.push(fiber);
              }
              if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
              }
              if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                pendingComponentWillUpdateWarnings.push(fiber);
              }
              if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === "function") {
                pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
              }
            };
            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
              var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillMountWarnings.length > 0) {
                pendingComponentWillMountWarnings.forEach(function(fiber) {
                  componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillMountWarnings = [];
              }
              var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
                pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillMountWarnings = [];
              }
              var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillReceivePropsWarnings.length > 0) {
                pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
                  componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillReceivePropsWarnings = [];
              }
              var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
                pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
              }
              var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
              if (pendingComponentWillUpdateWarnings.length > 0) {
                pendingComponentWillUpdateWarnings.forEach(function(fiber) {
                  componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingComponentWillUpdateWarnings = [];
              }
              var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
              if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
                pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
                  UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutUnsafeLifecycles.add(fiber.type);
                });
                pendingUNSAFE_ComponentWillUpdateWarnings = [];
              }
              if (UNSAFE_componentWillMountUniqueNames.size > 0) {
                var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
                error3("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s", sortedNames);
              }
              if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
                var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
                error3("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s", _sortedNames);
              }
              if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
                var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
                error3("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s", _sortedNames2);
              }
              if (componentWillMountUniqueNames.size > 0) {
                var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
                warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames3);
              }
              if (componentWillReceivePropsUniqueNames.size > 0) {
                var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
                warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames4);
              }
              if (componentWillUpdateUniqueNames.size > 0) {
                var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
                warn("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s", _sortedNames5);
              }
            };
            var pendingLegacyContextWarning = /* @__PURE__ */ new Map();
            var didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
            ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
              var strictRoot = findStrictRoot(fiber);
              if (strictRoot === null) {
                error3("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
                return;
              }
              if (didWarnAboutLegacyContext.has(fiber.type)) {
                return;
              }
              var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
              if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
                if (warningsForRoot === void 0) {
                  warningsForRoot = [];
                  pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
                }
                warningsForRoot.push(fiber);
              }
            };
            ReactStrictModeWarnings.flushLegacyContextWarning = function() {
              pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
                if (fiberArray.length === 0) {
                  return;
                }
                var firstFiber = fiberArray[0];
                var uniqueNames = /* @__PURE__ */ new Set();
                fiberArray.forEach(function(fiber) {
                  uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
                  didWarnAboutLegacyContext.add(fiber.type);
                });
                var sortedNames = setToSortedString(uniqueNames);
                try {
                  setCurrentFiber(firstFiber);
                  error3("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context", sortedNames);
                } finally {
                  resetCurrentFiber();
                }
              });
            };
            ReactStrictModeWarnings.discardPendingWarnings = function() {
              pendingComponentWillMountWarnings = [];
              pendingUNSAFE_ComponentWillMountWarnings = [];
              pendingComponentWillReceivePropsWarnings = [];
              pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
              pendingComponentWillUpdateWarnings = [];
              pendingUNSAFE_ComponentWillUpdateWarnings = [];
              pendingLegacyContextWarning = /* @__PURE__ */ new Map();
            };
          }
          function resolveDefaultProps(Component2, baseProps) {
            if (Component2 && Component2.defaultProps) {
              var props = assign2({}, baseProps);
              var defaultProps19 = Component2.defaultProps;
              for (var propName in defaultProps19) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps19[propName];
                }
              }
              return props;
            }
            return baseProps;
          }
          var valueCursor = createCursor(null);
          var rendererSigil;
          {
            rendererSigil = {};
          }
          var currentlyRenderingFiber = null;
          var lastContextDependency = null;
          var lastFullyObservedContext = null;
          var isDisallowedContextReadInDEV = false;
          function resetContextDependencies() {
            currentlyRenderingFiber = null;
            lastContextDependency = null;
            lastFullyObservedContext = null;
            {
              isDisallowedContextReadInDEV = false;
            }
          }
          function enterDisallowedContextReadInDEV() {
            {
              isDisallowedContextReadInDEV = true;
            }
          }
          function exitDisallowedContextReadInDEV() {
            {
              isDisallowedContextReadInDEV = false;
            }
          }
          function pushProvider(providerFiber, context, nextValue) {
            {
              push3(valueCursor, context._currentValue, providerFiber);
              context._currentValue = nextValue;
              {
                if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                  error3("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
                }
                context._currentRenderer = rendererSigil;
              }
            }
          }
          function popProvider(context, providerFiber) {
            var currentValue = valueCursor.current;
            pop(valueCursor, providerFiber);
            {
              {
                context._currentValue = currentValue;
              }
            }
          }
          function scheduleContextWorkOnParentPath(parent2, renderLanes2, propagationRoot) {
            var node = parent2;
            while (node !== null) {
              var alternate = node.alternate;
              if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {
                node.childLanes = mergeLanes(node.childLanes, renderLanes2);
                if (alternate !== null) {
                  alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
                }
              } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
                alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
              }
              if (node === propagationRoot) {
                break;
              }
              node = node.return;
            }
            {
              if (node !== propagationRoot) {
                error3("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
          }
          function propagateContextChange(workInProgress2, context, renderLanes2) {
            {
              propagateContextChange_eager(workInProgress2, context, renderLanes2);
            }
          }
          function propagateContextChange_eager(workInProgress2, context, renderLanes2) {
            var fiber = workInProgress2.child;
            if (fiber !== null) {
              fiber.return = workInProgress2;
            }
            while (fiber !== null) {
              var nextFiber = void 0;
              var list = fiber.dependencies;
              if (list !== null) {
                nextFiber = fiber.child;
                var dependency = list.firstContext;
                while (dependency !== null) {
                  if (dependency.context === context) {
                    if (fiber.tag === ClassComponent) {
                      var lane = pickArbitraryLane(renderLanes2);
                      var update = createUpdate(NoTimestamp, lane);
                      update.tag = ForceUpdate;
                      var updateQueue = fiber.updateQueue;
                      if (updateQueue === null)
                        ;
                      else {
                        var sharedQueue = updateQueue.shared;
                        var pending = sharedQueue.pending;
                        if (pending === null) {
                          update.next = update;
                        } else {
                          update.next = pending.next;
                          pending.next = update;
                        }
                        sharedQueue.pending = update;
                      }
                    }
                    fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                    var alternate = fiber.alternate;
                    if (alternate !== null) {
                      alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                    }
                    scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2);
                    list.lanes = mergeLanes(list.lanes, renderLanes2);
                    break;
                  }
                  dependency = dependency.next;
                }
              } else if (fiber.tag === ContextProvider) {
                nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
              } else if (fiber.tag === DehydratedFragment) {
                var parentSuspense = fiber.return;
                if (parentSuspense === null) {
                  throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
                }
                parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);
                var _alternate = parentSuspense.alternate;
                if (_alternate !== null) {
                  _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2);
                }
                scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2);
                nextFiber = fiber.sibling;
              } else {
                nextFiber = fiber.child;
              }
              if (nextFiber !== null) {
                nextFiber.return = fiber;
              } else {
                nextFiber = fiber;
                while (nextFiber !== null) {
                  if (nextFiber === workInProgress2) {
                    nextFiber = null;
                    break;
                  }
                  var sibling = nextFiber.sibling;
                  if (sibling !== null) {
                    sibling.return = nextFiber.return;
                    nextFiber = sibling;
                    break;
                  }
                  nextFiber = nextFiber.return;
                }
              }
              fiber = nextFiber;
            }
          }
          function prepareToReadContext(workInProgress2, renderLanes2) {
            currentlyRenderingFiber = workInProgress2;
            lastContextDependency = null;
            lastFullyObservedContext = null;
            var dependencies = workInProgress2.dependencies;
            if (dependencies !== null) {
              {
                var firstContext = dependencies.firstContext;
                if (firstContext !== null) {
                  if (includesSomeLane(dependencies.lanes, renderLanes2)) {
                    markWorkInProgressReceivedUpdate();
                  }
                  dependencies.firstContext = null;
                }
              }
            }
          }
          function readContext(context) {
            {
              if (isDisallowedContextReadInDEV) {
                error3("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
              }
            }
            var value13 = context._currentValue;
            if (lastFullyObservedContext === context)
              ;
            else {
              var contextItem = {
                context,
                memoizedValue: value13,
                next: null
              };
              if (lastContextDependency === null) {
                if (currentlyRenderingFiber === null) {
                  throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
                }
                lastContextDependency = contextItem;
                currentlyRenderingFiber.dependencies = {
                  lanes: NoLanes,
                  firstContext: contextItem
                };
              } else {
                lastContextDependency = lastContextDependency.next = contextItem;
              }
            }
            return value13;
          }
          var concurrentQueues = null;
          function pushConcurrentUpdateQueue(queue) {
            if (concurrentQueues === null) {
              concurrentQueues = [queue];
            } else {
              concurrentQueues.push(queue);
            }
          }
          function finishQueueingConcurrentUpdates() {
            if (concurrentQueues !== null) {
              for (var i = 0; i < concurrentQueues.length; i++) {
                var queue = concurrentQueues[i];
                var lastInterleavedUpdate = queue.interleaved;
                if (lastInterleavedUpdate !== null) {
                  queue.interleaved = null;
                  var firstInterleavedUpdate = lastInterleavedUpdate.next;
                  var lastPendingUpdate = queue.pending;
                  if (lastPendingUpdate !== null) {
                    var firstPendingUpdate = lastPendingUpdate.next;
                    lastPendingUpdate.next = firstInterleavedUpdate;
                    lastInterleavedUpdate.next = firstPendingUpdate;
                  }
                  queue.pending = lastInterleavedUpdate;
                }
              }
              concurrentQueues = null;
            }
          }
          function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
              update.next = update;
              pushConcurrentUpdateQueue(queue);
            } else {
              update.next = interleaved.next;
              interleaved.next = update;
            }
            queue.interleaved = update;
            return markUpdateLaneFromFiberToRoot(fiber, lane);
          }
          function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
              update.next = update;
              pushConcurrentUpdateQueue(queue);
            } else {
              update.next = interleaved.next;
              interleaved.next = update;
            }
            queue.interleaved = update;
          }
          function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {
            var interleaved = queue.interleaved;
            if (interleaved === null) {
              update.next = update;
              pushConcurrentUpdateQueue(queue);
            } else {
              update.next = interleaved.next;
              interleaved.next = update;
            }
            queue.interleaved = update;
            return markUpdateLaneFromFiberToRoot(fiber, lane);
          }
          function enqueueConcurrentRenderForLane(fiber, lane) {
            return markUpdateLaneFromFiberToRoot(fiber, lane);
          }
          var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;
          function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
            var alternate = sourceFiber.alternate;
            if (alternate !== null) {
              alternate.lanes = mergeLanes(alternate.lanes, lane);
            }
            {
              if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
                warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
              }
            }
            var node = sourceFiber;
            var parent2 = sourceFiber.return;
            while (parent2 !== null) {
              parent2.childLanes = mergeLanes(parent2.childLanes, lane);
              alternate = parent2.alternate;
              if (alternate !== null) {
                alternate.childLanes = mergeLanes(alternate.childLanes, lane);
              } else {
                {
                  if ((parent2.flags & (Placement | Hydrating)) !== NoFlags) {
                    warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
                  }
                }
              }
              node = parent2;
              parent2 = parent2.return;
            }
            if (node.tag === HostRoot) {
              var root2 = node.stateNode;
              return root2;
            } else {
              return null;
            }
          }
          var UpdateState = 0;
          var ReplaceState = 1;
          var ForceUpdate = 2;
          var CaptureUpdate = 3;
          var hasForceUpdate = false;
          var didWarnUpdateInsideUpdate;
          var currentlyProcessingQueue;
          {
            didWarnUpdateInsideUpdate = false;
            currentlyProcessingQueue = null;
          }
          function initializeUpdateQueue(fiber) {
            var queue = {
              baseState: fiber.memoizedState,
              firstBaseUpdate: null,
              lastBaseUpdate: null,
              shared: {
                pending: null,
                interleaved: null,
                lanes: NoLanes
              },
              effects: null
            };
            fiber.updateQueue = queue;
          }
          function cloneUpdateQueue(current2, workInProgress2) {
            var queue = workInProgress2.updateQueue;
            var currentQueue = current2.updateQueue;
            if (queue === currentQueue) {
              var clone2 = {
                baseState: currentQueue.baseState,
                firstBaseUpdate: currentQueue.firstBaseUpdate,
                lastBaseUpdate: currentQueue.lastBaseUpdate,
                shared: currentQueue.shared,
                effects: currentQueue.effects
              };
              workInProgress2.updateQueue = clone2;
            }
          }
          function createUpdate(eventTime, lane) {
            var update = {
              eventTime,
              lane,
              tag: UpdateState,
              payload: null,
              callback: null,
              next: null
            };
            return update;
          }
          function enqueueUpdate(fiber, update, lane) {
            var updateQueue = fiber.updateQueue;
            if (updateQueue === null) {
              return null;
            }
            var sharedQueue = updateQueue.shared;
            {
              if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
                error3("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.");
                didWarnUpdateInsideUpdate = true;
              }
            }
            if (isUnsafeClassRenderPhaseUpdate()) {
              var pending = sharedQueue.pending;
              if (pending === null) {
                update.next = update;
              } else {
                update.next = pending.next;
                pending.next = update;
              }
              sharedQueue.pending = update;
              return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
            } else {
              return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);
            }
          }
          function entangleTransitions(root2, fiber, lane) {
            var updateQueue = fiber.updateQueue;
            if (updateQueue === null) {
              return;
            }
            var sharedQueue = updateQueue.shared;
            if (isTransitionLane(lane)) {
              var queueLanes = sharedQueue.lanes;
              queueLanes = intersectLanes(queueLanes, root2.pendingLanes);
              var newQueueLanes = mergeLanes(queueLanes, lane);
              sharedQueue.lanes = newQueueLanes;
              markRootEntangled(root2, newQueueLanes);
            }
          }
          function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
            var queue = workInProgress2.updateQueue;
            var current2 = workInProgress2.alternate;
            if (current2 !== null) {
              var currentQueue = current2.updateQueue;
              if (queue === currentQueue) {
                var newFirst = null;
                var newLast = null;
                var firstBaseUpdate = queue.firstBaseUpdate;
                if (firstBaseUpdate !== null) {
                  var update = firstBaseUpdate;
                  do {
                    var clone2 = {
                      eventTime: update.eventTime,
                      lane: update.lane,
                      tag: update.tag,
                      payload: update.payload,
                      callback: update.callback,
                      next: null
                    };
                    if (newLast === null) {
                      newFirst = newLast = clone2;
                    } else {
                      newLast.next = clone2;
                      newLast = clone2;
                    }
                    update = update.next;
                  } while (update !== null);
                  if (newLast === null) {
                    newFirst = newLast = capturedUpdate;
                  } else {
                    newLast.next = capturedUpdate;
                    newLast = capturedUpdate;
                  }
                } else {
                  newFirst = newLast = capturedUpdate;
                }
                queue = {
                  baseState: currentQueue.baseState,
                  firstBaseUpdate: newFirst,
                  lastBaseUpdate: newLast,
                  shared: currentQueue.shared,
                  effects: currentQueue.effects
                };
                workInProgress2.updateQueue = queue;
                return;
              }
            }
            var lastBaseUpdate = queue.lastBaseUpdate;
            if (lastBaseUpdate === null) {
              queue.firstBaseUpdate = capturedUpdate;
            } else {
              lastBaseUpdate.next = capturedUpdate;
            }
            queue.lastBaseUpdate = capturedUpdate;
          }
          function getStateFromUpdate(workInProgress2, queue, update, prevState, nextProps, instance) {
            switch (update.tag) {
              case ReplaceState: {
                var payload = update.payload;
                if (typeof payload === "function") {
                  {
                    enterDisallowedContextReadInDEV();
                  }
                  var nextState = payload.call(instance, prevState, nextProps);
                  {
                    if (workInProgress2.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(true);
                      try {
                        payload.call(instance, prevState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(false);
                      }
                    }
                    exitDisallowedContextReadInDEV();
                  }
                  return nextState;
                }
                return payload;
              }
              case CaptureUpdate: {
                workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
              }
              case UpdateState: {
                var _payload = update.payload;
                var partialState;
                if (typeof _payload === "function") {
                  {
                    enterDisallowedContextReadInDEV();
                  }
                  partialState = _payload.call(instance, prevState, nextProps);
                  {
                    if (workInProgress2.mode & StrictLegacyMode) {
                      setIsStrictModeForDevtools(true);
                      try {
                        _payload.call(instance, prevState, nextProps);
                      } finally {
                        setIsStrictModeForDevtools(false);
                      }
                    }
                    exitDisallowedContextReadInDEV();
                  }
                } else {
                  partialState = _payload;
                }
                if (partialState === null || partialState === void 0) {
                  return prevState;
                }
                return assign2({}, prevState, partialState);
              }
              case ForceUpdate: {
                hasForceUpdate = true;
                return prevState;
              }
            }
            return prevState;
          }
          function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {
            var queue = workInProgress2.updateQueue;
            hasForceUpdate = false;
            {
              currentlyProcessingQueue = queue.shared;
            }
            var firstBaseUpdate = queue.firstBaseUpdate;
            var lastBaseUpdate = queue.lastBaseUpdate;
            var pendingQueue = queue.shared.pending;
            if (pendingQueue !== null) {
              queue.shared.pending = null;
              var lastPendingUpdate = pendingQueue;
              var firstPendingUpdate = lastPendingUpdate.next;
              lastPendingUpdate.next = null;
              if (lastBaseUpdate === null) {
                firstBaseUpdate = firstPendingUpdate;
              } else {
                lastBaseUpdate.next = firstPendingUpdate;
              }
              lastBaseUpdate = lastPendingUpdate;
              var current2 = workInProgress2.alternate;
              if (current2 !== null) {
                var currentQueue = current2.updateQueue;
                var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
                if (currentLastBaseUpdate !== lastBaseUpdate) {
                  if (currentLastBaseUpdate === null) {
                    currentQueue.firstBaseUpdate = firstPendingUpdate;
                  } else {
                    currentLastBaseUpdate.next = firstPendingUpdate;
                  }
                  currentQueue.lastBaseUpdate = lastPendingUpdate;
                }
              }
            }
            if (firstBaseUpdate !== null) {
              var newState = queue.baseState;
              var newLanes = NoLanes;
              var newBaseState = null;
              var newFirstBaseUpdate = null;
              var newLastBaseUpdate = null;
              var update = firstBaseUpdate;
              do {
                var updateLane = update.lane;
                var updateEventTime = update.eventTime;
                if (!isSubsetOfLanes(renderLanes2, updateLane)) {
                  var clone2 = {
                    eventTime: updateEventTime,
                    lane: updateLane,
                    tag: update.tag,
                    payload: update.payload,
                    callback: update.callback,
                    next: null
                  };
                  if (newLastBaseUpdate === null) {
                    newFirstBaseUpdate = newLastBaseUpdate = clone2;
                    newBaseState = newState;
                  } else {
                    newLastBaseUpdate = newLastBaseUpdate.next = clone2;
                  }
                  newLanes = mergeLanes(newLanes, updateLane);
                } else {
                  if (newLastBaseUpdate !== null) {
                    var _clone = {
                      eventTime: updateEventTime,
                      lane: NoLane,
                      tag: update.tag,
                      payload: update.payload,
                      callback: update.callback,
                      next: null
                    };
                    newLastBaseUpdate = newLastBaseUpdate.next = _clone;
                  }
                  newState = getStateFromUpdate(workInProgress2, queue, update, newState, props, instance);
                  var callback = update.callback;
                  if (callback !== null && update.lane !== NoLane) {
                    workInProgress2.flags |= Callback;
                    var effects = queue.effects;
                    if (effects === null) {
                      queue.effects = [update];
                    } else {
                      effects.push(update);
                    }
                  }
                }
                update = update.next;
                if (update === null) {
                  pendingQueue = queue.shared.pending;
                  if (pendingQueue === null) {
                    break;
                  } else {
                    var _lastPendingUpdate = pendingQueue;
                    var _firstPendingUpdate = _lastPendingUpdate.next;
                    _lastPendingUpdate.next = null;
                    update = _firstPendingUpdate;
                    queue.lastBaseUpdate = _lastPendingUpdate;
                    queue.shared.pending = null;
                  }
                }
              } while (true);
              if (newLastBaseUpdate === null) {
                newBaseState = newState;
              }
              queue.baseState = newBaseState;
              queue.firstBaseUpdate = newFirstBaseUpdate;
              queue.lastBaseUpdate = newLastBaseUpdate;
              var lastInterleaved = queue.shared.interleaved;
              if (lastInterleaved !== null) {
                var interleaved = lastInterleaved;
                do {
                  newLanes = mergeLanes(newLanes, interleaved.lane);
                  interleaved = interleaved.next;
                } while (interleaved !== lastInterleaved);
              } else if (firstBaseUpdate === null) {
                queue.shared.lanes = NoLanes;
              }
              markSkippedUpdateLanes(newLanes);
              workInProgress2.lanes = newLanes;
              workInProgress2.memoizedState = newState;
            }
            {
              currentlyProcessingQueue = null;
            }
          }
          function callCallback(callback, context) {
            if (typeof callback !== "function") {
              throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + callback));
            }
            callback.call(context);
          }
          function resetHasForceUpdateBeforeProcessing() {
            hasForceUpdate = false;
          }
          function checkHasForceUpdateAfterProcessing() {
            return hasForceUpdate;
          }
          function commitUpdateQueue(finishedWork, finishedQueue, instance) {
            var effects = finishedQueue.effects;
            finishedQueue.effects = null;
            if (effects !== null) {
              for (var i = 0; i < effects.length; i++) {
                var effect = effects[i];
                var callback = effect.callback;
                if (callback !== null) {
                  effect.callback = null;
                  callCallback(callback, instance);
                }
              }
            }
          }
          var fakeInternalInstance = {};
          var emptyRefsObject = new React18.Component().refs;
          var didWarnAboutStateAssignmentForComponent;
          var didWarnAboutUninitializedState;
          var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
          var didWarnAboutLegacyLifecyclesAndDerivedState;
          var didWarnAboutUndefinedDerivedState;
          var warnOnUndefinedDerivedState;
          var warnOnInvalidCallback;
          var didWarnAboutDirectlyAssigningPropsToState;
          var didWarnAboutContextTypeAndContextTypes;
          var didWarnAboutInvalidateContextType;
          {
            didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
            didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
            didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
            didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
            didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
            var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
            warnOnInvalidCallback = function(callback, callerName) {
              if (callback === null || typeof callback === "function") {
                return;
              }
              var key = callerName + "_" + callback;
              if (!didWarnOnInvalidCallback.has(key)) {
                didWarnOnInvalidCallback.add(key);
                error3("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            };
            warnOnUndefinedDerivedState = function(type, partialState) {
              if (partialState === void 0) {
                var componentName = getComponentNameFromType(type) || "Component";
                if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                  didWarnAboutUndefinedDerivedState.add(componentName);
                  error3("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
                }
              }
            };
            Object.defineProperty(fakeInternalInstance, "_processChildContext", {
              enumerable: false,
              value: function() {
                throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
              }
            });
            Object.freeze(fakeInternalInstance);
          }
          function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
            var prevState = workInProgress2.memoizedState;
            var partialState = getDerivedStateFromProps(nextProps, prevState);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  partialState = getDerivedStateFromProps(nextProps, prevState);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              warnOnUndefinedDerivedState(ctor, partialState);
            }
            var memoizedState = partialState === null || partialState === void 0 ? prevState : assign2({}, prevState, partialState);
            workInProgress2.memoizedState = memoizedState;
            if (workInProgress2.lanes === NoLanes) {
              var updateQueue = workInProgress2.updateQueue;
              updateQueue.baseState = memoizedState;
            }
          }
          var classComponentUpdater = {
            isMounted,
            enqueueSetState: function(inst, payload, callback) {
              var fiber = get3(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.payload = payload;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "setState");
                }
                update.callback = callback;
              }
              var root2 = enqueueUpdate(fiber, update, lane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
                entangleTransitions(root2, fiber, lane);
              }
              {
                markStateUpdateScheduled(fiber, lane);
              }
            },
            enqueueReplaceState: function(inst, payload, callback) {
              var fiber = get3(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.tag = ReplaceState;
              update.payload = payload;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "replaceState");
                }
                update.callback = callback;
              }
              var root2 = enqueueUpdate(fiber, update, lane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
                entangleTransitions(root2, fiber, lane);
              }
              {
                markStateUpdateScheduled(fiber, lane);
              }
            },
            enqueueForceUpdate: function(inst, callback) {
              var fiber = get3(inst);
              var eventTime = requestEventTime();
              var lane = requestUpdateLane(fiber);
              var update = createUpdate(eventTime, lane);
              update.tag = ForceUpdate;
              if (callback !== void 0 && callback !== null) {
                {
                  warnOnInvalidCallback(callback, "forceUpdate");
                }
                update.callback = callback;
              }
              var root2 = enqueueUpdate(fiber, update, lane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
                entangleTransitions(root2, fiber, lane);
              }
              {
                markForceUpdateScheduled(fiber, lane);
              }
            }
          };
          function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
            var instance = workInProgress2.stateNode;
            if (typeof instance.shouldComponentUpdate === "function") {
              var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                if (shouldUpdate === void 0) {
                  error3("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
                }
              }
              return shouldUpdate;
            }
            if (ctor.prototype && ctor.prototype.isPureReactComponent) {
              return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
            }
            return true;
          }
          function checkClassInstance(workInProgress2, ctor, newProps) {
            var instance = workInProgress2.stateNode;
            {
              var name16 = getComponentNameFromType(ctor) || "Component";
              var renderPresent = instance.render;
              if (!renderPresent) {
                if (ctor.prototype && typeof ctor.prototype.render === "function") {
                  error3("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name16);
                } else {
                  error3("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name16);
                }
              }
              if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
                error3("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name16);
              }
              if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
                error3("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name16);
              }
              if (instance.propTypes) {
                error3("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name16);
              }
              if (instance.contextType) {
                error3("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name16);
              }
              {
                if (instance.contextTypes) {
                  error3("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name16);
                }
                if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                  didWarnAboutContextTypeAndContextTypes.add(ctor);
                  error3("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name16);
                }
              }
              if (typeof instance.componentShouldUpdate === "function") {
                error3("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name16);
              }
              if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
                error3("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
              }
              if (typeof instance.componentDidUnmount === "function") {
                error3("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name16);
              }
              if (typeof instance.componentDidReceiveProps === "function") {
                error3("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name16);
              }
              if (typeof instance.componentWillRecieveProps === "function") {
                error3("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name16);
              }
              if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
                error3("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name16);
              }
              var hasMutatedProps = instance.props !== newProps;
              if (instance.props !== void 0 && hasMutatedProps) {
                error3("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name16, name16);
              }
              if (instance.defaultProps) {
                error3("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name16, name16);
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
                didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
                error3("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
              }
              if (typeof instance.getDerivedStateFromProps === "function") {
                error3("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name16);
              }
              if (typeof instance.getDerivedStateFromError === "function") {
                error3("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name16);
              }
              if (typeof ctor.getSnapshotBeforeUpdate === "function") {
                error3("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name16);
              }
              var _state = instance.state;
              if (_state && (typeof _state !== "object" || isArray6(_state))) {
                error3("%s.state: must be set to an object or null", name16);
              }
              if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
                error3("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name16);
              }
            }
          }
          function adoptClassInstance(workInProgress2, instance) {
            instance.updater = classComponentUpdater;
            workInProgress2.stateNode = instance;
            set(instance, workInProgress2);
            {
              instance._reactInternalInstance = fakeInternalInstance;
            }
          }
          function constructClassInstance(workInProgress2, ctor, props) {
            var isLegacyContextConsumer = false;
            var unmaskedContext = emptyContextObject;
            var context = emptyContextObject;
            var contextType = ctor.contextType;
            {
              if ("contextType" in ctor) {
                var isValid3 = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
                if (!isValid3 && !didWarnAboutInvalidateContextType.has(ctor)) {
                  didWarnAboutInvalidateContextType.add(ctor);
                  var addendum = "";
                  if (contextType === void 0) {
                    addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                  } else if (typeof contextType !== "object") {
                    addendum = " However, it is set to a " + typeof contextType + ".";
                  } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                    addendum = " Did you accidentally pass the Context.Provider instead?";
                  } else if (contextType._context !== void 0) {
                    addendum = " Did you accidentally pass the Context.Consumer instead?";
                  } else {
                    addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                  }
                  error3("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
                }
              }
            }
            if (typeof contextType === "object" && contextType !== null) {
              context = readContext(contextType);
            } else {
              unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              var contextTypes = ctor.contextTypes;
              isLegacyContextConsumer = contextTypes !== null && contextTypes !== void 0;
              context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
            }
            var instance = new ctor(props, context);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  instance = new ctor(props, context);
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
            }
            var state3 = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;
            adoptClassInstance(workInProgress2, instance);
            {
              if (typeof ctor.getDerivedStateFromProps === "function" && state3 === null) {
                var componentName = getComponentNameFromType(ctor) || "Component";
                if (!didWarnAboutUninitializedState.has(componentName)) {
                  didWarnAboutUninitializedState.add(componentName);
                  error3("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
                }
              }
              if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
                var foundWillMountName = null;
                var foundWillReceivePropsName = null;
                var foundWillUpdateName = null;
                if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                  foundWillMountName = "componentWillMount";
                } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                  foundWillMountName = "UNSAFE_componentWillMount";
                }
                if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                  foundWillReceivePropsName = "componentWillReceiveProps";
                } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                  foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
                }
                if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                  foundWillUpdateName = "componentWillUpdate";
                } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  foundWillUpdateName = "UNSAFE_componentWillUpdate";
                }
                if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                  var _componentName = getComponentNameFromType(ctor) || "Component";
                  var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                  if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                    didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                    error3("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                  }
                }
              }
            }
            if (isLegacyContextConsumer) {
              cacheContext(workInProgress2, unmaskedContext, context);
            }
            return instance;
          }
          function callComponentWillMount(workInProgress2, instance) {
            var oldState = instance.state;
            if (typeof instance.componentWillMount === "function") {
              instance.componentWillMount();
            }
            if (typeof instance.UNSAFE_componentWillMount === "function") {
              instance.UNSAFE_componentWillMount();
            }
            if (oldState !== instance.state) {
              {
                error3("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component");
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
            var oldState = instance.state;
            if (typeof instance.componentWillReceiveProps === "function") {
              instance.componentWillReceiveProps(newProps, nextContext);
            }
            if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
            }
            if (instance.state !== oldState) {
              {
                var componentName = getComponentNameFromFiber(workInProgress2) || "Component";
                if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
                  didWarnAboutStateAssignmentForComponent.add(componentName);
                  error3("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName);
                }
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
            {
              checkClassInstance(workInProgress2, ctor, newProps);
            }
            var instance = workInProgress2.stateNode;
            instance.props = newProps;
            instance.state = workInProgress2.memoizedState;
            instance.refs = emptyRefsObject;
            initializeUpdateQueue(workInProgress2);
            var contextType = ctor.contextType;
            if (typeof contextType === "object" && contextType !== null) {
              instance.context = readContext(contextType);
            } else {
              var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              instance.context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            {
              if (instance.state === newProps) {
                var componentName = getComponentNameFromType(ctor) || "Component";
                if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                  didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                  error3("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
                }
              }
              if (workInProgress2.mode & StrictLegacyMode) {
                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance);
              }
              {
                ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);
              }
            }
            instance.state = workInProgress2.memoizedState;
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              instance.state = workInProgress2.memoizedState;
            }
            if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
              callComponentWillMount(workInProgress2, instance);
              processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
              instance.state = workInProgress2.memoizedState;
            }
            if (typeof instance.componentDidMount === "function") {
              var fiberFlags = Update;
              {
                fiberFlags |= LayoutStatic;
              }
              if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                fiberFlags |= MountLayoutDev;
              }
              workInProgress2.flags |= fiberFlags;
            }
          }
          function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
            var instance = workInProgress2.stateNode;
            var oldProps = workInProgress2.memoizedProps;
            instance.props = oldProps;
            var oldContext = instance.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === "object" && contextType !== null) {
              nextContext = readContext(contextType);
            } else {
              var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
              if (oldProps !== newProps || oldContext !== nextContext) {
                callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
              }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress2.memoizedState;
            var newState = instance.state = oldState;
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            newState = workInProgress2.memoizedState;
            if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
              if (typeof instance.componentDidMount === "function") {
                var fiberFlags = Update;
                {
                  fiberFlags |= LayoutStatic;
                }
                if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                  fiberFlags |= MountLayoutDev;
                }
                workInProgress2.flags |= fiberFlags;
              }
              return false;
            }
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              newState = workInProgress2.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
            if (shouldUpdate) {
              if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
                if (typeof instance.componentWillMount === "function") {
                  instance.componentWillMount();
                }
                if (typeof instance.UNSAFE_componentWillMount === "function") {
                  instance.UNSAFE_componentWillMount();
                }
              }
              if (typeof instance.componentDidMount === "function") {
                var _fiberFlags = Update;
                {
                  _fiberFlags |= LayoutStatic;
                }
                if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                  _fiberFlags |= MountLayoutDev;
                }
                workInProgress2.flags |= _fiberFlags;
              }
            } else {
              if (typeof instance.componentDidMount === "function") {
                var _fiberFlags2 = Update;
                {
                  _fiberFlags2 |= LayoutStatic;
                }
                if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
                  _fiberFlags2 |= MountLayoutDev;
                }
                workInProgress2.flags |= _fiberFlags2;
              }
              workInProgress2.memoizedProps = newProps;
              workInProgress2.memoizedState = newState;
            }
            instance.props = newProps;
            instance.state = newState;
            instance.context = nextContext;
            return shouldUpdate;
          }
          function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
            var instance = workInProgress2.stateNode;
            cloneUpdateQueue(current2, workInProgress2);
            var unresolvedOldProps = workInProgress2.memoizedProps;
            var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
            instance.props = oldProps;
            var unresolvedNewProps = workInProgress2.pendingProps;
            var oldContext = instance.context;
            var contextType = ctor.contextType;
            var nextContext = emptyContextObject;
            if (typeof contextType === "object" && contextType !== null) {
              nextContext = readContext(contextType);
            } else {
              var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
              nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
              if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
                callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
              }
            }
            resetHasForceUpdateBeforeProcessing();
            var oldState = workInProgress2.memoizedState;
            var newState = instance.state = oldState;
            processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
            newState = workInProgress2.memoizedState;
            if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {
              if (typeof instance.componentDidUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Update;
                }
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Snapshot;
                }
              }
              return false;
            }
            if (typeof getDerivedStateFromProps === "function") {
              applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
              newState = workInProgress2.memoizedState;
            }
            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || enableLazyContextPropagation;
            if (shouldUpdate) {
              if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
                if (typeof instance.componentWillUpdate === "function") {
                  instance.componentWillUpdate(newProps, newState, nextContext);
                }
                if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
                }
              }
              if (typeof instance.componentDidUpdate === "function") {
                workInProgress2.flags |= Update;
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                workInProgress2.flags |= Snapshot;
              }
            } else {
              if (typeof instance.componentDidUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Update;
                }
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function") {
                if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
                  workInProgress2.flags |= Snapshot;
                }
              }
              workInProgress2.memoizedProps = newProps;
              workInProgress2.memoizedState = newState;
            }
            instance.props = newProps;
            instance.state = newState;
            instance.context = nextContext;
            return shouldUpdate;
          }
          var didWarnAboutMaps;
          var didWarnAboutGenerators;
          var didWarnAboutStringRefs;
          var ownerHasKeyUseWarning;
          var ownerHasFunctionTypeWarning;
          var warnForMissingKey = function(child, returnFiber) {
          };
          {
            didWarnAboutMaps = false;
            didWarnAboutGenerators = false;
            didWarnAboutStringRefs = {};
            ownerHasKeyUseWarning = {};
            ownerHasFunctionTypeWarning = {};
            warnForMissingKey = function(child, returnFiber) {
              if (child === null || typeof child !== "object") {
                return;
              }
              if (!child._store || child._store.validated || child.key != null) {
                return;
              }
              if (typeof child._store !== "object") {
                throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
              }
              child._store.validated = true;
              var componentName = getComponentNameFromFiber(returnFiber) || "Component";
              if (ownerHasKeyUseWarning[componentName]) {
                return;
              }
              ownerHasKeyUseWarning[componentName] = true;
              error3('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.');
            };
          }
          function coerceRef(returnFiber, current2, element) {
            var mixedRef = element.ref;
            if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
              {
                if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && !(element._owner && element._self && element._owner.stateNode !== element._self)) {
                  var componentName = getComponentNameFromFiber(returnFiber) || "Component";
                  if (!didWarnAboutStringRefs[componentName]) {
                    {
                      error3('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', mixedRef);
                    }
                    didWarnAboutStringRefs[componentName] = true;
                  }
                }
              }
              if (element._owner) {
                var owner = element._owner;
                var inst;
                if (owner) {
                  var ownerFiber = owner;
                  if (ownerFiber.tag !== ClassComponent) {
                    throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
                  }
                  inst = ownerFiber.stateNode;
                }
                if (!inst) {
                  throw new Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
                }
                var resolvedInst = inst;
                {
                  checkPropStringCoercion(mixedRef, "ref");
                }
                var stringRef = "" + mixedRef;
                if (current2 !== null && current2.ref !== null && typeof current2.ref === "function" && current2.ref._stringRef === stringRef) {
                  return current2.ref;
                }
                var ref = function(value13) {
                  var refs = resolvedInst.refs;
                  if (refs === emptyRefsObject) {
                    refs = resolvedInst.refs = {};
                  }
                  if (value13 === null) {
                    delete refs[stringRef];
                  } else {
                    refs[stringRef] = value13;
                  }
                };
                ref._stringRef = stringRef;
                return ref;
              } else {
                if (typeof mixedRef !== "string") {
                  throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
                }
                if (!element._owner) {
                  throw new Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");
                }
              }
            }
            return mixedRef;
          }
          function throwOnInvalidObjectType(returnFiber, newChild) {
            var childString = Object.prototype.toString.call(newChild);
            throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
          }
          function warnOnFunctionType(returnFiber) {
            {
              var componentName = getComponentNameFromFiber(returnFiber) || "Component";
              if (ownerHasFunctionTypeWarning[componentName]) {
                return;
              }
              ownerHasFunctionTypeWarning[componentName] = true;
              error3("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
            }
          }
          function resolveLazy(lazyType) {
            var payload = lazyType._payload;
            var init3 = lazyType._init;
            return init3(payload);
          }
          function ChildReconciler(shouldTrackSideEffects) {
            function deleteChild(returnFiber, childToDelete) {
              if (!shouldTrackSideEffects) {
                return;
              }
              var deletions = returnFiber.deletions;
              if (deletions === null) {
                returnFiber.deletions = [childToDelete];
                returnFiber.flags |= ChildDeletion;
              } else {
                deletions.push(childToDelete);
              }
            }
            function deleteRemainingChildren(returnFiber, currentFirstChild) {
              if (!shouldTrackSideEffects) {
                return null;
              }
              var childToDelete = currentFirstChild;
              while (childToDelete !== null) {
                deleteChild(returnFiber, childToDelete);
                childToDelete = childToDelete.sibling;
              }
              return null;
            }
            function mapRemainingChildren(returnFiber, currentFirstChild) {
              var existingChildren = /* @__PURE__ */ new Map();
              var existingChild = currentFirstChild;
              while (existingChild !== null) {
                if (existingChild.key !== null) {
                  existingChildren.set(existingChild.key, existingChild);
                } else {
                  existingChildren.set(existingChild.index, existingChild);
                }
                existingChild = existingChild.sibling;
              }
              return existingChildren;
            }
            function useFiber(fiber, pendingProps) {
              var clone2 = createWorkInProgress(fiber, pendingProps);
              clone2.index = 0;
              clone2.sibling = null;
              return clone2;
            }
            function placeChild(newFiber, lastPlacedIndex, newIndex) {
              newFiber.index = newIndex;
              if (!shouldTrackSideEffects) {
                newFiber.flags |= Forked;
                return lastPlacedIndex;
              }
              var current2 = newFiber.alternate;
              if (current2 !== null) {
                var oldIndex = current2.index;
                if (oldIndex < lastPlacedIndex) {
                  newFiber.flags |= Placement;
                  return lastPlacedIndex;
                } else {
                  return oldIndex;
                }
              } else {
                newFiber.flags |= Placement;
                return lastPlacedIndex;
              }
            }
            function placeSingleChild(newFiber) {
              if (shouldTrackSideEffects && newFiber.alternate === null) {
                newFiber.flags |= Placement;
              }
              return newFiber;
            }
            function updateTextNode(returnFiber, current2, textContent, lanes) {
              if (current2 === null || current2.tag !== HostText) {
                var created = createFiberFromText(textContent, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, textContent);
                existing.return = returnFiber;
                return existing;
              }
            }
            function updateElement(returnFiber, current2, element, lanes) {
              var elementType = element.type;
              if (elementType === REACT_FRAGMENT_TYPE) {
                return updateFragment2(returnFiber, current2, element.props.children, lanes, element.key);
              }
              if (current2 !== null) {
                if (current2.elementType === elementType || isCompatibleFamilyForHotReloading(current2, element) || typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type) {
                  var existing = useFiber(current2, element.props);
                  existing.ref = coerceRef(returnFiber, current2, element);
                  existing.return = returnFiber;
                  {
                    existing._debugSource = element._source;
                    existing._debugOwner = element._owner;
                  }
                  return existing;
                }
              }
              var created = createFiberFromElement(element, returnFiber.mode, lanes);
              created.ref = coerceRef(returnFiber, current2, element);
              created.return = returnFiber;
              return created;
            }
            function updatePortal(returnFiber, current2, portal, lanes) {
              if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
                var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, portal.children || []);
                existing.return = returnFiber;
                return existing;
              }
            }
            function updateFragment2(returnFiber, current2, fragment2, lanes, key) {
              if (current2 === null || current2.tag !== Fragment2) {
                var created = createFiberFromFragment(fragment2, returnFiber.mode, lanes, key);
                created.return = returnFiber;
                return created;
              } else {
                var existing = useFiber(current2, fragment2);
                existing.return = returnFiber;
                return existing;
              }
            }
            function createChild(returnFiber, newChild, lanes) {
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
                created.return = returnFiber;
                return created;
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                    _created.ref = coerceRef(returnFiber, null, newChild);
                    _created.return = returnFiber;
                    return _created;
                  }
                  case REACT_PORTAL_TYPE: {
                    var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                    _created2.return = returnFiber;
                    return _created2;
                  }
                  case REACT_LAZY_TYPE: {
                    var payload = newChild._payload;
                    var init3 = newChild._init;
                    return createChild(returnFiber, init3(payload), lanes);
                  }
                }
                if (isArray6(newChild) || getIteratorFn(newChild)) {
                  var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
                  _created3.return = returnFiber;
                  return _created3;
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function updateSlot(returnFiber, oldFiber, newChild, lanes) {
              var key = oldFiber !== null ? oldFiber.key : null;
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                if (key !== null) {
                  return null;
                }
                return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    if (newChild.key === key) {
                      return updateElement(returnFiber, oldFiber, newChild, lanes);
                    } else {
                      return null;
                    }
                  }
                  case REACT_PORTAL_TYPE: {
                    if (newChild.key === key) {
                      return updatePortal(returnFiber, oldFiber, newChild, lanes);
                    } else {
                      return null;
                    }
                  }
                  case REACT_LAZY_TYPE: {
                    var payload = newChild._payload;
                    var init3 = newChild._init;
                    return updateSlot(returnFiber, oldFiber, init3(payload), lanes);
                  }
                }
                if (isArray6(newChild) || getIteratorFn(newChild)) {
                  if (key !== null) {
                    return null;
                  }
                  return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                var matchedFiber = existingChildren.get(newIdx) || null;
                return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE: {
                    var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                    return updateElement(returnFiber, _matchedFiber, newChild, lanes);
                  }
                  case REACT_PORTAL_TYPE: {
                    var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                    return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
                  }
                  case REACT_LAZY_TYPE:
                    var payload = newChild._payload;
                    var init3 = newChild._init;
                    return updateFromMap(existingChildren, returnFiber, newIdx, init3(payload), lanes);
                }
                if (isArray6(newChild) || getIteratorFn(newChild)) {
                  var _matchedFiber3 = existingChildren.get(newIdx) || null;
                  return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return null;
            }
            function warnOnInvalidKey(child, knownKeys, returnFiber) {
              {
                if (typeof child !== "object" || child === null) {
                  return knownKeys;
                }
                switch (child.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                  case REACT_PORTAL_TYPE:
                    warnForMissingKey(child, returnFiber);
                    var key = child.key;
                    if (typeof key !== "string") {
                      break;
                    }
                    if (knownKeys === null) {
                      knownKeys = /* @__PURE__ */ new Set();
                      knownKeys.add(key);
                      break;
                    }
                    if (!knownKeys.has(key)) {
                      knownKeys.add(key);
                      break;
                    }
                    error3("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key);
                    break;
                  case REACT_LAZY_TYPE:
                    var payload = child._payload;
                    var init3 = child._init;
                    warnOnInvalidKey(init3(payload), knownKeys, returnFiber);
                    break;
                }
              }
              return knownKeys;
            }
            function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
              {
                var knownKeys = null;
                for (var i = 0; i < newChildren.length; i++) {
                  var child = newChildren[i];
                  knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                }
              }
              var resultingFirstChild = null;
              var previousNewFiber = null;
              var oldFiber = currentFirstChild;
              var lastPlacedIndex = 0;
              var newIdx = 0;
              var nextOldFiber = null;
              for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
                if (oldFiber.index > newIdx) {
                  nextOldFiber = oldFiber;
                  oldFiber = null;
                } else {
                  nextOldFiber = oldFiber.sibling;
                }
                var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
                if (newFiber === null) {
                  if (oldFiber === null) {
                    oldFiber = nextOldFiber;
                  }
                  break;
                }
                if (shouldTrackSideEffects) {
                  if (oldFiber && newFiber.alternate === null) {
                    deleteChild(returnFiber, oldFiber);
                  }
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = newFiber;
                } else {
                  previousNewFiber.sibling = newFiber;
                }
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (newIdx === newChildren.length) {
                deleteRemainingChildren(returnFiber, oldFiber);
                if (getIsHydrating()) {
                  var numberOfForks = newIdx;
                  pushTreeFork(returnFiber, numberOfForks);
                }
                return resultingFirstChild;
              }
              if (oldFiber === null) {
                for (; newIdx < newChildren.length; newIdx++) {
                  var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
                  if (_newFiber === null) {
                    continue;
                  }
                  lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber;
                  } else {
                    previousNewFiber.sibling = _newFiber;
                  }
                  previousNewFiber = _newFiber;
                }
                if (getIsHydrating()) {
                  var _numberOfForks = newIdx;
                  pushTreeFork(returnFiber, _numberOfForks);
                }
                return resultingFirstChild;
              }
              var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
              for (; newIdx < newChildren.length; newIdx++) {
                var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
                if (_newFiber2 !== null) {
                  if (shouldTrackSideEffects) {
                    if (_newFiber2.alternate !== null) {
                      existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                    }
                  }
                  lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber2;
                  } else {
                    previousNewFiber.sibling = _newFiber2;
                  }
                  previousNewFiber = _newFiber2;
                }
              }
              if (shouldTrackSideEffects) {
                existingChildren.forEach(function(child2) {
                  return deleteChild(returnFiber, child2);
                });
              }
              if (getIsHydrating()) {
                var _numberOfForks2 = newIdx;
                pushTreeFork(returnFiber, _numberOfForks2);
              }
              return resultingFirstChild;
            }
            function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
              var iteratorFn = getIteratorFn(newChildrenIterable);
              if (typeof iteratorFn !== "function") {
                throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
              }
              {
                if (typeof Symbol === "function" && newChildrenIterable[Symbol.toStringTag] === "Generator") {
                  if (!didWarnAboutGenerators) {
                    error3("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                  }
                  didWarnAboutGenerators = true;
                }
                if (newChildrenIterable.entries === iteratorFn) {
                  if (!didWarnAboutMaps) {
                    error3("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                  }
                  didWarnAboutMaps = true;
                }
                var _newChildren = iteratorFn.call(newChildrenIterable);
                if (_newChildren) {
                  var knownKeys = null;
                  var _step = _newChildren.next();
                  for (; !_step.done; _step = _newChildren.next()) {
                    var child = _step.value;
                    knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
                  }
                }
              }
              var newChildren = iteratorFn.call(newChildrenIterable);
              if (newChildren == null) {
                throw new Error("An iterable object provided no iterator.");
              }
              var resultingFirstChild = null;
              var previousNewFiber = null;
              var oldFiber = currentFirstChild;
              var lastPlacedIndex = 0;
              var newIdx = 0;
              var nextOldFiber = null;
              var step2 = newChildren.next();
              for (; oldFiber !== null && !step2.done; newIdx++, step2 = newChildren.next()) {
                if (oldFiber.index > newIdx) {
                  nextOldFiber = oldFiber;
                  oldFiber = null;
                } else {
                  nextOldFiber = oldFiber.sibling;
                }
                var newFiber = updateSlot(returnFiber, oldFiber, step2.value, lanes);
                if (newFiber === null) {
                  if (oldFiber === null) {
                    oldFiber = nextOldFiber;
                  }
                  break;
                }
                if (shouldTrackSideEffects) {
                  if (oldFiber && newFiber.alternate === null) {
                    deleteChild(returnFiber, oldFiber);
                  }
                }
                lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
                if (previousNewFiber === null) {
                  resultingFirstChild = newFiber;
                } else {
                  previousNewFiber.sibling = newFiber;
                }
                previousNewFiber = newFiber;
                oldFiber = nextOldFiber;
              }
              if (step2.done) {
                deleteRemainingChildren(returnFiber, oldFiber);
                if (getIsHydrating()) {
                  var numberOfForks = newIdx;
                  pushTreeFork(returnFiber, numberOfForks);
                }
                return resultingFirstChild;
              }
              if (oldFiber === null) {
                for (; !step2.done; newIdx++, step2 = newChildren.next()) {
                  var _newFiber3 = createChild(returnFiber, step2.value, lanes);
                  if (_newFiber3 === null) {
                    continue;
                  }
                  lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber3;
                  } else {
                    previousNewFiber.sibling = _newFiber3;
                  }
                  previousNewFiber = _newFiber3;
                }
                if (getIsHydrating()) {
                  var _numberOfForks3 = newIdx;
                  pushTreeFork(returnFiber, _numberOfForks3);
                }
                return resultingFirstChild;
              }
              var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
              for (; !step2.done; newIdx++, step2 = newChildren.next()) {
                var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step2.value, lanes);
                if (_newFiber4 !== null) {
                  if (shouldTrackSideEffects) {
                    if (_newFiber4.alternate !== null) {
                      existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                    }
                  }
                  lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
                  if (previousNewFiber === null) {
                    resultingFirstChild = _newFiber4;
                  } else {
                    previousNewFiber.sibling = _newFiber4;
                  }
                  previousNewFiber = _newFiber4;
                }
              }
              if (shouldTrackSideEffects) {
                existingChildren.forEach(function(child2) {
                  return deleteChild(returnFiber, child2);
                });
              }
              if (getIsHydrating()) {
                var _numberOfForks4 = newIdx;
                pushTreeFork(returnFiber, _numberOfForks4);
              }
              return resultingFirstChild;
            }
            function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
              if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
                deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
                var existing = useFiber(currentFirstChild, textContent);
                existing.return = returnFiber;
                return existing;
              }
              deleteRemainingChildren(returnFiber, currentFirstChild);
              var created = createFiberFromText(textContent, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
              var key = element.key;
              var child = currentFirstChild;
              while (child !== null) {
                if (child.key === key) {
                  var elementType = element.type;
                  if (elementType === REACT_FRAGMENT_TYPE) {
                    if (child.tag === Fragment2) {
                      deleteRemainingChildren(returnFiber, child.sibling);
                      var existing = useFiber(child, element.props.children);
                      existing.return = returnFiber;
                      {
                        existing._debugSource = element._source;
                        existing._debugOwner = element._owner;
                      }
                      return existing;
                    }
                  } else {
                    if (child.elementType === elementType || isCompatibleFamilyForHotReloading(child, element) || typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {
                      deleteRemainingChildren(returnFiber, child.sibling);
                      var _existing = useFiber(child, element.props);
                      _existing.ref = coerceRef(returnFiber, child, element);
                      _existing.return = returnFiber;
                      {
                        _existing._debugSource = element._source;
                        _existing._debugOwner = element._owner;
                      }
                      return _existing;
                    }
                  }
                  deleteRemainingChildren(returnFiber, child);
                  break;
                } else {
                  deleteChild(returnFiber, child);
                }
                child = child.sibling;
              }
              if (element.type === REACT_FRAGMENT_TYPE) {
                var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
                created.return = returnFiber;
                return created;
              } else {
                var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
                _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
                _created4.return = returnFiber;
                return _created4;
              }
            }
            function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
              var key = portal.key;
              var child = currentFirstChild;
              while (child !== null) {
                if (child.key === key) {
                  if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                    deleteRemainingChildren(returnFiber, child.sibling);
                    var existing = useFiber(child, portal.children || []);
                    existing.return = returnFiber;
                    return existing;
                  } else {
                    deleteRemainingChildren(returnFiber, child);
                    break;
                  }
                } else {
                  deleteChild(returnFiber, child);
                }
                child = child.sibling;
              }
              var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
              created.return = returnFiber;
              return created;
            }
            function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
              var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
              if (isUnkeyedTopLevelFragment) {
                newChild = newChild.props.children;
              }
              if (typeof newChild === "object" && newChild !== null) {
                switch (newChild.$$typeof) {
                  case REACT_ELEMENT_TYPE:
                    return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
                  case REACT_PORTAL_TYPE:
                    return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
                  case REACT_LAZY_TYPE:
                    var payload = newChild._payload;
                    var init3 = newChild._init;
                    return reconcileChildFibers2(returnFiber, currentFirstChild, init3(payload), lanes);
                }
                if (isArray6(newChild)) {
                  return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
                }
                if (getIteratorFn(newChild)) {
                  return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
                }
                throwOnInvalidObjectType(returnFiber, newChild);
              }
              if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
                return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
              }
              {
                if (typeof newChild === "function") {
                  warnOnFunctionType(returnFiber);
                }
              }
              return deleteRemainingChildren(returnFiber, currentFirstChild);
            }
            return reconcileChildFibers2;
          }
          var reconcileChildFibers = ChildReconciler(true);
          var mountChildFibers = ChildReconciler(false);
          function cloneChildFibers(current2, workInProgress2) {
            if (current2 !== null && workInProgress2.child !== current2.child) {
              throw new Error("Resuming work not yet implemented.");
            }
            if (workInProgress2.child === null) {
              return;
            }
            var currentChild = workInProgress2.child;
            var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
            workInProgress2.child = newChild;
            newChild.return = workInProgress2;
            while (currentChild.sibling !== null) {
              currentChild = currentChild.sibling;
              newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
              newChild.return = workInProgress2;
            }
            newChild.sibling = null;
          }
          function resetChildFibers(workInProgress2, lanes) {
            var child = workInProgress2.child;
            while (child !== null) {
              resetWorkInProgress(child, lanes);
              child = child.sibling;
            }
          }
          var NO_CONTEXT = {};
          var contextStackCursor$1 = createCursor(NO_CONTEXT);
          var contextFiberStackCursor = createCursor(NO_CONTEXT);
          var rootInstanceStackCursor = createCursor(NO_CONTEXT);
          function requiredContext(c) {
            if (c === NO_CONTEXT) {
              throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
            }
            return c;
          }
          function getRootHostContainer() {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            return rootInstance;
          }
          function pushHostContainer(fiber, nextRootInstance) {
            push3(rootInstanceStackCursor, nextRootInstance, fiber);
            push3(contextFiberStackCursor, fiber, fiber);
            push3(contextStackCursor$1, NO_CONTEXT, fiber);
            var nextRootContext = getRootHostContext(nextRootInstance);
            pop(contextStackCursor$1, fiber);
            push3(contextStackCursor$1, nextRootContext, fiber);
          }
          function popHostContainer(fiber) {
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
            pop(rootInstanceStackCursor, fiber);
          }
          function getHostContext() {
            var context = requiredContext(contextStackCursor$1.current);
            return context;
          }
          function pushHostContext(fiber) {
            var rootInstance = requiredContext(rootInstanceStackCursor.current);
            var context = requiredContext(contextStackCursor$1.current);
            var nextContext = getChildHostContext(context, fiber.type);
            if (context === nextContext) {
              return;
            }
            push3(contextFiberStackCursor, fiber, fiber);
            push3(contextStackCursor$1, nextContext, fiber);
          }
          function popHostContext(fiber) {
            if (contextFiberStackCursor.current !== fiber) {
              return;
            }
            pop(contextStackCursor$1, fiber);
            pop(contextFiberStackCursor, fiber);
          }
          var DefaultSuspenseContext = 0;
          var SubtreeSuspenseContextMask = 1;
          var InvisibleParentSuspenseContext = 1;
          var ForceSuspenseFallback = 2;
          var suspenseStackCursor = createCursor(DefaultSuspenseContext);
          function hasSuspenseContext(parentContext, flag) {
            return (parentContext & flag) !== 0;
          }
          function setDefaultShallowSuspenseContext(parentContext) {
            return parentContext & SubtreeSuspenseContextMask;
          }
          function setShallowSuspenseContext(parentContext, shallowContext) {
            return parentContext & SubtreeSuspenseContextMask | shallowContext;
          }
          function addSubtreeSuspenseContext(parentContext, subtreeContext) {
            return parentContext | subtreeContext;
          }
          function pushSuspenseContext(fiber, newContext) {
            push3(suspenseStackCursor, newContext, fiber);
          }
          function popSuspenseContext(fiber) {
            pop(suspenseStackCursor, fiber);
          }
          function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
            var nextState = workInProgress2.memoizedState;
            if (nextState !== null) {
              if (nextState.dehydrated !== null) {
                return true;
              }
              return false;
            }
            var props = workInProgress2.memoizedProps;
            {
              return true;
            }
          }
          function findFirstSuspended(row) {
            var node = row;
            while (node !== null) {
              if (node.tag === SuspenseComponent) {
                var state3 = node.memoizedState;
                if (state3 !== null) {
                  var dehydrated = state3.dehydrated;
                  if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                    return node;
                  }
                }
              } else if (node.tag === SuspenseListComponent && node.memoizedProps.revealOrder !== void 0) {
                var didSuspend = (node.flags & DidCapture) !== NoFlags;
                if (didSuspend) {
                  return node;
                }
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === row) {
                return null;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === row) {
                  return null;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return null;
          }
          var NoFlags$1 = 0;
          var HasEffect = 1;
          var Insertion = 2;
          var Layout = 4;
          var Passive$1 = 8;
          var workInProgressSources = [];
          function resetWorkInProgressVersions() {
            for (var i = 0; i < workInProgressSources.length; i++) {
              var mutableSource = workInProgressSources[i];
              {
                mutableSource._workInProgressVersionPrimary = null;
              }
            }
            workInProgressSources.length = 0;
          }
          function registerMutableSourceForHydration(root2, mutableSource) {
            var getVersion2 = mutableSource._getVersion;
            var version = getVersion2(mutableSource._source);
            if (root2.mutableSourceEagerHydrationData == null) {
              root2.mutableSourceEagerHydrationData = [mutableSource, version];
            } else {
              root2.mutableSourceEagerHydrationData.push(mutableSource, version);
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig;
          var didWarnAboutMismatchedHooksForComponent;
          var didWarnUncachedGetSnapshot;
          {
            didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
          }
          var renderLanes = NoLanes;
          var currentlyRenderingFiber$1 = null;
          var currentHook = null;
          var workInProgressHook = null;
          var didScheduleRenderPhaseUpdate = false;
          var didScheduleRenderPhaseUpdateDuringThisPass = false;
          var localIdCounter = 0;
          var globalClientIdCounter = 0;
          var RE_RENDER_LIMIT = 25;
          var currentHookNameInDev = null;
          var hookTypesDev = null;
          var hookTypesUpdateIndexDev = -1;
          var ignorePreviousDependencies = false;
          function mountHookTypesDev() {
            {
              var hookName = currentHookNameInDev;
              if (hookTypesDev === null) {
                hookTypesDev = [hookName];
              } else {
                hookTypesDev.push(hookName);
              }
            }
          }
          function updateHookTypesDev() {
            {
              var hookName = currentHookNameInDev;
              if (hookTypesDev !== null) {
                hookTypesUpdateIndexDev++;
                if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
                  warnOnHookMismatchInDev(hookName);
                }
              }
            }
          }
          function checkDepsAreArrayDev(deps) {
            {
              if (deps !== void 0 && deps !== null && !isArray6(deps)) {
                error3("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
              }
            }
          }
          function warnOnHookMismatchInDev(currentHookName) {
            {
              var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
              if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
                didWarnAboutMismatchedHooksForComponent.add(componentName);
                if (hookTypesDev !== null) {
                  var table = "";
                  var secondColumnStart = 30;
                  for (var i = 0; i <= hookTypesUpdateIndexDev; i++) {
                    var oldHookName = hookTypesDev[i];
                    var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                    var row = i + 1 + ". " + oldHookName;
                    while (row.length < secondColumnStart) {
                      row += " ";
                    }
                    row += newHookName + "\n";
                    table += row;
                  }
                  error3("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", componentName, table);
                }
              }
            }
          }
          function throwInvalidHookError() {
            throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
          }
          function areHookInputsEqual(nextDeps, prevDeps) {
            {
              if (ignorePreviousDependencies) {
                return false;
              }
            }
            if (prevDeps === null) {
              {
                error3("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
              }
              return false;
            }
            {
              if (nextDeps.length !== prevDeps.length) {
                error3("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
              }
            }
            for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
              if (objectIs(nextDeps[i], prevDeps[i])) {
                continue;
              }
              return false;
            }
            return true;
          }
          function renderWithHooks(current2, workInProgress2, Component2, props, secondArg, nextRenderLanes) {
            renderLanes = nextRenderLanes;
            currentlyRenderingFiber$1 = workInProgress2;
            {
              hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
              hookTypesUpdateIndexDev = -1;
              ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
            }
            workInProgress2.memoizedState = null;
            workInProgress2.updateQueue = null;
            workInProgress2.lanes = NoLanes;
            {
              if (current2 !== null && current2.memoizedState !== null) {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
              } else if (hookTypesDev !== null) {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
              } else {
                ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
              }
            }
            var children = Component2(props, secondArg);
            if (didScheduleRenderPhaseUpdateDuringThisPass) {
              var numberOfReRenders = 0;
              do {
                didScheduleRenderPhaseUpdateDuringThisPass = false;
                localIdCounter = 0;
                if (numberOfReRenders >= RE_RENDER_LIMIT) {
                  throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
                }
                numberOfReRenders += 1;
                {
                  ignorePreviousDependencies = false;
                }
                currentHook = null;
                workInProgressHook = null;
                workInProgress2.updateQueue = null;
                {
                  hookTypesUpdateIndexDev = -1;
                }
                ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
                children = Component2(props, secondArg);
              } while (didScheduleRenderPhaseUpdateDuringThisPass);
            }
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            {
              workInProgress2._debugHookTypes = hookTypesDev;
            }
            var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
              currentHookNameInDev = null;
              hookTypesDev = null;
              hookTypesUpdateIndexDev = -1;
              if (current2 !== null && (current2.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && (current2.mode & ConcurrentMode) !== NoMode) {
                error3("Internal React error: Expected static flag was missing. Please notify the React team.");
              }
            }
            didScheduleRenderPhaseUpdate = false;
            if (didRenderTooFewHooks) {
              throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
            }
            return children;
          }
          function checkDidRenderIdHook() {
            var didRenderIdHook = localIdCounter !== 0;
            localIdCounter = 0;
            return didRenderIdHook;
          }
          function bailoutHooks(current2, workInProgress2, lanes) {
            workInProgress2.updateQueue = current2.updateQueue;
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);
            } else {
              workInProgress2.flags &= ~(Passive | Update);
            }
            current2.lanes = removeLanes(current2.lanes, lanes);
          }
          function resetHooksAfterThrow() {
            ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
            if (didScheduleRenderPhaseUpdate) {
              var hook = currentlyRenderingFiber$1.memoizedState;
              while (hook !== null) {
                var queue = hook.queue;
                if (queue !== null) {
                  queue.pending = null;
                }
                hook = hook.next;
              }
              didScheduleRenderPhaseUpdate = false;
            }
            renderLanes = NoLanes;
            currentlyRenderingFiber$1 = null;
            currentHook = null;
            workInProgressHook = null;
            {
              hookTypesDev = null;
              hookTypesUpdateIndexDev = -1;
              currentHookNameInDev = null;
              isUpdatingOpaqueValueInRenderPhase = false;
            }
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            localIdCounter = 0;
          }
          function mountWorkInProgressHook() {
            var hook = {
              memoizedState: null,
              baseState: null,
              baseQueue: null,
              queue: null,
              next: null
            };
            if (workInProgressHook === null) {
              currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
            } else {
              workInProgressHook = workInProgressHook.next = hook;
            }
            return workInProgressHook;
          }
          function updateWorkInProgressHook() {
            var nextCurrentHook;
            if (currentHook === null) {
              var current2 = currentlyRenderingFiber$1.alternate;
              if (current2 !== null) {
                nextCurrentHook = current2.memoizedState;
              } else {
                nextCurrentHook = null;
              }
            } else {
              nextCurrentHook = currentHook.next;
            }
            var nextWorkInProgressHook;
            if (workInProgressHook === null) {
              nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
            } else {
              nextWorkInProgressHook = workInProgressHook.next;
            }
            if (nextWorkInProgressHook !== null) {
              workInProgressHook = nextWorkInProgressHook;
              nextWorkInProgressHook = workInProgressHook.next;
              currentHook = nextCurrentHook;
            } else {
              if (nextCurrentHook === null) {
                throw new Error("Rendered more hooks than during the previous render.");
              }
              currentHook = nextCurrentHook;
              var newHook = {
                memoizedState: currentHook.memoizedState,
                baseState: currentHook.baseState,
                baseQueue: currentHook.baseQueue,
                queue: currentHook.queue,
                next: null
              };
              if (workInProgressHook === null) {
                currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
              } else {
                workInProgressHook = workInProgressHook.next = newHook;
              }
            }
            return workInProgressHook;
          }
          function createFunctionComponentUpdateQueue() {
            return {
              lastEffect: null,
              stores: null
            };
          }
          function basicStateReducer(state3, action2) {
            return typeof action2 === "function" ? action2(state3) : action2;
          }
          function mountReducer(reducer, initialArg, init3) {
            var hook = mountWorkInProgressHook();
            var initialState;
            if (init3 !== void 0) {
              initialState = init3(initialArg);
            } else {
              initialState = initialArg;
            }
            hook.memoizedState = hook.baseState = initialState;
            var queue = {
              pending: null,
              interleaved: null,
              lanes: NoLanes,
              dispatch: null,
              lastRenderedReducer: reducer,
              lastRenderedState: initialState
            };
            hook.queue = queue;
            var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);
            return [hook.memoizedState, dispatch];
          }
          function updateReducer(reducer, initialArg, init3) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (queue === null) {
              throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
            }
            queue.lastRenderedReducer = reducer;
            var current2 = currentHook;
            var baseQueue = current2.baseQueue;
            var pendingQueue = queue.pending;
            if (pendingQueue !== null) {
              if (baseQueue !== null) {
                var baseFirst = baseQueue.next;
                var pendingFirst = pendingQueue.next;
                baseQueue.next = pendingFirst;
                pendingQueue.next = baseFirst;
              }
              {
                if (current2.baseQueue !== baseQueue) {
                  error3("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
                }
              }
              current2.baseQueue = baseQueue = pendingQueue;
              queue.pending = null;
            }
            if (baseQueue !== null) {
              var first = baseQueue.next;
              var newState = current2.baseState;
              var newBaseState = null;
              var newBaseQueueFirst = null;
              var newBaseQueueLast = null;
              var update = first;
              do {
                var updateLane = update.lane;
                if (!isSubsetOfLanes(renderLanes, updateLane)) {
                  var clone2 = {
                    lane: updateLane,
                    action: update.action,
                    hasEagerState: update.hasEagerState,
                    eagerState: update.eagerState,
                    next: null
                  };
                  if (newBaseQueueLast === null) {
                    newBaseQueueFirst = newBaseQueueLast = clone2;
                    newBaseState = newState;
                  } else {
                    newBaseQueueLast = newBaseQueueLast.next = clone2;
                  }
                  currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
                  markSkippedUpdateLanes(updateLane);
                } else {
                  if (newBaseQueueLast !== null) {
                    var _clone = {
                      lane: NoLane,
                      action: update.action,
                      hasEagerState: update.hasEagerState,
                      eagerState: update.eagerState,
                      next: null
                    };
                    newBaseQueueLast = newBaseQueueLast.next = _clone;
                  }
                  if (update.hasEagerState) {
                    newState = update.eagerState;
                  } else {
                    var action2 = update.action;
                    newState = reducer(newState, action2);
                  }
                }
                update = update.next;
              } while (update !== null && update !== first);
              if (newBaseQueueLast === null) {
                newBaseState = newState;
              } else {
                newBaseQueueLast.next = newBaseQueueFirst;
              }
              if (!objectIs(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = newState;
              hook.baseState = newBaseState;
              hook.baseQueue = newBaseQueueLast;
              queue.lastRenderedState = newState;
            }
            var lastInterleaved = queue.interleaved;
            if (lastInterleaved !== null) {
              var interleaved = lastInterleaved;
              do {
                var interleavedLane = interleaved.lane;
                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);
                markSkippedUpdateLanes(interleavedLane);
                interleaved = interleaved.next;
              } while (interleaved !== lastInterleaved);
            } else if (baseQueue === null) {
              queue.lanes = NoLanes;
            }
            var dispatch = queue.dispatch;
            return [hook.memoizedState, dispatch];
          }
          function rerenderReducer(reducer, initialArg, init3) {
            var hook = updateWorkInProgressHook();
            var queue = hook.queue;
            if (queue === null) {
              throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
            }
            queue.lastRenderedReducer = reducer;
            var dispatch = queue.dispatch;
            var lastRenderPhaseUpdate = queue.pending;
            var newState = hook.memoizedState;
            if (lastRenderPhaseUpdate !== null) {
              queue.pending = null;
              var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              var update = firstRenderPhaseUpdate;
              do {
                var action2 = update.action;
                newState = reducer(newState, action2);
                update = update.next;
              } while (update !== firstRenderPhaseUpdate);
              if (!objectIs(newState, hook.memoizedState)) {
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = newState;
              if (hook.baseQueue === null) {
                hook.baseState = newState;
              }
              queue.lastRenderedState = newState;
            }
            return [newState, dispatch];
          }
          function mountMutableSource(source, getSnapshot, subscribe) {
            {
              return void 0;
            }
          }
          function updateMutableSource(source, getSnapshot, subscribe) {
            {
              return void 0;
            }
          }
          function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var fiber = currentlyRenderingFiber$1;
            var hook = mountWorkInProgressHook();
            var nextSnapshot;
            var isHydrating2 = getIsHydrating();
            if (isHydrating2) {
              if (getServerSnapshot === void 0) {
                throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
              }
              nextSnapshot = getServerSnapshot();
              {
                if (!didWarnUncachedGetSnapshot) {
                  if (nextSnapshot !== getServerSnapshot()) {
                    error3("The result of getServerSnapshot should be cached to avoid an infinite loop");
                    didWarnUncachedGetSnapshot = true;
                  }
                }
              }
            } else {
              nextSnapshot = getSnapshot();
              {
                if (!didWarnUncachedGetSnapshot) {
                  var cachedSnapshot = getSnapshot();
                  if (!objectIs(nextSnapshot, cachedSnapshot)) {
                    error3("The result of getSnapshot should be cached to avoid an infinite loop");
                    didWarnUncachedGetSnapshot = true;
                  }
                }
              }
              var root2 = getWorkInProgressRoot();
              if (root2 === null) {
                throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
              }
              if (!includesBlockingLane(root2, renderLanes)) {
                pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
              }
            }
            hook.memoizedState = nextSnapshot;
            var inst = {
              value: nextSnapshot,
              getSnapshot
            };
            hook.queue = inst;
            mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
            fiber.flags |= Passive;
            pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
            return nextSnapshot;
          }
          function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            var fiber = currentlyRenderingFiber$1;
            var hook = updateWorkInProgressHook();
            var nextSnapshot = getSnapshot();
            {
              if (!didWarnUncachedGetSnapshot) {
                var cachedSnapshot = getSnapshot();
                if (!objectIs(nextSnapshot, cachedSnapshot)) {
                  error3("The result of getSnapshot should be cached to avoid an infinite loop");
                  didWarnUncachedGetSnapshot = true;
                }
              }
            }
            var prevSnapshot = hook.memoizedState;
            var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
            if (snapshotChanged) {
              hook.memoizedState = nextSnapshot;
              markWorkInProgressReceivedUpdate();
            }
            var inst = hook.queue;
            updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
            if (inst.getSnapshot !== getSnapshot || snapshotChanged || workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
              fiber.flags |= Passive;
              pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
              var root2 = getWorkInProgressRoot();
              if (root2 === null) {
                throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
              }
              if (!includesBlockingLane(root2, renderLanes)) {
                pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
              }
            }
            return nextSnapshot;
          }
          function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
            fiber.flags |= StoreConsistency;
            var check = {
              getSnapshot,
              value: renderedSnapshot
            };
            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
            if (componentUpdateQueue === null) {
              componentUpdateQueue = createFunctionComponentUpdateQueue();
              currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
              componentUpdateQueue.stores = [check];
            } else {
              var stores = componentUpdateQueue.stores;
              if (stores === null) {
                componentUpdateQueue.stores = [check];
              } else {
                stores.push(check);
              }
            }
          }
          function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
            inst.value = nextSnapshot;
            inst.getSnapshot = getSnapshot;
            if (checkIfSnapshotChanged(inst)) {
              forceStoreRerender(fiber);
            }
          }
          function subscribeToStore(fiber, inst, subscribe) {
            var handleStoreChange = function() {
              if (checkIfSnapshotChanged(inst)) {
                forceStoreRerender(fiber);
              }
            };
            return subscribe(handleStoreChange);
          }
          function checkIfSnapshotChanged(inst) {
            var latestGetSnapshot = inst.getSnapshot;
            var prevValue = inst.value;
            try {
              var nextValue = latestGetSnapshot();
              return !objectIs(prevValue, nextValue);
            } catch (error4) {
              return true;
            }
          }
          function forceStoreRerender(fiber) {
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          }
          function mountState(initialState) {
            var hook = mountWorkInProgressHook();
            if (typeof initialState === "function") {
              initialState = initialState();
            }
            hook.memoizedState = hook.baseState = initialState;
            var queue = {
              pending: null,
              interleaved: null,
              lanes: NoLanes,
              dispatch: null,
              lastRenderedReducer: basicStateReducer,
              lastRenderedState: initialState
            };
            hook.queue = queue;
            var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
            return [hook.memoizedState, dispatch];
          }
          function updateState(initialState) {
            return updateReducer(basicStateReducer);
          }
          function rerenderState(initialState) {
            return rerenderReducer(basicStateReducer);
          }
          function pushEffect(tag, create6, destroy, deps) {
            var effect = {
              tag,
              create: create6,
              destroy,
              deps,
              next: null
            };
            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
            if (componentUpdateQueue === null) {
              componentUpdateQueue = createFunctionComponentUpdateQueue();
              currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
              componentUpdateQueue.lastEffect = effect.next = effect;
            } else {
              var lastEffect = componentUpdateQueue.lastEffect;
              if (lastEffect === null) {
                componentUpdateQueue.lastEffect = effect.next = effect;
              } else {
                var firstEffect = lastEffect.next;
                lastEffect.next = effect;
                effect.next = firstEffect;
                componentUpdateQueue.lastEffect = effect;
              }
            }
            return effect;
          }
          function mountRef(initialValue) {
            var hook = mountWorkInProgressHook();
            {
              var _ref2 = {
                current: initialValue
              };
              hook.memoizedState = _ref2;
              return _ref2;
            }
          }
          function updateRef(initialValue) {
            var hook = updateWorkInProgressHook();
            return hook.memoizedState;
          }
          function mountEffectImpl(fiberFlags, hookFlags, create6, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create6, void 0, nextDeps);
          }
          function updateEffectImpl(fiberFlags, hookFlags, create6, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var destroy = void 0;
            if (currentHook !== null) {
              var prevEffect = currentHook.memoizedState;
              destroy = prevEffect.destroy;
              if (nextDeps !== null) {
                var prevDeps = prevEffect.deps;
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  hook.memoizedState = pushEffect(hookFlags, create6, destroy, nextDeps);
                  return;
                }
              }
            }
            currentlyRenderingFiber$1.flags |= fiberFlags;
            hook.memoizedState = pushEffect(HasEffect | hookFlags, create6, destroy, nextDeps);
          }
          function mountEffect(create6, deps) {
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
              return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create6, deps);
            } else {
              return mountEffectImpl(Passive | PassiveStatic, Passive$1, create6, deps);
            }
          }
          function updateEffect(create6, deps) {
            return updateEffectImpl(Passive, Passive$1, create6, deps);
          }
          function mountInsertionEffect(create6, deps) {
            return mountEffectImpl(Update, Insertion, create6, deps);
          }
          function updateInsertionEffect(create6, deps) {
            return updateEffectImpl(Update, Insertion, create6, deps);
          }
          function mountLayoutEffect(create6, deps) {
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            return mountEffectImpl(fiberFlags, Layout, create6, deps);
          }
          function updateLayoutEffect(create6, deps) {
            return updateEffectImpl(Update, Layout, create6, deps);
          }
          function imperativeHandleEffect(create6, ref) {
            if (typeof ref === "function") {
              var refCallback = ref;
              var _inst = create6();
              refCallback(_inst);
              return function() {
                refCallback(null);
              };
            } else if (ref !== null && ref !== void 0) {
              var refObject = ref;
              {
                if (!refObject.hasOwnProperty("current")) {
                  error3("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
                }
              }
              var _inst2 = create6();
              refObject.current = _inst2;
              return function() {
                refObject.current = null;
              };
            }
          }
          function mountImperativeHandle(ref, create6, deps) {
            {
              if (typeof create6 !== "function") {
                error3("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create6 !== null ? typeof create6 : "null");
              }
            }
            var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create6, ref), effectDeps);
          }
          function updateImperativeHandle(ref, create6, deps) {
            {
              if (typeof create6 !== "function") {
                error3("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create6 !== null ? typeof create6 : "null");
              }
            }
            var effectDeps = deps !== null && deps !== void 0 ? deps.concat([ref]) : null;
            return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create6, ref), effectDeps);
          }
          function mountDebugValue(value13, formatterFn) {
          }
          var updateDebugValue = mountDebugValue;
          function mountCallback(callback, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            hook.memoizedState = [callback, nextDeps];
            return callback;
          }
          function updateCallback(callback, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
            hook.memoizedState = [callback, nextDeps];
            return callback;
          }
          function mountMemo(nextCreate, deps) {
            var hook = mountWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function updateMemo(nextCreate, deps) {
            var hook = updateWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            var prevState = hook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
            var nextValue = nextCreate();
            hook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function mountDeferredValue(value13) {
            var hook = mountWorkInProgressHook();
            hook.memoizedState = value13;
            return value13;
          }
          function updateDeferredValue(value13) {
            var hook = updateWorkInProgressHook();
            var resolvedCurrentHook = currentHook;
            var prevValue = resolvedCurrentHook.memoizedState;
            return updateDeferredValueImpl(hook, prevValue, value13);
          }
          function rerenderDeferredValue(value13) {
            var hook = updateWorkInProgressHook();
            if (currentHook === null) {
              hook.memoizedState = value13;
              return value13;
            } else {
              var prevValue = currentHook.memoizedState;
              return updateDeferredValueImpl(hook, prevValue, value13);
            }
          }
          function updateDeferredValueImpl(hook, prevValue, value13) {
            var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);
            if (shouldDeferValue) {
              if (!objectIs(value13, prevValue)) {
                var deferredLane = claimNextTransitionLane();
                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);
                markSkippedUpdateLanes(deferredLane);
                hook.baseState = true;
              }
              return prevValue;
            } else {
              if (hook.baseState) {
                hook.baseState = false;
                markWorkInProgressReceivedUpdate();
              }
              hook.memoizedState = value13;
              return value13;
            }
          }
          function startTransition(setPending, callback, options3) {
            var previousPriority = getCurrentUpdatePriority();
            setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));
            setPending(true);
            var prevTransition = ReactCurrentBatchConfig$2.transition;
            ReactCurrentBatchConfig$2.transition = {};
            var currentTransition = ReactCurrentBatchConfig$2.transition;
            {
              ReactCurrentBatchConfig$2.transition._updatedFibers = /* @__PURE__ */ new Set();
            }
            try {
              setPending(false);
              callback();
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$2.transition = prevTransition;
              {
                if (prevTransition === null && currentTransition._updatedFibers) {
                  var updatedFibersCount = currentTransition._updatedFibers.size;
                  if (updatedFibersCount > 10) {
                    warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.");
                  }
                  currentTransition._updatedFibers.clear();
                }
              }
            }
          }
          function mountTransition() {
            var _mountState = mountState(false), isPending = _mountState[0], setPending = _mountState[1];
            var start2 = startTransition.bind(null, setPending);
            var hook = mountWorkInProgressHook();
            hook.memoizedState = start2;
            return [isPending, start2];
          }
          function updateTransition() {
            var _updateState = updateState(), isPending = _updateState[0];
            var hook = updateWorkInProgressHook();
            var start2 = hook.memoizedState;
            return [isPending, start2];
          }
          function rerenderTransition() {
            var _rerenderState = rerenderState(), isPending = _rerenderState[0];
            var hook = updateWorkInProgressHook();
            var start2 = hook.memoizedState;
            return [isPending, start2];
          }
          var isUpdatingOpaqueValueInRenderPhase = false;
          function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
            {
              return isUpdatingOpaqueValueInRenderPhase;
            }
          }
          function mountId() {
            var hook = mountWorkInProgressHook();
            var root2 = getWorkInProgressRoot();
            var identifierPrefix = root2.identifierPrefix;
            var id2;
            if (getIsHydrating()) {
              var treeId = getTreeId();
              id2 = ":" + identifierPrefix + "R" + treeId;
              var localId = localIdCounter++;
              if (localId > 0) {
                id2 += "H" + localId.toString(32);
              }
              id2 += ":";
            } else {
              var globalClientId = globalClientIdCounter++;
              id2 = ":" + identifierPrefix + "r" + globalClientId.toString(32) + ":";
            }
            hook.memoizedState = id2;
            return id2;
          }
          function updateId() {
            var hook = updateWorkInProgressHook();
            var id2 = hook.memoizedState;
            return id2;
          }
          function dispatchReducerAction(fiber, queue, action2) {
            {
              if (typeof arguments[3] === "function") {
                error3("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
              }
            }
            var lane = requestUpdateLane(fiber);
            var update = {
              lane,
              action: action2,
              hasEagerState: false,
              eagerState: null,
              next: null
            };
            if (isRenderPhaseUpdate(fiber)) {
              enqueueRenderPhaseUpdate(queue, update);
            } else {
              var root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
              if (root2 !== null) {
                var eventTime = requestEventTime();
                scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
                entangleTransitionUpdate(root2, queue, lane);
              }
            }
            markUpdateInDevTools(fiber, lane);
          }
          function dispatchSetState(fiber, queue, action2) {
            {
              if (typeof arguments[3] === "function") {
                error3("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
              }
            }
            var lane = requestUpdateLane(fiber);
            var update = {
              lane,
              action: action2,
              hasEagerState: false,
              eagerState: null,
              next: null
            };
            if (isRenderPhaseUpdate(fiber)) {
              enqueueRenderPhaseUpdate(queue, update);
            } else {
              var alternate = fiber.alternate;
              if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
                var lastRenderedReducer = queue.lastRenderedReducer;
                if (lastRenderedReducer !== null) {
                  var prevDispatcher;
                  {
                    prevDispatcher = ReactCurrentDispatcher$1.current;
                    ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                  }
                  try {
                    var currentState = queue.lastRenderedState;
                    var eagerState = lastRenderedReducer(currentState, action2);
                    update.hasEagerState = true;
                    update.eagerState = eagerState;
                    if (objectIs(eagerState, currentState)) {
                      enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane);
                      return;
                    }
                  } catch (error4) {
                  } finally {
                    {
                      ReactCurrentDispatcher$1.current = prevDispatcher;
                    }
                  }
                }
              }
              var root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
              if (root2 !== null) {
                var eventTime = requestEventTime();
                scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
                entangleTransitionUpdate(root2, queue, lane);
              }
            }
            markUpdateInDevTools(fiber, lane);
          }
          function isRenderPhaseUpdate(fiber) {
            var alternate = fiber.alternate;
            return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
          }
          function enqueueRenderPhaseUpdate(queue, update) {
            didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
            var pending = queue.pending;
            if (pending === null) {
              update.next = update;
            } else {
              update.next = pending.next;
              pending.next = update;
            }
            queue.pending = update;
          }
          function entangleTransitionUpdate(root2, queue, lane) {
            if (isTransitionLane(lane)) {
              var queueLanes = queue.lanes;
              queueLanes = intersectLanes(queueLanes, root2.pendingLanes);
              var newQueueLanes = mergeLanes(queueLanes, lane);
              queue.lanes = newQueueLanes;
              markRootEntangled(root2, newQueueLanes);
            }
          }
          function markUpdateInDevTools(fiber, lane, action2) {
            {
              markStateUpdateScheduled(fiber, lane);
            }
          }
          var ContextOnlyDispatcher = {
            readContext,
            useCallback: throwInvalidHookError,
            useContext: throwInvalidHookError,
            useEffect: throwInvalidHookError,
            useImperativeHandle: throwInvalidHookError,
            useInsertionEffect: throwInvalidHookError,
            useLayoutEffect: throwInvalidHookError,
            useMemo: throwInvalidHookError,
            useReducer: throwInvalidHookError,
            useRef: throwInvalidHookError,
            useState: throwInvalidHookError,
            useDebugValue: throwInvalidHookError,
            useDeferredValue: throwInvalidHookError,
            useTransition: throwInvalidHookError,
            useMutableSource: throwInvalidHookError,
            useSyncExternalStore: throwInvalidHookError,
            useId: throwInvalidHookError,
            unstable_isNewReconciler: enableNewReconciler
          };
          var HooksDispatcherOnMountInDEV = null;
          var HooksDispatcherOnMountWithHookTypesInDEV = null;
          var HooksDispatcherOnUpdateInDEV = null;
          var HooksDispatcherOnRerenderInDEV = null;
          var InvalidNestedHooksDispatcherOnMountInDEV = null;
          var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
          var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
          {
            var warnInvalidContextAccess = function() {
              error3("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            };
            var warnInvalidHookAccess = function() {
              error3("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            };
            HooksDispatcherOnMountInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                mountHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create6, deps) {
                currentHookNameInDev = "useEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountEffect(create6, deps);
              },
              useImperativeHandle: function(ref, create6, deps) {
                currentHookNameInDev = "useImperativeHandle";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountImperativeHandle(ref, create6, deps);
              },
              useInsertionEffect: function(create6, deps) {
                currentHookNameInDev = "useInsertionEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountInsertionEffect(create6, deps);
              },
              useLayoutEffect: function(create6, deps) {
                currentHookNameInDev = "useLayoutEffect";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                return mountLayoutEffect(create6, deps);
              },
              useMemo: function(create6, deps) {
                currentHookNameInDev = "useMemo";
                mountHookTypesDev();
                checkDepsAreArrayDev(deps);
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create6, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init3) {
                currentHookNameInDev = "useReducer";
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init3);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                mountHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value13, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                mountHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value13) {
                currentHookNameInDev = "useDeferredValue";
                mountHookTypesDev();
                return mountDeferredValue(value13);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                mountHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                mountHookTypesDev();
                return mountMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                mountHookTypesDev();
                return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                mountHookTypesDev();
                return mountId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnMountWithHookTypesInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return mountCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create6, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return mountEffect(create6, deps);
              },
              useImperativeHandle: function(ref, create6, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return mountImperativeHandle(ref, create6, deps);
              },
              useInsertionEffect: function(create6, deps) {
                currentHookNameInDev = "useInsertionEffect";
                updateHookTypesDev();
                return mountInsertionEffect(create6, deps);
              },
              useLayoutEffect: function(create6, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return mountLayoutEffect(create6, deps);
              },
              useMemo: function(create6, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create6, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init3) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init3);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value13, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value13) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return mountDeferredValue(value13);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return mountMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                updateHookTypesDev();
                return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                updateHookTypesDev();
                return mountId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnUpdateInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create6, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return updateEffect(create6, deps);
              },
              useImperativeHandle: function(ref, create6, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return updateImperativeHandle(ref, create6, deps);
              },
              useInsertionEffect: function(create6, deps) {
                currentHookNameInDev = "useInsertionEffect";
                updateHookTypesDev();
                return updateInsertionEffect(create6, deps);
              },
              useLayoutEffect: function(create6, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return updateLayoutEffect(create6, deps);
              },
              useMemo: function(create6, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create6, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init3) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateReducer(reducer, initialArg, init3);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value13, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value13) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return updateDeferredValue(value13);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return updateTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            HooksDispatcherOnRerenderInDEV = {
              readContext: function(context) {
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create6, deps) {
                currentHookNameInDev = "useEffect";
                updateHookTypesDev();
                return updateEffect(create6, deps);
              },
              useImperativeHandle: function(ref, create6, deps) {
                currentHookNameInDev = "useImperativeHandle";
                updateHookTypesDev();
                return updateImperativeHandle(ref, create6, deps);
              },
              useInsertionEffect: function(create6, deps) {
                currentHookNameInDev = "useInsertionEffect";
                updateHookTypesDev();
                return updateInsertionEffect(create6, deps);
              },
              useLayoutEffect: function(create6, deps) {
                currentHookNameInDev = "useLayoutEffect";
                updateHookTypesDev();
                return updateLayoutEffect(create6, deps);
              },
              useMemo: function(create6, deps) {
                currentHookNameInDev = "useMemo";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return updateMemo(create6, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init3) {
                currentHookNameInDev = "useReducer";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return rerenderReducer(reducer, initialArg, init3);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
                try {
                  return rerenderState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value13, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value13) {
                currentHookNameInDev = "useDeferredValue";
                updateHookTypesDev();
                return rerenderDeferredValue(value13);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                updateHookTypesDev();
                return rerenderTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnMountInDEV = {
              readContext: function(context) {
                warnInvalidContextAccess();
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create6, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountEffect(create6, deps);
              },
              useImperativeHandle: function(ref, create6, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountImperativeHandle(ref, create6, deps);
              },
              useInsertionEffect: function(create6, deps) {
                currentHookNameInDev = "useInsertionEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountInsertionEffect(create6, deps);
              },
              useLayoutEffect: function(create6, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountLayoutEffect(create6, deps);
              },
              useMemo: function(create6, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountMemo(create6, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init3) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountReducer(reducer, initialArg, init3);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountRef(initialValue);
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                mountHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
                try {
                  return mountState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value13, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountDebugValue();
              },
              useDeferredValue: function(value13) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountDeferredValue(value13);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                warnInvalidHookAccess();
                mountHookTypesDev();
                return mountId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnUpdateInDEV = {
              readContext: function(context) {
                warnInvalidContextAccess();
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create6, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateEffect(create6, deps);
              },
              useImperativeHandle: function(ref, create6, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateImperativeHandle(ref, create6, deps);
              },
              useInsertionEffect: function(create6, deps) {
                currentHookNameInDev = "useInsertionEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateInsertionEffect(create6, deps);
              },
              useLayoutEffect: function(create6, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateLayoutEffect(create6, deps);
              },
              useMemo: function(create6, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create6, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init3) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateReducer(reducer, initialArg, init3);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value13, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value13) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDeferredValue(value13);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
            InvalidNestedHooksDispatcherOnRerenderInDEV = {
              readContext: function(context) {
                warnInvalidContextAccess();
                return readContext(context);
              },
              useCallback: function(callback, deps) {
                currentHookNameInDev = "useCallback";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateCallback(callback, deps);
              },
              useContext: function(context) {
                currentHookNameInDev = "useContext";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return readContext(context);
              },
              useEffect: function(create6, deps) {
                currentHookNameInDev = "useEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateEffect(create6, deps);
              },
              useImperativeHandle: function(ref, create6, deps) {
                currentHookNameInDev = "useImperativeHandle";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateImperativeHandle(ref, create6, deps);
              },
              useInsertionEffect: function(create6, deps) {
                currentHookNameInDev = "useInsertionEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateInsertionEffect(create6, deps);
              },
              useLayoutEffect: function(create6, deps) {
                currentHookNameInDev = "useLayoutEffect";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateLayoutEffect(create6, deps);
              },
              useMemo: function(create6, deps) {
                currentHookNameInDev = "useMemo";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return updateMemo(create6, deps);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useReducer: function(reducer, initialArg, init3) {
                currentHookNameInDev = "useReducer";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return rerenderReducer(reducer, initialArg, init3);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useRef: function(initialValue) {
                currentHookNameInDev = "useRef";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateRef();
              },
              useState: function(initialState) {
                currentHookNameInDev = "useState";
                warnInvalidHookAccess();
                updateHookTypesDev();
                var prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
                try {
                  return rerenderState(initialState);
                } finally {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              },
              useDebugValue: function(value13, formatterFn) {
                currentHookNameInDev = "useDebugValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateDebugValue();
              },
              useDeferredValue: function(value13) {
                currentHookNameInDev = "useDeferredValue";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderDeferredValue(value13);
              },
              useTransition: function() {
                currentHookNameInDev = "useTransition";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return rerenderTransition();
              },
              useMutableSource: function(source, getSnapshot, subscribe) {
                currentHookNameInDev = "useMutableSource";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateMutableSource();
              },
              useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
                currentHookNameInDev = "useSyncExternalStore";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateSyncExternalStore(subscribe, getSnapshot);
              },
              useId: function() {
                currentHookNameInDev = "useId";
                warnInvalidHookAccess();
                updateHookTypesDev();
                return updateId();
              },
              unstable_isNewReconciler: enableNewReconciler
            };
          }
          var now$1 = Scheduler.unstable_now;
          var commitTime = 0;
          var layoutEffectStartTime = -1;
          var profilerStartTime = -1;
          var passiveEffectStartTime = -1;
          var currentUpdateIsNested = false;
          var nestedUpdateScheduled = false;
          function isCurrentUpdateNested() {
            return currentUpdateIsNested;
          }
          function markNestedUpdateScheduled() {
            {
              nestedUpdateScheduled = true;
            }
          }
          function resetNestedUpdateFlag() {
            {
              currentUpdateIsNested = false;
              nestedUpdateScheduled = false;
            }
          }
          function syncNestedUpdateFlag() {
            {
              currentUpdateIsNested = nestedUpdateScheduled;
              nestedUpdateScheduled = false;
            }
          }
          function getCommitTime() {
            return commitTime;
          }
          function recordCommitTime() {
            commitTime = now$1();
          }
          function startProfilerTimer(fiber) {
            profilerStartTime = now$1();
            if (fiber.actualStartTime < 0) {
              fiber.actualStartTime = now$1();
            }
          }
          function stopProfilerTimerIfRunning(fiber) {
            profilerStartTime = -1;
          }
          function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
            if (profilerStartTime >= 0) {
              var elapsedTime = now$1() - profilerStartTime;
              fiber.actualDuration += elapsedTime;
              if (overrideBaseTime) {
                fiber.selfBaseDuration = elapsedTime;
              }
              profilerStartTime = -1;
            }
          }
          function recordLayoutEffectDuration(fiber) {
            if (layoutEffectStartTime >= 0) {
              var elapsedTime = now$1() - layoutEffectStartTime;
              layoutEffectStartTime = -1;
              var parentFiber = fiber.return;
              while (parentFiber !== null) {
                switch (parentFiber.tag) {
                  case HostRoot:
                    var root2 = parentFiber.stateNode;
                    root2.effectDuration += elapsedTime;
                    return;
                  case Profiler:
                    var parentStateNode = parentFiber.stateNode;
                    parentStateNode.effectDuration += elapsedTime;
                    return;
                }
                parentFiber = parentFiber.return;
              }
            }
          }
          function recordPassiveEffectDuration(fiber) {
            if (passiveEffectStartTime >= 0) {
              var elapsedTime = now$1() - passiveEffectStartTime;
              passiveEffectStartTime = -1;
              var parentFiber = fiber.return;
              while (parentFiber !== null) {
                switch (parentFiber.tag) {
                  case HostRoot:
                    var root2 = parentFiber.stateNode;
                    if (root2 !== null) {
                      root2.passiveEffectDuration += elapsedTime;
                    }
                    return;
                  case Profiler:
                    var parentStateNode = parentFiber.stateNode;
                    if (parentStateNode !== null) {
                      parentStateNode.passiveEffectDuration += elapsedTime;
                    }
                    return;
                }
                parentFiber = parentFiber.return;
              }
            }
          }
          function startLayoutEffectTimer() {
            layoutEffectStartTime = now$1();
          }
          function startPassiveEffectTimer() {
            passiveEffectStartTime = now$1();
          }
          function transferActualDuration(fiber) {
            var child = fiber.child;
            while (child) {
              fiber.actualDuration += child.actualDuration;
              child = child.sibling;
            }
          }
          function createCapturedValueAtFiber(value13, source) {
            return {
              value: value13,
              source,
              stack: getStackByFiberInDevAndProd(source),
              digest: null
            };
          }
          function createCapturedValue(value13, digest, stack) {
            return {
              value: value13,
              source: null,
              stack: stack != null ? stack : null,
              digest: digest != null ? digest : null
            };
          }
          function showErrorDialog(boundary, errorInfo) {
            return true;
          }
          function logCapturedError(boundary, errorInfo) {
            try {
              var logError = showErrorDialog(boundary, errorInfo);
              if (logError === false) {
                return;
              }
              var error4 = errorInfo.value;
              if (true) {
                var source = errorInfo.source;
                var stack = errorInfo.stack;
                var componentStack = stack !== null ? stack : "";
                if (error4 != null && error4._suppressLogging) {
                  if (boundary.tag === ClassComponent) {
                    return;
                  }
                  console["error"](error4);
                }
                var componentName = source ? getComponentNameFromFiber(source) : null;
                var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
                var errorBoundaryMessage;
                if (boundary.tag === HostRoot) {
                  errorBoundaryMessage = "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
                } else {
                  var errorBoundaryName = getComponentNameFromFiber(boundary) || "Anonymous";
                  errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
                }
                var combinedMessage = componentNameMessage + "\n" + componentStack + "\n\n" + ("" + errorBoundaryMessage);
                console["error"](combinedMessage);
              } else {
                console["error"](error4);
              }
            } catch (e) {
              setTimeout(function() {
                throw e;
              });
            }
          }
          var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
          function createRootErrorUpdate(fiber, errorInfo, lane) {
            var update = createUpdate(NoTimestamp, lane);
            update.tag = CaptureUpdate;
            update.payload = {
              element: null
            };
            var error4 = errorInfo.value;
            update.callback = function() {
              onUncaughtError(error4);
              logCapturedError(fiber, errorInfo);
            };
            return update;
          }
          function createClassErrorUpdate(fiber, errorInfo, lane) {
            var update = createUpdate(NoTimestamp, lane);
            update.tag = CaptureUpdate;
            var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
            if (typeof getDerivedStateFromError === "function") {
              var error$1 = errorInfo.value;
              update.payload = function() {
                return getDerivedStateFromError(error$1);
              };
              update.callback = function() {
                {
                  markFailedErrorBoundaryForHotReloading(fiber);
                }
                logCapturedError(fiber, errorInfo);
              };
            }
            var inst = fiber.stateNode;
            if (inst !== null && typeof inst.componentDidCatch === "function") {
              update.callback = function callback() {
                {
                  markFailedErrorBoundaryForHotReloading(fiber);
                }
                logCapturedError(fiber, errorInfo);
                if (typeof getDerivedStateFromError !== "function") {
                  markLegacyErrorBoundaryAsFailed(this);
                }
                var error$12 = errorInfo.value;
                var stack = errorInfo.stack;
                this.componentDidCatch(error$12, {
                  componentStack: stack !== null ? stack : ""
                });
                {
                  if (typeof getDerivedStateFromError !== "function") {
                    if (!includesSomeLane(fiber.lanes, SyncLane)) {
                      error3("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
                    }
                  }
                }
              };
            }
            return update;
          }
          function attachPingListener(root2, wakeable, lanes) {
            var pingCache = root2.pingCache;
            var threadIDs;
            if (pingCache === null) {
              pingCache = root2.pingCache = new PossiblyWeakMap$1();
              threadIDs = /* @__PURE__ */ new Set();
              pingCache.set(wakeable, threadIDs);
            } else {
              threadIDs = pingCache.get(wakeable);
              if (threadIDs === void 0) {
                threadIDs = /* @__PURE__ */ new Set();
                pingCache.set(wakeable, threadIDs);
              }
            }
            if (!threadIDs.has(lanes)) {
              threadIDs.add(lanes);
              var ping = pingSuspendedRoot.bind(null, root2, wakeable, lanes);
              {
                if (isDevToolsPresent) {
                  restorePendingUpdaters(root2, lanes);
                }
              }
              wakeable.then(ping, ping);
            }
          }
          function attachRetryListener(suspenseBoundary, root2, wakeable, lanes) {
            var wakeables = suspenseBoundary.updateQueue;
            if (wakeables === null) {
              var updateQueue = /* @__PURE__ */ new Set();
              updateQueue.add(wakeable);
              suspenseBoundary.updateQueue = updateQueue;
            } else {
              wakeables.add(wakeable);
            }
          }
          function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
            var tag = sourceFiber.tag;
            if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {
              var currentSource = sourceFiber.alternate;
              if (currentSource) {
                sourceFiber.updateQueue = currentSource.updateQueue;
                sourceFiber.memoizedState = currentSource.memoizedState;
                sourceFiber.lanes = currentSource.lanes;
              } else {
                sourceFiber.updateQueue = null;
                sourceFiber.memoizedState = null;
              }
            }
          }
          function getNearestSuspenseBoundaryToCapture(returnFiber) {
            var node = returnFiber;
            do {
              if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {
                return node;
              }
              node = node.return;
            } while (node !== null);
            return null;
          }
          function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes) {
            if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
              if (suspenseBoundary === returnFiber) {
                suspenseBoundary.flags |= ShouldCapture;
              } else {
                suspenseBoundary.flags |= DidCapture;
                sourceFiber.flags |= ForceUpdateForLegacySuspense;
                sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
                if (sourceFiber.tag === ClassComponent) {
                  var currentSourceFiber = sourceFiber.alternate;
                  if (currentSourceFiber === null) {
                    sourceFiber.tag = IncompleteClassComponent;
                  } else {
                    var update = createUpdate(NoTimestamp, SyncLane);
                    update.tag = ForceUpdate;
                    enqueueUpdate(sourceFiber, update, SyncLane);
                  }
                }
                sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
              }
              return suspenseBoundary;
            }
            suspenseBoundary.flags |= ShouldCapture;
            suspenseBoundary.lanes = rootRenderLanes;
            return suspenseBoundary;
          }
          function throwException2(root2, returnFiber, sourceFiber, value13, rootRenderLanes) {
            sourceFiber.flags |= Incomplete;
            {
              if (isDevToolsPresent) {
                restorePendingUpdaters(root2, rootRenderLanes);
              }
            }
            if (value13 !== null && typeof value13 === "object" && typeof value13.then === "function") {
              var wakeable = value13;
              resetSuspendedComponent(sourceFiber);
              {
                if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                  markDidThrowWhileHydratingDEV();
                }
              }
              var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
              if (suspenseBoundary !== null) {
                suspenseBoundary.flags &= ~ForceClientRender;
                markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);
                if (suspenseBoundary.mode & ConcurrentMode) {
                  attachPingListener(root2, wakeable, rootRenderLanes);
                }
                attachRetryListener(suspenseBoundary, root2, wakeable);
                return;
              } else {
                if (!includesSyncLane(rootRenderLanes)) {
                  attachPingListener(root2, wakeable, rootRenderLanes);
                  renderDidSuspendDelayIfPossible();
                  return;
                }
                var uncaughtSuspenseError = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
                value13 = uncaughtSuspenseError;
              }
            } else {
              if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
                markDidThrowWhileHydratingDEV();
                var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
                if (_suspenseBoundary !== null) {
                  if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {
                    _suspenseBoundary.flags |= ForceClientRender;
                  }
                  markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);
                  queueHydrationError(createCapturedValueAtFiber(value13, sourceFiber));
                  return;
                }
              }
            }
            value13 = createCapturedValueAtFiber(value13, sourceFiber);
            renderDidError(value13);
            var workInProgress2 = returnFiber;
            do {
              switch (workInProgress2.tag) {
                case HostRoot: {
                  var _errorInfo = value13;
                  workInProgress2.flags |= ShouldCapture;
                  var lane = pickArbitraryLane(rootRenderLanes);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                  var update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
                  enqueueCapturedUpdate(workInProgress2, update);
                  return;
                }
                case ClassComponent:
                  var errorInfo = value13;
                  var ctor = workInProgress2.type;
                  var instance = workInProgress2.stateNode;
                  if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                    workInProgress2.flags |= ShouldCapture;
                    var _lane = pickArbitraryLane(rootRenderLanes);
                    workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                    var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                    enqueueCapturedUpdate(workInProgress2, _update);
                    return;
                  }
                  break;
              }
              workInProgress2 = workInProgress2.return;
            } while (workInProgress2 !== null);
          }
          function getSuspendedCache() {
            {
              return null;
            }
          }
          var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
          var didReceiveUpdate = false;
          var didWarnAboutBadClass;
          var didWarnAboutModulePatternComponent;
          var didWarnAboutContextTypeOnFunctionComponent;
          var didWarnAboutGetDerivedStateOnFunctionComponent;
          var didWarnAboutFunctionRefs;
          var didWarnAboutReassigningProps;
          var didWarnAboutRevealOrder;
          var didWarnAboutTailOptions;
          {
            didWarnAboutBadClass = {};
            didWarnAboutModulePatternComponent = {};
            didWarnAboutContextTypeOnFunctionComponent = {};
            didWarnAboutGetDerivedStateOnFunctionComponent = {};
            didWarnAboutFunctionRefs = {};
            didWarnAboutReassigningProps = false;
            didWarnAboutRevealOrder = {};
            didWarnAboutTailOptions = {};
          }
          function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
            if (current2 === null) {
              workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            } else {
              workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
            }
          }
          function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
            workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          }
          function updateForwardRef(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component2.propTypes;
                if (innerPropTypes) {
                  checkPropTypes3(
                    innerPropTypes,
                    nextProps,
                    "prop",
                    getComponentNameFromType(Component2)
                  );
                }
              }
            }
            var render3 = Component2.render;
            var ref = workInProgress2.ref;
            var nextChildren;
            var hasId;
            prepareToReadContext(workInProgress2, renderLanes2);
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              nextChildren = renderWithHooks(current2, workInProgress2, render3, nextProps, ref, renderLanes2);
              hasId = checkDidRenderIdHook();
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  nextChildren = renderWithHooks(current2, workInProgress2, render3, nextProps, ref, renderLanes2);
                  hasId = checkDidRenderIdHook();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            if (current2 !== null && !didReceiveUpdate) {
              bailoutHooks(current2, workInProgress2, renderLanes2);
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            if (getIsHydrating() && hasId) {
              pushMaterializedTreeId(workInProgress2);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateMemoComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            if (current2 === null) {
              var type = Component2.type;
              if (isSimpleFunctionComponent(type) && Component2.compare === null && Component2.defaultProps === void 0) {
                var resolvedType = type;
                {
                  resolvedType = resolveFunctionForHotReloading(type);
                }
                workInProgress2.tag = SimpleMemoComponent;
                workInProgress2.type = resolvedType;
                {
                  validateFunctionComponentInDev(workInProgress2, type);
                }
                return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, renderLanes2);
              }
              {
                var innerPropTypes = type.propTypes;
                if (innerPropTypes) {
                  checkPropTypes3(
                    innerPropTypes,
                    nextProps,
                    "prop",
                    getComponentNameFromType(type)
                  );
                }
              }
              var child = createFiberFromTypeAndProps(Component2.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
              child.ref = workInProgress2.ref;
              child.return = workInProgress2;
              workInProgress2.child = child;
              return child;
            }
            {
              var _type = Component2.type;
              var _innerPropTypes = _type.propTypes;
              if (_innerPropTypes) {
                checkPropTypes3(
                  _innerPropTypes,
                  nextProps,
                  "prop",
                  getComponentNameFromType(_type)
                );
              }
            }
            var currentChild = current2.child;
            var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
            if (!hasScheduledUpdateOrContext) {
              var prevProps = currentChild.memoizedProps;
              var compare2 = Component2.compare;
              compare2 = compare2 !== null ? compare2 : shallowEqual;
              if (compare2(prevProps, nextProps) && current2.ref === workInProgress2.ref) {
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              }
            }
            workInProgress2.flags |= PerformedWork;
            var newChild = createWorkInProgress(currentChild, nextProps);
            newChild.ref = workInProgress2.ref;
            newChild.return = workInProgress2;
            workInProgress2.child = newChild;
            return newChild;
          }
          function updateSimpleMemoComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var outerMemoType = workInProgress2.elementType;
                if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
                  var lazyComponent = outerMemoType;
                  var payload = lazyComponent._payload;
                  var init3 = lazyComponent._init;
                  try {
                    outerMemoType = init3(payload);
                  } catch (x) {
                    outerMemoType = null;
                  }
                  var outerPropTypes = outerMemoType && outerMemoType.propTypes;
                  if (outerPropTypes) {
                    checkPropTypes3(
                      outerPropTypes,
                      nextProps,
                      "prop",
                      getComponentNameFromType(outerMemoType)
                    );
                  }
                }
              }
            }
            if (current2 !== null) {
              var prevProps = current2.memoizedProps;
              if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type) {
                didReceiveUpdate = false;
                workInProgress2.pendingProps = nextProps = prevProps;
                if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
                  workInProgress2.lanes = current2.lanes;
                  return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                  didReceiveUpdate = true;
                }
              }
            }
            return updateFunctionComponent(current2, workInProgress2, Component2, nextProps, renderLanes2);
          }
          function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            var nextChildren = nextProps.children;
            var prevState = current2 !== null ? current2.memoizedState : null;
            if (nextProps.mode === "hidden" || enableLegacyHidden) {
              if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
                var nextState = {
                  baseLanes: NoLanes,
                  cachePool: null,
                  transitions: null
                };
                workInProgress2.memoizedState = nextState;
                pushRenderLanes(workInProgress2, renderLanes2);
              } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
                var spawnedCachePool = null;
                var nextBaseLanes;
                if (prevState !== null) {
                  var prevBaseLanes = prevState.baseLanes;
                  nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
                } else {
                  nextBaseLanes = renderLanes2;
                }
                workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
                var _nextState = {
                  baseLanes: nextBaseLanes,
                  cachePool: spawnedCachePool,
                  transitions: null
                };
                workInProgress2.memoizedState = _nextState;
                workInProgress2.updateQueue = null;
                pushRenderLanes(workInProgress2, nextBaseLanes);
                return null;
              } else {
                var _nextState2 = {
                  baseLanes: NoLanes,
                  cachePool: null,
                  transitions: null
                };
                workInProgress2.memoizedState = _nextState2;
                var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
                pushRenderLanes(workInProgress2, subtreeRenderLanes2);
              }
            } else {
              var _subtreeRenderLanes;
              if (prevState !== null) {
                _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);
                workInProgress2.memoizedState = null;
              } else {
                _subtreeRenderLanes = renderLanes2;
              }
              pushRenderLanes(workInProgress2, _subtreeRenderLanes);
            }
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateFragment(current2, workInProgress2, renderLanes2) {
            var nextChildren = workInProgress2.pendingProps;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateMode(current2, workInProgress2, renderLanes2) {
            var nextChildren = workInProgress2.pendingProps.children;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateProfiler(current2, workInProgress2, renderLanes2) {
            {
              workInProgress2.flags |= Update;
              {
                var stateNode = workInProgress2.stateNode;
                stateNode.effectDuration = 0;
                stateNode.passiveEffectDuration = 0;
              }
            }
            var nextProps = workInProgress2.pendingProps;
            var nextChildren = nextProps.children;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function markRef(current2, workInProgress2) {
            var ref = workInProgress2.ref;
            if (current2 === null && ref !== null || current2 !== null && current2.ref !== ref) {
              workInProgress2.flags |= Ref;
              {
                workInProgress2.flags |= RefStatic;
              }
            }
          }
          function updateFunctionComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component2.propTypes;
                if (innerPropTypes) {
                  checkPropTypes3(
                    innerPropTypes,
                    nextProps,
                    "prop",
                    getComponentNameFromType(Component2)
                  );
                }
              }
            }
            var context;
            {
              var unmaskedContext = getUnmaskedContext(workInProgress2, Component2, true);
              context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            var nextChildren;
            var hasId;
            prepareToReadContext(workInProgress2, renderLanes2);
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              nextChildren = renderWithHooks(current2, workInProgress2, Component2, nextProps, context, renderLanes2);
              hasId = checkDidRenderIdHook();
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(true);
                try {
                  nextChildren = renderWithHooks(current2, workInProgress2, Component2, nextProps, context, renderLanes2);
                  hasId = checkDidRenderIdHook();
                } finally {
                  setIsStrictModeForDevtools(false);
                }
              }
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            if (current2 !== null && !didReceiveUpdate) {
              bailoutHooks(current2, workInProgress2, renderLanes2);
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            if (getIsHydrating() && hasId) {
              pushMaterializedTreeId(workInProgress2);
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateClassComponent(current2, workInProgress2, Component2, nextProps, renderLanes2) {
            {
              switch (shouldError(workInProgress2)) {
                case false: {
                  var _instance = workInProgress2.stateNode;
                  var ctor = workInProgress2.type;
                  var tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context);
                  var state3 = tempInstance.state;
                  _instance.updater.enqueueSetState(_instance, state3, null);
                  break;
                }
                case true: {
                  workInProgress2.flags |= DidCapture;
                  workInProgress2.flags |= ShouldCapture;
                  var error$1 = new Error("Simulated error coming from DevTools");
                  var lane = pickArbitraryLane(renderLanes2);
                  workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
                  var update = createClassErrorUpdate(workInProgress2, createCapturedValueAtFiber(error$1, workInProgress2), lane);
                  enqueueCapturedUpdate(workInProgress2, update);
                  break;
                }
              }
              if (workInProgress2.type !== workInProgress2.elementType) {
                var innerPropTypes = Component2.propTypes;
                if (innerPropTypes) {
                  checkPropTypes3(
                    innerPropTypes,
                    nextProps,
                    "prop",
                    getComponentNameFromType(Component2)
                  );
                }
              }
            }
            var hasContext;
            if (isContextProvider(Component2)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var instance = workInProgress2.stateNode;
            var shouldUpdate;
            if (instance === null) {
              resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2);
              constructClassInstance(workInProgress2, Component2, nextProps);
              mountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
              shouldUpdate = true;
            } else if (current2 === null) {
              shouldUpdate = resumeMountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
            } else {
              shouldUpdate = updateClassInstance(current2, workInProgress2, Component2, nextProps, renderLanes2);
            }
            var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component2, shouldUpdate, hasContext, renderLanes2);
            {
              var inst = workInProgress2.stateNode;
              if (shouldUpdate && inst.props !== nextProps) {
                if (!didWarnAboutReassigningProps) {
                  error3("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component");
                }
                didWarnAboutReassigningProps = true;
              }
            }
            return nextUnitOfWork;
          }
          function finishClassComponent(current2, workInProgress2, Component2, shouldUpdate, hasContext, renderLanes2) {
            markRef(current2, workInProgress2);
            var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
            if (!shouldUpdate && !didCaptureError) {
              if (hasContext) {
                invalidateContextProvider(workInProgress2, Component2, false);
              }
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            }
            var instance = workInProgress2.stateNode;
            ReactCurrentOwner$1.current = workInProgress2;
            var nextChildren;
            if (didCaptureError && typeof Component2.getDerivedStateFromError !== "function") {
              nextChildren = null;
              {
                stopProfilerTimerIfRunning();
              }
            } else {
              {
                markComponentRenderStarted(workInProgress2);
              }
              {
                setIsRendering(true);
                nextChildren = instance.render();
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    instance.render();
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                setIsRendering(false);
              }
              {
                markComponentRenderStopped();
              }
            }
            workInProgress2.flags |= PerformedWork;
            if (current2 !== null && didCaptureError) {
              forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2);
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            workInProgress2.memoizedState = instance.state;
            if (hasContext) {
              invalidateContextProvider(workInProgress2, Component2, true);
            }
            return workInProgress2.child;
          }
          function pushHostRootContext(workInProgress2) {
            var root2 = workInProgress2.stateNode;
            if (root2.pendingContext) {
              pushTopLevelContextObject(workInProgress2, root2.pendingContext, root2.pendingContext !== root2.context);
            } else if (root2.context) {
              pushTopLevelContextObject(workInProgress2, root2.context, false);
            }
            pushHostContainer(workInProgress2, root2.containerInfo);
          }
          function updateHostRoot(current2, workInProgress2, renderLanes2) {
            pushHostRootContext(workInProgress2);
            if (current2 === null) {
              throw new Error("Should have a current fiber. This is a bug in React.");
            }
            var nextProps = workInProgress2.pendingProps;
            var prevState = workInProgress2.memoizedState;
            var prevChildren = prevState.element;
            cloneUpdateQueue(current2, workInProgress2);
            processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
            var nextState = workInProgress2.memoizedState;
            var root2 = workInProgress2.stateNode;
            var nextChildren = nextState.element;
            if (prevState.isDehydrated) {
              var overrideState = {
                element: nextChildren,
                isDehydrated: false,
                cache: nextState.cache,
                pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
                transitions: nextState.transitions
              };
              var updateQueue = workInProgress2.updateQueue;
              updateQueue.baseState = overrideState;
              workInProgress2.memoizedState = overrideState;
              if (workInProgress2.flags & ForceClientRender) {
                var recoverableError = createCapturedValueAtFiber(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), workInProgress2);
                return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError);
              } else if (nextChildren !== prevChildren) {
                var _recoverableError = createCapturedValueAtFiber(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress2);
                return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, _recoverableError);
              } else {
                enterHydrationState(workInProgress2);
                var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
                workInProgress2.child = child;
                var node = child;
                while (node) {
                  node.flags = node.flags & ~Placement | Hydrating;
                  node = node.sibling;
                }
              }
            } else {
              resetHydrationState();
              if (nextChildren === prevChildren) {
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              }
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            return workInProgress2.child;
          }
          function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError) {
            resetHydrationState();
            queueHydrationError(recoverableError);
            workInProgress2.flags |= ForceClientRender;
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateHostComponent(current2, workInProgress2, renderLanes2) {
            pushHostContext(workInProgress2);
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            var type = workInProgress2.type;
            var nextProps = workInProgress2.pendingProps;
            var prevProps = current2 !== null ? current2.memoizedProps : null;
            var nextChildren = nextProps.children;
            var isDirectTextChild = shouldSetTextContent(type, nextProps);
            if (isDirectTextChild) {
              nextChildren = null;
            } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
              workInProgress2.flags |= ContentReset;
            }
            markRef(current2, workInProgress2);
            reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            return workInProgress2.child;
          }
          function updateHostText(current2, workInProgress2) {
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
            }
            return null;
          }
          function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
            var props = workInProgress2.pendingProps;
            var lazyComponent = elementType;
            var payload = lazyComponent._payload;
            var init3 = lazyComponent._init;
            var Component2 = init3(payload);
            workInProgress2.type = Component2;
            var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component2);
            var resolvedProps = resolveDefaultProps(Component2, props);
            var child;
            switch (resolvedTag) {
              case FunctionComponent: {
                {
                  validateFunctionComponentInDev(workInProgress2, Component2);
                  workInProgress2.type = Component2 = resolveFunctionForHotReloading(Component2);
                }
                child = updateFunctionComponent(null, workInProgress2, Component2, resolvedProps, renderLanes2);
                return child;
              }
              case ClassComponent: {
                {
                  workInProgress2.type = Component2 = resolveClassForHotReloading(Component2);
                }
                child = updateClassComponent(null, workInProgress2, Component2, resolvedProps, renderLanes2);
                return child;
              }
              case ForwardRef: {
                {
                  workInProgress2.type = Component2 = resolveForwardRefForHotReloading(Component2);
                }
                child = updateForwardRef(null, workInProgress2, Component2, resolvedProps, renderLanes2);
                return child;
              }
              case MemoComponent: {
                {
                  if (workInProgress2.type !== workInProgress2.elementType) {
                    var outerPropTypes = Component2.propTypes;
                    if (outerPropTypes) {
                      checkPropTypes3(
                        outerPropTypes,
                        resolvedProps,
                        "prop",
                        getComponentNameFromType(Component2)
                      );
                    }
                  }
                }
                child = updateMemoComponent(
                  null,
                  workInProgress2,
                  Component2,
                  resolveDefaultProps(Component2.type, resolvedProps),
                  renderLanes2
                );
                return child;
              }
            }
            var hint2 = "";
            {
              if (Component2 !== null && typeof Component2 === "object" && Component2.$$typeof === REACT_LAZY_TYPE) {
                hint2 = " Did you wrap a component in React.lazy() more than once?";
              }
            }
            throw new Error("Element type is invalid. Received a promise that resolves to: " + Component2 + ". " + ("Lazy element type must resolve to a class or function." + hint2));
          }
          function mountIncompleteClassComponent(_current, workInProgress2, Component2, nextProps, renderLanes2) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
            workInProgress2.tag = ClassComponent;
            var hasContext;
            if (isContextProvider(Component2)) {
              hasContext = true;
              pushContextProvider(workInProgress2);
            } else {
              hasContext = false;
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            constructClassInstance(workInProgress2, Component2, nextProps);
            mountClassInstance(workInProgress2, Component2, nextProps, renderLanes2);
            return finishClassComponent(null, workInProgress2, Component2, true, hasContext, renderLanes2);
          }
          function mountIndeterminateComponent(_current, workInProgress2, Component2, renderLanes2) {
            resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
            var props = workInProgress2.pendingProps;
            var context;
            {
              var unmaskedContext = getUnmaskedContext(workInProgress2, Component2, false);
              context = getMaskedContext(workInProgress2, unmaskedContext);
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var value13;
            var hasId;
            {
              markComponentRenderStarted(workInProgress2);
            }
            {
              if (Component2.prototype && typeof Component2.prototype.render === "function") {
                var componentName = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutBadClass[componentName]) {
                  error3("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                  didWarnAboutBadClass[componentName] = true;
                }
              }
              if (workInProgress2.mode & StrictLegacyMode) {
                ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
              }
              setIsRendering(true);
              ReactCurrentOwner$1.current = workInProgress2;
              value13 = renderWithHooks(null, workInProgress2, Component2, props, context, renderLanes2);
              hasId = checkDidRenderIdHook();
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            workInProgress2.flags |= PerformedWork;
            {
              if (typeof value13 === "object" && value13 !== null && typeof value13.render === "function" && value13.$$typeof === void 0) {
                var _componentName = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName]) {
                  error3("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                  didWarnAboutModulePatternComponent[_componentName] = true;
                }
              }
            }
            if (typeof value13 === "object" && value13 !== null && typeof value13.render === "function" && value13.$$typeof === void 0) {
              {
                var _componentName2 = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName2]) {
                  error3("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                  didWarnAboutModulePatternComponent[_componentName2] = true;
                }
              }
              workInProgress2.tag = ClassComponent;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              var hasContext = false;
              if (isContextProvider(Component2)) {
                hasContext = true;
                pushContextProvider(workInProgress2);
              } else {
                hasContext = false;
              }
              workInProgress2.memoizedState = value13.state !== null && value13.state !== void 0 ? value13.state : null;
              initializeUpdateQueue(workInProgress2);
              adoptClassInstance(workInProgress2, value13);
              mountClassInstance(workInProgress2, Component2, props, renderLanes2);
              return finishClassComponent(null, workInProgress2, Component2, true, hasContext, renderLanes2);
            } else {
              workInProgress2.tag = FunctionComponent;
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    value13 = renderWithHooks(null, workInProgress2, Component2, props, context, renderLanes2);
                    hasId = checkDidRenderIdHook();
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
              }
              if (getIsHydrating() && hasId) {
                pushMaterializedTreeId(workInProgress2);
              }
              reconcileChildren(null, workInProgress2, value13, renderLanes2);
              {
                validateFunctionComponentInDev(workInProgress2, Component2);
              }
              return workInProgress2.child;
            }
          }
          function validateFunctionComponentInDev(workInProgress2, Component2) {
            {
              if (Component2) {
                if (Component2.childContextTypes) {
                  error3("%s(...): childContextTypes cannot be defined on a function component.", Component2.displayName || Component2.name || "Component");
                }
              }
              if (workInProgress2.ref !== null) {
                var info = "";
                var ownerName = getCurrentFiberOwnerNameInDevOrNull();
                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }
                var warningKey = ownerName || "";
                var debugSource = workInProgress2._debugSource;
                if (debugSource) {
                  warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
                }
                if (!didWarnAboutFunctionRefs[warningKey]) {
                  didWarnAboutFunctionRefs[warningKey] = true;
                  error3("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info);
                }
              }
              if (typeof Component2.getDerivedStateFromProps === "function") {
                var _componentName3 = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                  error3("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                  didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
                }
              }
              if (typeof Component2.contextType === "object" && Component2.contextType !== null) {
                var _componentName4 = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                  error3("%s: Function components do not support contextType.", _componentName4);
                  didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
                }
              }
            }
          }
          var SUSPENDED_MARKER = {
            dehydrated: null,
            treeContext: null,
            retryLane: NoLane
          };
          function mountSuspenseOffscreenState(renderLanes2) {
            return {
              baseLanes: renderLanes2,
              cachePool: getSuspendedCache(),
              transitions: null
            };
          }
          function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
            var cachePool = null;
            return {
              baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),
              cachePool,
              transitions: prevOffscreenState.transitions
            };
          }
          function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
            if (current2 !== null) {
              var suspenseState = current2.memoizedState;
              if (suspenseState === null) {
                return false;
              }
            }
            return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
          }
          function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
            return removeLanes(current2.childLanes, renderLanes2);
          }
          function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            {
              if (shouldSuspend(workInProgress2)) {
                workInProgress2.flags |= DidCapture;
              }
            }
            var suspenseContext = suspenseStackCursor.current;
            var showFallback = false;
            var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
            if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {
              showFallback = true;
              workInProgress2.flags &= ~DidCapture;
            } else {
              if (current2 === null || current2.memoizedState !== null) {
                {
                  suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
                }
              }
            }
            suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            pushSuspenseContext(workInProgress2, suspenseContext);
            if (current2 === null) {
              tryToClaimNextHydratableInstance(workInProgress2);
              var suspenseState = workInProgress2.memoizedState;
              if (suspenseState !== null) {
                var dehydrated = suspenseState.dehydrated;
                if (dehydrated !== null) {
                  return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);
                }
              }
              var nextPrimaryChildren = nextProps.children;
              var nextFallbackChildren = nextProps.fallback;
              if (showFallback) {
                var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
                var primaryChildFragment = workInProgress2.child;
                primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackFragment;
              } else {
                return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
              }
            } else {
              var prevState = current2.memoizedState;
              if (prevState !== null) {
                var _dehydrated = prevState.dehydrated;
                if (_dehydrated !== null) {
                  return updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, _dehydrated, prevState, renderLanes2);
                }
              }
              if (showFallback) {
                var _nextFallbackChildren = nextProps.fallback;
                var _nextPrimaryChildren = nextProps.children;
                var fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2);
                var _primaryChildFragment2 = workInProgress2.child;
                var prevOffscreenState = current2.child.memoizedState;
                _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
                _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackChildFragment;
              } else {
                var _nextPrimaryChildren2 = nextProps.children;
                var _primaryChildFragment3 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren2, renderLanes2);
                workInProgress2.memoizedState = null;
                return _primaryChildFragment3;
              }
            }
          }
          function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var primaryChildProps = {
              mode: "visible",
              children: primaryChildren
            };
            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
            primaryChildFragment.return = workInProgress2;
            workInProgress2.child = primaryChildFragment;
            return primaryChildFragment;
          }
          function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var progressedPrimaryFragment = workInProgress2.child;
            var primaryChildProps = {
              mode: "hidden",
              children: primaryChildren
            };
            var primaryChildFragment;
            var fallbackChildFragment;
            if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {
              primaryChildFragment = progressedPrimaryFragment;
              primaryChildFragment.childLanes = NoLanes;
              primaryChildFragment.pendingProps = primaryChildProps;
              if (workInProgress2.mode & ProfileMode) {
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = 0;
                primaryChildFragment.treeBaseDuration = 0;
              }
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            } else {
              primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
            }
            primaryChildFragment.return = workInProgress2;
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            return fallbackChildFragment;
          }
          function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {
            return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);
          }
          function updateWorkInProgressOffscreenFiber(current2, offscreenProps) {
            return createWorkInProgress(current2, offscreenProps);
          }
          function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
            var currentPrimaryChildFragment = current2.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
              mode: "visible",
              children: primaryChildren
            });
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              primaryChildFragment.lanes = renderLanes2;
            }
            primaryChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = null;
            if (currentFallbackChildFragment !== null) {
              var deletions = workInProgress2.deletions;
              if (deletions === null) {
                workInProgress2.deletions = [currentFallbackChildFragment];
                workInProgress2.flags |= ChildDeletion;
              } else {
                deletions.push(currentFallbackChildFragment);
              }
            }
            workInProgress2.child = primaryChildFragment;
            return primaryChildFragment;
          }
          function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var mode = workInProgress2.mode;
            var currentPrimaryChildFragment = current2.child;
            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
            var primaryChildProps = {
              mode: "hidden",
              children: primaryChildren
            };
            var primaryChildFragment;
            if ((mode & ConcurrentMode) === NoMode && workInProgress2.child !== currentPrimaryChildFragment) {
              var progressedPrimaryFragment = workInProgress2.child;
              primaryChildFragment = progressedPrimaryFragment;
              primaryChildFragment.childLanes = NoLanes;
              primaryChildFragment.pendingProps = primaryChildProps;
              if (workInProgress2.mode & ProfileMode) {
                primaryChildFragment.actualDuration = 0;
                primaryChildFragment.actualStartTime = -1;
                primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
                primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
              }
              workInProgress2.deletions = null;
            } else {
              primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
              primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
            }
            var fallbackChildFragment;
            if (currentFallbackChildFragment !== null) {
              fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
            } else {
              fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
              fallbackChildFragment.flags |= Placement;
            }
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            return fallbackChildFragment;
          }
          function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, recoverableError) {
            if (recoverableError !== null) {
              queueHydrationError(recoverableError);
            }
            reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            var nextProps = workInProgress2.pendingProps;
            var primaryChildren = nextProps.children;
            var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
            primaryChildFragment.flags |= Placement;
            workInProgress2.memoizedState = null;
            return primaryChildFragment;
          }
          function mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
            var fiberMode = workInProgress2.mode;
            var primaryChildProps = {
              mode: "visible",
              children: primaryChildren
            };
            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);
            var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);
            fallbackChildFragment.flags |= Placement;
            primaryChildFragment.return = workInProgress2;
            fallbackChildFragment.return = workInProgress2;
            primaryChildFragment.sibling = fallbackChildFragment;
            workInProgress2.child = primaryChildFragment;
            if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
              reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
            }
            return fallbackChildFragment;
          }
          function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              {
                error3("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components.");
              }
              workInProgress2.lanes = laneToLanes(SyncLane);
            } else if (isSuspenseInstanceFallback(suspenseInstance)) {
              workInProgress2.lanes = laneToLanes(DefaultHydrationLane);
            } else {
              workInProgress2.lanes = laneToLanes(OffscreenLane);
            }
            return null;
          }
          function updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes2) {
            if (!didSuspend) {
              warnIfHydrating();
              if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
                return retrySuspenseComponentWithoutHydrating(
                  current2,
                  workInProgress2,
                  renderLanes2,
                  null
                );
              }
              if (isSuspenseInstanceFallback(suspenseInstance)) {
                var digest, message2, stack;
                {
                  var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);
                  digest = _getSuspenseInstanceF.digest;
                  message2 = _getSuspenseInstanceF.message;
                  stack = _getSuspenseInstanceF.stack;
                }
                var error4;
                if (message2) {
                  error4 = new Error(message2);
                } else {
                  error4 = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
                }
                var capturedValue = createCapturedValue(error4, digest, stack);
                return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, capturedValue);
              }
              var hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes);
              if (didReceiveUpdate || hasContextChanged2) {
                var root2 = getWorkInProgressRoot();
                if (root2 !== null) {
                  var attemptHydrationAtLane = getBumpedLaneForHydration(root2, renderLanes2);
                  if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
                    suspenseState.retryLane = attemptHydrationAtLane;
                    var eventTime = NoTimestamp;
                    enqueueConcurrentRenderForLane(current2, attemptHydrationAtLane);
                    scheduleUpdateOnFiber(root2, current2, attemptHydrationAtLane, eventTime);
                  }
                }
                renderDidSuspendDelayIfPossible();
                var _capturedValue = createCapturedValue(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
                return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue);
              } else if (isSuspenseInstancePending(suspenseInstance)) {
                workInProgress2.flags |= DidCapture;
                workInProgress2.child = current2.child;
                var retry = retryDehydratedSuspenseBoundary.bind(null, current2);
                registerSuspenseInstanceRetry(suspenseInstance, retry);
                return null;
              } else {
                reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);
                var primaryChildren = nextProps.children;
                var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
                primaryChildFragment.flags |= Hydrating;
                return primaryChildFragment;
              }
            } else {
              if (workInProgress2.flags & ForceClientRender) {
                workInProgress2.flags &= ~ForceClientRender;
                var _capturedValue2 = createCapturedValue(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
                return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue2);
              } else if (workInProgress2.memoizedState !== null) {
                workInProgress2.child = current2.child;
                workInProgress2.flags |= DidCapture;
                return null;
              } else {
                var nextPrimaryChildren = nextProps.children;
                var nextFallbackChildren = nextProps.fallback;
                var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
                var _primaryChildFragment4 = workInProgress2.child;
                _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2);
                workInProgress2.memoizedState = SUSPENDED_MARKER;
                return fallbackChildFragment;
              }
            }
          }
          function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
            fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
            var alternate = fiber.alternate;
            if (alternate !== null) {
              alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
            }
            scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
          }
          function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
            var node = firstChild;
            while (node !== null) {
              if (node.tag === SuspenseComponent) {
                var state3 = node.memoizedState;
                if (state3 !== null) {
                  scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
                }
              } else if (node.tag === SuspenseListComponent) {
                scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
              } else if (node.child !== null) {
                node.child.return = node;
                node = node.child;
                continue;
              }
              if (node === workInProgress2) {
                return;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === workInProgress2) {
                  return;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
          }
          function findLastContentRow(firstChild) {
            var row = firstChild;
            var lastContentRow = null;
            while (row !== null) {
              var currentRow = row.alternate;
              if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                lastContentRow = row;
              }
              row = row.sibling;
            }
            return lastContentRow;
          }
          function validateRevealOrder(revealOrder) {
            {
              if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
                didWarnAboutRevealOrder[revealOrder] = true;
                if (typeof revealOrder === "string") {
                  switch (revealOrder.toLowerCase()) {
                    case "together":
                    case "forwards":
                    case "backwards": {
                      error3('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                      break;
                    }
                    case "forward":
                    case "backward": {
                      error3('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                      break;
                    }
                    default:
                      error3('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                      break;
                  }
                } else {
                  error3('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
                }
              }
            }
          }
          function validateTailOptions(tailMode, revealOrder) {
            {
              if (tailMode !== void 0 && !didWarnAboutTailOptions[tailMode]) {
                if (tailMode !== "collapsed" && tailMode !== "hidden") {
                  didWarnAboutTailOptions[tailMode] = true;
                  error3('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode);
                } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
                  didWarnAboutTailOptions[tailMode] = true;
                  error3('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode);
                }
              }
            }
          }
          function validateSuspenseListNestedChild(childSlot, index6) {
            {
              var isAnArray = isArray6(childSlot);
              var isIterable2 = !isAnArray && typeof getIteratorFn(childSlot) === "function";
              if (isAnArray || isIterable2) {
                var type = isAnArray ? "array" : "iterable";
                error3("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type, index6, type);
                return false;
              }
            }
            return true;
          }
          function validateSuspenseListChildren(children, revealOrder) {
            {
              if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== false) {
                if (isArray6(children)) {
                  for (var i = 0; i < children.length; i++) {
                    if (!validateSuspenseListNestedChild(children[i], i)) {
                      return;
                    }
                  }
                } else {
                  var iteratorFn = getIteratorFn(children);
                  if (typeof iteratorFn === "function") {
                    var childrenIterator = iteratorFn.call(children);
                    if (childrenIterator) {
                      var step2 = childrenIterator.next();
                      var _i = 0;
                      for (; !step2.done; step2 = childrenIterator.next()) {
                        if (!validateSuspenseListNestedChild(step2.value, _i)) {
                          return;
                        }
                        _i++;
                      }
                    }
                  } else {
                    error3('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
                  }
                }
              }
            }
          }
          function initSuspenseListRenderState(workInProgress2, isBackwards, tail3, lastContentRow, tailMode) {
            var renderState = workInProgress2.memoizedState;
            if (renderState === null) {
              workInProgress2.memoizedState = {
                isBackwards,
                rendering: null,
                renderingStartTime: 0,
                last: lastContentRow,
                tail: tail3,
                tailMode
              };
            } else {
              renderState.isBackwards = isBackwards;
              renderState.rendering = null;
              renderState.renderingStartTime = 0;
              renderState.last = lastContentRow;
              renderState.tail = tail3;
              renderState.tailMode = tailMode;
            }
          }
          function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
            var nextProps = workInProgress2.pendingProps;
            var revealOrder = nextProps.revealOrder;
            var tailMode = nextProps.tail;
            var newChildren = nextProps.children;
            validateRevealOrder(revealOrder);
            validateTailOptions(tailMode, revealOrder);
            validateSuspenseListChildren(newChildren, revealOrder);
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            var suspenseContext = suspenseStackCursor.current;
            var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
            if (shouldForceFallback) {
              suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
              workInProgress2.flags |= DidCapture;
            } else {
              var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
              if (didSuspendBefore) {
                propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);
              }
              suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
            }
            pushSuspenseContext(workInProgress2, suspenseContext);
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              workInProgress2.memoizedState = null;
            } else {
              switch (revealOrder) {
                case "forwards": {
                  var lastContentRow = findLastContentRow(workInProgress2.child);
                  var tail3;
                  if (lastContentRow === null) {
                    tail3 = workInProgress2.child;
                    workInProgress2.child = null;
                  } else {
                    tail3 = lastContentRow.sibling;
                    lastContentRow.sibling = null;
                  }
                  initSuspenseListRenderState(
                    workInProgress2,
                    false,
                    tail3,
                    lastContentRow,
                    tailMode
                  );
                  break;
                }
                case "backwards": {
                  var _tail = null;
                  var row = workInProgress2.child;
                  workInProgress2.child = null;
                  while (row !== null) {
                    var currentRow = row.alternate;
                    if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                      workInProgress2.child = row;
                      break;
                    }
                    var nextRow = row.sibling;
                    row.sibling = _tail;
                    _tail = row;
                    row = nextRow;
                  }
                  initSuspenseListRenderState(
                    workInProgress2,
                    true,
                    _tail,
                    null,
                    tailMode
                  );
                  break;
                }
                case "together": {
                  initSuspenseListRenderState(
                    workInProgress2,
                    false,
                    null,
                    null,
                    void 0
                  );
                  break;
                }
                default: {
                  workInProgress2.memoizedState = null;
                }
              }
            }
            return workInProgress2.child;
          }
          function updatePortalComponent(current2, workInProgress2, renderLanes2) {
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            var nextChildren = workInProgress2.pendingProps;
            if (current2 === null) {
              workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            } else {
              reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
            }
            return workInProgress2.child;
          }
          var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
          function updateContextProvider(current2, workInProgress2, renderLanes2) {
            var providerType = workInProgress2.type;
            var context = providerType._context;
            var newProps = workInProgress2.pendingProps;
            var oldProps = workInProgress2.memoizedProps;
            var newValue = newProps.value;
            {
              if (!("value" in newProps)) {
                if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
                  hasWarnedAboutUsingNoValuePropOnContextProvider = true;
                  error3("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?");
                }
              }
              var providerPropTypes = workInProgress2.type.propTypes;
              if (providerPropTypes) {
                checkPropTypes3(providerPropTypes, newProps, "prop", "Context.Provider");
              }
            }
            pushProvider(workInProgress2, context, newValue);
            {
              if (oldProps !== null) {
                var oldValue = oldProps.value;
                if (objectIs(oldValue, newValue)) {
                  if (oldProps.children === newProps.children && !hasContextChanged()) {
                    return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                  }
                } else {
                  propagateContextChange(workInProgress2, context, renderLanes2);
                }
              }
            }
            var newChildren = newProps.children;
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            return workInProgress2.child;
          }
          var hasWarnedAboutUsingContextAsConsumer = false;
          function updateContextConsumer(current2, workInProgress2, renderLanes2) {
            var context = workInProgress2.type;
            {
              if (context._context === void 0) {
                if (context !== context.Consumer) {
                  if (!hasWarnedAboutUsingContextAsConsumer) {
                    hasWarnedAboutUsingContextAsConsumer = true;
                    error3("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                }
              } else {
                context = context._context;
              }
            }
            var newProps = workInProgress2.pendingProps;
            var render3 = newProps.children;
            {
              if (typeof render3 !== "function") {
                error3("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
              }
            }
            prepareToReadContext(workInProgress2, renderLanes2);
            var newValue = readContext(context);
            {
              markComponentRenderStarted(workInProgress2);
            }
            var newChildren;
            {
              ReactCurrentOwner$1.current = workInProgress2;
              setIsRendering(true);
              newChildren = render3(newValue);
              setIsRendering(false);
            }
            {
              markComponentRenderStopped();
            }
            workInProgress2.flags |= PerformedWork;
            reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
            return workInProgress2.child;
          }
          function markWorkInProgressReceivedUpdate() {
            didReceiveUpdate = true;
          }
          function resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2) {
            if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
              if (current2 !== null) {
                current2.alternate = null;
                workInProgress2.alternate = null;
                workInProgress2.flags |= Placement;
              }
            }
          }
          function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
            if (current2 !== null) {
              workInProgress2.dependencies = current2.dependencies;
            }
            {
              stopProfilerTimerIfRunning();
            }
            markSkippedUpdateLanes(workInProgress2.lanes);
            if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
              {
                return null;
              }
            }
            cloneChildFibers(current2, workInProgress2);
            return workInProgress2.child;
          }
          function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
            {
              var returnFiber = oldWorkInProgress.return;
              if (returnFiber === null) {
                throw new Error("Cannot swap the root fiber.");
              }
              current2.alternate = null;
              oldWorkInProgress.alternate = null;
              newWorkInProgress.index = oldWorkInProgress.index;
              newWorkInProgress.sibling = oldWorkInProgress.sibling;
              newWorkInProgress.return = oldWorkInProgress.return;
              newWorkInProgress.ref = oldWorkInProgress.ref;
              if (oldWorkInProgress === returnFiber.child) {
                returnFiber.child = newWorkInProgress;
              } else {
                var prevSibling = returnFiber.child;
                if (prevSibling === null) {
                  throw new Error("Expected parent to have a child.");
                }
                while (prevSibling.sibling !== oldWorkInProgress) {
                  prevSibling = prevSibling.sibling;
                  if (prevSibling === null) {
                    throw new Error("Expected to find the previous sibling.");
                  }
                }
                prevSibling.sibling = newWorkInProgress;
              }
              var deletions = returnFiber.deletions;
              if (deletions === null) {
                returnFiber.deletions = [current2];
                returnFiber.flags |= ChildDeletion;
              } else {
                deletions.push(current2);
              }
              newWorkInProgress.flags |= Placement;
              return newWorkInProgress;
            }
          }
          function checkScheduledUpdateOrContext(current2, renderLanes2) {
            var updateLanes = current2.lanes;
            if (includesSomeLane(updateLanes, renderLanes2)) {
              return true;
            }
            return false;
          }
          function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
            switch (workInProgress2.tag) {
              case HostRoot:
                pushHostRootContext(workInProgress2);
                var root2 = workInProgress2.stateNode;
                resetHydrationState();
                break;
              case HostComponent:
                pushHostContext(workInProgress2);
                break;
              case ClassComponent: {
                var Component2 = workInProgress2.type;
                if (isContextProvider(Component2)) {
                  pushContextProvider(workInProgress2);
                }
                break;
              }
              case HostPortal:
                pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
                break;
              case ContextProvider: {
                var newValue = workInProgress2.memoizedProps.value;
                var context = workInProgress2.type._context;
                pushProvider(workInProgress2, context, newValue);
                break;
              }
              case Profiler:
                {
                  var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                  if (hasChildWork) {
                    workInProgress2.flags |= Update;
                  }
                  {
                    var stateNode = workInProgress2.stateNode;
                    stateNode.effectDuration = 0;
                    stateNode.passiveEffectDuration = 0;
                  }
                }
                break;
              case SuspenseComponent: {
                var state3 = workInProgress2.memoizedState;
                if (state3 !== null) {
                  if (state3.dehydrated !== null) {
                    pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                    workInProgress2.flags |= DidCapture;
                    return null;
                  }
                  var primaryChildFragment = workInProgress2.child;
                  var primaryChildLanes = primaryChildFragment.childLanes;
                  if (includesSomeLane(renderLanes2, primaryChildLanes)) {
                    return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
                  } else {
                    pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                    var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                    if (child !== null) {
                      return child.sibling;
                    } else {
                      return null;
                    }
                  }
                } else {
                  pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                }
                break;
              }
              case SuspenseListComponent: {
                var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;
                var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
                if (didSuspendBefore) {
                  if (_hasChildWork) {
                    return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
                  }
                  workInProgress2.flags |= DidCapture;
                }
                var renderState = workInProgress2.memoizedState;
                if (renderState !== null) {
                  renderState.rendering = null;
                  renderState.tail = null;
                  renderState.lastEffect = null;
                }
                pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
                if (_hasChildWork) {
                  break;
                } else {
                  return null;
                }
              }
              case OffscreenComponent:
              case LegacyHiddenComponent: {
                workInProgress2.lanes = NoLanes;
                return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
              }
            }
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          function beginWork(current2, workInProgress2, renderLanes2) {
            {
              if (workInProgress2._debugNeedsRemount && current2 !== null) {
                return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
              }
            }
            if (current2 !== null) {
              var oldProps = current2.memoizedProps;
              var newProps = workInProgress2.pendingProps;
              if (oldProps !== newProps || hasContextChanged() || workInProgress2.type !== current2.type) {
                didReceiveUpdate = true;
              } else {
                var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
                if (!hasScheduledUpdateOrContext && (workInProgress2.flags & DidCapture) === NoFlags) {
                  didReceiveUpdate = false;
                  return attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);
                }
                if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
                  didReceiveUpdate = true;
                } else {
                  didReceiveUpdate = false;
                }
              }
            } else {
              didReceiveUpdate = false;
              if (getIsHydrating() && isForkedChild(workInProgress2)) {
                var slotIndex = workInProgress2.index;
                var numberOfForks = getForksAtLevel();
                pushTreeId(workInProgress2, numberOfForks, slotIndex);
              }
            }
            workInProgress2.lanes = NoLanes;
            switch (workInProgress2.tag) {
              case IndeterminateComponent: {
                return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);
              }
              case LazyComponent: {
                var elementType = workInProgress2.elementType;
                return mountLazyComponent(current2, workInProgress2, elementType, renderLanes2);
              }
              case FunctionComponent: {
                var Component2 = workInProgress2.type;
                var unresolvedProps = workInProgress2.pendingProps;
                var resolvedProps = workInProgress2.elementType === Component2 ? unresolvedProps : resolveDefaultProps(Component2, unresolvedProps);
                return updateFunctionComponent(current2, workInProgress2, Component2, resolvedProps, renderLanes2);
              }
              case ClassComponent: {
                var _Component = workInProgress2.type;
                var _unresolvedProps = workInProgress2.pendingProps;
                var _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
                return updateClassComponent(current2, workInProgress2, _Component, _resolvedProps, renderLanes2);
              }
              case HostRoot:
                return updateHostRoot(current2, workInProgress2, renderLanes2);
              case HostComponent:
                return updateHostComponent(current2, workInProgress2, renderLanes2);
              case HostText:
                return updateHostText(current2, workInProgress2);
              case SuspenseComponent:
                return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
              case HostPortal:
                return updatePortalComponent(current2, workInProgress2, renderLanes2);
              case ForwardRef: {
                var type = workInProgress2.type;
                var _unresolvedProps2 = workInProgress2.pendingProps;
                var _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
                return updateForwardRef(current2, workInProgress2, type, _resolvedProps2, renderLanes2);
              }
              case Fragment2:
                return updateFragment(current2, workInProgress2, renderLanes2);
              case Mode:
                return updateMode(current2, workInProgress2, renderLanes2);
              case Profiler:
                return updateProfiler(current2, workInProgress2, renderLanes2);
              case ContextProvider:
                return updateContextProvider(current2, workInProgress2, renderLanes2);
              case ContextConsumer:
                return updateContextConsumer(current2, workInProgress2, renderLanes2);
              case MemoComponent: {
                var _type2 = workInProgress2.type;
                var _unresolvedProps3 = workInProgress2.pendingProps;
                var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
                {
                  if (workInProgress2.type !== workInProgress2.elementType) {
                    var outerPropTypes = _type2.propTypes;
                    if (outerPropTypes) {
                      checkPropTypes3(
                        outerPropTypes,
                        _resolvedProps3,
                        "prop",
                        getComponentNameFromType(_type2)
                      );
                    }
                  }
                }
                _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
                return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, renderLanes2);
              }
              case SimpleMemoComponent: {
                return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
              }
              case IncompleteClassComponent: {
                var _Component2 = workInProgress2.type;
                var _unresolvedProps4 = workInProgress2.pendingProps;
                var _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);
                return mountIncompleteClassComponent(current2, workInProgress2, _Component2, _resolvedProps4, renderLanes2);
              }
              case SuspenseListComponent: {
                return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
              }
              case ScopeComponent: {
                break;
              }
              case OffscreenComponent: {
                return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
              }
            }
            throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
          }
          function markUpdate(workInProgress2) {
            workInProgress2.flags |= Update;
          }
          function markRef$1(workInProgress2) {
            workInProgress2.flags |= Ref;
            {
              workInProgress2.flags |= RefStatic;
            }
          }
          var appendAllChildren;
          var updateHostContainer;
          var updateHostComponent$1;
          var updateHostText$1;
          {
            appendAllChildren = function(parent2, workInProgress2, needsVisibilityToggle, isHidden) {
              var node = workInProgress2.child;
              while (node !== null) {
                if (node.tag === HostComponent || node.tag === HostText) {
                  appendInitialChild(parent2, node.stateNode);
                } else if (node.tag === HostPortal)
                  ;
                else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === workInProgress2) {
                  return;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === workInProgress2) {
                    return;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            };
            updateHostContainer = function(current2, workInProgress2) {
            };
            updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {
              var oldProps = current2.memoizedProps;
              if (oldProps === newProps) {
                return;
              }
              var instance = workInProgress2.stateNode;
              var currentHostContext = getHostContext();
              var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
              workInProgress2.updateQueue = updatePayload;
              if (updatePayload) {
                markUpdate(workInProgress2);
              }
            };
            updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
              if (oldText !== newText) {
                markUpdate(workInProgress2);
              }
            };
          }
          function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
            if (getIsHydrating()) {
              return;
            }
            switch (renderState.tailMode) {
              case "hidden": {
                var tailNode = renderState.tail;
                var lastTailNode = null;
                while (tailNode !== null) {
                  if (tailNode.alternate !== null) {
                    lastTailNode = tailNode;
                  }
                  tailNode = tailNode.sibling;
                }
                if (lastTailNode === null) {
                  renderState.tail = null;
                } else {
                  lastTailNode.sibling = null;
                }
                break;
              }
              case "collapsed": {
                var _tailNode = renderState.tail;
                var _lastTailNode = null;
                while (_tailNode !== null) {
                  if (_tailNode.alternate !== null) {
                    _lastTailNode = _tailNode;
                  }
                  _tailNode = _tailNode.sibling;
                }
                if (_lastTailNode === null) {
                  if (!hasRenderedATailFallback && renderState.tail !== null) {
                    renderState.tail.sibling = null;
                  } else {
                    renderState.tail = null;
                  }
                } else {
                  _lastTailNode.sibling = null;
                }
                break;
              }
            }
          }
          function bubbleProperties(completedWork) {
            var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;
            var newChildLanes = NoLanes;
            var subtreeFlags = NoFlags;
            if (!didBailout) {
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                var actualDuration = completedWork.actualDuration;
                var treeBaseDuration = completedWork.selfBaseDuration;
                var child = completedWork.child;
                while (child !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
                  subtreeFlags |= child.subtreeFlags;
                  subtreeFlags |= child.flags;
                  actualDuration += child.actualDuration;
                  treeBaseDuration += child.treeBaseDuration;
                  child = child.sibling;
                }
                completedWork.actualDuration = actualDuration;
                completedWork.treeBaseDuration = treeBaseDuration;
              } else {
                var _child = completedWork.child;
                while (_child !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
                  subtreeFlags |= _child.subtreeFlags;
                  subtreeFlags |= _child.flags;
                  _child.return = completedWork;
                  _child = _child.sibling;
                }
              }
              completedWork.subtreeFlags |= subtreeFlags;
            } else {
              if ((completedWork.mode & ProfileMode) !== NoMode) {
                var _treeBaseDuration = completedWork.selfBaseDuration;
                var _child2 = completedWork.child;
                while (_child2 !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes));
                  subtreeFlags |= _child2.subtreeFlags & StaticMask;
                  subtreeFlags |= _child2.flags & StaticMask;
                  _treeBaseDuration += _child2.treeBaseDuration;
                  _child2 = _child2.sibling;
                }
                completedWork.treeBaseDuration = _treeBaseDuration;
              } else {
                var _child3 = completedWork.child;
                while (_child3 !== null) {
                  newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes));
                  subtreeFlags |= _child3.subtreeFlags & StaticMask;
                  subtreeFlags |= _child3.flags & StaticMask;
                  _child3.return = completedWork;
                  _child3 = _child3.sibling;
                }
              }
              completedWork.subtreeFlags |= subtreeFlags;
            }
            completedWork.childLanes = newChildLanes;
            return didBailout;
          }
          function completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState) {
            if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags) {
              warnIfUnhydratedTailNodes(workInProgress2);
              resetHydrationState();
              workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture;
              return false;
            }
            var wasHydrated = popHydrationState(workInProgress2);
            if (nextState !== null && nextState.dehydrated !== null) {
              if (current2 === null) {
                if (!wasHydrated) {
                  throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
                }
                prepareToHydrateHostSuspenseInstance(workInProgress2);
                bubbleProperties(workInProgress2);
                {
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    var isTimedOutSuspense = nextState !== null;
                    if (isTimedOutSuspense) {
                      var primaryChildFragment = workInProgress2.child;
                      if (primaryChildFragment !== null) {
                        workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                      }
                    }
                  }
                }
                return false;
              } else {
                resetHydrationState();
                if ((workInProgress2.flags & DidCapture) === NoFlags) {
                  workInProgress2.memoizedState = null;
                }
                workInProgress2.flags |= Update;
                bubbleProperties(workInProgress2);
                {
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    var _isTimedOutSuspense = nextState !== null;
                    if (_isTimedOutSuspense) {
                      var _primaryChildFragment = workInProgress2.child;
                      if (_primaryChildFragment !== null) {
                        workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;
                      }
                    }
                  }
                }
                return false;
              }
            } else {
              upgradeHydrationErrorsToRecoverable();
              return true;
            }
          }
          function completeWork(current2, workInProgress2, renderLanes2) {
            var newProps = workInProgress2.pendingProps;
            popTreeContext(workInProgress2);
            switch (workInProgress2.tag) {
              case IndeterminateComponent:
              case LazyComponent:
              case SimpleMemoComponent:
              case FunctionComponent:
              case ForwardRef:
              case Fragment2:
              case Mode:
              case Profiler:
              case ContextConsumer:
              case MemoComponent:
                bubbleProperties(workInProgress2);
                return null;
              case ClassComponent: {
                var Component2 = workInProgress2.type;
                if (isContextProvider(Component2)) {
                  popContext(workInProgress2);
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case HostRoot: {
                var fiberRoot = workInProgress2.stateNode;
                popHostContainer(workInProgress2);
                popTopLevelContextObject(workInProgress2);
                resetWorkInProgressVersions();
                if (fiberRoot.pendingContext) {
                  fiberRoot.context = fiberRoot.pendingContext;
                  fiberRoot.pendingContext = null;
                }
                if (current2 === null || current2.child === null) {
                  var wasHydrated = popHydrationState(workInProgress2);
                  if (wasHydrated) {
                    markUpdate(workInProgress2);
                  } else {
                    if (current2 !== null) {
                      var prevState = current2.memoizedState;
                      if (!prevState.isDehydrated || (workInProgress2.flags & ForceClientRender) !== NoFlags) {
                        workInProgress2.flags |= Snapshot;
                        upgradeHydrationErrorsToRecoverable();
                      }
                    }
                  }
                }
                updateHostContainer(current2, workInProgress2);
                bubbleProperties(workInProgress2);
                return null;
              }
              case HostComponent: {
                popHostContext(workInProgress2);
                var rootContainerInstance = getRootHostContainer();
                var type = workInProgress2.type;
                if (current2 !== null && workInProgress2.stateNode != null) {
                  updateHostComponent$1(current2, workInProgress2, type, newProps, rootContainerInstance);
                  if (current2.ref !== workInProgress2.ref) {
                    markRef$1(workInProgress2);
                  }
                } else {
                  if (!newProps) {
                    if (workInProgress2.stateNode === null) {
                      throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    bubbleProperties(workInProgress2);
                    return null;
                  }
                  var currentHostContext = getHostContext();
                  var _wasHydrated = popHydrationState(workInProgress2);
                  if (_wasHydrated) {
                    if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                      markUpdate(workInProgress2);
                    }
                  } else {
                    var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                    appendAllChildren(instance, workInProgress2, false, false);
                    workInProgress2.stateNode = instance;
                    if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
                      markUpdate(workInProgress2);
                    }
                  }
                  if (workInProgress2.ref !== null) {
                    markRef$1(workInProgress2);
                  }
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case HostText: {
                var newText = newProps;
                if (current2 && workInProgress2.stateNode != null) {
                  var oldText = current2.memoizedProps;
                  updateHostText$1(current2, workInProgress2, oldText, newText);
                } else {
                  if (typeof newText !== "string") {
                    if (workInProgress2.stateNode === null) {
                      throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
                    }
                  }
                  var _rootContainerInstance = getRootHostContainer();
                  var _currentHostContext = getHostContext();
                  var _wasHydrated2 = popHydrationState(workInProgress2);
                  if (_wasHydrated2) {
                    if (prepareToHydrateHostTextInstance(workInProgress2)) {
                      markUpdate(workInProgress2);
                    }
                  } else {
                    workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
                  }
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case SuspenseComponent: {
                popSuspenseContext(workInProgress2);
                var nextState = workInProgress2.memoizedState;
                if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {
                  var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState);
                  if (!fallthroughToNormalSuspensePath) {
                    if (workInProgress2.flags & ShouldCapture) {
                      return workInProgress2;
                    } else {
                      return null;
                    }
                  }
                }
                if ((workInProgress2.flags & DidCapture) !== NoFlags) {
                  workInProgress2.lanes = renderLanes2;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                var nextDidTimeout = nextState !== null;
                var prevDidTimeout = current2 !== null && current2.memoizedState !== null;
                if (nextDidTimeout !== prevDidTimeout) {
                  if (nextDidTimeout) {
                    var _offscreenFiber2 = workInProgress2.child;
                    _offscreenFiber2.flags |= Visibility;
                    if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
                      var hasInvisibleChildContext = current2 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);
                      if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                        renderDidSuspend();
                      } else {
                        renderDidSuspendDelayIfPossible();
                      }
                    }
                  }
                }
                var wakeables = workInProgress2.updateQueue;
                if (wakeables !== null) {
                  workInProgress2.flags |= Update;
                }
                bubbleProperties(workInProgress2);
                {
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    if (nextDidTimeout) {
                      var primaryChildFragment = workInProgress2.child;
                      if (primaryChildFragment !== null) {
                        workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                      }
                    }
                  }
                }
                return null;
              }
              case HostPortal:
                popHostContainer(workInProgress2);
                updateHostContainer(current2, workInProgress2);
                if (current2 === null) {
                  preparePortalMount(workInProgress2.stateNode.containerInfo);
                }
                bubbleProperties(workInProgress2);
                return null;
              case ContextProvider:
                var context = workInProgress2.type._context;
                popProvider(context, workInProgress2);
                bubbleProperties(workInProgress2);
                return null;
              case IncompleteClassComponent: {
                var _Component = workInProgress2.type;
                if (isContextProvider(_Component)) {
                  popContext(workInProgress2);
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case SuspenseListComponent: {
                popSuspenseContext(workInProgress2);
                var renderState = workInProgress2.memoizedState;
                if (renderState === null) {
                  bubbleProperties(workInProgress2);
                  return null;
                }
                var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
                var renderedTail = renderState.rendering;
                if (renderedTail === null) {
                  if (!didSuspendAlready) {
                    var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
                    if (!cannotBeSuspended) {
                      var row = workInProgress2.child;
                      while (row !== null) {
                        var suspended = findFirstSuspended(row);
                        if (suspended !== null) {
                          didSuspendAlready = true;
                          workInProgress2.flags |= DidCapture;
                          cutOffTailIfNeeded(renderState, false);
                          var newThenables = suspended.updateQueue;
                          if (newThenables !== null) {
                            workInProgress2.updateQueue = newThenables;
                            workInProgress2.flags |= Update;
                          }
                          workInProgress2.subtreeFlags = NoFlags;
                          resetChildFibers(workInProgress2, renderLanes2);
                          pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                          return workInProgress2.child;
                        }
                        row = row.sibling;
                      }
                    }
                    if (renderState.tail !== null && now2() > getRenderTargetTime()) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      cutOffTailIfNeeded(renderState, false);
                      workInProgress2.lanes = SomeRetryLane;
                    }
                  } else {
                    cutOffTailIfNeeded(renderState, false);
                  }
                } else {
                  if (!didSuspendAlready) {
                    var _suspended = findFirstSuspended(renderedTail);
                    if (_suspended !== null) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      var _newThenables = _suspended.updateQueue;
                      if (_newThenables !== null) {
                        workInProgress2.updateQueue = _newThenables;
                        workInProgress2.flags |= Update;
                      }
                      cutOffTailIfNeeded(renderState, true);
                      if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                        bubbleProperties(workInProgress2);
                        return null;
                      }
                    } else if (now2() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane) {
                      workInProgress2.flags |= DidCapture;
                      didSuspendAlready = true;
                      cutOffTailIfNeeded(renderState, false);
                      workInProgress2.lanes = SomeRetryLane;
                    }
                  }
                  if (renderState.isBackwards) {
                    renderedTail.sibling = workInProgress2.child;
                    workInProgress2.child = renderedTail;
                  } else {
                    var previousSibling = renderState.last;
                    if (previousSibling !== null) {
                      previousSibling.sibling = renderedTail;
                    } else {
                      workInProgress2.child = renderedTail;
                    }
                    renderState.last = renderedTail;
                  }
                }
                if (renderState.tail !== null) {
                  var next = renderState.tail;
                  renderState.rendering = next;
                  renderState.tail = next.sibling;
                  renderState.renderingStartTime = now2();
                  next.sibling = null;
                  var suspenseContext = suspenseStackCursor.current;
                  if (didSuspendAlready) {
                    suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
                  } else {
                    suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
                  }
                  pushSuspenseContext(workInProgress2, suspenseContext);
                  return next;
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              case ScopeComponent: {
                break;
              }
              case OffscreenComponent:
              case LegacyHiddenComponent: {
                popRenderLanes(workInProgress2);
                var _nextState = workInProgress2.memoizedState;
                var nextIsHidden = _nextState !== null;
                if (current2 !== null) {
                  var _prevState = current2.memoizedState;
                  var prevIsHidden = _prevState !== null;
                  if (prevIsHidden !== nextIsHidden && !enableLegacyHidden) {
                    workInProgress2.flags |= Visibility;
                  }
                }
                if (!nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode) {
                  bubbleProperties(workInProgress2);
                } else {
                  if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {
                    bubbleProperties(workInProgress2);
                    {
                      if (workInProgress2.subtreeFlags & (Placement | Update)) {
                        workInProgress2.flags |= Visibility;
                      }
                    }
                  }
                }
                return null;
              }
              case CacheComponent: {
                return null;
              }
              case TracingMarkerComponent: {
                return null;
              }
            }
            throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
          }
          function unwindWork(current2, workInProgress2, renderLanes2) {
            popTreeContext(workInProgress2);
            switch (workInProgress2.tag) {
              case ClassComponent: {
                var Component2 = workInProgress2.type;
                if (isContextProvider(Component2)) {
                  popContext(workInProgress2);
                }
                var flags = workInProgress2.flags;
                if (flags & ShouldCapture) {
                  workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                return null;
              }
              case HostRoot: {
                var root2 = workInProgress2.stateNode;
                popHostContainer(workInProgress2);
                popTopLevelContextObject(workInProgress2);
                resetWorkInProgressVersions();
                var _flags = workInProgress2.flags;
                if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {
                  workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;
                  return workInProgress2;
                }
                return null;
              }
              case HostComponent: {
                popHostContext(workInProgress2);
                return null;
              }
              case SuspenseComponent: {
                popSuspenseContext(workInProgress2);
                var suspenseState = workInProgress2.memoizedState;
                if (suspenseState !== null && suspenseState.dehydrated !== null) {
                  if (workInProgress2.alternate === null) {
                    throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
                  }
                  resetHydrationState();
                }
                var _flags2 = workInProgress2.flags;
                if (_flags2 & ShouldCapture) {
                  workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;
                  if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                    transferActualDuration(workInProgress2);
                  }
                  return workInProgress2;
                }
                return null;
              }
              case SuspenseListComponent: {
                popSuspenseContext(workInProgress2);
                return null;
              }
              case HostPortal:
                popHostContainer(workInProgress2);
                return null;
              case ContextProvider:
                var context = workInProgress2.type._context;
                popProvider(context, workInProgress2);
                return null;
              case OffscreenComponent:
              case LegacyHiddenComponent:
                popRenderLanes(workInProgress2);
                return null;
              case CacheComponent:
                return null;
              default:
                return null;
            }
          }
          function unwindInterruptedWork(current2, interruptedWork, renderLanes2) {
            popTreeContext(interruptedWork);
            switch (interruptedWork.tag) {
              case ClassComponent: {
                var childContextTypes = interruptedWork.type.childContextTypes;
                if (childContextTypes !== null && childContextTypes !== void 0) {
                  popContext(interruptedWork);
                }
                break;
              }
              case HostRoot: {
                var root2 = interruptedWork.stateNode;
                popHostContainer(interruptedWork);
                popTopLevelContextObject(interruptedWork);
                resetWorkInProgressVersions();
                break;
              }
              case HostComponent: {
                popHostContext(interruptedWork);
                break;
              }
              case HostPortal:
                popHostContainer(interruptedWork);
                break;
              case SuspenseComponent:
                popSuspenseContext(interruptedWork);
                break;
              case SuspenseListComponent:
                popSuspenseContext(interruptedWork);
                break;
              case ContextProvider:
                var context = interruptedWork.type._context;
                popProvider(context, interruptedWork);
                break;
              case OffscreenComponent:
              case LegacyHiddenComponent:
                popRenderLanes(interruptedWork);
                break;
            }
          }
          var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
          {
            didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
          }
          var offscreenSubtreeIsHidden = false;
          var offscreenSubtreeWasHidden = false;
          var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
          var nextEffect = null;
          var inProgressLanes = null;
          var inProgressRoot = null;
          function reportUncaughtErrorInDEV(error4) {
            {
              invokeGuardedCallback(null, function() {
                throw error4;
              });
              clearCaughtError();
            }
          }
          var callComponentWillUnmountWithTimer = function(current2, instance) {
            instance.props = current2.memoizedProps;
            instance.state = current2.memoizedState;
            if (current2.mode & ProfileMode) {
              try {
                startLayoutEffectTimer();
                instance.componentWillUnmount();
              } finally {
                recordLayoutEffectDuration(current2);
              }
            } else {
              instance.componentWillUnmount();
            }
          };
          function safelyCallCommitHookLayoutEffectListMount(current2, nearestMountedAncestor) {
            try {
              commitHookEffectListMount(Layout, current2);
            } catch (error4) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error4);
            }
          }
          function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
            try {
              callComponentWillUnmountWithTimer(current2, instance);
            } catch (error4) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error4);
            }
          }
          function safelyCallComponentDidMount(current2, nearestMountedAncestor, instance) {
            try {
              instance.componentDidMount();
            } catch (error4) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error4);
            }
          }
          function safelyAttachRef(current2, nearestMountedAncestor) {
            try {
              commitAttachRef(current2);
            } catch (error4) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error4);
            }
          }
          function safelyDetachRef(current2, nearestMountedAncestor) {
            var ref = current2.ref;
            if (ref !== null) {
              if (typeof ref === "function") {
                var retVal;
                try {
                  if (enableProfilerTimer && enableProfilerCommitHooks && current2.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      retVal = ref(null);
                    } finally {
                      recordLayoutEffectDuration(current2);
                    }
                  } else {
                    retVal = ref(null);
                  }
                } catch (error4) {
                  captureCommitPhaseError(current2, nearestMountedAncestor, error4);
                }
                {
                  if (typeof retVal === "function") {
                    error3("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(current2));
                  }
                }
              } else {
                ref.current = null;
              }
            }
          }
          function safelyCallDestroy(current2, nearestMountedAncestor, destroy) {
            try {
              destroy();
            } catch (error4) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error4);
            }
          }
          var focusedInstanceHandle = null;
          var shouldFireAfterActiveInstanceBlur = false;
          function commitBeforeMutationEffects(root2, firstChild) {
            focusedInstanceHandle = prepareForCommit(root2.containerInfo);
            nextEffect = firstChild;
            commitBeforeMutationEffects_begin();
            var shouldFire = shouldFireAfterActiveInstanceBlur;
            shouldFireAfterActiveInstanceBlur = false;
            focusedInstanceHandle = null;
            return shouldFire;
          }
          function commitBeforeMutationEffects_begin() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var child = fiber.child;
              if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {
                child.return = fiber;
                nextEffect = child;
              } else {
                commitBeforeMutationEffects_complete();
              }
            }
          }
          function commitBeforeMutationEffects_complete() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              setCurrentFiber(fiber);
              try {
                commitBeforeMutationEffectsOnFiber(fiber);
              } catch (error4) {
                captureCommitPhaseError(fiber, fiber.return, error4);
              }
              resetCurrentFiber();
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitBeforeMutationEffectsOnFiber(finishedWork) {
            var current2 = finishedWork.alternate;
            var flags = finishedWork.flags;
            if ((flags & Snapshot) !== NoFlags) {
              setCurrentFiber(finishedWork);
              switch (finishedWork.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  break;
                }
                case ClassComponent: {
                  if (current2 !== null) {
                    var prevProps = current2.memoizedProps;
                    var prevState = current2.memoizedState;
                    var instance = finishedWork.stateNode;
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error3("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error3("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                      }
                    }
                    var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                    {
                      var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                      if (snapshot === void 0 && !didWarnSet.has(finishedWork.type)) {
                        didWarnSet.add(finishedWork.type);
                        error3("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
                      }
                    }
                    instance.__reactInternalSnapshotBeforeUpdate = snapshot;
                  }
                  break;
                }
                case HostRoot: {
                  {
                    var root2 = finishedWork.stateNode;
                    clearContainer(root2.containerInfo);
                  }
                  break;
                }
                case HostComponent:
                case HostText:
                case HostPortal:
                case IncompleteClassComponent:
                  break;
                default: {
                  throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              resetCurrentFiber();
            }
          }
          function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect = firstEffect;
              do {
                if ((effect.tag & flags) === flags) {
                  var destroy = effect.destroy;
                  effect.destroy = void 0;
                  if (destroy !== void 0) {
                    {
                      if ((flags & Passive$1) !== NoFlags$1) {
                        markComponentPassiveEffectUnmountStarted(finishedWork);
                      } else if ((flags & Layout) !== NoFlags$1) {
                        markComponentLayoutEffectUnmountStarted(finishedWork);
                      }
                    }
                    {
                      if ((flags & Insertion) !== NoFlags$1) {
                        setIsRunningInsertionEffect(true);
                      }
                    }
                    safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);
                    {
                      if ((flags & Insertion) !== NoFlags$1) {
                        setIsRunningInsertionEffect(false);
                      }
                    }
                    {
                      if ((flags & Passive$1) !== NoFlags$1) {
                        markComponentPassiveEffectUnmountStopped();
                      } else if ((flags & Layout) !== NoFlags$1) {
                        markComponentLayoutEffectUnmountStopped();
                      }
                    }
                  }
                }
                effect = effect.next;
              } while (effect !== firstEffect);
            }
          }
          function commitHookEffectListMount(flags, finishedWork) {
            var updateQueue = finishedWork.updateQueue;
            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
            if (lastEffect !== null) {
              var firstEffect = lastEffect.next;
              var effect = firstEffect;
              do {
                if ((effect.tag & flags) === flags) {
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectMountStarted(finishedWork);
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectMountStarted(finishedWork);
                    }
                  }
                  var create6 = effect.create;
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(true);
                    }
                  }
                  effect.destroy = create6();
                  {
                    if ((flags & Insertion) !== NoFlags$1) {
                      setIsRunningInsertionEffect(false);
                    }
                  }
                  {
                    if ((flags & Passive$1) !== NoFlags$1) {
                      markComponentPassiveEffectMountStopped();
                    } else if ((flags & Layout) !== NoFlags$1) {
                      markComponentLayoutEffectMountStopped();
                    }
                  }
                  {
                    var destroy = effect.destroy;
                    if (destroy !== void 0 && typeof destroy !== "function") {
                      var hookName = void 0;
                      if ((effect.tag & Layout) !== NoFlags) {
                        hookName = "useLayoutEffect";
                      } else if ((effect.tag & Insertion) !== NoFlags) {
                        hookName = "useInsertionEffect";
                      } else {
                        hookName = "useEffect";
                      }
                      var addendum = void 0;
                      if (destroy === null) {
                        addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing).";
                      } else if (typeof destroy.then === "function") {
                        addendum = "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                      } else {
                        addendum = " You returned: " + destroy;
                      }
                      error3("%s must not return anything besides a function, which is used for clean-up.%s", hookName, addendum);
                    }
                  }
                }
                effect = effect.next;
              } while (effect !== firstEffect);
            }
          }
          function commitPassiveEffectDurations(finishedRoot, finishedWork) {
            {
              if ((finishedWork.flags & Update) !== NoFlags) {
                switch (finishedWork.tag) {
                  case Profiler: {
                    var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;
                    var _finishedWork$memoize = finishedWork.memoizedProps, id2 = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit;
                    var commitTime2 = getCommitTime();
                    var phase = finishedWork.alternate === null ? "mount" : "update";
                    {
                      if (isCurrentUpdateNested()) {
                        phase = "nested-update";
                      }
                    }
                    if (typeof onPostCommit === "function") {
                      onPostCommit(id2, phase, passiveEffectDuration, commitTime2);
                    }
                    var parentFiber = finishedWork.return;
                    outer:
                      while (parentFiber !== null) {
                        switch (parentFiber.tag) {
                          case HostRoot:
                            var root2 = parentFiber.stateNode;
                            root2.passiveEffectDuration += passiveEffectDuration;
                            break outer;
                          case Profiler:
                            var parentStateNode = parentFiber.stateNode;
                            parentStateNode.passiveEffectDuration += passiveEffectDuration;
                            break outer;
                        }
                        parentFiber = parentFiber.return;
                      }
                    break;
                  }
                }
              }
            }
          }
          function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork, committedLanes) {
            if ((finishedWork.flags & LayoutMask) !== NoFlags) {
              switch (finishedWork.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  if (!offscreenSubtreeWasHidden) {
                    if (finishedWork.mode & ProfileMode) {
                      try {
                        startLayoutEffectTimer();
                        commitHookEffectListMount(Layout | HasEffect, finishedWork);
                      } finally {
                        recordLayoutEffectDuration(finishedWork);
                      }
                    } else {
                      commitHookEffectListMount(Layout | HasEffect, finishedWork);
                    }
                  }
                  break;
                }
                case ClassComponent: {
                  var instance = finishedWork.stateNode;
                  if (finishedWork.flags & Update) {
                    if (!offscreenSubtreeWasHidden) {
                      if (current2 === null) {
                        {
                          if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                            if (instance.props !== finishedWork.memoizedProps) {
                              error3("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                            if (instance.state !== finishedWork.memoizedState) {
                              error3("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                          }
                        }
                        if (finishedWork.mode & ProfileMode) {
                          try {
                            startLayoutEffectTimer();
                            instance.componentDidMount();
                          } finally {
                            recordLayoutEffectDuration(finishedWork);
                          }
                        } else {
                          instance.componentDidMount();
                        }
                      } else {
                        var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);
                        var prevState = current2.memoizedState;
                        {
                          if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                            if (instance.props !== finishedWork.memoizedProps) {
                              error3("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                            if (instance.state !== finishedWork.memoizedState) {
                              error3("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                            }
                          }
                        }
                        if (finishedWork.mode & ProfileMode) {
                          try {
                            startLayoutEffectTimer();
                            instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                          } finally {
                            recordLayoutEffectDuration(finishedWork);
                          }
                        } else {
                          instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                        }
                      }
                    }
                  }
                  var updateQueue = finishedWork.updateQueue;
                  if (updateQueue !== null) {
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error3("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error3("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                      }
                    }
                    commitUpdateQueue(finishedWork, updateQueue, instance);
                  }
                  break;
                }
                case HostRoot: {
                  var _updateQueue = finishedWork.updateQueue;
                  if (_updateQueue !== null) {
                    var _instance = null;
                    if (finishedWork.child !== null) {
                      switch (finishedWork.child.tag) {
                        case HostComponent:
                          _instance = getPublicInstance(finishedWork.child.stateNode);
                          break;
                        case ClassComponent:
                          _instance = finishedWork.child.stateNode;
                          break;
                      }
                    }
                    commitUpdateQueue(finishedWork, _updateQueue, _instance);
                  }
                  break;
                }
                case HostComponent: {
                  var _instance2 = finishedWork.stateNode;
                  if (current2 === null && finishedWork.flags & Update) {
                    var type = finishedWork.type;
                    var props = finishedWork.memoizedProps;
                    commitMount(_instance2, type, props);
                  }
                  break;
                }
                case HostText: {
                  break;
                }
                case HostPortal: {
                  break;
                }
                case Profiler: {
                  {
                    var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                    var effectDuration = finishedWork.stateNode.effectDuration;
                    var commitTime2 = getCommitTime();
                    var phase = current2 === null ? "mount" : "update";
                    {
                      if (isCurrentUpdateNested()) {
                        phase = "nested-update";
                      }
                    }
                    if (typeof onRender === "function") {
                      onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);
                    }
                    {
                      if (typeof onCommit === "function") {
                        onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2);
                      }
                      enqueuePendingPassiveProfilerEffect(finishedWork);
                      var parentFiber = finishedWork.return;
                      outer:
                        while (parentFiber !== null) {
                          switch (parentFiber.tag) {
                            case HostRoot:
                              var root2 = parentFiber.stateNode;
                              root2.effectDuration += effectDuration;
                              break outer;
                            case Profiler:
                              var parentStateNode = parentFiber.stateNode;
                              parentStateNode.effectDuration += effectDuration;
                              break outer;
                          }
                          parentFiber = parentFiber.return;
                        }
                    }
                  }
                  break;
                }
                case SuspenseComponent: {
                  commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
                  break;
                }
                case SuspenseListComponent:
                case IncompleteClassComponent:
                case ScopeComponent:
                case OffscreenComponent:
                case LegacyHiddenComponent:
                case TracingMarkerComponent: {
                  break;
                }
                default:
                  throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
              }
            }
            if (!offscreenSubtreeWasHidden) {
              {
                if (finishedWork.flags & Ref) {
                  commitAttachRef(finishedWork);
                }
              }
            }
          }
          function reappearLayoutEffectsOnFiber(node) {
            switch (node.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (node.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    safelyCallCommitHookLayoutEffectListMount(node, node.return);
                  } finally {
                    recordLayoutEffectDuration(node);
                  }
                } else {
                  safelyCallCommitHookLayoutEffectListMount(node, node.return);
                }
                break;
              }
              case ClassComponent: {
                var instance = node.stateNode;
                if (typeof instance.componentDidMount === "function") {
                  safelyCallComponentDidMount(node, node.return, instance);
                }
                safelyAttachRef(node, node.return);
                break;
              }
              case HostComponent: {
                safelyAttachRef(node, node.return);
                break;
              }
            }
          }
          function hideOrUnhideAllChildren(finishedWork, isHidden) {
            var hostSubtreeRoot = null;
            {
              var node = finishedWork;
              while (true) {
                if (node.tag === HostComponent) {
                  if (hostSubtreeRoot === null) {
                    hostSubtreeRoot = node;
                    try {
                      var instance = node.stateNode;
                      if (isHidden) {
                        hideInstance(instance);
                      } else {
                        unhideInstance(node.stateNode, node.memoizedProps);
                      }
                    } catch (error4) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error4);
                    }
                  }
                } else if (node.tag === HostText) {
                  if (hostSubtreeRoot === null) {
                    try {
                      var _instance3 = node.stateNode;
                      if (isHidden) {
                        hideTextInstance(_instance3);
                      } else {
                        unhideTextInstance(_instance3, node.memoizedProps);
                      }
                    } catch (error4) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error4);
                    }
                  }
                } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork)
                  ;
                else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === finishedWork) {
                  return;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === finishedWork) {
                    return;
                  }
                  if (hostSubtreeRoot === node) {
                    hostSubtreeRoot = null;
                  }
                  node = node.return;
                }
                if (hostSubtreeRoot === node) {
                  hostSubtreeRoot = null;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            }
          }
          function commitAttachRef(finishedWork) {
            var ref = finishedWork.ref;
            if (ref !== null) {
              var instance = finishedWork.stateNode;
              var instanceToUse;
              switch (finishedWork.tag) {
                case HostComponent:
                  instanceToUse = getPublicInstance(instance);
                  break;
                default:
                  instanceToUse = instance;
              }
              if (typeof ref === "function") {
                var retVal;
                if (finishedWork.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    retVal = ref(instanceToUse);
                  } finally {
                    recordLayoutEffectDuration(finishedWork);
                  }
                } else {
                  retVal = ref(instanceToUse);
                }
                {
                  if (typeof retVal === "function") {
                    error3("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(finishedWork));
                  }
                }
              } else {
                {
                  if (!ref.hasOwnProperty("current")) {
                    error3("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork));
                  }
                }
                ref.current = instanceToUse;
              }
            }
          }
          function detachFiberMutation(fiber) {
            var alternate = fiber.alternate;
            if (alternate !== null) {
              alternate.return = null;
            }
            fiber.return = null;
          }
          function detachFiberAfterEffects(fiber) {
            var alternate = fiber.alternate;
            if (alternate !== null) {
              fiber.alternate = null;
              detachFiberAfterEffects(alternate);
            }
            {
              fiber.child = null;
              fiber.deletions = null;
              fiber.sibling = null;
              if (fiber.tag === HostComponent) {
                var hostInstance = fiber.stateNode;
                if (hostInstance !== null) {
                  detachDeletedInstance(hostInstance);
                }
              }
              fiber.stateNode = null;
              {
                fiber._debugOwner = null;
              }
              {
                fiber.return = null;
                fiber.dependencies = null;
                fiber.memoizedProps = null;
                fiber.memoizedState = null;
                fiber.pendingProps = null;
                fiber.stateNode = null;
                fiber.updateQueue = null;
              }
            }
          }
          function getHostParentFiber(fiber) {
            var parent2 = fiber.return;
            while (parent2 !== null) {
              if (isHostParent(parent2)) {
                return parent2;
              }
              parent2 = parent2.return;
            }
            throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
          }
          function isHostParent(fiber) {
            return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
          }
          function getHostSibling(fiber) {
            var node = fiber;
            siblings:
              while (true) {
                while (node.sibling === null) {
                  if (node.return === null || isHostParent(node.return)) {
                    return null;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
                while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
                  if (node.flags & Placement) {
                    continue siblings;
                  }
                  if (node.child === null || node.tag === HostPortal) {
                    continue siblings;
                  } else {
                    node.child.return = node;
                    node = node.child;
                  }
                }
                if (!(node.flags & Placement)) {
                  return node.stateNode;
                }
              }
          }
          function commitPlacement(finishedWork) {
            var parentFiber = getHostParentFiber(finishedWork);
            switch (parentFiber.tag) {
              case HostComponent: {
                var parent2 = parentFiber.stateNode;
                if (parentFiber.flags & ContentReset) {
                  resetTextContent(parent2);
                  parentFiber.flags &= ~ContentReset;
                }
                var before = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before, parent2);
                break;
              }
              case HostRoot:
              case HostPortal: {
                var _parent = parentFiber.stateNode.containerInfo;
                var _before = getHostSibling(finishedWork);
                insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
                break;
              }
              default:
                throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          function insertOrAppendPlacementNodeIntoContainer(node, before, parent2) {
            var tag = node.tag;
            var isHost = tag === HostComponent || tag === HostText;
            if (isHost) {
              var stateNode = node.stateNode;
              if (before) {
                insertInContainerBefore(parent2, stateNode, before);
              } else {
                appendChildToContainer(parent2, stateNode);
              }
            } else if (tag === HostPortal)
              ;
            else {
              var child = node.child;
              if (child !== null) {
                insertOrAppendPlacementNodeIntoContainer(child, before, parent2);
                var sibling = child.sibling;
                while (sibling !== null) {
                  insertOrAppendPlacementNodeIntoContainer(sibling, before, parent2);
                  sibling = sibling.sibling;
                }
              }
            }
          }
          function insertOrAppendPlacementNode(node, before, parent2) {
            var tag = node.tag;
            var isHost = tag === HostComponent || tag === HostText;
            if (isHost) {
              var stateNode = node.stateNode;
              if (before) {
                insertBefore(parent2, stateNode, before);
              } else {
                appendChild(parent2, stateNode);
              }
            } else if (tag === HostPortal)
              ;
            else {
              var child = node.child;
              if (child !== null) {
                insertOrAppendPlacementNode(child, before, parent2);
                var sibling = child.sibling;
                while (sibling !== null) {
                  insertOrAppendPlacementNode(sibling, before, parent2);
                  sibling = sibling.sibling;
                }
              }
            }
          }
          var hostParent = null;
          var hostParentIsContainer = false;
          function commitDeletionEffects(root2, returnFiber, deletedFiber) {
            {
              var parent2 = returnFiber;
              findParent:
                while (parent2 !== null) {
                  switch (parent2.tag) {
                    case HostComponent: {
                      hostParent = parent2.stateNode;
                      hostParentIsContainer = false;
                      break findParent;
                    }
                    case HostRoot: {
                      hostParent = parent2.stateNode.containerInfo;
                      hostParentIsContainer = true;
                      break findParent;
                    }
                    case HostPortal: {
                      hostParent = parent2.stateNode.containerInfo;
                      hostParentIsContainer = true;
                      break findParent;
                    }
                  }
                  parent2 = parent2.return;
                }
              if (hostParent === null) {
                throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
              }
              commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);
              hostParent = null;
              hostParentIsContainer = false;
            }
            detachFiberMutation(deletedFiber);
          }
          function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent2) {
            var child = parent2.child;
            while (child !== null) {
              commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
              child = child.sibling;
            }
          }
          function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
            onCommitUnmount(deletedFiber);
            switch (deletedFiber.tag) {
              case HostComponent: {
                if (!offscreenSubtreeWasHidden) {
                  safelyDetachRef(deletedFiber, nearestMountedAncestor);
                }
              }
              case HostText: {
                {
                  var prevHostParent = hostParent;
                  var prevHostParentIsContainer = hostParentIsContainer;
                  hostParent = null;
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                  hostParent = prevHostParent;
                  hostParentIsContainer = prevHostParentIsContainer;
                  if (hostParent !== null) {
                    if (hostParentIsContainer) {
                      removeChildFromContainer(hostParent, deletedFiber.stateNode);
                    } else {
                      removeChild(hostParent, deletedFiber.stateNode);
                    }
                  }
                }
                return;
              }
              case DehydratedFragment: {
                {
                  if (hostParent !== null) {
                    if (hostParentIsContainer) {
                      clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);
                    } else {
                      clearSuspenseBoundary(hostParent, deletedFiber.stateNode);
                    }
                  }
                }
                return;
              }
              case HostPortal: {
                {
                  var _prevHostParent = hostParent;
                  var _prevHostParentIsContainer = hostParentIsContainer;
                  hostParent = deletedFiber.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                  hostParent = _prevHostParent;
                  hostParentIsContainer = _prevHostParentIsContainer;
                }
                return;
              }
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent: {
                if (!offscreenSubtreeWasHidden) {
                  var updateQueue = deletedFiber.updateQueue;
                  if (updateQueue !== null) {
                    var lastEffect = updateQueue.lastEffect;
                    if (lastEffect !== null) {
                      var firstEffect = lastEffect.next;
                      var effect = firstEffect;
                      do {
                        var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;
                        if (destroy !== void 0) {
                          if ((tag & Insertion) !== NoFlags$1) {
                            safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                          } else if ((tag & Layout) !== NoFlags$1) {
                            {
                              markComponentLayoutEffectUnmountStarted(deletedFiber);
                            }
                            if (deletedFiber.mode & ProfileMode) {
                              startLayoutEffectTimer();
                              safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                              recordLayoutEffectDuration(deletedFiber);
                            } else {
                              safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                            }
                            {
                              markComponentLayoutEffectUnmountStopped();
                            }
                          }
                        }
                        effect = effect.next;
                      } while (effect !== firstEffect);
                    }
                  }
                }
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
              case ClassComponent: {
                if (!offscreenSubtreeWasHidden) {
                  safelyDetachRef(deletedFiber, nearestMountedAncestor);
                  var instance = deletedFiber.stateNode;
                  if (typeof instance.componentWillUnmount === "function") {
                    safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);
                  }
                }
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
              case ScopeComponent: {
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
              case OffscreenComponent: {
                if (deletedFiber.mode & ConcurrentMode) {
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                } else {
                  recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                }
                break;
              }
              default: {
                recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
                return;
              }
            }
          }
          function commitSuspenseCallback(finishedWork) {
            var newState = finishedWork.memoizedState;
          }
          function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
            var newState = finishedWork.memoizedState;
            if (newState === null) {
              var current2 = finishedWork.alternate;
              if (current2 !== null) {
                var prevState = current2.memoizedState;
                if (prevState !== null) {
                  var suspenseInstance = prevState.dehydrated;
                  if (suspenseInstance !== null) {
                    commitHydratedSuspenseInstance(suspenseInstance);
                  }
                }
              }
            }
          }
          function attachSuspenseRetryListeners(finishedWork) {
            var wakeables = finishedWork.updateQueue;
            if (wakeables !== null) {
              finishedWork.updateQueue = null;
              var retryCache = finishedWork.stateNode;
              if (retryCache === null) {
                retryCache = finishedWork.stateNode = new PossiblyWeakSet();
              }
              wakeables.forEach(function(wakeable) {
                var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
                if (!retryCache.has(wakeable)) {
                  retryCache.add(wakeable);
                  {
                    if (isDevToolsPresent) {
                      if (inProgressLanes !== null && inProgressRoot !== null) {
                        restorePendingUpdaters(inProgressRoot, inProgressLanes);
                      } else {
                        throw Error("Expected finished root and lanes to be set. This is a bug in React.");
                      }
                    }
                  }
                  wakeable.then(retry, retry);
                }
              });
            }
          }
          function commitMutationEffects(root2, finishedWork, committedLanes) {
            inProgressLanes = committedLanes;
            inProgressRoot = root2;
            setCurrentFiber(finishedWork);
            commitMutationEffectsOnFiber(finishedWork, root2);
            setCurrentFiber(finishedWork);
            inProgressLanes = null;
            inProgressRoot = null;
          }
          function recursivelyTraverseMutationEffects(root2, parentFiber, lanes) {
            var deletions = parentFiber.deletions;
            if (deletions !== null) {
              for (var i = 0; i < deletions.length; i++) {
                var childToDelete = deletions[i];
                try {
                  commitDeletionEffects(root2, parentFiber, childToDelete);
                } catch (error4) {
                  captureCommitPhaseError(childToDelete, parentFiber, error4);
                }
              }
            }
            var prevDebugFiber = getCurrentFiber();
            if (parentFiber.subtreeFlags & MutationMask) {
              var child = parentFiber.child;
              while (child !== null) {
                setCurrentFiber(child);
                commitMutationEffectsOnFiber(child, root2);
                child = child.sibling;
              }
            }
            setCurrentFiber(prevDebugFiber);
          }
          function commitMutationEffectsOnFiber(finishedWork, root2, lanes) {
            var current2 = finishedWork.alternate;
            var flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case MemoComponent:
              case SimpleMemoComponent: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  try {
                    commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);
                    commitHookEffectListMount(Insertion | HasEffect, finishedWork);
                  } catch (error4) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error4);
                  }
                  if (finishedWork.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                    } catch (error4) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error4);
                    }
                    recordLayoutEffectDuration(finishedWork);
                  } else {
                    try {
                      commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                    } catch (error4) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error4);
                    }
                  }
                }
                return;
              }
              case ClassComponent: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Ref) {
                  if (current2 !== null) {
                    safelyDetachRef(current2, current2.return);
                  }
                }
                return;
              }
              case HostComponent: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Ref) {
                  if (current2 !== null) {
                    safelyDetachRef(current2, current2.return);
                  }
                }
                {
                  if (finishedWork.flags & ContentReset) {
                    var instance = finishedWork.stateNode;
                    try {
                      resetTextContent(instance);
                    } catch (error4) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error4);
                    }
                  }
                  if (flags & Update) {
                    var _instance4 = finishedWork.stateNode;
                    if (_instance4 != null) {
                      var newProps = finishedWork.memoizedProps;
                      var oldProps = current2 !== null ? current2.memoizedProps : newProps;
                      var type = finishedWork.type;
                      var updatePayload = finishedWork.updateQueue;
                      finishedWork.updateQueue = null;
                      if (updatePayload !== null) {
                        try {
                          commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);
                        } catch (error4) {
                          captureCommitPhaseError(finishedWork, finishedWork.return, error4);
                        }
                      }
                    }
                  }
                }
                return;
              }
              case HostText: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  {
                    if (finishedWork.stateNode === null) {
                      throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
                    }
                    var textInstance = finishedWork.stateNode;
                    var newText = finishedWork.memoizedProps;
                    var oldText = current2 !== null ? current2.memoizedProps : newText;
                    try {
                      commitTextUpdate(textInstance, oldText, newText);
                    } catch (error4) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error4);
                    }
                  }
                }
                return;
              }
              case HostRoot: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  {
                    if (current2 !== null) {
                      var prevRootState = current2.memoizedState;
                      if (prevRootState.isDehydrated) {
                        try {
                          commitHydratedContainer(root2.containerInfo);
                        } catch (error4) {
                          captureCommitPhaseError(finishedWork, finishedWork.return, error4);
                        }
                      }
                    }
                  }
                }
                return;
              }
              case HostPortal: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                return;
              }
              case SuspenseComponent: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                var offscreenFiber = finishedWork.child;
                if (offscreenFiber.flags & Visibility) {
                  var offscreenInstance = offscreenFiber.stateNode;
                  var newState = offscreenFiber.memoizedState;
                  var isHidden = newState !== null;
                  offscreenInstance.isHidden = isHidden;
                  if (isHidden) {
                    var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;
                    if (!wasHidden) {
                      markCommitTimeOfFallback();
                    }
                  }
                }
                if (flags & Update) {
                  try {
                    commitSuspenseCallback(finishedWork);
                  } catch (error4) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error4);
                  }
                  attachSuspenseRetryListeners(finishedWork);
                }
                return;
              }
              case OffscreenComponent: {
                var _wasHidden = current2 !== null && current2.memoizedState !== null;
                if (finishedWork.mode & ConcurrentMode) {
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;
                  recursivelyTraverseMutationEffects(root2, finishedWork);
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                } else {
                  recursivelyTraverseMutationEffects(root2, finishedWork);
                }
                commitReconciliationEffects(finishedWork);
                if (flags & Visibility) {
                  var _offscreenInstance = finishedWork.stateNode;
                  var _newState = finishedWork.memoizedState;
                  var _isHidden = _newState !== null;
                  var offscreenBoundary = finishedWork;
                  _offscreenInstance.isHidden = _isHidden;
                  {
                    if (_isHidden) {
                      if (!_wasHidden) {
                        if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
                          nextEffect = offscreenBoundary;
                          var offscreenChild = offscreenBoundary.child;
                          while (offscreenChild !== null) {
                            nextEffect = offscreenChild;
                            disappearLayoutEffects_begin(offscreenChild);
                            offscreenChild = offscreenChild.sibling;
                          }
                        }
                      }
                    }
                  }
                  {
                    hideOrUnhideAllChildren(offscreenBoundary, _isHidden);
                  }
                }
                return;
              }
              case SuspenseListComponent: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                if (flags & Update) {
                  attachSuspenseRetryListeners(finishedWork);
                }
                return;
              }
              case ScopeComponent: {
                return;
              }
              default: {
                recursivelyTraverseMutationEffects(root2, finishedWork);
                commitReconciliationEffects(finishedWork);
                return;
              }
            }
          }
          function commitReconciliationEffects(finishedWork) {
            var flags = finishedWork.flags;
            if (flags & Placement) {
              try {
                commitPlacement(finishedWork);
              } catch (error4) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error4);
              }
              finishedWork.flags &= ~Placement;
            }
            if (flags & Hydrating) {
              finishedWork.flags &= ~Hydrating;
            }
          }
          function commitLayoutEffects(finishedWork, root2, committedLanes) {
            inProgressLanes = committedLanes;
            inProgressRoot = root2;
            nextEffect = finishedWork;
            commitLayoutEffects_begin(finishedWork, root2, committedLanes);
            inProgressLanes = null;
            inProgressRoot = null;
          }
          function commitLayoutEffects_begin(subtreeRoot, root2, committedLanes) {
            var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              if (fiber.tag === OffscreenComponent && isModernRoot) {
                var isHidden = fiber.memoizedState !== null;
                var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;
                if (newOffscreenSubtreeIsHidden) {
                  commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
                  continue;
                } else {
                  var current2 = fiber.alternate;
                  var wasHidden = current2 !== null && current2.memoizedState !== null;
                  var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;
                  var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;
                  var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
                  offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;
                  offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;
                  if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {
                    nextEffect = fiber;
                    reappearLayoutEffects_begin(fiber);
                  }
                  var child = firstChild;
                  while (child !== null) {
                    nextEffect = child;
                    commitLayoutEffects_begin(
                      child,
                      root2,
                      committedLanes
                    );
                    child = child.sibling;
                  }
                  nextEffect = fiber;
                  offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
                  offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
                  commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
                  continue;
                }
              }
              if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
              }
            }
          }
          function commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if ((fiber.flags & LayoutMask) !== NoFlags) {
                var current2 = fiber.alternate;
                setCurrentFiber(fiber);
                try {
                  commitLayoutEffectOnFiber(root2, current2, fiber, committedLanes);
                } catch (error4) {
                  captureCommitPhaseError(fiber, fiber.return, error4);
                }
                resetCurrentFiber();
              }
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function disappearLayoutEffects_begin(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case MemoComponent:
                case SimpleMemoComponent: {
                  if (fiber.mode & ProfileMode) {
                    try {
                      startLayoutEffectTimer();
                      commitHookEffectListUnmount(Layout, fiber, fiber.return);
                    } finally {
                      recordLayoutEffectDuration(fiber);
                    }
                  } else {
                    commitHookEffectListUnmount(Layout, fiber, fiber.return);
                  }
                  break;
                }
                case ClassComponent: {
                  safelyDetachRef(fiber, fiber.return);
                  var instance = fiber.stateNode;
                  if (typeof instance.componentWillUnmount === "function") {
                    safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                  }
                  break;
                }
                case HostComponent: {
                  safelyDetachRef(fiber, fiber.return);
                  break;
                }
                case OffscreenComponent: {
                  var isHidden = fiber.memoizedState !== null;
                  if (isHidden) {
                    disappearLayoutEffects_complete(subtreeRoot);
                    continue;
                  }
                  break;
                }
              }
              if (firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                disappearLayoutEffects_complete(subtreeRoot);
              }
            }
          }
          function disappearLayoutEffects_complete(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function reappearLayoutEffects_begin(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              if (fiber.tag === OffscreenComponent) {
                var isHidden = fiber.memoizedState !== null;
                if (isHidden) {
                  reappearLayoutEffects_complete(subtreeRoot);
                  continue;
                }
              }
              if (firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                reappearLayoutEffects_complete(subtreeRoot);
              }
            }
          }
          function reappearLayoutEffects_complete(subtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              setCurrentFiber(fiber);
              try {
                reappearLayoutEffectsOnFiber(fiber);
              } catch (error4) {
                captureCommitPhaseError(fiber, fiber.return, error4);
              }
              resetCurrentFiber();
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitPassiveMountEffects(root2, finishedWork, committedLanes, committedTransitions) {
            nextEffect = finishedWork;
            commitPassiveMountEffects_begin(finishedWork, root2, committedLanes, committedTransitions);
          }
          function commitPassiveMountEffects_begin(subtreeRoot, root2, committedLanes, committedTransitions) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var firstChild = fiber.child;
              if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {
                firstChild.return = fiber;
                nextEffect = firstChild;
              } else {
                commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions);
              }
            }
          }
          function commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if ((fiber.flags & Passive) !== NoFlags) {
                setCurrentFiber(fiber);
                try {
                  commitPassiveMountOnFiber(root2, fiber, committedLanes, committedTransitions);
                } catch (error4) {
                  captureCommitPhaseError(fiber, fiber.return, error4);
                }
                resetCurrentFiber();
              }
              if (fiber === subtreeRoot) {
                nextEffect = null;
                return;
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (finishedWork.mode & ProfileMode) {
                  startPassiveEffectTimer();
                  try {
                    commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                  } finally {
                    recordPassiveEffectDuration(finishedWork);
                  }
                } else {
                  commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
                }
                break;
              }
            }
          }
          function commitPassiveUnmountEffects(firstChild) {
            nextEffect = firstChild;
            commitPassiveUnmountEffects_begin();
          }
          function commitPassiveUnmountEffects_begin() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var child = fiber.child;
              if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
                var deletions = fiber.deletions;
                if (deletions !== null) {
                  for (var i = 0; i < deletions.length; i++) {
                    var fiberToDelete = deletions[i];
                    nextEffect = fiberToDelete;
                    commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);
                  }
                  {
                    var previousFiber = fiber.alternate;
                    if (previousFiber !== null) {
                      var detachedChild = previousFiber.child;
                      if (detachedChild !== null) {
                        previousFiber.child = null;
                        do {
                          var detachedSibling = detachedChild.sibling;
                          detachedChild.sibling = null;
                          detachedChild = detachedSibling;
                        } while (detachedChild !== null);
                      }
                    }
                  }
                  nextEffect = fiber;
                }
              }
              if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {
                child.return = fiber;
                nextEffect = child;
              } else {
                commitPassiveUnmountEffects_complete();
              }
            }
          }
          function commitPassiveUnmountEffects_complete() {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              if ((fiber.flags & Passive) !== NoFlags) {
                setCurrentFiber(fiber);
                commitPassiveUnmountOnFiber(fiber);
                resetCurrentFiber();
              }
              var sibling = fiber.sibling;
              if (sibling !== null) {
                sibling.return = fiber.return;
                nextEffect = sibling;
                return;
              }
              nextEffect = fiber.return;
            }
          }
          function commitPassiveUnmountOnFiber(finishedWork) {
            switch (finishedWork.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (finishedWork.mode & ProfileMode) {
                  startPassiveEffectTimer();
                  commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                  recordPassiveEffectDuration(finishedWork);
                } else {
                  commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
                }
                break;
              }
            }
          }
          function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              setCurrentFiber(fiber);
              commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);
              resetCurrentFiber();
              var child = fiber.child;
              if (child !== null) {
                child.return = fiber;
                nextEffect = child;
              } else {
                commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);
              }
            }
          }
          function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
            while (nextEffect !== null) {
              var fiber = nextEffect;
              var sibling = fiber.sibling;
              var returnFiber = fiber.return;
              {
                detachFiberAfterEffects(fiber);
                if (fiber === deletedSubtreeRoot) {
                  nextEffect = null;
                  return;
                }
              }
              if (sibling !== null) {
                sibling.return = returnFiber;
                nextEffect = sibling;
                return;
              }
              nextEffect = returnFiber;
            }
          }
          function commitPassiveUnmountInsideDeletedTreeOnFiber(current2, nearestMountedAncestor) {
            switch (current2.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                if (current2.mode & ProfileMode) {
                  startPassiveEffectTimer();
                  commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
                  recordPassiveEffectDuration(current2);
                } else {
                  commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
                }
                break;
              }
            }
          }
          function invokeLayoutEffectMountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListMount(Layout | HasEffect, fiber);
                  } catch (error4) {
                    captureCommitPhaseError(fiber, fiber.return, error4);
                  }
                  break;
                }
                case ClassComponent: {
                  var instance = fiber.stateNode;
                  try {
                    instance.componentDidMount();
                  } catch (error4) {
                    captureCommitPhaseError(fiber, fiber.return, error4);
                  }
                  break;
                }
              }
            }
          }
          function invokePassiveEffectMountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListMount(Passive$1 | HasEffect, fiber);
                  } catch (error4) {
                    captureCommitPhaseError(fiber, fiber.return, error4);
                  }
                  break;
                }
              }
            }
          }
          function invokeLayoutEffectUnmountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);
                  } catch (error4) {
                    captureCommitPhaseError(fiber, fiber.return, error4);
                  }
                  break;
                }
                case ClassComponent: {
                  var instance = fiber.stateNode;
                  if (typeof instance.componentWillUnmount === "function") {
                    safelyCallComponentWillUnmount(fiber, fiber.return, instance);
                  }
                  break;
                }
              }
            }
          }
          function invokePassiveEffectUnmountInDEV(fiber) {
            {
              switch (fiber.tag) {
                case FunctionComponent:
                case ForwardRef:
                case SimpleMemoComponent: {
                  try {
                    commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);
                  } catch (error4) {
                    captureCommitPhaseError(fiber, fiber.return, error4);
                  }
                }
              }
            }
          }
          var COMPONENT_TYPE = 0;
          var HAS_PSEUDO_CLASS_TYPE = 1;
          var ROLE_TYPE = 2;
          var TEST_NAME_TYPE = 3;
          var TEXT_TYPE = 4;
          if (typeof Symbol === "function" && Symbol.for) {
            var symbolFor = Symbol.for;
            COMPONENT_TYPE = symbolFor("selector.component");
            HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
            ROLE_TYPE = symbolFor("selector.role");
            TEST_NAME_TYPE = symbolFor("selector.test_id");
            TEXT_TYPE = symbolFor("selector.text");
          }
          var commitHooks = [];
          function onCommitRoot$1() {
            {
              commitHooks.forEach(function(commitHook) {
                return commitHook();
              });
            }
          }
          var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;
          function isLegacyActEnvironment(fiber) {
            {
              var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0;
              var jestIsDefined = typeof jest !== "undefined";
              return jestIsDefined && isReactActEnvironmentGlobal !== false;
            }
          }
          function isConcurrentActEnvironment() {
            {
              var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : void 0;
              if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {
                error3("The current testing environment is not configured to support act(...)");
              }
              return isReactActEnvironmentGlobal;
            }
          }
          var ceil2 = Math.ceil;
          var ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$3 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue;
          var NoContext = 0;
          var BatchedContext = 1;
          var RenderContext = 2;
          var CommitContext = 4;
          var RootInProgress = 0;
          var RootFatalErrored = 1;
          var RootErrored = 2;
          var RootSuspended = 3;
          var RootSuspendedWithDelay = 4;
          var RootCompleted = 5;
          var RootDidNotComplete = 6;
          var executionContext = NoContext;
          var workInProgressRoot = null;
          var workInProgress = null;
          var workInProgressRootRenderLanes = NoLanes;
          var subtreeRenderLanes = NoLanes;
          var subtreeRenderLanesCursor = createCursor(NoLanes);
          var workInProgressRootExitStatus = RootInProgress;
          var workInProgressRootFatalError = null;
          var workInProgressRootIncludedLanes = NoLanes;
          var workInProgressRootSkippedLanes = NoLanes;
          var workInProgressRootInterleavedUpdatedLanes = NoLanes;
          var workInProgressRootPingedLanes = NoLanes;
          var workInProgressRootConcurrentErrors = null;
          var workInProgressRootRecoverableErrors = null;
          var globalMostRecentFallbackTime = 0;
          var FALLBACK_THROTTLE_MS = 500;
          var workInProgressRootRenderTargetTime = Infinity;
          var RENDER_TIMEOUT_MS = 500;
          var workInProgressTransitions = null;
          function resetRenderTimer() {
            workInProgressRootRenderTargetTime = now2() + RENDER_TIMEOUT_MS;
          }
          function getRenderTargetTime() {
            return workInProgressRootRenderTargetTime;
          }
          var hasUncaughtError = false;
          var firstUncaughtError = null;
          var legacyErrorBoundariesThatAlreadyFailed = null;
          var rootDoesHavePassiveEffects = false;
          var rootWithPendingPassiveEffects = null;
          var pendingPassiveEffectsLanes = NoLanes;
          var pendingPassiveProfilerEffects = [];
          var pendingPassiveTransitions = null;
          var NESTED_UPDATE_LIMIT = 50;
          var nestedUpdateCount = 0;
          var rootWithNestedUpdates = null;
          var isFlushingPassiveEffects = false;
          var didScheduleUpdateDuringPassiveEffects = false;
          var NESTED_PASSIVE_UPDATE_LIMIT = 50;
          var nestedPassiveUpdateCount = 0;
          var rootWithPassiveNestedUpdates = null;
          var currentEventTime = NoTimestamp;
          var currentEventTransitionLane = NoLanes;
          var isRunningInsertionEffect = false;
          function getWorkInProgressRoot() {
            return workInProgressRoot;
          }
          function requestEventTime() {
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              return now2();
            }
            if (currentEventTime !== NoTimestamp) {
              return currentEventTime;
            }
            currentEventTime = now2();
            return currentEventTime;
          }
          function requestUpdateLane(fiber) {
            var mode = fiber.mode;
            if ((mode & ConcurrentMode) === NoMode) {
              return SyncLane;
            } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {
              return pickArbitraryLane(workInProgressRootRenderLanes);
            }
            var isTransition = requestCurrentTransition() !== NoTransition;
            if (isTransition) {
              if (ReactCurrentBatchConfig$3.transition !== null) {
                var transition = ReactCurrentBatchConfig$3.transition;
                if (!transition._updatedFibers) {
                  transition._updatedFibers = /* @__PURE__ */ new Set();
                }
                transition._updatedFibers.add(fiber);
              }
              if (currentEventTransitionLane === NoLane) {
                currentEventTransitionLane = claimNextTransitionLane();
              }
              return currentEventTransitionLane;
            }
            var updateLane = getCurrentUpdatePriority();
            if (updateLane !== NoLane) {
              return updateLane;
            }
            var eventLane = getCurrentEventPriority();
            return eventLane;
          }
          function requestRetryLane(fiber) {
            var mode = fiber.mode;
            if ((mode & ConcurrentMode) === NoMode) {
              return SyncLane;
            }
            return claimNextRetryLane();
          }
          function scheduleUpdateOnFiber(root2, fiber, lane, eventTime) {
            checkForNestedUpdates();
            {
              if (isRunningInsertionEffect) {
                error3("useInsertionEffect must not schedule updates.");
              }
            }
            {
              if (isFlushingPassiveEffects) {
                didScheduleUpdateDuringPassiveEffects = true;
              }
            }
            markRootUpdated(root2, lane, eventTime);
            if ((executionContext & RenderContext) !== NoLanes && root2 === workInProgressRoot) {
              warnAboutRenderPhaseUpdatesInDEV(fiber);
            } else {
              {
                if (isDevToolsPresent) {
                  addFiberToLanesMap(root2, fiber, lane);
                }
              }
              warnIfUpdatesNotWrappedWithActDEV(fiber);
              if (root2 === workInProgressRoot) {
                if ((executionContext & RenderContext) === NoContext) {
                  workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);
                }
                if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
                  markRootSuspended$1(root2, workInProgressRootRenderLanes);
                }
              }
              ensureRootIsScheduled(root2, eventTime);
              if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && !ReactCurrentActQueue$1.isBatchingLegacy) {
                resetRenderTimer();
                flushSyncCallbacksOnlyInLegacyMode();
              }
            }
          }
          function scheduleInitialHydrationOnRoot(root2, lane, eventTime) {
            var current2 = root2.current;
            current2.lanes = lane;
            markRootUpdated(root2, lane, eventTime);
            ensureRootIsScheduled(root2, eventTime);
          }
          function isUnsafeClassRenderPhaseUpdate(fiber) {
            return (executionContext & RenderContext) !== NoContext;
          }
          function ensureRootIsScheduled(root2, currentTime2) {
            var existingCallbackNode = root2.callbackNode;
            markStarvedLanesAsExpired(root2, currentTime2);
            var nextLanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            if (nextLanes === NoLanes) {
              if (existingCallbackNode !== null) {
                cancelCallback$1(existingCallbackNode);
              }
              root2.callbackNode = null;
              root2.callbackPriority = NoLane;
              return;
            }
            var newCallbackPriority = getHighestPriorityLane(nextLanes);
            var existingCallbackPriority = root2.callbackPriority;
            if (existingCallbackPriority === newCallbackPriority && !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {
              {
                if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {
                  error3("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
                }
              }
              return;
            }
            if (existingCallbackNode != null) {
              cancelCallback$1(existingCallbackNode);
            }
            var newCallbackNode;
            if (newCallbackPriority === SyncLane) {
              if (root2.tag === LegacyRoot) {
                if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {
                  ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;
                }
                scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root2));
              } else {
                scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root2));
              }
              {
                if (ReactCurrentActQueue$1.current !== null) {
                  ReactCurrentActQueue$1.current.push(flushSyncCallbacks);
                } else {
                  scheduleMicrotask(function() {
                    if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                      flushSyncCallbacks();
                    }
                  });
                }
              }
              newCallbackNode = null;
            } else {
              var schedulerPriorityLevel;
              switch (lanesToEventPriority(nextLanes)) {
                case DiscreteEventPriority:
                  schedulerPriorityLevel = ImmediatePriority;
                  break;
                case ContinuousEventPriority:
                  schedulerPriorityLevel = UserBlockingPriority;
                  break;
                case DefaultEventPriority:
                  schedulerPriorityLevel = NormalPriority;
                  break;
                case IdleEventPriority:
                  schedulerPriorityLevel = IdlePriority;
                  break;
                default:
                  schedulerPriorityLevel = NormalPriority;
                  break;
              }
              newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root2));
            }
            root2.callbackPriority = newCallbackPriority;
            root2.callbackNode = newCallbackNode;
          }
          function performConcurrentWorkOnRoot(root2, didTimeout) {
            {
              resetNestedUpdateFlag();
            }
            currentEventTime = NoTimestamp;
            currentEventTransitionLane = NoLanes;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Should not already be working.");
            }
            var originalCallbackNode = root2.callbackNode;
            var didFlushPassiveEffects = flushPassiveEffects();
            if (didFlushPassiveEffects) {
              if (root2.callbackNode !== originalCallbackNode) {
                return null;
              }
            }
            var lanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
            if (lanes === NoLanes) {
              return null;
            }
            var shouldTimeSlice = !includesBlockingLane(root2, lanes) && !includesExpiredLane(root2, lanes) && !didTimeout;
            var exitStatus = shouldTimeSlice ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes);
            if (exitStatus !== RootInProgress) {
              if (exitStatus === RootErrored) {
                var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
                if (errorRetryLanes !== NoLanes) {
                  lanes = errorRetryLanes;
                  exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);
                }
              }
              if (exitStatus === RootFatalErrored) {
                var fatalError = workInProgressRootFatalError;
                prepareFreshStack(root2, NoLanes);
                markRootSuspended$1(root2, lanes);
                ensureRootIsScheduled(root2, now2());
                throw fatalError;
              }
              if (exitStatus === RootDidNotComplete) {
                markRootSuspended$1(root2, lanes);
              } else {
                var renderWasConcurrent = !includesBlockingLane(root2, lanes);
                var finishedWork = root2.current.alternate;
                if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
                  exitStatus = renderRootSync(root2, lanes);
                  if (exitStatus === RootErrored) {
                    var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
                    if (_errorRetryLanes !== NoLanes) {
                      lanes = _errorRetryLanes;
                      exitStatus = recoverFromConcurrentError(root2, _errorRetryLanes);
                    }
                  }
                  if (exitStatus === RootFatalErrored) {
                    var _fatalError = workInProgressRootFatalError;
                    prepareFreshStack(root2, NoLanes);
                    markRootSuspended$1(root2, lanes);
                    ensureRootIsScheduled(root2, now2());
                    throw _fatalError;
                  }
                }
                root2.finishedWork = finishedWork;
                root2.finishedLanes = lanes;
                finishConcurrentRender(root2, exitStatus, lanes);
              }
            }
            ensureRootIsScheduled(root2, now2());
            if (root2.callbackNode === originalCallbackNode) {
              return performConcurrentWorkOnRoot.bind(null, root2);
            }
            return null;
          }
          function recoverFromConcurrentError(root2, errorRetryLanes) {
            var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
            if (isRootDehydrated(root2)) {
              var rootWorkInProgress = prepareFreshStack(root2, errorRetryLanes);
              rootWorkInProgress.flags |= ForceClientRender;
              {
                errorHydratingContainer(root2.containerInfo);
              }
            }
            var exitStatus = renderRootSync(root2, errorRetryLanes);
            if (exitStatus !== RootErrored) {
              var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
              workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
              if (errorsFromSecondAttempt !== null) {
                queueRecoverableErrors(errorsFromSecondAttempt);
              }
            }
            return exitStatus;
          }
          function queueRecoverableErrors(errors) {
            if (workInProgressRootRecoverableErrors === null) {
              workInProgressRootRecoverableErrors = errors;
            } else {
              workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);
            }
          }
          function finishConcurrentRender(root2, exitStatus, lanes) {
            switch (exitStatus) {
              case RootInProgress:
              case RootFatalErrored: {
                throw new Error("Root did not complete. This is a bug in React.");
              }
              case RootErrored: {
                commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              case RootSuspended: {
                markRootSuspended$1(root2, lanes);
                if (includesOnlyRetries(lanes) && !shouldForceFlushFallbacksInDEV()) {
                  var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now2();
                  if (msUntilTimeout > 10) {
                    var nextLanes = getNextLanes(root2, NoLanes);
                    if (nextLanes !== NoLanes) {
                      break;
                    }
                    var suspendedLanes = root2.suspendedLanes;
                    if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                      var eventTime = requestEventTime();
                      markRootPinged(root2, suspendedLanes);
                      break;
                    }
                    root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);
                    break;
                  }
                }
                commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              case RootSuspendedWithDelay: {
                markRootSuspended$1(root2, lanes);
                if (includesOnlyTransitions(lanes)) {
                  break;
                }
                if (!shouldForceFlushFallbacksInDEV()) {
                  var mostRecentEventTime = getMostRecentEventTime(root2, lanes);
                  var eventTimeMs = mostRecentEventTime;
                  var timeElapsedMs = now2() - eventTimeMs;
                  var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
                  if (_msUntilTimeout > 10) {
                    root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);
                    break;
                  }
                }
                commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              case RootCompleted: {
                commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
                break;
              }
              default: {
                throw new Error("Unknown root exit status.");
              }
            }
          }
          function isRenderConsistentWithExternalStores(finishedWork) {
            var node = finishedWork;
            while (true) {
              if (node.flags & StoreConsistency) {
                var updateQueue = node.updateQueue;
                if (updateQueue !== null) {
                  var checks = updateQueue.stores;
                  if (checks !== null) {
                    for (var i = 0; i < checks.length; i++) {
                      var check = checks[i];
                      var getSnapshot = check.getSnapshot;
                      var renderedValue = check.value;
                      try {
                        if (!objectIs(getSnapshot(), renderedValue)) {
                          return false;
                        }
                      } catch (error4) {
                        return false;
                      }
                    }
                  }
                }
              }
              var child = node.child;
              if (node.subtreeFlags & StoreConsistency && child !== null) {
                child.return = node;
                node = child;
                continue;
              }
              if (node === finishedWork) {
                return true;
              }
              while (node.sibling === null) {
                if (node.return === null || node.return === finishedWork) {
                  return true;
                }
                node = node.return;
              }
              node.sibling.return = node.return;
              node = node.sibling;
            }
            return true;
          }
          function markRootSuspended$1(root2, suspendedLanes) {
            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);
            markRootSuspended(root2, suspendedLanes);
          }
          function performSyncWorkOnRoot(root2) {
            {
              syncNestedUpdateFlag();
            }
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Should not already be working.");
            }
            flushPassiveEffects();
            var lanes = getNextLanes(root2, NoLanes);
            if (!includesSomeLane(lanes, SyncLane)) {
              ensureRootIsScheduled(root2, now2());
              return null;
            }
            var exitStatus = renderRootSync(root2, lanes);
            if (root2.tag !== LegacyRoot && exitStatus === RootErrored) {
              var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
              if (errorRetryLanes !== NoLanes) {
                lanes = errorRetryLanes;
                exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);
              }
            }
            if (exitStatus === RootFatalErrored) {
              var fatalError = workInProgressRootFatalError;
              prepareFreshStack(root2, NoLanes);
              markRootSuspended$1(root2, lanes);
              ensureRootIsScheduled(root2, now2());
              throw fatalError;
            }
            if (exitStatus === RootDidNotComplete) {
              throw new Error("Root did not complete. This is a bug in React.");
            }
            var finishedWork = root2.current.alternate;
            root2.finishedWork = finishedWork;
            root2.finishedLanes = lanes;
            commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
            ensureRootIsScheduled(root2, now2());
            return null;
          }
          function flushRoot(root2, lanes) {
            if (lanes !== NoLanes) {
              markRootEntangled(root2, mergeLanes(lanes, SyncLane));
              ensureRootIsScheduled(root2, now2());
              if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                resetRenderTimer();
                flushSyncCallbacks();
              }
            }
          }
          function batchedUpdates$1(fn, a) {
            var prevExecutionContext = executionContext;
            executionContext |= BatchedContext;
            try {
              return fn(a);
            } finally {
              executionContext = prevExecutionContext;
              if (executionContext === NoContext && !ReactCurrentActQueue$1.isBatchingLegacy) {
                resetRenderTimer();
                flushSyncCallbacksOnlyInLegacyMode();
              }
            }
          }
          function discreteUpdates(fn, a, b, c, d) {
            var previousPriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(DiscreteEventPriority);
              return fn(a, b, c, d);
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
              if (executionContext === NoContext) {
                resetRenderTimer();
              }
            }
          }
          function flushSync(fn) {
            if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {
              flushPassiveEffects();
            }
            var prevExecutionContext = executionContext;
            executionContext |= BatchedContext;
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            var previousPriority = getCurrentUpdatePriority();
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(DiscreteEventPriority);
              if (fn) {
                return fn();
              } else {
                return void 0;
              }
            } finally {
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
              executionContext = prevExecutionContext;
              if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                flushSyncCallbacks();
              }
            }
          }
          function isAlreadyRendering() {
            return (executionContext & (RenderContext | CommitContext)) !== NoContext;
          }
          function pushRenderLanes(fiber, lanes) {
            push3(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
            subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
            workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
          }
          function popRenderLanes(fiber) {
            subtreeRenderLanes = subtreeRenderLanesCursor.current;
            pop(subtreeRenderLanesCursor, fiber);
          }
          function prepareFreshStack(root2, lanes) {
            root2.finishedWork = null;
            root2.finishedLanes = NoLanes;
            var timeoutHandle = root2.timeoutHandle;
            if (timeoutHandle !== noTimeout) {
              root2.timeoutHandle = noTimeout;
              cancelTimeout(timeoutHandle);
            }
            if (workInProgress !== null) {
              var interruptedWork = workInProgress.return;
              while (interruptedWork !== null) {
                var current2 = interruptedWork.alternate;
                unwindInterruptedWork(current2, interruptedWork);
                interruptedWork = interruptedWork.return;
              }
            }
            workInProgressRoot = root2;
            var rootWorkInProgress = createWorkInProgress(root2.current, null);
            workInProgress = rootWorkInProgress;
            workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
            workInProgressRootExitStatus = RootInProgress;
            workInProgressRootFatalError = null;
            workInProgressRootSkippedLanes = NoLanes;
            workInProgressRootInterleavedUpdatedLanes = NoLanes;
            workInProgressRootPingedLanes = NoLanes;
            workInProgressRootConcurrentErrors = null;
            workInProgressRootRecoverableErrors = null;
            finishQueueingConcurrentUpdates();
            {
              ReactStrictModeWarnings.discardPendingWarnings();
            }
            return rootWorkInProgress;
          }
          function handleError(root2, thrownValue) {
            do {
              var erroredWork = workInProgress;
              try {
                resetContextDependencies();
                resetHooksAfterThrow();
                resetCurrentFiber();
                ReactCurrentOwner$2.current = null;
                if (erroredWork === null || erroredWork.return === null) {
                  workInProgressRootExitStatus = RootFatalErrored;
                  workInProgressRootFatalError = thrownValue;
                  workInProgress = null;
                  return;
                }
                if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
                  stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
                }
                if (enableSchedulingProfiler) {
                  markComponentRenderStopped();
                  if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
                    var wakeable = thrownValue;
                    markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);
                  } else {
                    markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
                  }
                }
                throwException2(root2, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
                completeUnitOfWork(erroredWork);
              } catch (yetAnotherThrownValue) {
                thrownValue = yetAnotherThrownValue;
                if (workInProgress === erroredWork && erroredWork !== null) {
                  erroredWork = erroredWork.return;
                  workInProgress = erroredWork;
                } else {
                  erroredWork = workInProgress;
                }
                continue;
              }
              return;
            } while (true);
          }
          function pushDispatcher() {
            var prevDispatcher = ReactCurrentDispatcher$2.current;
            ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
            if (prevDispatcher === null) {
              return ContextOnlyDispatcher;
            } else {
              return prevDispatcher;
            }
          }
          function popDispatcher(prevDispatcher) {
            ReactCurrentDispatcher$2.current = prevDispatcher;
          }
          function markCommitTimeOfFallback() {
            globalMostRecentFallbackTime = now2();
          }
          function markSkippedUpdateLanes(lane) {
            workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
          }
          function renderDidSuspend() {
            if (workInProgressRootExitStatus === RootInProgress) {
              workInProgressRootExitStatus = RootSuspended;
            }
          }
          function renderDidSuspendDelayIfPossible() {
            if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {
              workInProgressRootExitStatus = RootSuspendedWithDelay;
            }
            if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {
              markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
            }
          }
          function renderDidError(error4) {
            if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {
              workInProgressRootExitStatus = RootErrored;
            }
            if (workInProgressRootConcurrentErrors === null) {
              workInProgressRootConcurrentErrors = [error4];
            } else {
              workInProgressRootConcurrentErrors.push(error4);
            }
          }
          function renderHasNotSuspendedYet() {
            return workInProgressRootExitStatus === RootInProgress;
          }
          function renderRootSync(root2, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher();
            if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
              {
                if (isDevToolsPresent) {
                  var memoizedUpdaters = root2.memoizedUpdaters;
                  if (memoizedUpdaters.size > 0) {
                    restorePendingUpdaters(root2, workInProgressRootRenderLanes);
                    memoizedUpdaters.clear();
                  }
                  movePendingFibersToMemoized(root2, lanes);
                }
              }
              workInProgressTransitions = getTransitionsForLanes();
              prepareFreshStack(root2, lanes);
            }
            {
              markRenderStarted(lanes);
            }
            do {
              try {
                workLoopSync();
                break;
              } catch (thrownValue) {
                handleError(root2, thrownValue);
              }
            } while (true);
            resetContextDependencies();
            executionContext = prevExecutionContext;
            popDispatcher(prevDispatcher);
            if (workInProgress !== null) {
              throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
            }
            {
              markRenderStopped();
            }
            workInProgressRoot = null;
            workInProgressRootRenderLanes = NoLanes;
            return workInProgressRootExitStatus;
          }
          function workLoopSync() {
            while (workInProgress !== null) {
              performUnitOfWork(workInProgress);
            }
          }
          function renderRootConcurrent(root2, lanes) {
            var prevExecutionContext = executionContext;
            executionContext |= RenderContext;
            var prevDispatcher = pushDispatcher();
            if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
              {
                if (isDevToolsPresent) {
                  var memoizedUpdaters = root2.memoizedUpdaters;
                  if (memoizedUpdaters.size > 0) {
                    restorePendingUpdaters(root2, workInProgressRootRenderLanes);
                    memoizedUpdaters.clear();
                  }
                  movePendingFibersToMemoized(root2, lanes);
                }
              }
              workInProgressTransitions = getTransitionsForLanes();
              resetRenderTimer();
              prepareFreshStack(root2, lanes);
            }
            {
              markRenderStarted(lanes);
            }
            do {
              try {
                workLoopConcurrent();
                break;
              } catch (thrownValue) {
                handleError(root2, thrownValue);
              }
            } while (true);
            resetContextDependencies();
            popDispatcher(prevDispatcher);
            executionContext = prevExecutionContext;
            if (workInProgress !== null) {
              {
                markRenderYielded();
              }
              return RootInProgress;
            } else {
              {
                markRenderStopped();
              }
              workInProgressRoot = null;
              workInProgressRootRenderLanes = NoLanes;
              return workInProgressRootExitStatus;
            }
          }
          function workLoopConcurrent() {
            while (workInProgress !== null && !shouldYield()) {
              performUnitOfWork(workInProgress);
            }
          }
          function performUnitOfWork(unitOfWork) {
            var current2 = unitOfWork.alternate;
            setCurrentFiber(unitOfWork);
            var next;
            if ((unitOfWork.mode & ProfileMode) !== NoMode) {
              startProfilerTimer(unitOfWork);
              next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
              stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
            } else {
              next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
            }
            resetCurrentFiber();
            unitOfWork.memoizedProps = unitOfWork.pendingProps;
            if (next === null) {
              completeUnitOfWork(unitOfWork);
            } else {
              workInProgress = next;
            }
            ReactCurrentOwner$2.current = null;
          }
          function completeUnitOfWork(unitOfWork) {
            var completedWork = unitOfWork;
            do {
              var current2 = completedWork.alternate;
              var returnFiber = completedWork.return;
              if ((completedWork.flags & Incomplete) === NoFlags) {
                setCurrentFiber(completedWork);
                var next = void 0;
                if ((completedWork.mode & ProfileMode) === NoMode) {
                  next = completeWork(current2, completedWork, subtreeRenderLanes);
                } else {
                  startProfilerTimer(completedWork);
                  next = completeWork(current2, completedWork, subtreeRenderLanes);
                  stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                }
                resetCurrentFiber();
                if (next !== null) {
                  workInProgress = next;
                  return;
                }
              } else {
                var _next = unwindWork(current2, completedWork);
                if (_next !== null) {
                  _next.flags &= HostEffectMask;
                  workInProgress = _next;
                  return;
                }
                if ((completedWork.mode & ProfileMode) !== NoMode) {
                  stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
                  var actualDuration = completedWork.actualDuration;
                  var child = completedWork.child;
                  while (child !== null) {
                    actualDuration += child.actualDuration;
                    child = child.sibling;
                  }
                  completedWork.actualDuration = actualDuration;
                }
                if (returnFiber !== null) {
                  returnFiber.flags |= Incomplete;
                  returnFiber.subtreeFlags = NoFlags;
                  returnFiber.deletions = null;
                } else {
                  workInProgressRootExitStatus = RootDidNotComplete;
                  workInProgress = null;
                  return;
                }
              }
              var siblingFiber = completedWork.sibling;
              if (siblingFiber !== null) {
                workInProgress = siblingFiber;
                return;
              }
              completedWork = returnFiber;
              workInProgress = completedWork;
            } while (completedWork !== null);
            if (workInProgressRootExitStatus === RootInProgress) {
              workInProgressRootExitStatus = RootCompleted;
            }
          }
          function commitRoot(root2, recoverableErrors, transitions) {
            var previousUpdateLanePriority = getCurrentUpdatePriority();
            var prevTransition = ReactCurrentBatchConfig$3.transition;
            try {
              ReactCurrentBatchConfig$3.transition = null;
              setCurrentUpdatePriority(DiscreteEventPriority);
              commitRootImpl(root2, recoverableErrors, transitions, previousUpdateLanePriority);
            } finally {
              ReactCurrentBatchConfig$3.transition = prevTransition;
              setCurrentUpdatePriority(previousUpdateLanePriority);
            }
            return null;
          }
          function commitRootImpl(root2, recoverableErrors, transitions, renderPriorityLevel) {
            do {
              flushPassiveEffects();
            } while (rootWithPendingPassiveEffects !== null);
            flushRenderPhaseStrictModeWarningsInDEV();
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Should not already be working.");
            }
            var finishedWork = root2.finishedWork;
            var lanes = root2.finishedLanes;
            {
              markCommitStarted(lanes);
            }
            if (finishedWork === null) {
              {
                markCommitStopped();
              }
              return null;
            } else {
              {
                if (lanes === NoLanes) {
                  error3("root.finishedLanes should not be empty during a commit. This is a bug in React.");
                }
              }
            }
            root2.finishedWork = null;
            root2.finishedLanes = NoLanes;
            if (finishedWork === root2.current) {
              throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
            }
            root2.callbackNode = null;
            root2.callbackPriority = NoLane;
            var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
            markRootFinished(root2, remainingLanes);
            if (root2 === workInProgressRoot) {
              workInProgressRoot = null;
              workInProgress = null;
              workInProgressRootRenderLanes = NoLanes;
            }
            if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {
              if (!rootDoesHavePassiveEffects) {
                rootDoesHavePassiveEffects = true;
                pendingPassiveTransitions = transitions;
                scheduleCallback$1(NormalPriority, function() {
                  flushPassiveEffects();
                  return null;
                });
              }
            }
            var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
            var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
            if (subtreeHasEffects || rootHasEffect) {
              var prevTransition = ReactCurrentBatchConfig$3.transition;
              ReactCurrentBatchConfig$3.transition = null;
              var previousPriority = getCurrentUpdatePriority();
              setCurrentUpdatePriority(DiscreteEventPriority);
              var prevExecutionContext = executionContext;
              executionContext |= CommitContext;
              ReactCurrentOwner$2.current = null;
              var shouldFireAfterActiveInstanceBlur2 = commitBeforeMutationEffects(root2, finishedWork);
              {
                recordCommitTime();
              }
              commitMutationEffects(root2, finishedWork, lanes);
              resetAfterCommit(root2.containerInfo);
              root2.current = finishedWork;
              {
                markLayoutEffectsStarted(lanes);
              }
              commitLayoutEffects(finishedWork, root2, lanes);
              {
                markLayoutEffectsStopped();
              }
              requestPaint();
              executionContext = prevExecutionContext;
              setCurrentUpdatePriority(previousPriority);
              ReactCurrentBatchConfig$3.transition = prevTransition;
            } else {
              root2.current = finishedWork;
              {
                recordCommitTime();
              }
            }
            var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
            if (rootDoesHavePassiveEffects) {
              rootDoesHavePassiveEffects = false;
              rootWithPendingPassiveEffects = root2;
              pendingPassiveEffectsLanes = lanes;
            } else {
              {
                nestedPassiveUpdateCount = 0;
                rootWithPassiveNestedUpdates = null;
              }
            }
            remainingLanes = root2.pendingLanes;
            if (remainingLanes === NoLanes) {
              legacyErrorBoundariesThatAlreadyFailed = null;
            }
            {
              if (!rootDidHavePassiveEffects) {
                commitDoubleInvokeEffectsInDEV(root2.current, false);
              }
            }
            onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
            {
              if (isDevToolsPresent) {
                root2.memoizedUpdaters.clear();
              }
            }
            {
              onCommitRoot$1();
            }
            ensureRootIsScheduled(root2, now2());
            if (recoverableErrors !== null) {
              var onRecoverableError = root2.onRecoverableError;
              for (var i = 0; i < recoverableErrors.length; i++) {
                var recoverableError = recoverableErrors[i];
                var componentStack = recoverableError.stack;
                var digest = recoverableError.digest;
                onRecoverableError(recoverableError.value, {
                  componentStack,
                  digest
                });
              }
            }
            if (hasUncaughtError) {
              hasUncaughtError = false;
              var error$1 = firstUncaughtError;
              firstUncaughtError = null;
              throw error$1;
            }
            if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root2.tag !== LegacyRoot) {
              flushPassiveEffects();
            }
            remainingLanes = root2.pendingLanes;
            if (includesSomeLane(remainingLanes, SyncLane)) {
              {
                markNestedUpdateScheduled();
              }
              if (root2 === rootWithNestedUpdates) {
                nestedUpdateCount++;
              } else {
                nestedUpdateCount = 0;
                rootWithNestedUpdates = root2;
              }
            } else {
              nestedUpdateCount = 0;
            }
            flushSyncCallbacks();
            {
              markCommitStopped();
            }
            return null;
          }
          function flushPassiveEffects() {
            if (rootWithPendingPassiveEffects !== null) {
              var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);
              var priority = lowerEventPriority(DefaultEventPriority, renderPriority);
              var prevTransition = ReactCurrentBatchConfig$3.transition;
              var previousPriority = getCurrentUpdatePriority();
              try {
                ReactCurrentBatchConfig$3.transition = null;
                setCurrentUpdatePriority(priority);
                return flushPassiveEffectsImpl();
              } finally {
                setCurrentUpdatePriority(previousPriority);
                ReactCurrentBatchConfig$3.transition = prevTransition;
              }
            }
            return false;
          }
          function enqueuePendingPassiveProfilerEffect(fiber) {
            {
              pendingPassiveProfilerEffects.push(fiber);
              if (!rootDoesHavePassiveEffects) {
                rootDoesHavePassiveEffects = true;
                scheduleCallback$1(NormalPriority, function() {
                  flushPassiveEffects();
                  return null;
                });
              }
            }
          }
          function flushPassiveEffectsImpl() {
            if (rootWithPendingPassiveEffects === null) {
              return false;
            }
            var transitions = pendingPassiveTransitions;
            pendingPassiveTransitions = null;
            var root2 = rootWithPendingPassiveEffects;
            var lanes = pendingPassiveEffectsLanes;
            rootWithPendingPassiveEffects = null;
            pendingPassiveEffectsLanes = NoLanes;
            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
              throw new Error("Cannot flush passive effects while already rendering.");
            }
            {
              isFlushingPassiveEffects = true;
              didScheduleUpdateDuringPassiveEffects = false;
            }
            {
              markPassiveEffectsStarted(lanes);
            }
            var prevExecutionContext = executionContext;
            executionContext |= CommitContext;
            commitPassiveUnmountEffects(root2.current);
            commitPassiveMountEffects(root2, root2.current, lanes, transitions);
            {
              var profilerEffects = pendingPassiveProfilerEffects;
              pendingPassiveProfilerEffects = [];
              for (var i = 0; i < profilerEffects.length; i++) {
                var _fiber = profilerEffects[i];
                commitPassiveEffectDurations(root2, _fiber);
              }
            }
            {
              markPassiveEffectsStopped();
            }
            {
              commitDoubleInvokeEffectsInDEV(root2.current, true);
            }
            executionContext = prevExecutionContext;
            flushSyncCallbacks();
            {
              if (didScheduleUpdateDuringPassiveEffects) {
                if (root2 === rootWithPassiveNestedUpdates) {
                  nestedPassiveUpdateCount++;
                } else {
                  nestedPassiveUpdateCount = 0;
                  rootWithPassiveNestedUpdates = root2;
                }
              } else {
                nestedPassiveUpdateCount = 0;
              }
              isFlushingPassiveEffects = false;
              didScheduleUpdateDuringPassiveEffects = false;
            }
            onPostCommitRoot(root2);
            {
              var stateNode = root2.current.stateNode;
              stateNode.effectDuration = 0;
              stateNode.passiveEffectDuration = 0;
            }
            return true;
          }
          function isAlreadyFailedLegacyErrorBoundary(instance) {
            return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
          }
          function markLegacyErrorBoundaryAsFailed(instance) {
            if (legacyErrorBoundariesThatAlreadyFailed === null) {
              legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance]);
            } else {
              legacyErrorBoundariesThatAlreadyFailed.add(instance);
            }
          }
          function prepareToThrowUncaughtError(error4) {
            if (!hasUncaughtError) {
              hasUncaughtError = true;
              firstUncaughtError = error4;
            }
          }
          var onUncaughtError = prepareToThrowUncaughtError;
          function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error4) {
            var errorInfo = createCapturedValueAtFiber(error4, sourceFiber);
            var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
            var root2 = enqueueUpdate(rootFiber, update, SyncLane);
            var eventTime = requestEventTime();
            if (root2 !== null) {
              markRootUpdated(root2, SyncLane, eventTime);
              ensureRootIsScheduled(root2, eventTime);
            }
          }
          function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
            {
              reportUncaughtErrorInDEV(error$1);
              setIsRunningInsertionEffect(false);
            }
            if (sourceFiber.tag === HostRoot) {
              captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);
              return;
            }
            var fiber = null;
            {
              fiber = nearestMountedAncestor;
            }
            while (fiber !== null) {
              if (fiber.tag === HostRoot) {
                captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);
                return;
              } else if (fiber.tag === ClassComponent) {
                var ctor = fiber.type;
                var instance = fiber.stateNode;
                if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
                  var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);
                  var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
                  var root2 = enqueueUpdate(fiber, update, SyncLane);
                  var eventTime = requestEventTime();
                  if (root2 !== null) {
                    markRootUpdated(root2, SyncLane, eventTime);
                    ensureRootIsScheduled(root2, eventTime);
                  }
                  return;
                }
              }
              fiber = fiber.return;
            }
            {
              error3("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s", error$1);
            }
          }
          function pingSuspendedRoot(root2, wakeable, pingedLanes) {
            var pingCache = root2.pingCache;
            if (pingCache !== null) {
              pingCache.delete(wakeable);
            }
            var eventTime = requestEventTime();
            markRootPinged(root2, pingedLanes);
            warnIfSuspenseResolutionNotWrappedWithActDEV(root2);
            if (workInProgressRoot === root2 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
              if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now2() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
                prepareFreshStack(root2, NoLanes);
              } else {
                workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
              }
            }
            ensureRootIsScheduled(root2, eventTime);
          }
          function retryTimedOutBoundary(boundaryFiber, retryLane) {
            if (retryLane === NoLane) {
              retryLane = requestRetryLane(boundaryFiber);
            }
            var eventTime = requestEventTime();
            var root2 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
            if (root2 !== null) {
              markRootUpdated(root2, retryLane, eventTime);
              ensureRootIsScheduled(root2, eventTime);
            }
          }
          function retryDehydratedSuspenseBoundary(boundaryFiber) {
            var suspenseState = boundaryFiber.memoizedState;
            var retryLane = NoLane;
            if (suspenseState !== null) {
              retryLane = suspenseState.retryLane;
            }
            retryTimedOutBoundary(boundaryFiber, retryLane);
          }
          function resolveRetryWakeable(boundaryFiber, wakeable) {
            var retryLane = NoLane;
            var retryCache;
            switch (boundaryFiber.tag) {
              case SuspenseComponent:
                retryCache = boundaryFiber.stateNode;
                var suspenseState = boundaryFiber.memoizedState;
                if (suspenseState !== null) {
                  retryLane = suspenseState.retryLane;
                }
                break;
              case SuspenseListComponent:
                retryCache = boundaryFiber.stateNode;
                break;
              default:
                throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
            }
            if (retryCache !== null) {
              retryCache.delete(wakeable);
            }
            retryTimedOutBoundary(boundaryFiber, retryLane);
          }
          function jnd(timeElapsed) {
            return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil2(timeElapsed / 1960) * 1960;
          }
          function checkForNestedUpdates() {
            if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
              nestedUpdateCount = 0;
              rootWithNestedUpdates = null;
              throw new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
            }
            {
              if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
                nestedPassiveUpdateCount = 0;
                rootWithPassiveNestedUpdates = null;
                error3("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.");
              }
            }
          }
          function flushRenderPhaseStrictModeWarningsInDEV() {
            {
              ReactStrictModeWarnings.flushLegacyContextWarning();
              {
                ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
              }
            }
          }
          function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
            {
              setCurrentFiber(fiber);
              invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);
              if (hasPassiveEffects) {
                invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);
              }
              invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);
              if (hasPassiveEffects) {
                invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);
              }
              resetCurrentFiber();
            }
          }
          function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
            {
              var current2 = firstChild;
              var subtreeRoot = null;
              while (current2 !== null) {
                var primarySubtreeFlag = current2.subtreeFlags & fiberFlags;
                if (current2 !== subtreeRoot && current2.child !== null && primarySubtreeFlag !== NoFlags) {
                  current2 = current2.child;
                } else {
                  if ((current2.flags & fiberFlags) !== NoFlags) {
                    invokeEffectFn(current2);
                  }
                  if (current2.sibling !== null) {
                    current2 = current2.sibling;
                  } else {
                    current2 = subtreeRoot = current2.return;
                  }
                }
              }
            }
          }
          var didWarnStateUpdateForNotYetMountedComponent = null;
          function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
            {
              if ((executionContext & RenderContext) !== NoContext) {
                return;
              }
              if (!(fiber.mode & ConcurrentMode)) {
                return;
              }
              var tag = fiber.tag;
              if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {
                return;
              }
              var componentName = getComponentNameFromFiber(fiber) || "ReactComponent";
              if (didWarnStateUpdateForNotYetMountedComponent !== null) {
                if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
                  return;
                }
                didWarnStateUpdateForNotYetMountedComponent.add(componentName);
              } else {
                didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);
              }
              var previousFiber = current;
              try {
                setCurrentFiber(fiber);
                error3("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
              } finally {
                if (previousFiber) {
                  setCurrentFiber(fiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
          var beginWork$1;
          {
            var dummyFiber = null;
            beginWork$1 = function(current2, unitOfWork, lanes) {
              var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
              try {
                return beginWork(current2, unitOfWork, lanes);
              } catch (originalError) {
                if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
                  throw originalError;
                }
                resetContextDependencies();
                resetHooksAfterThrow();
                unwindInterruptedWork(current2, unitOfWork);
                assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
                if (unitOfWork.mode & ProfileMode) {
                  startProfilerTimer(unitOfWork);
                }
                invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes);
                if (hasCaughtError()) {
                  var replayError = clearCaughtError();
                  if (typeof replayError === "object" && replayError !== null && replayError._suppressLogging && typeof originalError === "object" && originalError !== null && !originalError._suppressLogging) {
                    originalError._suppressLogging = true;
                  }
                }
                throw originalError;
              }
            };
          }
          var didWarnAboutUpdateInRender = false;
          var didWarnAboutUpdateInRenderForAnotherComponent;
          {
            didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
          }
          function warnAboutRenderPhaseUpdatesInDEV(fiber) {
            {
              if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
                switch (fiber.tag) {
                  case FunctionComponent:
                  case ForwardRef:
                  case SimpleMemoComponent: {
                    var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                    var dedupeKey = renderingComponentName;
                    if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                      didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                      var setStateComponentName = getComponentNameFromFiber(fiber) || "Unknown";
                      error3("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                    }
                    break;
                  }
                  case ClassComponent: {
                    if (!didWarnAboutUpdateInRender) {
                      error3("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.");
                      didWarnAboutUpdateInRender = true;
                    }
                    break;
                  }
                }
              }
            }
          }
          function restorePendingUpdaters(root2, lanes) {
            {
              if (isDevToolsPresent) {
                var memoizedUpdaters = root2.memoizedUpdaters;
                memoizedUpdaters.forEach(function(schedulingFiber) {
                  addFiberToLanesMap(root2, schedulingFiber, lanes);
                });
              }
            }
          }
          var fakeActCallbackNode = {};
          function scheduleCallback$1(priorityLevel, callback) {
            {
              var actQueue = ReactCurrentActQueue$1.current;
              if (actQueue !== null) {
                actQueue.push(callback);
                return fakeActCallbackNode;
              } else {
                return scheduleCallback(priorityLevel, callback);
              }
            }
          }
          function cancelCallback$1(callbackNode) {
            if (callbackNode === fakeActCallbackNode) {
              return;
            }
            return cancelCallback(callbackNode);
          }
          function shouldForceFlushFallbacksInDEV() {
            return ReactCurrentActQueue$1.current !== null;
          }
          function warnIfUpdatesNotWrappedWithActDEV(fiber) {
            {
              if (fiber.mode & ConcurrentMode) {
                if (!isConcurrentActEnvironment()) {
                  return;
                }
              } else {
                if (!isLegacyActEnvironment()) {
                  return;
                }
                if (executionContext !== NoContext) {
                  return;
                }
                if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {
                  return;
                }
              }
              if (ReactCurrentActQueue$1.current === null) {
                var previousFiber = current;
                try {
                  setCurrentFiber(fiber);
                  error3("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentNameFromFiber(fiber));
                } finally {
                  if (previousFiber) {
                    setCurrentFiber(fiber);
                  } else {
                    resetCurrentFiber();
                  }
                }
              }
            }
          }
          function warnIfSuspenseResolutionNotWrappedWithActDEV(root2) {
            {
              if (root2.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {
                error3("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act");
              }
            }
          }
          function setIsRunningInsertionEffect(isRunning) {
            {
              isRunningInsertionEffect = isRunning;
            }
          }
          var resolveFamily = null;
          var failedBoundaries = null;
          var setRefreshHandler = function(handler) {
            {
              resolveFamily = handler;
            }
          };
          function resolveFunctionForHotReloading(type) {
            {
              if (resolveFamily === null) {
                return type;
              }
              var family = resolveFamily(type);
              if (family === void 0) {
                return type;
              }
              return family.current;
            }
          }
          function resolveClassForHotReloading(type) {
            return resolveFunctionForHotReloading(type);
          }
          function resolveForwardRefForHotReloading(type) {
            {
              if (resolveFamily === null) {
                return type;
              }
              var family = resolveFamily(type);
              if (family === void 0) {
                if (type !== null && type !== void 0 && typeof type.render === "function") {
                  var currentRender = resolveFunctionForHotReloading(type.render);
                  if (type.render !== currentRender) {
                    var syntheticType = {
                      $$typeof: REACT_FORWARD_REF_TYPE,
                      render: currentRender
                    };
                    if (type.displayName !== void 0) {
                      syntheticType.displayName = type.displayName;
                    }
                    return syntheticType;
                  }
                }
                return type;
              }
              return family.current;
            }
          }
          function isCompatibleFamilyForHotReloading(fiber, element) {
            {
              if (resolveFamily === null) {
                return false;
              }
              var prevType = fiber.elementType;
              var nextType = element.type;
              var needsCompareFamilies = false;
              var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
              switch (fiber.tag) {
                case ClassComponent: {
                  if (typeof nextType === "function") {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case FunctionComponent: {
                  if (typeof nextType === "function") {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case ForwardRef: {
                  if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                case MemoComponent:
                case SimpleMemoComponent: {
                  if ($$typeofNextType === REACT_MEMO_TYPE) {
                    needsCompareFamilies = true;
                  } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                    needsCompareFamilies = true;
                  }
                  break;
                }
                default:
                  return false;
              }
              if (needsCompareFamilies) {
                var prevFamily = resolveFamily(prevType);
                if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType)) {
                  return true;
                }
              }
              return false;
            }
          }
          function markFailedErrorBoundaryForHotReloading(fiber) {
            {
              if (resolveFamily === null) {
                return;
              }
              if (typeof WeakSet !== "function") {
                return;
              }
              if (failedBoundaries === null) {
                failedBoundaries = /* @__PURE__ */ new WeakSet();
              }
              failedBoundaries.add(fiber);
            }
          }
          var scheduleRefresh = function(root2, update) {
            {
              if (resolveFamily === null) {
                return;
              }
              var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
              flushPassiveEffects();
              flushSync(function() {
                scheduleFibersWithFamiliesRecursively(root2.current, updatedFamilies, staleFamilies);
              });
            }
          };
          var scheduleRoot = function(root2, element) {
            {
              if (root2.context !== emptyContextObject) {
                return;
              }
              flushPassiveEffects();
              flushSync(function() {
                updateContainer(element, root2, null, null);
              });
            }
          };
          function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
            {
              var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
              var candidateType = null;
              switch (tag) {
                case FunctionComponent:
                case SimpleMemoComponent:
                case ClassComponent:
                  candidateType = type;
                  break;
                case ForwardRef:
                  candidateType = type.render;
                  break;
              }
              if (resolveFamily === null) {
                throw new Error("Expected resolveFamily to be set during hot reload.");
              }
              var needsRender = false;
              var needsRemount = false;
              if (candidateType !== null) {
                var family = resolveFamily(candidateType);
                if (family !== void 0) {
                  if (staleFamilies.has(family)) {
                    needsRemount = true;
                  } else if (updatedFamilies.has(family)) {
                    if (tag === ClassComponent) {
                      needsRemount = true;
                    } else {
                      needsRender = true;
                    }
                  }
                }
              }
              if (failedBoundaries !== null) {
                if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
                  needsRemount = true;
                }
              }
              if (needsRemount) {
                fiber._debugNeedsRemount = true;
              }
              if (needsRemount || needsRender) {
                var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (_root !== null) {
                  scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);
                }
              }
              if (child !== null && !needsRemount) {
                scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
              }
              if (sibling !== null) {
                scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
              }
            }
          }
          var findHostInstancesForRefresh = function(root2, families) {
            {
              var hostInstances = /* @__PURE__ */ new Set();
              var types = new Set(families.map(function(family) {
                return family.current;
              }));
              findHostInstancesForMatchingFibersRecursively(root2.current, types, hostInstances);
              return hostInstances;
            }
          };
          function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
            {
              var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;
              var candidateType = null;
              switch (tag) {
                case FunctionComponent:
                case SimpleMemoComponent:
                case ClassComponent:
                  candidateType = type;
                  break;
                case ForwardRef:
                  candidateType = type.render;
                  break;
              }
              var didMatch = false;
              if (candidateType !== null) {
                if (types.has(candidateType)) {
                  didMatch = true;
                }
              }
              if (didMatch) {
                findHostInstancesForFiberShallowly(fiber, hostInstances);
              } else {
                if (child !== null) {
                  findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
                }
              }
              if (sibling !== null) {
                findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
              }
            }
          }
          function findHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
              var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
              if (foundHostInstances) {
                return;
              }
              var node = fiber;
              while (true) {
                switch (node.tag) {
                  case HostComponent:
                    hostInstances.add(node.stateNode);
                    return;
                  case HostPortal:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
                  case HostRoot:
                    hostInstances.add(node.stateNode.containerInfo);
                    return;
                }
                if (node.return === null) {
                  throw new Error("Expected to reach root first.");
                }
                node = node.return;
              }
            }
          }
          function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
            {
              var node = fiber;
              var foundHostInstances = false;
              while (true) {
                if (node.tag === HostComponent) {
                  foundHostInstances = true;
                  hostInstances.add(node.stateNode);
                } else if (node.child !== null) {
                  node.child.return = node;
                  node = node.child;
                  continue;
                }
                if (node === fiber) {
                  return foundHostInstances;
                }
                while (node.sibling === null) {
                  if (node.return === null || node.return === fiber) {
                    return foundHostInstances;
                  }
                  node = node.return;
                }
                node.sibling.return = node.return;
                node = node.sibling;
              }
            }
            return false;
          }
          var hasBadMapPolyfill;
          {
            hasBadMapPolyfill = false;
            try {
              var nonExtensibleObject = Object.preventExtensions({});
              /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
              /* @__PURE__ */ new Set([nonExtensibleObject]);
            } catch (e) {
              hasBadMapPolyfill = true;
            }
          }
          function FiberNode(tag, pendingProps, key, mode) {
            this.tag = tag;
            this.key = key;
            this.elementType = null;
            this.type = null;
            this.stateNode = null;
            this.return = null;
            this.child = null;
            this.sibling = null;
            this.index = 0;
            this.ref = null;
            this.pendingProps = pendingProps;
            this.memoizedProps = null;
            this.updateQueue = null;
            this.memoizedState = null;
            this.dependencies = null;
            this.mode = mode;
            this.flags = NoFlags;
            this.subtreeFlags = NoFlags;
            this.deletions = null;
            this.lanes = NoLanes;
            this.childLanes = NoLanes;
            this.alternate = null;
            {
              this.actualDuration = Number.NaN;
              this.actualStartTime = Number.NaN;
              this.selfBaseDuration = Number.NaN;
              this.treeBaseDuration = Number.NaN;
              this.actualDuration = 0;
              this.actualStartTime = -1;
              this.selfBaseDuration = 0;
              this.treeBaseDuration = 0;
            }
            {
              this._debugSource = null;
              this._debugOwner = null;
              this._debugNeedsRemount = false;
              this._debugHookTypes = null;
              if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
                Object.preventExtensions(this);
              }
            }
          }
          var createFiber = function(tag, pendingProps, key, mode) {
            return new FiberNode(tag, pendingProps, key, mode);
          };
          function shouldConstruct$1(Component2) {
            var prototype = Component2.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function isSimpleFunctionComponent(type) {
            return typeof type === "function" && !shouldConstruct$1(type) && type.defaultProps === void 0;
          }
          function resolveLazyComponentTag(Component2) {
            if (typeof Component2 === "function") {
              return shouldConstruct$1(Component2) ? ClassComponent : FunctionComponent;
            } else if (Component2 !== void 0 && Component2 !== null) {
              var $$typeof = Component2.$$typeof;
              if ($$typeof === REACT_FORWARD_REF_TYPE) {
                return ForwardRef;
              }
              if ($$typeof === REACT_MEMO_TYPE) {
                return MemoComponent;
              }
            }
            return IndeterminateComponent;
          }
          function createWorkInProgress(current2, pendingProps) {
            var workInProgress2 = current2.alternate;
            if (workInProgress2 === null) {
              workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);
              workInProgress2.elementType = current2.elementType;
              workInProgress2.type = current2.type;
              workInProgress2.stateNode = current2.stateNode;
              {
                workInProgress2._debugSource = current2._debugSource;
                workInProgress2._debugOwner = current2._debugOwner;
                workInProgress2._debugHookTypes = current2._debugHookTypes;
              }
              workInProgress2.alternate = current2;
              current2.alternate = workInProgress2;
            } else {
              workInProgress2.pendingProps = pendingProps;
              workInProgress2.type = current2.type;
              workInProgress2.flags = NoFlags;
              workInProgress2.subtreeFlags = NoFlags;
              workInProgress2.deletions = null;
              {
                workInProgress2.actualDuration = 0;
                workInProgress2.actualStartTime = -1;
              }
            }
            workInProgress2.flags = current2.flags & StaticMask;
            workInProgress2.childLanes = current2.childLanes;
            workInProgress2.lanes = current2.lanes;
            workInProgress2.child = current2.child;
            workInProgress2.memoizedProps = current2.memoizedProps;
            workInProgress2.memoizedState = current2.memoizedState;
            workInProgress2.updateQueue = current2.updateQueue;
            var currentDependencies = current2.dependencies;
            workInProgress2.dependencies = currentDependencies === null ? null : {
              lanes: currentDependencies.lanes,
              firstContext: currentDependencies.firstContext
            };
            workInProgress2.sibling = current2.sibling;
            workInProgress2.index = current2.index;
            workInProgress2.ref = current2.ref;
            {
              workInProgress2.selfBaseDuration = current2.selfBaseDuration;
              workInProgress2.treeBaseDuration = current2.treeBaseDuration;
            }
            {
              workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
              switch (workInProgress2.tag) {
                case IndeterminateComponent:
                case FunctionComponent:
                case SimpleMemoComponent:
                  workInProgress2.type = resolveFunctionForHotReloading(current2.type);
                  break;
                case ClassComponent:
                  workInProgress2.type = resolveClassForHotReloading(current2.type);
                  break;
                case ForwardRef:
                  workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
                  break;
              }
            }
            return workInProgress2;
          }
          function resetWorkInProgress(workInProgress2, renderLanes2) {
            workInProgress2.flags &= StaticMask | Placement;
            var current2 = workInProgress2.alternate;
            if (current2 === null) {
              workInProgress2.childLanes = NoLanes;
              workInProgress2.lanes = renderLanes2;
              workInProgress2.child = null;
              workInProgress2.subtreeFlags = NoFlags;
              workInProgress2.memoizedProps = null;
              workInProgress2.memoizedState = null;
              workInProgress2.updateQueue = null;
              workInProgress2.dependencies = null;
              workInProgress2.stateNode = null;
              {
                workInProgress2.selfBaseDuration = 0;
                workInProgress2.treeBaseDuration = 0;
              }
            } else {
              workInProgress2.childLanes = current2.childLanes;
              workInProgress2.lanes = current2.lanes;
              workInProgress2.child = current2.child;
              workInProgress2.subtreeFlags = NoFlags;
              workInProgress2.deletions = null;
              workInProgress2.memoizedProps = current2.memoizedProps;
              workInProgress2.memoizedState = current2.memoizedState;
              workInProgress2.updateQueue = current2.updateQueue;
              workInProgress2.type = current2.type;
              var currentDependencies = current2.dependencies;
              workInProgress2.dependencies = currentDependencies === null ? null : {
                lanes: currentDependencies.lanes,
                firstContext: currentDependencies.firstContext
              };
              {
                workInProgress2.selfBaseDuration = current2.selfBaseDuration;
                workInProgress2.treeBaseDuration = current2.treeBaseDuration;
              }
            }
            return workInProgress2;
          }
          function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {
            var mode;
            if (tag === ConcurrentRoot) {
              mode = ConcurrentMode;
              if (isStrictMode === true) {
                mode |= StrictLegacyMode;
                {
                  mode |= StrictEffectsMode;
                }
              }
            } else {
              mode = NoMode;
            }
            if (isDevToolsPresent) {
              mode |= ProfileMode;
            }
            return createFiber(HostRoot, null, null, mode);
          }
          function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
            var fiberTag = IndeterminateComponent;
            var resolvedType = type;
            if (typeof type === "function") {
              if (shouldConstruct$1(type)) {
                fiberTag = ClassComponent;
                {
                  resolvedType = resolveClassForHotReloading(resolvedType);
                }
              } else {
                {
                  resolvedType = resolveFunctionForHotReloading(resolvedType);
                }
              }
            } else if (typeof type === "string") {
              fiberTag = HostComponent;
            } else {
              getTag:
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                    return createFiberFromFragment(pendingProps.children, mode, lanes, key);
                  case REACT_STRICT_MODE_TYPE:
                    fiberTag = Mode;
                    mode |= StrictLegacyMode;
                    if ((mode & ConcurrentMode) !== NoMode) {
                      mode |= StrictEffectsMode;
                    }
                    break;
                  case REACT_PROFILER_TYPE:
                    return createFiberFromProfiler(pendingProps, mode, lanes, key);
                  case REACT_SUSPENSE_TYPE:
                    return createFiberFromSuspense(pendingProps, mode, lanes, key);
                  case REACT_SUSPENSE_LIST_TYPE:
                    return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
                  case REACT_OFFSCREEN_TYPE:
                    return createFiberFromOffscreen(pendingProps, mode, lanes, key);
                  case REACT_LEGACY_HIDDEN_TYPE:
                  case REACT_SCOPE_TYPE:
                  case REACT_CACHE_TYPE:
                  case REACT_TRACING_MARKER_TYPE:
                  case REACT_DEBUG_TRACING_MODE_TYPE:
                  default: {
                    if (typeof type === "object" && type !== null) {
                      switch (type.$$typeof) {
                        case REACT_PROVIDER_TYPE:
                          fiberTag = ContextProvider;
                          break getTag;
                        case REACT_CONTEXT_TYPE:
                          fiberTag = ContextConsumer;
                          break getTag;
                        case REACT_FORWARD_REF_TYPE:
                          fiberTag = ForwardRef;
                          {
                            resolvedType = resolveForwardRefForHotReloading(resolvedType);
                          }
                          break getTag;
                        case REACT_MEMO_TYPE:
                          fiberTag = MemoComponent;
                          break getTag;
                        case REACT_LAZY_TYPE:
                          fiberTag = LazyComponent;
                          resolvedType = null;
                          break getTag;
                      }
                    }
                    var info = "";
                    {
                      if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                        info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                      }
                      var ownerName = owner ? getComponentNameFromFiber(owner) : null;
                      if (ownerName) {
                        info += "\n\nCheck the render method of `" + ownerName + "`.";
                      }
                    }
                    throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
                  }
                }
            }
            var fiber = createFiber(fiberTag, pendingProps, key, mode);
            fiber.elementType = type;
            fiber.type = resolvedType;
            fiber.lanes = lanes;
            {
              fiber._debugOwner = owner;
            }
            return fiber;
          }
          function createFiberFromElement(element, mode, lanes) {
            var owner = null;
            {
              owner = element._owner;
            }
            var type = element.type;
            var key = element.key;
            var pendingProps = element.props;
            var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);
            {
              fiber._debugSource = element._source;
              fiber._debugOwner = element._owner;
            }
            return fiber;
          }
          function createFiberFromFragment(elements, mode, lanes, key) {
            var fiber = createFiber(Fragment2, elements, key, mode);
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromProfiler(pendingProps, mode, lanes, key) {
            {
              if (typeof pendingProps.id !== "string") {
                error3('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);
              }
            }
            var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
            fiber.elementType = REACT_PROFILER_TYPE;
            fiber.lanes = lanes;
            {
              fiber.stateNode = {
                effectDuration: 0,
                passiveEffectDuration: 0
              };
            }
            return fiber;
          }
          function createFiberFromSuspense(pendingProps, mode, lanes, key) {
            var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
            fiber.elementType = REACT_SUSPENSE_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
            var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
            fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
            var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);
            fiber.elementType = REACT_OFFSCREEN_TYPE;
            fiber.lanes = lanes;
            var primaryChildInstance = {
              isHidden: false
            };
            fiber.stateNode = primaryChildInstance;
            return fiber;
          }
          function createFiberFromText(content3, mode, lanes) {
            var fiber = createFiber(HostText, content3, null, mode);
            fiber.lanes = lanes;
            return fiber;
          }
          function createFiberFromHostInstanceForDeletion() {
            var fiber = createFiber(HostComponent, null, null, NoMode);
            fiber.elementType = "DELETED";
            return fiber;
          }
          function createFiberFromDehydratedFragment(dehydratedNode) {
            var fiber = createFiber(DehydratedFragment, null, null, NoMode);
            fiber.stateNode = dehydratedNode;
            return fiber;
          }
          function createFiberFromPortal(portal, mode, lanes) {
            var pendingProps = portal.children !== null ? portal.children : [];
            var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
            fiber.lanes = lanes;
            fiber.stateNode = {
              containerInfo: portal.containerInfo,
              pendingChildren: null,
              implementation: portal.implementation
            };
            return fiber;
          }
          function assignFiberPropertiesInDEV(target5, source) {
            if (target5 === null) {
              target5 = createFiber(IndeterminateComponent, null, null, NoMode);
            }
            target5.tag = source.tag;
            target5.key = source.key;
            target5.elementType = source.elementType;
            target5.type = source.type;
            target5.stateNode = source.stateNode;
            target5.return = source.return;
            target5.child = source.child;
            target5.sibling = source.sibling;
            target5.index = source.index;
            target5.ref = source.ref;
            target5.pendingProps = source.pendingProps;
            target5.memoizedProps = source.memoizedProps;
            target5.updateQueue = source.updateQueue;
            target5.memoizedState = source.memoizedState;
            target5.dependencies = source.dependencies;
            target5.mode = source.mode;
            target5.flags = source.flags;
            target5.subtreeFlags = source.subtreeFlags;
            target5.deletions = source.deletions;
            target5.lanes = source.lanes;
            target5.childLanes = source.childLanes;
            target5.alternate = source.alternate;
            {
              target5.actualDuration = source.actualDuration;
              target5.actualStartTime = source.actualStartTime;
              target5.selfBaseDuration = source.selfBaseDuration;
              target5.treeBaseDuration = source.treeBaseDuration;
            }
            target5._debugSource = source._debugSource;
            target5._debugOwner = source._debugOwner;
            target5._debugNeedsRemount = source._debugNeedsRemount;
            target5._debugHookTypes = source._debugHookTypes;
            return target5;
          }
          function FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError) {
            this.tag = tag;
            this.containerInfo = containerInfo;
            this.pendingChildren = null;
            this.current = null;
            this.pingCache = null;
            this.finishedWork = null;
            this.timeoutHandle = noTimeout;
            this.context = null;
            this.pendingContext = null;
            this.callbackNode = null;
            this.callbackPriority = NoLane;
            this.eventTimes = createLaneMap(NoLanes);
            this.expirationTimes = createLaneMap(NoTimestamp);
            this.pendingLanes = NoLanes;
            this.suspendedLanes = NoLanes;
            this.pingedLanes = NoLanes;
            this.expiredLanes = NoLanes;
            this.mutableReadLanes = NoLanes;
            this.finishedLanes = NoLanes;
            this.entangledLanes = NoLanes;
            this.entanglements = createLaneMap(NoLanes);
            this.identifierPrefix = identifierPrefix;
            this.onRecoverableError = onRecoverableError;
            {
              this.mutableSourceEagerHydrationData = null;
            }
            {
              this.effectDuration = 0;
              this.passiveEffectDuration = 0;
            }
            {
              this.memoizedUpdaters = /* @__PURE__ */ new Set();
              var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];
              for (var _i = 0; _i < TotalLanes; _i++) {
                pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set());
              }
            }
            {
              switch (tag) {
                case ConcurrentRoot:
                  this._debugRootType = hydrate2 ? "hydrateRoot()" : "createRoot()";
                  break;
                case LegacyRoot:
                  this._debugRootType = hydrate2 ? "hydrate()" : "render()";
                  break;
              }
            }
          }
          function createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var root2 = new FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError);
            var uninitializedFiber = createHostRootFiber(tag, isStrictMode);
            root2.current = uninitializedFiber;
            uninitializedFiber.stateNode = root2;
            {
              var _initialState = {
                element: initialChildren,
                isDehydrated: hydrate2,
                cache: null,
                transitions: null,
                pendingSuspenseBoundaries: null
              };
              uninitializedFiber.memoizedState = _initialState;
            }
            initializeUpdateQueue(uninitializedFiber);
            return root2;
          }
          var ReactVersion = "18.2.0";
          function createPortal(children, containerInfo, implementation) {
            var key = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
            {
              checkKeyStringCoercion(key);
            }
            return {
              $$typeof: REACT_PORTAL_TYPE,
              key: key == null ? null : "" + key,
              children,
              containerInfo,
              implementation
            };
          }
          var didWarnAboutNestedUpdates;
          var didWarnAboutFindNodeInStrictMode;
          {
            didWarnAboutNestedUpdates = false;
            didWarnAboutFindNodeInStrictMode = {};
          }
          function getContextForSubtree(parentComponent) {
            if (!parentComponent) {
              return emptyContextObject;
            }
            var fiber = get3(parentComponent);
            var parentContext = findCurrentUnmaskedContext(fiber);
            if (fiber.tag === ClassComponent) {
              var Component2 = fiber.type;
              if (isContextProvider(Component2)) {
                return processChildContext(fiber, Component2, parentContext);
              }
            }
            return parentContext;
          }
          function findHostInstanceWithWarning(component2, methodName) {
            {
              var fiber = get3(component2);
              if (fiber === void 0) {
                if (typeof component2.render === "function") {
                  throw new Error("Unable to find node on an unmounted component.");
                } else {
                  var keys3 = Object.keys(component2).join(",");
                  throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys3);
                }
              }
              var hostFiber = findCurrentHostFiber(fiber);
              if (hostFiber === null) {
                return null;
              }
              if (hostFiber.mode & StrictLegacyMode) {
                var componentName = getComponentNameFromFiber(fiber) || "Component";
                if (!didWarnAboutFindNodeInStrictMode[componentName]) {
                  didWarnAboutFindNodeInStrictMode[componentName] = true;
                  var previousFiber = current;
                  try {
                    setCurrentFiber(hostFiber);
                    if (fiber.mode & StrictLegacyMode) {
                      error3("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                    } else {
                      error3("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                    }
                  } finally {
                    if (previousFiber) {
                      setCurrentFiber(previousFiber);
                    } else {
                      resetCurrentFiber();
                    }
                  }
                }
              }
              return hostFiber.stateNode;
            }
          }
          function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var hydrate2 = false;
            var initialChildren = null;
            return createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
          }
          function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
            var hydrate2 = true;
            var root2 = createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            root2.context = getContextForSubtree(null);
            var current2 = root2.current;
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(current2);
            var update = createUpdate(eventTime, lane);
            update.callback = callback !== void 0 && callback !== null ? callback : null;
            enqueueUpdate(current2, update, lane);
            scheduleInitialHydrationOnRoot(root2, lane, eventTime);
            return root2;
          }
          function updateContainer(element, container, parentComponent, callback) {
            {
              onScheduleRoot(container, element);
            }
            var current$1 = container.current;
            var eventTime = requestEventTime();
            var lane = requestUpdateLane(current$1);
            {
              markRenderScheduled(lane);
            }
            var context = getContextForSubtree(parentComponent);
            if (container.context === null) {
              container.context = context;
            } else {
              container.pendingContext = context;
            }
            {
              if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
                didWarnAboutNestedUpdates = true;
                error3("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.", getComponentNameFromFiber(current) || "Unknown");
              }
            }
            var update = createUpdate(eventTime, lane);
            update.payload = {
              element
            };
            callback = callback === void 0 ? null : callback;
            if (callback !== null) {
              {
                if (typeof callback !== "function") {
                  error3("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback);
                }
              }
              update.callback = callback;
            }
            var root2 = enqueueUpdate(current$1, update, lane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, current$1, lane, eventTime);
              entangleTransitions(root2, current$1, lane);
            }
            return lane;
          }
          function getPublicRootInstance(container) {
            var containerFiber = container.current;
            if (!containerFiber.child) {
              return null;
            }
            switch (containerFiber.child.tag) {
              case HostComponent:
                return getPublicInstance(containerFiber.child.stateNode);
              default:
                return containerFiber.child.stateNode;
            }
          }
          function attemptSynchronousHydration$1(fiber) {
            switch (fiber.tag) {
              case HostRoot: {
                var root2 = fiber.stateNode;
                if (isRootDehydrated(root2)) {
                  var lanes = getHighestPriorityPendingLanes(root2);
                  flushRoot(root2, lanes);
                }
                break;
              }
              case SuspenseComponent: {
                flushSync(function() {
                  var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                  if (root3 !== null) {
                    var eventTime = requestEventTime();
                    scheduleUpdateOnFiber(root3, fiber, SyncLane, eventTime);
                  }
                });
                var retryLane = SyncLane;
                markRetryLaneIfNotHydrated(fiber, retryLane);
                break;
              }
            }
          }
          function markRetryLaneImpl(fiber, retryLane) {
            var suspenseState = fiber.memoizedState;
            if (suspenseState !== null && suspenseState.dehydrated !== null) {
              suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
            }
          }
          function markRetryLaneIfNotHydrated(fiber, retryLane) {
            markRetryLaneImpl(fiber, retryLane);
            var alternate = fiber.alternate;
            if (alternate) {
              markRetryLaneImpl(alternate, retryLane);
            }
          }
          function attemptContinuousHydration$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var lane = SelectiveHydrationLane;
            var root2 = enqueueConcurrentRenderForLane(fiber, lane);
            if (root2 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
            }
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function attemptHydrationAtCurrentPriority$1(fiber) {
            if (fiber.tag !== SuspenseComponent) {
              return;
            }
            var lane = requestUpdateLane(fiber);
            var root2 = enqueueConcurrentRenderForLane(fiber, lane);
            if (root2 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
            }
            markRetryLaneIfNotHydrated(fiber, lane);
          }
          function findHostInstanceWithNoPortals(fiber) {
            var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
            if (hostFiber === null) {
              return null;
            }
            return hostFiber.stateNode;
          }
          var shouldErrorImpl = function(fiber) {
            return null;
          };
          function shouldError(fiber) {
            return shouldErrorImpl(fiber);
          }
          var shouldSuspendImpl = function(fiber) {
            return false;
          };
          function shouldSuspend(fiber) {
            return shouldSuspendImpl(fiber);
          }
          var overrideHookState = null;
          var overrideHookStateDeletePath = null;
          var overrideHookStateRenamePath = null;
          var overrideProps = null;
          var overridePropsDeletePath = null;
          var overridePropsRenamePath = null;
          var scheduleUpdate = null;
          var setErrorHandler = null;
          var setSuspenseHandler = null;
          {
            var copyWithDeleteImpl = function(obj, path, index6) {
              var key = path[index6];
              var updated = isArray6(obj) ? obj.slice() : assign2({}, obj);
              if (index6 + 1 === path.length) {
                if (isArray6(updated)) {
                  updated.splice(key, 1);
                } else {
                  delete updated[key];
                }
                return updated;
              }
              updated[key] = copyWithDeleteImpl(obj[key], path, index6 + 1);
              return updated;
            };
            var copyWithDelete = function(obj, path) {
              return copyWithDeleteImpl(obj, path, 0);
            };
            var copyWithRenameImpl = function(obj, oldPath, newPath, index6) {
              var oldKey = oldPath[index6];
              var updated = isArray6(obj) ? obj.slice() : assign2({}, obj);
              if (index6 + 1 === oldPath.length) {
                var newKey = newPath[index6];
                updated[newKey] = updated[oldKey];
                if (isArray6(updated)) {
                  updated.splice(oldKey, 1);
                } else {
                  delete updated[oldKey];
                }
              } else {
                updated[oldKey] = copyWithRenameImpl(
                  obj[oldKey],
                  oldPath,
                  newPath,
                  index6 + 1
                );
              }
              return updated;
            };
            var copyWithRename = function(obj, oldPath, newPath) {
              if (oldPath.length !== newPath.length) {
                warn("copyWithRename() expects paths of the same length");
                return;
              } else {
                for (var i = 0; i < newPath.length - 1; i++) {
                  if (oldPath[i] !== newPath[i]) {
                    warn("copyWithRename() expects paths to be the same except for the deepest key");
                    return;
                  }
                }
              }
              return copyWithRenameImpl(obj, oldPath, newPath, 0);
            };
            var copyWithSetImpl = function(obj, path, index6, value13) {
              if (index6 >= path.length) {
                return value13;
              }
              var key = path[index6];
              var updated = isArray6(obj) ? obj.slice() : assign2({}, obj);
              updated[key] = copyWithSetImpl(obj[key], path, index6 + 1, value13);
              return updated;
            };
            var copyWithSet = function(obj, path, value13) {
              return copyWithSetImpl(obj, path, 0, value13);
            };
            var findHook = function(fiber, id2) {
              var currentHook2 = fiber.memoizedState;
              while (currentHook2 !== null && id2 > 0) {
                currentHook2 = currentHook2.next;
                id2--;
              }
              return currentHook2;
            };
            overrideHookState = function(fiber, id2, path, value13) {
              var hook = findHook(fiber, id2);
              if (hook !== null) {
                var newState = copyWithSet(hook.memoizedState, path, value13);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = assign2({}, fiber.memoizedProps);
                var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root2 !== null) {
                  scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
                }
              }
            };
            overrideHookStateDeletePath = function(fiber, id2, path) {
              var hook = findHook(fiber, id2);
              if (hook !== null) {
                var newState = copyWithDelete(hook.memoizedState, path);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = assign2({}, fiber.memoizedProps);
                var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root2 !== null) {
                  scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
                }
              }
            };
            overrideHookStateRenamePath = function(fiber, id2, oldPath, newPath) {
              var hook = findHook(fiber, id2);
              if (hook !== null) {
                var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
                hook.memoizedState = newState;
                hook.baseState = newState;
                fiber.memoizedProps = assign2({}, fiber.memoizedProps);
                var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
                if (root2 !== null) {
                  scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
                }
              }
            };
            overrideProps = function(fiber, path, value13) {
              fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value13);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            };
            overridePropsDeletePath = function(fiber, path) {
              fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            };
            overridePropsRenamePath = function(fiber, oldPath, newPath) {
              fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
              if (fiber.alternate) {
                fiber.alternate.pendingProps = fiber.pendingProps;
              }
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            };
            scheduleUpdate = function(fiber) {
              var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root2 !== null) {
                scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
              }
            };
            setErrorHandler = function(newShouldErrorImpl) {
              shouldErrorImpl = newShouldErrorImpl;
            };
            setSuspenseHandler = function(newShouldSuspendImpl) {
              shouldSuspendImpl = newShouldSuspendImpl;
            };
          }
          function findHostInstanceByFiber(fiber) {
            var hostFiber = findCurrentHostFiber(fiber);
            if (hostFiber === null) {
              return null;
            }
            return hostFiber.stateNode;
          }
          function emptyFindFiberByHostInstance(instance) {
            return null;
          }
          function getCurrentFiberForDevTools() {
            return current;
          }
          function injectIntoDevTools(devToolsConfig) {
            var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
            var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
            return injectInternals({
              bundleType: devToolsConfig.bundleType,
              version: devToolsConfig.version,
              rendererPackageName: devToolsConfig.rendererPackageName,
              rendererConfig: devToolsConfig.rendererConfig,
              overrideHookState,
              overrideHookStateDeletePath,
              overrideHookStateRenamePath,
              overrideProps,
              overridePropsDeletePath,
              overridePropsRenamePath,
              setErrorHandler,
              setSuspenseHandler,
              scheduleUpdate,
              currentDispatcherRef: ReactCurrentDispatcher2,
              findHostInstanceByFiber,
              findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
              findHostInstancesForRefresh,
              scheduleRefresh,
              scheduleRoot,
              setRefreshHandler,
              getCurrentFiber: getCurrentFiberForDevTools,
              reconcilerVersion: ReactVersion
            });
          }
          var defaultOnRecoverableError = typeof reportError === "function" ? reportError : function(error4) {
            console["error"](error4);
          };
          function ReactDOMRoot(internalRoot) {
            this._internalRoot = internalRoot;
          }
          ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
            var root2 = this._internalRoot;
            if (root2 === null) {
              throw new Error("Cannot update an unmounted root.");
            }
            {
              if (typeof arguments[1] === "function") {
                error3("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
              } else if (isValidContainer(arguments[1])) {
                error3("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.");
              } else if (typeof arguments[1] !== "undefined") {
                error3("You passed a second argument to root.render(...) but it only accepts one argument.");
              }
              var container = root2.containerInfo;
              if (container.nodeType !== COMMENT_NODE) {
                var hostInstance = findHostInstanceWithNoPortals(root2.current);
                if (hostInstance) {
                  if (hostInstance.parentNode !== container) {
                    error3("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
                  }
                }
              }
            }
            updateContainer(children, root2, null, null);
          };
          ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
            {
              if (typeof arguments[0] === "function") {
                error3("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
              }
            }
            var root2 = this._internalRoot;
            if (root2 !== null) {
              this._internalRoot = null;
              var container = root2.containerInfo;
              {
                if (isAlreadyRendering()) {
                  error3("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition.");
                }
              }
              flushSync(function() {
                updateContainer(null, root2, null, null);
              });
              unmarkContainerAsRoot(container);
            }
          };
          function createRoot(container, options3) {
            if (!isValidContainer(container)) {
              throw new Error("createRoot(...): Target container is not a DOM element.");
            }
            warnIfReactDOMContainerInDEV(container);
            var isStrictMode = false;
            var concurrentUpdatesByDefaultOverride = false;
            var identifierPrefix = "";
            var onRecoverableError = defaultOnRecoverableError;
            var transitionCallbacks = null;
            if (options3 !== null && options3 !== void 0) {
              {
                if (options3.hydrate) {
                  warn("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.");
                } else {
                  if (typeof options3 === "object" && options3 !== null && options3.$$typeof === REACT_ELEMENT_TYPE) {
                    error3("You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);");
                  }
                }
              }
              if (options3.unstable_strictMode === true) {
                isStrictMode = true;
              }
              if (options3.identifierPrefix !== void 0) {
                identifierPrefix = options3.identifierPrefix;
              }
              if (options3.onRecoverableError !== void 0) {
                onRecoverableError = options3.onRecoverableError;
              }
              if (options3.transitionCallbacks !== void 0) {
                transitionCallbacks = options3.transitionCallbacks;
              }
            }
            var root2 = createContainer(container, ConcurrentRoot, null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            markContainerAsRoot(root2.current, container);
            var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
            listenToAllSupportedEvents(rootContainerElement);
            return new ReactDOMRoot(root2);
          }
          function ReactDOMHydrationRoot(internalRoot) {
            this._internalRoot = internalRoot;
          }
          function scheduleHydration(target5) {
            if (target5) {
              queueExplicitHydrationTarget(target5);
            }
          }
          ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
          function hydrateRoot(container, initialChildren, options3) {
            if (!isValidContainer(container)) {
              throw new Error("hydrateRoot(...): Target container is not a DOM element.");
            }
            warnIfReactDOMContainerInDEV(container);
            {
              if (initialChildren === void 0) {
                error3("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
              }
            }
            var hydrationCallbacks = options3 != null ? options3 : null;
            var mutableSources = options3 != null && options3.hydratedSources || null;
            var isStrictMode = false;
            var concurrentUpdatesByDefaultOverride = false;
            var identifierPrefix = "";
            var onRecoverableError = defaultOnRecoverableError;
            if (options3 !== null && options3 !== void 0) {
              if (options3.unstable_strictMode === true) {
                isStrictMode = true;
              }
              if (options3.identifierPrefix !== void 0) {
                identifierPrefix = options3.identifierPrefix;
              }
              if (options3.onRecoverableError !== void 0) {
                onRecoverableError = options3.onRecoverableError;
              }
            }
            var root2 = createHydrationContainer(initialChildren, null, container, ConcurrentRoot, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
            markContainerAsRoot(root2.current, container);
            listenToAllSupportedEvents(container);
            if (mutableSources) {
              for (var i = 0; i < mutableSources.length; i++) {
                var mutableSource = mutableSources[i];
                registerMutableSourceForHydration(root2, mutableSource);
              }
            }
            return new ReactDOMHydrationRoot(root2);
          }
          function isValidContainer(node) {
            return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || !disableCommentsAsDOMContainers));
          }
          function isValidContainerLegacy(node) {
            return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === " react-mount-point-unstable "));
          }
          function warnIfReactDOMContainerInDEV(container) {
            {
              if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
                error3("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app.");
              }
              if (isContainerMarkedAsRoot(container)) {
                if (container._reactRootContainer) {
                  error3("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.");
                } else {
                  error3("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it.");
                }
              }
            }
          }
          var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
          var topLevelUpdateWarnings;
          {
            topLevelUpdateWarnings = function(container) {
              if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
                var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer.current);
                if (hostInstance) {
                  if (hostInstance.parentNode !== container) {
                    error3("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
                  }
                }
              }
              var isRootRenderedBySomeReact = !!container._reactRootContainer;
              var rootEl = getReactRootElementInContainer(container);
              var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
              if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
                error3("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");
              }
              if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
                error3("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
              }
            };
          }
          function getReactRootElementInContainer(container) {
            if (!container) {
              return null;
            }
            if (container.nodeType === DOCUMENT_NODE) {
              return container.documentElement;
            } else {
              return container.firstChild;
            }
          }
          function noopOnRecoverableError() {
          }
          function legacyCreateRootFromDOMContainer(container, initialChildren, parentComponent, callback, isHydrationContainer) {
            if (isHydrationContainer) {
              if (typeof callback === "function") {
                var originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(root2);
                  originalCallback.call(instance);
                };
              }
              var root2 = createHydrationContainer(
                initialChildren,
                callback,
                container,
                LegacyRoot,
                null,
                false,
                false,
                "",
                noopOnRecoverableError
              );
              container._reactRootContainer = root2;
              markContainerAsRoot(root2.current, container);
              var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
              listenToAllSupportedEvents(rootContainerElement);
              flushSync();
              return root2;
            } else {
              var rootSibling;
              while (rootSibling = container.lastChild) {
                container.removeChild(rootSibling);
              }
              if (typeof callback === "function") {
                var _originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(_root);
                  _originalCallback.call(instance);
                };
              }
              var _root = createContainer(
                container,
                LegacyRoot,
                null,
                false,
                false,
                "",
                noopOnRecoverableError
              );
              container._reactRootContainer = _root;
              markContainerAsRoot(_root.current, container);
              var _rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
              listenToAllSupportedEvents(_rootContainerElement);
              flushSync(function() {
                updateContainer(initialChildren, _root, parentComponent, callback);
              });
              return _root;
            }
          }
          function warnOnInvalidCallback$1(callback, callerName) {
            {
              if (callback !== null && typeof callback !== "function") {
                error3("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            }
          }
          function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
            {
              topLevelUpdateWarnings(container);
              warnOnInvalidCallback$1(callback === void 0 ? null : callback, "render");
            }
            var maybeRoot = container._reactRootContainer;
            var root2;
            if (!maybeRoot) {
              root2 = legacyCreateRootFromDOMContainer(container, children, parentComponent, callback, forceHydrate);
            } else {
              root2 = maybeRoot;
              if (typeof callback === "function") {
                var originalCallback = callback;
                callback = function() {
                  var instance = getPublicRootInstance(root2);
                  originalCallback.call(instance);
                };
              }
              updateContainer(children, root2, parentComponent, callback);
            }
            return getPublicRootInstance(root2);
          }
          function findDOMNode(componentOrElement) {
            {
              var owner = ReactCurrentOwner$3.current;
              if (owner !== null && owner.stateNode !== null) {
                var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
                if (!warnedAboutRefsInRender) {
                  error3("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromType(owner.type) || "A component");
                }
                owner.stateNode._warnedAboutRefsInRender = true;
              }
            }
            if (componentOrElement == null) {
              return null;
            }
            if (componentOrElement.nodeType === ELEMENT_NODE) {
              return componentOrElement;
            }
            {
              return findHostInstanceWithWarning(componentOrElement, "findDOMNode");
            }
          }
          function hydrate(element, container, callback) {
            {
              error3("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
            if (!isValidContainerLegacy(container)) {
              throw new Error("Target container is not a DOM element.");
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
              if (isModernRoot) {
                error3("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
              }
            }
            return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
          }
          function render2(element, container, callback) {
            {
              error3("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
            if (!isValidContainerLegacy(container)) {
              throw new Error("Target container is not a DOM element.");
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
              if (isModernRoot) {
                error3("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
              }
            }
            return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
          }
          function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
            {
              error3("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot");
            }
            if (!isValidContainerLegacy(containerNode)) {
              throw new Error("Target container is not a DOM element.");
            }
            if (parentComponent == null || !has(parentComponent)) {
              throw new Error("parentComponent must be a valid React Component");
            }
            return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
          }
          function unmountComponentAtNode(container) {
            if (!isValidContainerLegacy(container)) {
              throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
            }
            {
              var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
              if (isModernRoot) {
                error3("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
              }
            }
            if (container._reactRootContainer) {
              {
                var rootEl = getReactRootElementInContainer(container);
                var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
                if (renderedByDifferentReact) {
                  error3("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
                }
              }
              flushSync(function() {
                legacyRenderSubtreeIntoContainer(null, null, container, false, function() {
                  container._reactRootContainer = null;
                  unmarkContainerAsRoot(container);
                });
              });
              return true;
            } else {
              {
                var _rootEl = getReactRootElementInContainer(container);
                var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));
                var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainerLegacy(container.parentNode) && !!container.parentNode._reactRootContainer;
                if (hasNonRootReactChild) {
                  error3("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
                }
              }
              return false;
            }
          }
          setAttemptSynchronousHydration(attemptSynchronousHydration$1);
          setAttemptContinuousHydration(attemptContinuousHydration$1);
          setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
          setGetCurrentUpdatePriority(getCurrentUpdatePriority);
          setAttemptHydrationAtPriority(runWithPriority);
          {
            if (typeof Map !== "function" || Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
              error3("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");
            }
          }
          setRestoreImplementation(restoreControlledState$3);
          setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync);
          function createPortal$1(children, container) {
            var key = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
            if (!isValidContainer(container)) {
              throw new Error("Target container is not a DOM element.");
            }
            return createPortal(children, container, null, key);
          }
          function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
            return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
          }
          var Internals = {
            usingClientEntryPoint: false,
            Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, batchedUpdates$1]
          };
          function createRoot$1(container, options3) {
            {
              if (!Internals.usingClientEntryPoint && true) {
                error3('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
              }
            }
            return createRoot(container, options3);
          }
          function hydrateRoot$1(container, initialChildren, options3) {
            {
              if (!Internals.usingClientEntryPoint && true) {
                error3('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".');
              }
            }
            return hydrateRoot(container, initialChildren, options3);
          }
          function flushSync$1(fn) {
            {
              if (isAlreadyRendering()) {
                error3("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task.");
              }
            }
            return flushSync(fn);
          }
          var foundDevTools = injectIntoDevTools({
            findFiberByHostInstance: getClosestInstanceFromNode,
            bundleType: 1,
            version: ReactVersion,
            rendererPackageName: "react-dom"
          });
          {
            if (!foundDevTools && canUseDOM && window.top === window.self) {
              if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
                var protocol2 = window.location.protocol;
                if (/^(https?|file):$/.test(protocol2)) {
                  console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol2 === "file:" ? "\nYou might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq" : ""), "font-weight:bold");
                }
              }
            }
          }
          exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
          exports.createPortal = createPortal$1;
          exports.createRoot = createRoot$1;
          exports.findDOMNode = findDOMNode;
          exports.flushSync = flushSync$1;
          exports.hydrate = hydrate;
          exports.hydrateRoot = hydrateRoot$1;
          exports.render = render2;
          exports.unmountComponentAtNode = unmountComponentAtNode;
          exports.unstable_batchedUpdates = batchedUpdates$1;
          exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
          exports.version = ReactVersion;
          if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
          }
        })();
      }
    }
  });

  // node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      if (false) {
        checkDCE();
        module.exports = null;
      } else {
        module.exports = require_react_dom_development();
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js
  var require_react_dom_server_legacy_browser_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom-server-legacy.browser.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var React18 = require_react();
          var ReactVersion = "18.2.0";
          var ReactSharedInternals = React18.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          function warn(format) {
            {
              {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format, args);
              }
            }
          }
          function error3(format) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format, args);
              }
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          function scheduleWork(callback) {
            callback();
          }
          function beginWriting(destination) {
          }
          function writeChunk(destination, chunk) {
            writeChunkAndReturn(destination, chunk);
          }
          function writeChunkAndReturn(destination, chunk) {
            return destination.push(chunk);
          }
          function completeWriting(destination) {
          }
          function close2(destination) {
            destination.push(null);
          }
          function stringToChunk(content3) {
            return content3;
          }
          function stringToPrecomputedChunk(content3) {
            return content3;
          }
          function closeWithError(destination, error4) {
            destination.destroy(error4);
          }
          function typeName(value13) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value13[Symbol.toStringTag] || value13.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value13) {
            {
              try {
                testStringCoercion(value13);
                return false;
              } catch (e) {
                return true;
              }
            }
          }
          function testStringCoercion(value13) {
            return "" + value13;
          }
          function checkAttributeStringCoercion(value13, attributeName) {
            {
              if (willCoercionThrow(value13)) {
                error3("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value13));
                return testStringCoercion(value13);
              }
            }
          }
          function checkCSSPropertyStringCoercion(value13, propName) {
            {
              if (willCoercionThrow(value13)) {
                error3("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value13));
                return testStringCoercion(value13);
              }
            }
          }
          function checkHtmlStringCoercion(value13) {
            {
              if (willCoercionThrow(value13)) {
                error3("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value13));
                return testStringCoercion(value13);
              }
            }
          }
          var hasOwnProperty3 = Object.prototype.hasOwnProperty;
          var RESERVED = 0;
          var STRING = 1;
          var BOOLEANISH_STRING = 2;
          var BOOLEAN = 3;
          var OVERLOADED_BOOLEAN = 4;
          var NUMERIC = 5;
          var POSITIVE_NUMERIC = 6;
          var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
          var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
          var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
          var illegalAttributeNameCache = {};
          var validatedAttributeNameCache = {};
          function isAttributeNameSafe(attributeName) {
            if (hasOwnProperty3.call(validatedAttributeNameCache, attributeName)) {
              return true;
            }
            if (hasOwnProperty3.call(illegalAttributeNameCache, attributeName)) {
              return false;
            }
            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
              validatedAttributeNameCache[attributeName] = true;
              return true;
            }
            illegalAttributeNameCache[attributeName] = true;
            {
              error3("Invalid attribute name: `%s`", attributeName);
            }
            return false;
          }
          function shouldRemoveAttributeWithWarning(name16, value13, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null && propertyInfo.type === RESERVED) {
              return false;
            }
            switch (typeof value13) {
              case "function":
              case "symbol":
                return true;
              case "boolean": {
                if (isCustomComponentTag) {
                  return false;
                }
                if (propertyInfo !== null) {
                  return !propertyInfo.acceptsBooleans;
                } else {
                  var prefix2 = name16.toLowerCase().slice(0, 5);
                  return prefix2 !== "data-" && prefix2 !== "aria-";
                }
              }
              default:
                return false;
            }
          }
          function getPropertyInfo(name16) {
            return properties.hasOwnProperty(name16) ? properties[name16] : null;
          }
          function PropertyInfoRecord(name16, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
            this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
            this.attributeName = attributeName;
            this.attributeNamespace = attributeNamespace;
            this.mustUseProperty = mustUseProperty;
            this.propertyName = name16;
            this.type = type;
            this.sanitizeURL = sanitizeURL2;
            this.removeEmptyString = removeEmptyString;
          }
          var properties = {};
          var reservedProps = [
            "children",
            "dangerouslySetInnerHTML",
            "defaultValue",
            "defaultChecked",
            "innerHTML",
            "suppressContentEditableWarning",
            "suppressHydrationWarning",
            "style"
          ];
          reservedProps.forEach(function(name16) {
            properties[name16] = new PropertyInfoRecord(
              name16,
              RESERVED,
              false,
              name16,
              null,
              false,
              false
            );
          });
          [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
            var name16 = _ref[0], attributeName = _ref[1];
            properties[name16] = new PropertyInfoRecord(
              name16,
              STRING,
              false,
              attributeName,
              null,
              false,
              false
            );
          });
          ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name16) {
            properties[name16] = new PropertyInfoRecord(
              name16,
              BOOLEANISH_STRING,
              false,
              name16.toLowerCase(),
              null,
              false,
              false
            );
          });
          ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name16) {
            properties[name16] = new PropertyInfoRecord(
              name16,
              BOOLEANISH_STRING,
              false,
              name16,
              null,
              false,
              false
            );
          });
          [
            "allowFullScreen",
            "async",
            "autoFocus",
            "autoPlay",
            "controls",
            "default",
            "defer",
            "disabled",
            "disablePictureInPicture",
            "disableRemotePlayback",
            "formNoValidate",
            "hidden",
            "loop",
            "noModule",
            "noValidate",
            "open",
            "playsInline",
            "readOnly",
            "required",
            "reversed",
            "scoped",
            "seamless",
            "itemScope"
          ].forEach(function(name16) {
            properties[name16] = new PropertyInfoRecord(
              name16,
              BOOLEAN,
              false,
              name16.toLowerCase(),
              null,
              false,
              false
            );
          });
          [
            "checked",
            "multiple",
            "muted",
            "selected"
          ].forEach(function(name16) {
            properties[name16] = new PropertyInfoRecord(
              name16,
              BOOLEAN,
              true,
              name16,
              null,
              false,
              false
            );
          });
          [
            "capture",
            "download"
          ].forEach(function(name16) {
            properties[name16] = new PropertyInfoRecord(
              name16,
              OVERLOADED_BOOLEAN,
              false,
              name16,
              null,
              false,
              false
            );
          });
          [
            "cols",
            "rows",
            "size",
            "span"
          ].forEach(function(name16) {
            properties[name16] = new PropertyInfoRecord(
              name16,
              POSITIVE_NUMERIC,
              false,
              name16,
              null,
              false,
              false
            );
          });
          ["rowSpan", "start"].forEach(function(name16) {
            properties[name16] = new PropertyInfoRecord(
              name16,
              NUMERIC,
              false,
              name16.toLowerCase(),
              null,
              false,
              false
            );
          });
          var CAMELIZE = /[\-\:]([a-z])/g;
          var capitalize = function(token) {
            return token[1].toUpperCase();
          };
          [
            "accent-height",
            "alignment-baseline",
            "arabic-form",
            "baseline-shift",
            "cap-height",
            "clip-path",
            "clip-rule",
            "color-interpolation",
            "color-interpolation-filters",
            "color-profile",
            "color-rendering",
            "dominant-baseline",
            "enable-background",
            "fill-opacity",
            "fill-rule",
            "flood-color",
            "flood-opacity",
            "font-family",
            "font-size",
            "font-size-adjust",
            "font-stretch",
            "font-style",
            "font-variant",
            "font-weight",
            "glyph-name",
            "glyph-orientation-horizontal",
            "glyph-orientation-vertical",
            "horiz-adv-x",
            "horiz-origin-x",
            "image-rendering",
            "letter-spacing",
            "lighting-color",
            "marker-end",
            "marker-mid",
            "marker-start",
            "overline-position",
            "overline-thickness",
            "paint-order",
            "panose-1",
            "pointer-events",
            "rendering-intent",
            "shape-rendering",
            "stop-color",
            "stop-opacity",
            "strikethrough-position",
            "strikethrough-thickness",
            "stroke-dasharray",
            "stroke-dashoffset",
            "stroke-linecap",
            "stroke-linejoin",
            "stroke-miterlimit",
            "stroke-opacity",
            "stroke-width",
            "text-anchor",
            "text-decoration",
            "text-rendering",
            "underline-position",
            "underline-thickness",
            "unicode-bidi",
            "unicode-range",
            "units-per-em",
            "v-alphabetic",
            "v-hanging",
            "v-ideographic",
            "v-mathematical",
            "vector-effect",
            "vert-adv-y",
            "vert-origin-x",
            "vert-origin-y",
            "word-spacing",
            "writing-mode",
            "xmlns:xlink",
            "x-height"
          ].forEach(function(attributeName) {
            var name16 = attributeName.replace(CAMELIZE, capitalize);
            properties[name16] = new PropertyInfoRecord(
              name16,
              STRING,
              false,
              attributeName,
              null,
              false,
              false
            );
          });
          [
            "xlink:actuate",
            "xlink:arcrole",
            "xlink:role",
            "xlink:show",
            "xlink:title",
            "xlink:type"
          ].forEach(function(attributeName) {
            var name16 = attributeName.replace(CAMELIZE, capitalize);
            properties[name16] = new PropertyInfoRecord(
              name16,
              STRING,
              false,
              attributeName,
              "http://www.w3.org/1999/xlink",
              false,
              false
            );
          });
          [
            "xml:base",
            "xml:lang",
            "xml:space"
          ].forEach(function(attributeName) {
            var name16 = attributeName.replace(CAMELIZE, capitalize);
            properties[name16] = new PropertyInfoRecord(
              name16,
              STRING,
              false,
              attributeName,
              "http://www.w3.org/XML/1998/namespace",
              false,
              false
            );
          });
          ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(
              attributeName,
              STRING,
              false,
              attributeName.toLowerCase(),
              null,
              false,
              false
            );
          });
          var xlinkHref = "xlinkHref";
          properties[xlinkHref] = new PropertyInfoRecord(
            "xlinkHref",
            STRING,
            false,
            "xlink:href",
            "http://www.w3.org/1999/xlink",
            true,
            false
          );
          ["src", "href", "action", "formAction"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(
              attributeName,
              STRING,
              false,
              attributeName.toLowerCase(),
              null,
              true,
              true
            );
          });
          var isUnitlessNumber = {
            animationIterationCount: true,
            aspectRatio: true,
            borderImageOutset: true,
            borderImageSlice: true,
            borderImageWidth: true,
            boxFlex: true,
            boxFlexGroup: true,
            boxOrdinalGroup: true,
            columnCount: true,
            columns: true,
            flex: true,
            flexGrow: true,
            flexPositive: true,
            flexShrink: true,
            flexNegative: true,
            flexOrder: true,
            gridArea: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowSpan: true,
            gridRowStart: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnSpan: true,
            gridColumnStart: true,
            fontWeight: true,
            lineClamp: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            tabSize: true,
            widows: true,
            zIndex: true,
            zoom: true,
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeDasharray: true,
            strokeDashoffset: true,
            strokeMiterlimit: true,
            strokeOpacity: true,
            strokeWidth: true
          };
          function prefixKey(prefix2, key) {
            return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
          }
          var prefixes = ["Webkit", "ms", "Moz", "O"];
          Object.keys(isUnitlessNumber).forEach(function(prop) {
            prefixes.forEach(function(prefix2) {
              isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
            });
          });
          var hasReadOnlyValue = {
            button: true,
            checkbox: true,
            image: true,
            hidden: true,
            radio: true,
            reset: true,
            submit: true
          };
          function checkControlledValueProps(tagName, props) {
            {
              if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
                error3("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
              }
              if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
                error3("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
              }
            }
          }
          function isCustomComponent(tagName, props) {
            if (tagName.indexOf("-") === -1) {
              return typeof props.is === "string";
            }
            switch (tagName) {
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph":
                return false;
              default:
                return true;
            }
          }
          var ariaProperties = {
            "aria-current": 0,
            "aria-description": 0,
            "aria-details": 0,
            "aria-disabled": 0,
            "aria-hidden": 0,
            "aria-invalid": 0,
            "aria-keyshortcuts": 0,
            "aria-label": 0,
            "aria-roledescription": 0,
            "aria-autocomplete": 0,
            "aria-checked": 0,
            "aria-expanded": 0,
            "aria-haspopup": 0,
            "aria-level": 0,
            "aria-modal": 0,
            "aria-multiline": 0,
            "aria-multiselectable": 0,
            "aria-orientation": 0,
            "aria-placeholder": 0,
            "aria-pressed": 0,
            "aria-readonly": 0,
            "aria-required": 0,
            "aria-selected": 0,
            "aria-sort": 0,
            "aria-valuemax": 0,
            "aria-valuemin": 0,
            "aria-valuenow": 0,
            "aria-valuetext": 0,
            "aria-atomic": 0,
            "aria-busy": 0,
            "aria-live": 0,
            "aria-relevant": 0,
            "aria-dropeffect": 0,
            "aria-grabbed": 0,
            "aria-activedescendant": 0,
            "aria-colcount": 0,
            "aria-colindex": 0,
            "aria-colspan": 0,
            "aria-controls": 0,
            "aria-describedby": 0,
            "aria-errormessage": 0,
            "aria-flowto": 0,
            "aria-labelledby": 0,
            "aria-owns": 0,
            "aria-posinset": 0,
            "aria-rowcount": 0,
            "aria-rowindex": 0,
            "aria-rowspan": 0,
            "aria-setsize": 0
          };
          var warnedProperties = {};
          var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          function validateProperty(tagName, name16) {
            {
              if (hasOwnProperty3.call(warnedProperties, name16) && warnedProperties[name16]) {
                return true;
              }
              if (rARIACamel.test(name16)) {
                var ariaName = "aria-" + name16.slice(4).toLowerCase();
                var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
                if (correctName == null) {
                  error3("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name16);
                  warnedProperties[name16] = true;
                  return true;
                }
                if (name16 !== correctName) {
                  error3("Invalid ARIA attribute `%s`. Did you mean `%s`?", name16, correctName);
                  warnedProperties[name16] = true;
                  return true;
                }
              }
              if (rARIA.test(name16)) {
                var lowerCasedName = name16.toLowerCase();
                var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
                if (standardName == null) {
                  warnedProperties[name16] = true;
                  return false;
                }
                if (name16 !== standardName) {
                  error3("Unknown ARIA attribute `%s`. Did you mean `%s`?", name16, standardName);
                  warnedProperties[name16] = true;
                  return true;
                }
              }
            }
            return true;
          }
          function warnInvalidARIAProps(type, props) {
            {
              var invalidProps = [];
              for (var key in props) {
                var isValid3 = validateProperty(type, key);
                if (!isValid3) {
                  invalidProps.push(key);
                }
              }
              var unknownPropString = invalidProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (invalidProps.length === 1) {
                error3("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              } else if (invalidProps.length > 1) {
                error3("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              }
            }
          }
          function validateProperties(type, props) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnInvalidARIAProps(type, props);
          }
          var didWarnValueNull = false;
          function validateProperties$1(type, props) {
            {
              if (type !== "input" && type !== "textarea" && type !== "select") {
                return;
              }
              if (props != null && props.value === null && !didWarnValueNull) {
                didWarnValueNull = true;
                if (type === "select" && props.multiple) {
                  error3("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
                } else {
                  error3("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
                }
              }
            }
          }
          var possibleStandardNames = {
            accept: "accept",
            acceptcharset: "acceptCharset",
            "accept-charset": "acceptCharset",
            accesskey: "accessKey",
            action: "action",
            allowfullscreen: "allowFullScreen",
            alt: "alt",
            as: "as",
            async: "async",
            autocapitalize: "autoCapitalize",
            autocomplete: "autoComplete",
            autocorrect: "autoCorrect",
            autofocus: "autoFocus",
            autoplay: "autoPlay",
            autosave: "autoSave",
            capture: "capture",
            cellpadding: "cellPadding",
            cellspacing: "cellSpacing",
            challenge: "challenge",
            charset: "charSet",
            checked: "checked",
            children: "children",
            cite: "cite",
            class: "className",
            classid: "classID",
            classname: "className",
            cols: "cols",
            colspan: "colSpan",
            content: "content",
            contenteditable: "contentEditable",
            contextmenu: "contextMenu",
            controls: "controls",
            controlslist: "controlsList",
            coords: "coords",
            crossorigin: "crossOrigin",
            dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
            data: "data",
            datetime: "dateTime",
            default: "default",
            defaultchecked: "defaultChecked",
            defaultvalue: "defaultValue",
            defer: "defer",
            dir: "dir",
            disabled: "disabled",
            disablepictureinpicture: "disablePictureInPicture",
            disableremoteplayback: "disableRemotePlayback",
            download: "download",
            draggable: "draggable",
            enctype: "encType",
            enterkeyhint: "enterKeyHint",
            for: "htmlFor",
            form: "form",
            formmethod: "formMethod",
            formaction: "formAction",
            formenctype: "formEncType",
            formnovalidate: "formNoValidate",
            formtarget: "formTarget",
            frameborder: "frameBorder",
            headers: "headers",
            height: "height",
            hidden: "hidden",
            high: "high",
            href: "href",
            hreflang: "hrefLang",
            htmlfor: "htmlFor",
            httpequiv: "httpEquiv",
            "http-equiv": "httpEquiv",
            icon: "icon",
            id: "id",
            imagesizes: "imageSizes",
            imagesrcset: "imageSrcSet",
            innerhtml: "innerHTML",
            inputmode: "inputMode",
            integrity: "integrity",
            is: "is",
            itemid: "itemID",
            itemprop: "itemProp",
            itemref: "itemRef",
            itemscope: "itemScope",
            itemtype: "itemType",
            keyparams: "keyParams",
            keytype: "keyType",
            kind: "kind",
            label: "label",
            lang: "lang",
            list: "list",
            loop: "loop",
            low: "low",
            manifest: "manifest",
            marginwidth: "marginWidth",
            marginheight: "marginHeight",
            max: "max",
            maxlength: "maxLength",
            media: "media",
            mediagroup: "mediaGroup",
            method: "method",
            min: "min",
            minlength: "minLength",
            multiple: "multiple",
            muted: "muted",
            name: "name",
            nomodule: "noModule",
            nonce: "nonce",
            novalidate: "noValidate",
            open: "open",
            optimum: "optimum",
            pattern: "pattern",
            placeholder: "placeholder",
            playsinline: "playsInline",
            poster: "poster",
            preload: "preload",
            profile: "profile",
            radiogroup: "radioGroup",
            readonly: "readOnly",
            referrerpolicy: "referrerPolicy",
            rel: "rel",
            required: "required",
            reversed: "reversed",
            role: "role",
            rows: "rows",
            rowspan: "rowSpan",
            sandbox: "sandbox",
            scope: "scope",
            scoped: "scoped",
            scrolling: "scrolling",
            seamless: "seamless",
            selected: "selected",
            shape: "shape",
            size: "size",
            sizes: "sizes",
            span: "span",
            spellcheck: "spellCheck",
            src: "src",
            srcdoc: "srcDoc",
            srclang: "srcLang",
            srcset: "srcSet",
            start: "start",
            step: "step",
            style: "style",
            summary: "summary",
            tabindex: "tabIndex",
            target: "target",
            title: "title",
            type: "type",
            usemap: "useMap",
            value: "value",
            width: "width",
            wmode: "wmode",
            wrap: "wrap",
            about: "about",
            accentheight: "accentHeight",
            "accent-height": "accentHeight",
            accumulate: "accumulate",
            additive: "additive",
            alignmentbaseline: "alignmentBaseline",
            "alignment-baseline": "alignmentBaseline",
            allowreorder: "allowReorder",
            alphabetic: "alphabetic",
            amplitude: "amplitude",
            arabicform: "arabicForm",
            "arabic-form": "arabicForm",
            ascent: "ascent",
            attributename: "attributeName",
            attributetype: "attributeType",
            autoreverse: "autoReverse",
            azimuth: "azimuth",
            basefrequency: "baseFrequency",
            baselineshift: "baselineShift",
            "baseline-shift": "baselineShift",
            baseprofile: "baseProfile",
            bbox: "bbox",
            begin: "begin",
            bias: "bias",
            by: "by",
            calcmode: "calcMode",
            capheight: "capHeight",
            "cap-height": "capHeight",
            clip: "clip",
            clippath: "clipPath",
            "clip-path": "clipPath",
            clippathunits: "clipPathUnits",
            cliprule: "clipRule",
            "clip-rule": "clipRule",
            color: "color",
            colorinterpolation: "colorInterpolation",
            "color-interpolation": "colorInterpolation",
            colorinterpolationfilters: "colorInterpolationFilters",
            "color-interpolation-filters": "colorInterpolationFilters",
            colorprofile: "colorProfile",
            "color-profile": "colorProfile",
            colorrendering: "colorRendering",
            "color-rendering": "colorRendering",
            contentscripttype: "contentScriptType",
            contentstyletype: "contentStyleType",
            cursor: "cursor",
            cx: "cx",
            cy: "cy",
            d: "d",
            datatype: "datatype",
            decelerate: "decelerate",
            descent: "descent",
            diffuseconstant: "diffuseConstant",
            direction: "direction",
            display: "display",
            divisor: "divisor",
            dominantbaseline: "dominantBaseline",
            "dominant-baseline": "dominantBaseline",
            dur: "dur",
            dx: "dx",
            dy: "dy",
            edgemode: "edgeMode",
            elevation: "elevation",
            enablebackground: "enableBackground",
            "enable-background": "enableBackground",
            end: "end",
            exponent: "exponent",
            externalresourcesrequired: "externalResourcesRequired",
            fill: "fill",
            fillopacity: "fillOpacity",
            "fill-opacity": "fillOpacity",
            fillrule: "fillRule",
            "fill-rule": "fillRule",
            filter: "filter",
            filterres: "filterRes",
            filterunits: "filterUnits",
            floodopacity: "floodOpacity",
            "flood-opacity": "floodOpacity",
            floodcolor: "floodColor",
            "flood-color": "floodColor",
            focusable: "focusable",
            fontfamily: "fontFamily",
            "font-family": "fontFamily",
            fontsize: "fontSize",
            "font-size": "fontSize",
            fontsizeadjust: "fontSizeAdjust",
            "font-size-adjust": "fontSizeAdjust",
            fontstretch: "fontStretch",
            "font-stretch": "fontStretch",
            fontstyle: "fontStyle",
            "font-style": "fontStyle",
            fontvariant: "fontVariant",
            "font-variant": "fontVariant",
            fontweight: "fontWeight",
            "font-weight": "fontWeight",
            format: "format",
            from: "from",
            fx: "fx",
            fy: "fy",
            g1: "g1",
            g2: "g2",
            glyphname: "glyphName",
            "glyph-name": "glyphName",
            glyphorientationhorizontal: "glyphOrientationHorizontal",
            "glyph-orientation-horizontal": "glyphOrientationHorizontal",
            glyphorientationvertical: "glyphOrientationVertical",
            "glyph-orientation-vertical": "glyphOrientationVertical",
            glyphref: "glyphRef",
            gradienttransform: "gradientTransform",
            gradientunits: "gradientUnits",
            hanging: "hanging",
            horizadvx: "horizAdvX",
            "horiz-adv-x": "horizAdvX",
            horizoriginx: "horizOriginX",
            "horiz-origin-x": "horizOriginX",
            ideographic: "ideographic",
            imagerendering: "imageRendering",
            "image-rendering": "imageRendering",
            in2: "in2",
            in: "in",
            inlist: "inlist",
            intercept: "intercept",
            k1: "k1",
            k2: "k2",
            k3: "k3",
            k4: "k4",
            k: "k",
            kernelmatrix: "kernelMatrix",
            kernelunitlength: "kernelUnitLength",
            kerning: "kerning",
            keypoints: "keyPoints",
            keysplines: "keySplines",
            keytimes: "keyTimes",
            lengthadjust: "lengthAdjust",
            letterspacing: "letterSpacing",
            "letter-spacing": "letterSpacing",
            lightingcolor: "lightingColor",
            "lighting-color": "lightingColor",
            limitingconeangle: "limitingConeAngle",
            local: "local",
            markerend: "markerEnd",
            "marker-end": "markerEnd",
            markerheight: "markerHeight",
            markermid: "markerMid",
            "marker-mid": "markerMid",
            markerstart: "markerStart",
            "marker-start": "markerStart",
            markerunits: "markerUnits",
            markerwidth: "markerWidth",
            mask: "mask",
            maskcontentunits: "maskContentUnits",
            maskunits: "maskUnits",
            mathematical: "mathematical",
            mode: "mode",
            numoctaves: "numOctaves",
            offset: "offset",
            opacity: "opacity",
            operator: "operator",
            order: "order",
            orient: "orient",
            orientation: "orientation",
            origin: "origin",
            overflow: "overflow",
            overlineposition: "overlinePosition",
            "overline-position": "overlinePosition",
            overlinethickness: "overlineThickness",
            "overline-thickness": "overlineThickness",
            paintorder: "paintOrder",
            "paint-order": "paintOrder",
            panose1: "panose1",
            "panose-1": "panose1",
            pathlength: "pathLength",
            patterncontentunits: "patternContentUnits",
            patterntransform: "patternTransform",
            patternunits: "patternUnits",
            pointerevents: "pointerEvents",
            "pointer-events": "pointerEvents",
            points: "points",
            pointsatx: "pointsAtX",
            pointsaty: "pointsAtY",
            pointsatz: "pointsAtZ",
            prefix: "prefix",
            preservealpha: "preserveAlpha",
            preserveaspectratio: "preserveAspectRatio",
            primitiveunits: "primitiveUnits",
            property: "property",
            r: "r",
            radius: "radius",
            refx: "refX",
            refy: "refY",
            renderingintent: "renderingIntent",
            "rendering-intent": "renderingIntent",
            repeatcount: "repeatCount",
            repeatdur: "repeatDur",
            requiredextensions: "requiredExtensions",
            requiredfeatures: "requiredFeatures",
            resource: "resource",
            restart: "restart",
            result: "result",
            results: "results",
            rotate: "rotate",
            rx: "rx",
            ry: "ry",
            scale: "scale",
            security: "security",
            seed: "seed",
            shaperendering: "shapeRendering",
            "shape-rendering": "shapeRendering",
            slope: "slope",
            spacing: "spacing",
            specularconstant: "specularConstant",
            specularexponent: "specularExponent",
            speed: "speed",
            spreadmethod: "spreadMethod",
            startoffset: "startOffset",
            stddeviation: "stdDeviation",
            stemh: "stemh",
            stemv: "stemv",
            stitchtiles: "stitchTiles",
            stopcolor: "stopColor",
            "stop-color": "stopColor",
            stopopacity: "stopOpacity",
            "stop-opacity": "stopOpacity",
            strikethroughposition: "strikethroughPosition",
            "strikethrough-position": "strikethroughPosition",
            strikethroughthickness: "strikethroughThickness",
            "strikethrough-thickness": "strikethroughThickness",
            string: "string",
            stroke: "stroke",
            strokedasharray: "strokeDasharray",
            "stroke-dasharray": "strokeDasharray",
            strokedashoffset: "strokeDashoffset",
            "stroke-dashoffset": "strokeDashoffset",
            strokelinecap: "strokeLinecap",
            "stroke-linecap": "strokeLinecap",
            strokelinejoin: "strokeLinejoin",
            "stroke-linejoin": "strokeLinejoin",
            strokemiterlimit: "strokeMiterlimit",
            "stroke-miterlimit": "strokeMiterlimit",
            strokewidth: "strokeWidth",
            "stroke-width": "strokeWidth",
            strokeopacity: "strokeOpacity",
            "stroke-opacity": "strokeOpacity",
            suppresscontenteditablewarning: "suppressContentEditableWarning",
            suppresshydrationwarning: "suppressHydrationWarning",
            surfacescale: "surfaceScale",
            systemlanguage: "systemLanguage",
            tablevalues: "tableValues",
            targetx: "targetX",
            targety: "targetY",
            textanchor: "textAnchor",
            "text-anchor": "textAnchor",
            textdecoration: "textDecoration",
            "text-decoration": "textDecoration",
            textlength: "textLength",
            textrendering: "textRendering",
            "text-rendering": "textRendering",
            to: "to",
            transform: "transform",
            typeof: "typeof",
            u1: "u1",
            u2: "u2",
            underlineposition: "underlinePosition",
            "underline-position": "underlinePosition",
            underlinethickness: "underlineThickness",
            "underline-thickness": "underlineThickness",
            unicode: "unicode",
            unicodebidi: "unicodeBidi",
            "unicode-bidi": "unicodeBidi",
            unicoderange: "unicodeRange",
            "unicode-range": "unicodeRange",
            unitsperem: "unitsPerEm",
            "units-per-em": "unitsPerEm",
            unselectable: "unselectable",
            valphabetic: "vAlphabetic",
            "v-alphabetic": "vAlphabetic",
            values: "values",
            vectoreffect: "vectorEffect",
            "vector-effect": "vectorEffect",
            version: "version",
            vertadvy: "vertAdvY",
            "vert-adv-y": "vertAdvY",
            vertoriginx: "vertOriginX",
            "vert-origin-x": "vertOriginX",
            vertoriginy: "vertOriginY",
            "vert-origin-y": "vertOriginY",
            vhanging: "vHanging",
            "v-hanging": "vHanging",
            videographic: "vIdeographic",
            "v-ideographic": "vIdeographic",
            viewbox: "viewBox",
            viewtarget: "viewTarget",
            visibility: "visibility",
            vmathematical: "vMathematical",
            "v-mathematical": "vMathematical",
            vocab: "vocab",
            widths: "widths",
            wordspacing: "wordSpacing",
            "word-spacing": "wordSpacing",
            writingmode: "writingMode",
            "writing-mode": "writingMode",
            x1: "x1",
            x2: "x2",
            x: "x",
            xchannelselector: "xChannelSelector",
            xheight: "xHeight",
            "x-height": "xHeight",
            xlinkactuate: "xlinkActuate",
            "xlink:actuate": "xlinkActuate",
            xlinkarcrole: "xlinkArcrole",
            "xlink:arcrole": "xlinkArcrole",
            xlinkhref: "xlinkHref",
            "xlink:href": "xlinkHref",
            xlinkrole: "xlinkRole",
            "xlink:role": "xlinkRole",
            xlinkshow: "xlinkShow",
            "xlink:show": "xlinkShow",
            xlinktitle: "xlinkTitle",
            "xlink:title": "xlinkTitle",
            xlinktype: "xlinkType",
            "xlink:type": "xlinkType",
            xmlbase: "xmlBase",
            "xml:base": "xmlBase",
            xmllang: "xmlLang",
            "xml:lang": "xmlLang",
            xmlns: "xmlns",
            "xml:space": "xmlSpace",
            xmlnsxlink: "xmlnsXlink",
            "xmlns:xlink": "xmlnsXlink",
            xmlspace: "xmlSpace",
            y1: "y1",
            y2: "y2",
            y: "y",
            ychannelselector: "yChannelSelector",
            z: "z",
            zoomandpan: "zoomAndPan"
          };
          var validateProperty$1 = function() {
          };
          {
            var warnedProperties$1 = {};
            var EVENT_NAME_REGEX = /^on./;
            var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
            var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
            var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
            validateProperty$1 = function(tagName, name16, value13, eventRegistry) {
              if (hasOwnProperty3.call(warnedProperties$1, name16) && warnedProperties$1[name16]) {
                return true;
              }
              var lowerCasedName = name16.toLowerCase();
              if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
                error3("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
                warnedProperties$1[name16] = true;
                return true;
              }
              if (eventRegistry != null) {
                var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
                if (registrationNameDependencies.hasOwnProperty(name16)) {
                  return true;
                }
                var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
                if (registrationName != null) {
                  error3("Invalid event handler property `%s`. Did you mean `%s`?", name16, registrationName);
                  warnedProperties$1[name16] = true;
                  return true;
                }
                if (EVENT_NAME_REGEX.test(name16)) {
                  error3("Unknown event handler property `%s`. It will be ignored.", name16);
                  warnedProperties$1[name16] = true;
                  return true;
                }
              } else if (EVENT_NAME_REGEX.test(name16)) {
                if (INVALID_EVENT_NAME_REGEX.test(name16)) {
                  error3("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name16);
                }
                warnedProperties$1[name16] = true;
                return true;
              }
              if (rARIA$1.test(name16) || rARIACamel$1.test(name16)) {
                return true;
              }
              if (lowerCasedName === "innerhtml") {
                error3("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
                warnedProperties$1[name16] = true;
                return true;
              }
              if (lowerCasedName === "aria") {
                error3("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
                warnedProperties$1[name16] = true;
                return true;
              }
              if (lowerCasedName === "is" && value13 !== null && value13 !== void 0 && typeof value13 !== "string") {
                error3("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value13);
                warnedProperties$1[name16] = true;
                return true;
              }
              if (typeof value13 === "number" && isNaN(value13)) {
                error3("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name16);
                warnedProperties$1[name16] = true;
                return true;
              }
              var propertyInfo = getPropertyInfo(name16);
              var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
              if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                var standardName = possibleStandardNames[lowerCasedName];
                if (standardName !== name16) {
                  error3("Invalid DOM property `%s`. Did you mean `%s`?", name16, standardName);
                  warnedProperties$1[name16] = true;
                  return true;
                }
              } else if (!isReserved && name16 !== lowerCasedName) {
                error3("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name16, lowerCasedName);
                warnedProperties$1[name16] = true;
                return true;
              }
              if (typeof value13 === "boolean" && shouldRemoveAttributeWithWarning(name16, value13, propertyInfo, false)) {
                if (value13) {
                  error3('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value13, name16, name16, value13, name16);
                } else {
                  error3('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value13, name16, name16, value13, name16, name16, name16);
                }
                warnedProperties$1[name16] = true;
                return true;
              }
              if (isReserved) {
                return true;
              }
              if (shouldRemoveAttributeWithWarning(name16, value13, propertyInfo, false)) {
                warnedProperties$1[name16] = true;
                return false;
              }
              if ((value13 === "false" || value13 === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
                error3("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value13, name16, value13 === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name16, value13);
                warnedProperties$1[name16] = true;
                return true;
              }
              return true;
            };
          }
          var warnUnknownProperties = function(type, props, eventRegistry) {
            {
              var unknownProps = [];
              for (var key in props) {
                var isValid3 = validateProperty$1(type, key, props[key], eventRegistry);
                if (!isValid3) {
                  unknownProps.push(key);
                }
              }
              var unknownPropString = unknownProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (unknownProps.length === 1) {
                error3("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              } else if (unknownProps.length > 1) {
                error3("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              }
            }
          };
          function validateProperties$2(type, props, eventRegistry) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnUnknownProperties(type, props, eventRegistry);
          }
          var warnValidStyle = function() {
          };
          {
            var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
            var msPattern = /^-ms-/;
            var hyphenPattern = /-(.)/g;
            var badStyleValueWithSemicolonPattern = /;\s*$/;
            var warnedStyleNames = {};
            var warnedStyleValues = {};
            var warnedForNaNValue = false;
            var warnedForInfinityValue = false;
            var camelize = function(string13) {
              return string13.replace(hyphenPattern, function(_, character) {
                return character.toUpperCase();
              });
            };
            var warnHyphenatedStyleName = function(name16) {
              if (warnedStyleNames.hasOwnProperty(name16) && warnedStyleNames[name16]) {
                return;
              }
              warnedStyleNames[name16] = true;
              error3(
                "Unsupported style property %s. Did you mean %s?",
                name16,
                camelize(name16.replace(msPattern, "ms-"))
              );
            };
            var warnBadVendoredStyleName = function(name16) {
              if (warnedStyleNames.hasOwnProperty(name16) && warnedStyleNames[name16]) {
                return;
              }
              warnedStyleNames[name16] = true;
              error3("Unsupported vendor-prefixed style property %s. Did you mean %s?", name16, name16.charAt(0).toUpperCase() + name16.slice(1));
            };
            var warnStyleValueWithSemicolon = function(name16, value13) {
              if (warnedStyleValues.hasOwnProperty(value13) && warnedStyleValues[value13]) {
                return;
              }
              warnedStyleValues[value13] = true;
              error3(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name16, value13.replace(badStyleValueWithSemicolonPattern, ""));
            };
            var warnStyleValueIsNaN = function(name16, value13) {
              if (warnedForNaNValue) {
                return;
              }
              warnedForNaNValue = true;
              error3("`NaN` is an invalid value for the `%s` css style property.", name16);
            };
            var warnStyleValueIsInfinity = function(name16, value13) {
              if (warnedForInfinityValue) {
                return;
              }
              warnedForInfinityValue = true;
              error3("`Infinity` is an invalid value for the `%s` css style property.", name16);
            };
            warnValidStyle = function(name16, value13) {
              if (name16.indexOf("-") > -1) {
                warnHyphenatedStyleName(name16);
              } else if (badVendoredStyleNamePattern.test(name16)) {
                warnBadVendoredStyleName(name16);
              } else if (badStyleValueWithSemicolonPattern.test(value13)) {
                warnStyleValueWithSemicolon(name16, value13);
              }
              if (typeof value13 === "number") {
                if (isNaN(value13)) {
                  warnStyleValueIsNaN(name16, value13);
                } else if (!isFinite(value13)) {
                  warnStyleValueIsInfinity(name16, value13);
                }
              }
            };
          }
          var warnValidStyle$1 = warnValidStyle;
          var matchHtmlRegExp = /["'&<>]/;
          function escapeHtml(string13) {
            {
              checkHtmlStringCoercion(string13);
            }
            var str = "" + string13;
            var match = matchHtmlRegExp.exec(str);
            if (!match) {
              return str;
            }
            var escape;
            var html = "";
            var index5;
            var lastIndex = 0;
            for (index5 = match.index; index5 < str.length; index5++) {
              switch (str.charCodeAt(index5)) {
                case 34:
                  escape = "&quot;";
                  break;
                case 38:
                  escape = "&amp;";
                  break;
                case 39:
                  escape = "&#x27;";
                  break;
                case 60:
                  escape = "&lt;";
                  break;
                case 62:
                  escape = "&gt;";
                  break;
                default:
                  continue;
              }
              if (lastIndex !== index5) {
                html += str.substring(lastIndex, index5);
              }
              lastIndex = index5 + 1;
              html += escape;
            }
            return lastIndex !== index5 ? html + str.substring(lastIndex, index5) : html;
          }
          function escapeTextForBrowser(text5) {
            if (typeof text5 === "boolean" || typeof text5 === "number") {
              return "" + text5;
            }
            return escapeHtml(text5);
          }
          var uppercasePattern = /([A-Z])/g;
          var msPattern$1 = /^ms-/;
          function hyphenateStyleName(name16) {
            return name16.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
          }
          var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
          var didWarn = false;
          function sanitizeURL(url) {
            {
              if (!didWarn && isJavaScriptProtocol.test(url)) {
                didWarn = true;
                error3("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
              }
            }
          }
          var isArrayImpl = Array.isArray;
          function isArray6(a) {
            return isArrayImpl(a);
          }
          var startInlineScript = stringToPrecomputedChunk("<script>");
          var endInlineScript = stringToPrecomputedChunk("<\/script>");
          var startScriptSrc = stringToPrecomputedChunk('<script src="');
          var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
          var endAsyncScript = stringToPrecomputedChunk('" async=""><\/script>');
          function escapeBootstrapScriptContent(scriptText) {
            {
              checkHtmlStringCoercion(scriptText);
            }
            return ("" + scriptText).replace(scriptRegex, scriptReplacer);
          }
          var scriptRegex = /(<\/|<)(s)(cript)/gi;
          var scriptReplacer = function(match, prefix2, s, suffix) {
            return "" + prefix2 + (s === "s" ? "\\u0073" : "\\u0053") + suffix;
          };
          function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
            var idPrefix = identifierPrefix === void 0 ? "" : identifierPrefix;
            var inlineScriptWithNonce = nonce === void 0 ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">');
            var bootstrapChunks = [];
            if (bootstrapScriptContent !== void 0) {
              bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);
            }
            if (bootstrapScripts !== void 0) {
              for (var i = 0; i < bootstrapScripts.length; i++) {
                bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i])), endAsyncScript);
              }
            }
            if (bootstrapModules !== void 0) {
              for (var _i = 0; _i < bootstrapModules.length; _i++) {
                bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i])), endAsyncScript);
              }
            }
            return {
              bootstrapChunks,
              startInlineScript: inlineScriptWithNonce,
              placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
              segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
              boundaryPrefix: idPrefix + "B:",
              idPrefix,
              nextSuspenseID: 0,
              sentCompleteSegmentFunction: false,
              sentCompleteBoundaryFunction: false,
              sentClientRenderFunction: false
            };
          }
          var ROOT_HTML_MODE = 0;
          var HTML_MODE = 1;
          var SVG_MODE = 2;
          var MATHML_MODE = 3;
          var HTML_TABLE_MODE = 4;
          var HTML_TABLE_BODY_MODE = 5;
          var HTML_TABLE_ROW_MODE = 6;
          var HTML_COLGROUP_MODE = 7;
          function createFormatContext(insertionMode, selectedValue) {
            return {
              insertionMode,
              selectedValue
            };
          }
          function getChildFormatContext(parentContext, type, props) {
            switch (type) {
              case "select":
                return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
              case "svg":
                return createFormatContext(SVG_MODE, null);
              case "math":
                return createFormatContext(MATHML_MODE, null);
              case "foreignObject":
                return createFormatContext(HTML_MODE, null);
              case "table":
                return createFormatContext(HTML_TABLE_MODE, null);
              case "thead":
              case "tbody":
              case "tfoot":
                return createFormatContext(HTML_TABLE_BODY_MODE, null);
              case "colgroup":
                return createFormatContext(HTML_COLGROUP_MODE, null);
              case "tr":
                return createFormatContext(HTML_TABLE_ROW_MODE, null);
            }
            if (parentContext.insertionMode >= HTML_TABLE_MODE) {
              return createFormatContext(HTML_MODE, null);
            }
            if (parentContext.insertionMode === ROOT_HTML_MODE) {
              return createFormatContext(HTML_MODE, null);
            }
            return parentContext;
          }
          var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
          function assignSuspenseBoundaryID(responseState) {
            var generatedID = responseState.nextSuspenseID++;
            return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
          }
          function makeId(responseState, treeId, localId) {
            var idPrefix = responseState.idPrefix;
            var id2 = ":" + idPrefix + "R" + treeId;
            if (localId > 0) {
              id2 += "H" + localId.toString(32);
            }
            return id2 + ":";
          }
          function encodeHTMLTextNode(text5) {
            return escapeTextForBrowser(text5);
          }
          var textSeparator = stringToPrecomputedChunk("<!-- -->");
          function pushTextInstance(target5, text5, responseState, textEmbedded) {
            if (text5 === "") {
              return textEmbedded;
            }
            if (textEmbedded) {
              target5.push(textSeparator);
            }
            target5.push(stringToChunk(encodeHTMLTextNode(text5)));
            return true;
          }
          function pushSegmentFinale(target5, responseState, lastPushedText, textEmbedded) {
            if (lastPushedText && textEmbedded) {
              target5.push(textSeparator);
            }
          }
          var styleNameCache = /* @__PURE__ */ new Map();
          function processStyleName(styleName) {
            var chunk = styleNameCache.get(styleName);
            if (chunk !== void 0) {
              return chunk;
            }
            var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
            styleNameCache.set(styleName, result);
            return result;
          }
          var styleAttributeStart = stringToPrecomputedChunk(' style="');
          var styleAssign = stringToPrecomputedChunk(":");
          var styleSeparator = stringToPrecomputedChunk(";");
          function pushStyle(target5, responseState, style) {
            if (typeof style !== "object") {
              throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
            }
            var isFirst = true;
            for (var styleName in style) {
              if (!hasOwnProperty3.call(style, styleName)) {
                continue;
              }
              var styleValue = style[styleName];
              if (styleValue == null || typeof styleValue === "boolean" || styleValue === "") {
                continue;
              }
              var nameChunk = void 0;
              var valueChunk = void 0;
              var isCustomProperty = styleName.indexOf("--") === 0;
              if (isCustomProperty) {
                nameChunk = stringToChunk(escapeTextForBrowser(styleName));
                {
                  checkCSSPropertyStringCoercion(styleValue, styleName);
                }
                valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
              } else {
                {
                  warnValidStyle$1(styleName, styleValue);
                }
                nameChunk = processStyleName(styleName);
                if (typeof styleValue === "number") {
                  if (styleValue !== 0 && !hasOwnProperty3.call(isUnitlessNumber, styleName)) {
                    valueChunk = stringToChunk(styleValue + "px");
                  } else {
                    valueChunk = stringToChunk("" + styleValue);
                  }
                } else {
                  {
                    checkCSSPropertyStringCoercion(styleValue, styleName);
                  }
                  valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
                }
              }
              if (isFirst) {
                isFirst = false;
                target5.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
              } else {
                target5.push(styleSeparator, nameChunk, styleAssign, valueChunk);
              }
            }
            if (!isFirst) {
              target5.push(attributeEnd);
            }
          }
          var attributeSeparator = stringToPrecomputedChunk(" ");
          var attributeAssign = stringToPrecomputedChunk('="');
          var attributeEnd = stringToPrecomputedChunk('"');
          var attributeEmptyString = stringToPrecomputedChunk('=""');
          function pushAttribute(target5, responseState, name16, value13) {
            switch (name16) {
              case "style": {
                pushStyle(target5, responseState, value13);
                return;
              }
              case "defaultValue":
              case "defaultChecked":
              case "innerHTML":
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                return;
            }
            if (name16.length > 2 && (name16[0] === "o" || name16[0] === "O") && (name16[1] === "n" || name16[1] === "N")) {
              return;
            }
            var propertyInfo = getPropertyInfo(name16);
            if (propertyInfo !== null) {
              switch (typeof value13) {
                case "function":
                case "symbol":
                  return;
                case "boolean": {
                  if (!propertyInfo.acceptsBooleans) {
                    return;
                  }
                }
              }
              var attributeName = propertyInfo.attributeName;
              var attributeNameChunk = stringToChunk(attributeName);
              switch (propertyInfo.type) {
                case BOOLEAN:
                  if (value13) {
                    target5.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                  }
                  return;
                case OVERLOADED_BOOLEAN:
                  if (value13 === true) {
                    target5.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                  } else if (value13 === false)
                    ;
                  else {
                    target5.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value13)), attributeEnd);
                  }
                  return;
                case NUMERIC:
                  if (!isNaN(value13)) {
                    target5.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value13)), attributeEnd);
                  }
                  break;
                case POSITIVE_NUMERIC:
                  if (!isNaN(value13) && value13 >= 1) {
                    target5.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value13)), attributeEnd);
                  }
                  break;
                default:
                  if (propertyInfo.sanitizeURL) {
                    {
                      checkAttributeStringCoercion(value13, attributeName);
                    }
                    value13 = "" + value13;
                    sanitizeURL(value13);
                  }
                  target5.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value13)), attributeEnd);
              }
            } else if (isAttributeNameSafe(name16)) {
              switch (typeof value13) {
                case "function":
                case "symbol":
                  return;
                case "boolean": {
                  var prefix2 = name16.toLowerCase().slice(0, 5);
                  if (prefix2 !== "data-" && prefix2 !== "aria-") {
                    return;
                  }
                }
              }
              target5.push(attributeSeparator, stringToChunk(name16), attributeAssign, stringToChunk(escapeTextForBrowser(value13)), attributeEnd);
            }
          }
          var endOfStartTag = stringToPrecomputedChunk(">");
          var endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
          function pushInnerHTML(target5, innerHTML, children) {
            if (innerHTML != null) {
              if (children != null) {
                throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              }
              if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
                throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
              }
              var html = innerHTML.__html;
              if (html !== null && html !== void 0) {
                {
                  checkHtmlStringCoercion(html);
                }
                target5.push(stringToChunk("" + html));
              }
            }
          }
          var didWarnDefaultInputValue = false;
          var didWarnDefaultChecked = false;
          var didWarnDefaultSelectValue = false;
          var didWarnDefaultTextareaValue = false;
          var didWarnInvalidOptionChildren = false;
          var didWarnInvalidOptionInnerHTML = false;
          var didWarnSelectedSetOnOption = false;
          function checkSelectProp(props, propName) {
            {
              var value13 = props[propName];
              if (value13 != null) {
                var array2 = isArray6(value13);
                if (props.multiple && !array2) {
                  error3("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
                } else if (!props.multiple && array2) {
                  error3("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
                }
              }
            }
          }
          function pushStartSelect(target5, props, responseState) {
            {
              checkControlledValueProps("select", props);
              checkSelectProp(props, "value");
              checkSelectProp(props, "defaultValue");
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue) {
                error3("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                didWarnDefaultSelectValue = true;
              }
            }
            target5.push(startChunkForTag("select"));
            var children = null;
            var innerHTML = null;
            for (var propKey in props) {
              if (hasOwnProperty3.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  case "defaultValue":
                  case "value":
                    break;
                  default:
                    pushAttribute(target5, responseState, propKey, propValue);
                    break;
                }
              }
            }
            target5.push(endOfStartTag);
            pushInnerHTML(target5, innerHTML, children);
            return children;
          }
          function flattenOptionChildren(children) {
            var content3 = "";
            React18.Children.forEach(children, function(child) {
              if (child == null) {
                return;
              }
              content3 += child;
              {
                if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
                  didWarnInvalidOptionChildren = true;
                  error3("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
                }
              }
            });
            return content3;
          }
          var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
          function pushStartOption(target5, props, responseState, formatContext) {
            var selectedValue = formatContext.selectedValue;
            target5.push(startChunkForTag("option"));
            var children = null;
            var value13 = null;
            var selected2 = null;
            var innerHTML = null;
            for (var propKey in props) {
              if (hasOwnProperty3.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "selected":
                    selected2 = propValue;
                    {
                      if (!didWarnSelectedSetOnOption) {
                        error3("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                        didWarnSelectedSetOnOption = true;
                      }
                    }
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  case "value":
                    value13 = propValue;
                  default:
                    pushAttribute(target5, responseState, propKey, propValue);
                    break;
                }
              }
            }
            if (selectedValue != null) {
              var stringValue;
              if (value13 !== null) {
                {
                  checkAttributeStringCoercion(value13, "value");
                }
                stringValue = "" + value13;
              } else {
                {
                  if (innerHTML !== null) {
                    if (!didWarnInvalidOptionInnerHTML) {
                      didWarnInvalidOptionInnerHTML = true;
                      error3("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                    }
                  }
                }
                stringValue = flattenOptionChildren(children);
              }
              if (isArray6(selectedValue)) {
                for (var i = 0; i < selectedValue.length; i++) {
                  {
                    checkAttributeStringCoercion(selectedValue[i], "value");
                  }
                  var v = "" + selectedValue[i];
                  if (v === stringValue) {
                    target5.push(selectedMarkerAttribute);
                    break;
                  }
                }
              } else {
                {
                  checkAttributeStringCoercion(selectedValue, "select.value");
                }
                if ("" + selectedValue === stringValue) {
                  target5.push(selectedMarkerAttribute);
                }
              }
            } else if (selected2) {
              target5.push(selectedMarkerAttribute);
            }
            target5.push(endOfStartTag);
            pushInnerHTML(target5, innerHTML, children);
            return children;
          }
          function pushInput(target5, props, responseState) {
            {
              checkControlledValueProps("input", props);
              if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked) {
                error3("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
                didWarnDefaultChecked = true;
              }
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue) {
                error3("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
                didWarnDefaultInputValue = true;
              }
            }
            target5.push(startChunkForTag("input"));
            var value13 = null;
            var defaultValue4 = null;
            var checked2 = null;
            var defaultChecked2 = null;
            for (var propKey in props) {
              if (hasOwnProperty3.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                  case "defaultChecked":
                    defaultChecked2 = propValue;
                    break;
                  case "defaultValue":
                    defaultValue4 = propValue;
                    break;
                  case "checked":
                    checked2 = propValue;
                    break;
                  case "value":
                    value13 = propValue;
                    break;
                  default:
                    pushAttribute(target5, responseState, propKey, propValue);
                    break;
                }
              }
            }
            if (checked2 !== null) {
              pushAttribute(target5, responseState, "checked", checked2);
            } else if (defaultChecked2 !== null) {
              pushAttribute(target5, responseState, "checked", defaultChecked2);
            }
            if (value13 !== null) {
              pushAttribute(target5, responseState, "value", value13);
            } else if (defaultValue4 !== null) {
              pushAttribute(target5, responseState, "value", defaultValue4);
            }
            target5.push(endOfStartTagSelfClosing);
            return null;
          }
          function pushStartTextArea(target5, props, responseState) {
            {
              checkControlledValueProps("textarea", props);
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue) {
                error3("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                didWarnDefaultTextareaValue = true;
              }
            }
            target5.push(startChunkForTag("textarea"));
            var value13 = null;
            var defaultValue4 = null;
            var children = null;
            for (var propKey in props) {
              if (hasOwnProperty3.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "value":
                    value13 = propValue;
                    break;
                  case "defaultValue":
                    defaultValue4 = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                  default:
                    pushAttribute(target5, responseState, propKey, propValue);
                    break;
                }
              }
            }
            if (value13 === null && defaultValue4 !== null) {
              value13 = defaultValue4;
            }
            target5.push(endOfStartTag);
            if (children != null) {
              {
                error3("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
              }
              if (value13 != null) {
                throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
              }
              if (isArray6(children)) {
                if (children.length > 1) {
                  throw new Error("<textarea> can only have at most one child.");
                }
                {
                  checkHtmlStringCoercion(children[0]);
                }
                value13 = "" + children[0];
              }
              {
                checkHtmlStringCoercion(children);
              }
              value13 = "" + children;
            }
            if (typeof value13 === "string" && value13[0] === "\n") {
              target5.push(leadingNewline);
            }
            if (value13 !== null) {
              {
                checkAttributeStringCoercion(value13, "value");
              }
              target5.push(stringToChunk(encodeHTMLTextNode("" + value13)));
            }
            return null;
          }
          function pushSelfClosing(target5, props, tag, responseState) {
            target5.push(startChunkForTag(tag));
            for (var propKey in props) {
              if (hasOwnProperty3.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw new Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                  default:
                    pushAttribute(target5, responseState, propKey, propValue);
                    break;
                }
              }
            }
            target5.push(endOfStartTagSelfClosing);
            return null;
          }
          function pushStartMenuItem(target5, props, responseState) {
            target5.push(startChunkForTag("menuitem"));
            for (var propKey in props) {
              if (hasOwnProperty3.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                  default:
                    pushAttribute(target5, responseState, propKey, propValue);
                    break;
                }
              }
            }
            target5.push(endOfStartTag);
            return null;
          }
          function pushStartTitle(target5, props, responseState) {
            target5.push(startChunkForTag("title"));
            var children = null;
            for (var propKey in props) {
              if (hasOwnProperty3.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
                  default:
                    pushAttribute(target5, responseState, propKey, propValue);
                    break;
                }
              }
            }
            target5.push(endOfStartTag);
            {
              var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
              if (Array.isArray(children) && children.length > 1) {
                error3("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
              } else if (child != null && child.$$typeof != null) {
                error3("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
              } else if (child != null && typeof child !== "string" && typeof child !== "number") {
                error3("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
              }
            }
            return children;
          }
          function pushStartGenericElement(target5, props, tag, responseState) {
            target5.push(startChunkForTag(tag));
            var children = null;
            var innerHTML = null;
            for (var propKey in props) {
              if (hasOwnProperty3.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  default:
                    pushAttribute(target5, responseState, propKey, propValue);
                    break;
                }
              }
            }
            target5.push(endOfStartTag);
            pushInnerHTML(target5, innerHTML, children);
            if (typeof children === "string") {
              target5.push(stringToChunk(encodeHTMLTextNode(children)));
              return null;
            }
            return children;
          }
          function pushStartCustomElement(target5, props, tag, responseState) {
            target5.push(startChunkForTag(tag));
            var children = null;
            var innerHTML = null;
            for (var propKey in props) {
              if (hasOwnProperty3.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  case "style":
                    pushStyle(target5, responseState, propValue);
                    break;
                  case "suppressContentEditableWarning":
                  case "suppressHydrationWarning":
                    break;
                  default:
                    if (isAttributeNameSafe(propKey) && typeof propValue !== "function" && typeof propValue !== "symbol") {
                      target5.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                    }
                    break;
                }
              }
            }
            target5.push(endOfStartTag);
            pushInnerHTML(target5, innerHTML, children);
            return children;
          }
          var leadingNewline = stringToPrecomputedChunk("\n");
          function pushStartPreformattedElement(target5, props, tag, responseState) {
            target5.push(startChunkForTag(tag));
            var children = null;
            var innerHTML = null;
            for (var propKey in props) {
              if (hasOwnProperty3.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  default:
                    pushAttribute(target5, responseState, propKey, propValue);
                    break;
                }
              }
            }
            target5.push(endOfStartTag);
            if (innerHTML != null) {
              if (children != null) {
                throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              }
              if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
                throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
              }
              var html = innerHTML.__html;
              if (html !== null && html !== void 0) {
                if (typeof html === "string" && html.length > 0 && html[0] === "\n") {
                  target5.push(leadingNewline, stringToChunk(html));
                } else {
                  {
                    checkHtmlStringCoercion(html);
                  }
                  target5.push(stringToChunk("" + html));
                }
              }
            }
            if (typeof children === "string" && children[0] === "\n") {
              target5.push(leadingNewline);
            }
            return children;
          }
          var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
          var validatedTagCache = /* @__PURE__ */ new Map();
          function startChunkForTag(tag) {
            var tagStartChunk = validatedTagCache.get(tag);
            if (tagStartChunk === void 0) {
              if (!VALID_TAG_REGEX.test(tag)) {
                throw new Error("Invalid tag: " + tag);
              }
              tagStartChunk = stringToPrecomputedChunk("<" + tag);
              validatedTagCache.set(tag, tagStartChunk);
            }
            return tagStartChunk;
          }
          var DOCTYPE = stringToPrecomputedChunk("<!DOCTYPE html>");
          function pushStartInstance(target5, type, props, responseState, formatContext) {
            {
              validateProperties(type, props);
              validateProperties$1(type, props);
              validateProperties$2(type, props, null);
              if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
                error3("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
              }
              if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {
                if (type.indexOf("-") === -1 && typeof props.is !== "string" && type.toLowerCase() !== type) {
                  error3("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
                }
              }
            }
            switch (type) {
              case "select":
                return pushStartSelect(target5, props, responseState);
              case "option":
                return pushStartOption(target5, props, responseState, formatContext);
              case "textarea":
                return pushStartTextArea(target5, props, responseState);
              case "input":
                return pushInput(target5, props, responseState);
              case "menuitem":
                return pushStartMenuItem(target5, props, responseState);
              case "title":
                return pushStartTitle(target5, props, responseState);
              case "listing":
              case "pre": {
                return pushStartPreformattedElement(target5, props, type, responseState);
              }
              case "area":
              case "base":
              case "br":
              case "col":
              case "embed":
              case "hr":
              case "img":
              case "keygen":
              case "link":
              case "meta":
              case "param":
              case "source":
              case "track":
              case "wbr": {
                return pushSelfClosing(target5, props, type, responseState);
              }
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph": {
                return pushStartGenericElement(target5, props, type, responseState);
              }
              case "html": {
                if (formatContext.insertionMode === ROOT_HTML_MODE) {
                  target5.push(DOCTYPE);
                }
                return pushStartGenericElement(target5, props, type, responseState);
              }
              default: {
                if (type.indexOf("-") === -1 && typeof props.is !== "string") {
                  return pushStartGenericElement(target5, props, type, responseState);
                } else {
                  return pushStartCustomElement(target5, props, type, responseState);
                }
              }
            }
          }
          var endTag1 = stringToPrecomputedChunk("</");
          var endTag2 = stringToPrecomputedChunk(">");
          function pushEndInstance(target5, type, props) {
            switch (type) {
              case "area":
              case "base":
              case "br":
              case "col":
              case "embed":
              case "hr":
              case "img":
              case "input":
              case "keygen":
              case "link":
              case "meta":
              case "param":
              case "source":
              case "track":
              case "wbr": {
                break;
              }
              default: {
                target5.push(endTag1, stringToChunk(type), endTag2);
              }
            }
          }
          function writeCompletedRoot(destination, responseState) {
            var bootstrapChunks = responseState.bootstrapChunks;
            var i = 0;
            for (; i < bootstrapChunks.length - 1; i++) {
              writeChunk(destination, bootstrapChunks[i]);
            }
            if (i < bootstrapChunks.length) {
              return writeChunkAndReturn(destination, bootstrapChunks[i]);
            }
            return true;
          }
          var placeholder1 = stringToPrecomputedChunk('<template id="');
          var placeholder22 = stringToPrecomputedChunk('"></template>');
          function writePlaceholder(destination, responseState, id2) {
            writeChunk(destination, placeholder1);
            writeChunk(destination, responseState.placeholderPrefix);
            var formattedID = stringToChunk(id2.toString(16));
            writeChunk(destination, formattedID);
            return writeChunkAndReturn(destination, placeholder22);
          }
          var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->");
          var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
          var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
          var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->");
          var endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->");
          var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template");
          var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
          var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
          var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
          var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
          var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
          function writeStartCompletedSuspenseBoundary(destination, responseState) {
            return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
          }
          function writeStartPendingSuspenseBoundary(destination, responseState, id2) {
            writeChunk(destination, startPendingSuspenseBoundary1);
            if (id2 === null) {
              throw new Error("An ID must have been assigned before we can complete the boundary.");
            }
            writeChunk(destination, id2);
            return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
          }
          function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
            var result;
            result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
            writeChunk(destination, clientRenderedSuspenseBoundaryError1);
            if (errorDigest) {
              writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
              writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
              writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
            }
            {
              if (errorMesssage) {
                writeChunk(destination, clientRenderedSuspenseBoundaryError1B);
                writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));
                writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
              }
              if (errorComponentStack) {
                writeChunk(destination, clientRenderedSuspenseBoundaryError1C);
                writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));
                writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
              }
            }
            result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
            return result;
          }
          function writeEndCompletedSuspenseBoundary(destination, responseState) {
            return writeChunkAndReturn(destination, endSuspenseBoundary);
          }
          function writeEndPendingSuspenseBoundary(destination, responseState) {
            return writeChunkAndReturn(destination, endSuspenseBoundary);
          }
          function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
            return writeChunkAndReturn(destination, endSuspenseBoundary);
          }
          var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
          var startSegmentHTML2 = stringToPrecomputedChunk('">');
          var endSegmentHTML = stringToPrecomputedChunk("</div>");
          var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
          var startSegmentSVG2 = stringToPrecomputedChunk('">');
          var endSegmentSVG = stringToPrecomputedChunk("</svg>");
          var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
          var startSegmentMathML2 = stringToPrecomputedChunk('">');
          var endSegmentMathML = stringToPrecomputedChunk("</math>");
          var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
          var startSegmentTable2 = stringToPrecomputedChunk('">');
          var endSegmentTable = stringToPrecomputedChunk("</table>");
          var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
          var startSegmentTableBody2 = stringToPrecomputedChunk('">');
          var endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>");
          var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
          var startSegmentTableRow2 = stringToPrecomputedChunk('">');
          var endSegmentTableRow = stringToPrecomputedChunk("</tr></table>");
          var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
          var startSegmentColGroup2 = stringToPrecomputedChunk('">');
          var endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
          function writeStartSegment(destination, responseState, formatContext, id2) {
            switch (formatContext.insertionMode) {
              case ROOT_HTML_MODE:
              case HTML_MODE: {
                writeChunk(destination, startSegmentHTML);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id2.toString(16)));
                return writeChunkAndReturn(destination, startSegmentHTML2);
              }
              case SVG_MODE: {
                writeChunk(destination, startSegmentSVG);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id2.toString(16)));
                return writeChunkAndReturn(destination, startSegmentSVG2);
              }
              case MATHML_MODE: {
                writeChunk(destination, startSegmentMathML);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id2.toString(16)));
                return writeChunkAndReturn(destination, startSegmentMathML2);
              }
              case HTML_TABLE_MODE: {
                writeChunk(destination, startSegmentTable);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id2.toString(16)));
                return writeChunkAndReturn(destination, startSegmentTable2);
              }
              case HTML_TABLE_BODY_MODE: {
                writeChunk(destination, startSegmentTableBody);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id2.toString(16)));
                return writeChunkAndReturn(destination, startSegmentTableBody2);
              }
              case HTML_TABLE_ROW_MODE: {
                writeChunk(destination, startSegmentTableRow);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id2.toString(16)));
                return writeChunkAndReturn(destination, startSegmentTableRow2);
              }
              case HTML_COLGROUP_MODE: {
                writeChunk(destination, startSegmentColGroup);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id2.toString(16)));
                return writeChunkAndReturn(destination, startSegmentColGroup2);
              }
              default: {
                throw new Error("Unknown insertion mode. This is a bug in React.");
              }
            }
          }
          function writeEndSegment(destination, formatContext) {
            switch (formatContext.insertionMode) {
              case ROOT_HTML_MODE:
              case HTML_MODE: {
                return writeChunkAndReturn(destination, endSegmentHTML);
              }
              case SVG_MODE: {
                return writeChunkAndReturn(destination, endSegmentSVG);
              }
              case MATHML_MODE: {
                return writeChunkAndReturn(destination, endSegmentMathML);
              }
              case HTML_TABLE_MODE: {
                return writeChunkAndReturn(destination, endSegmentTable);
              }
              case HTML_TABLE_BODY_MODE: {
                return writeChunkAndReturn(destination, endSegmentTableBody);
              }
              case HTML_TABLE_ROW_MODE: {
                return writeChunkAndReturn(destination, endSegmentTableRow);
              }
              case HTML_COLGROUP_MODE: {
                return writeChunkAndReturn(destination, endSegmentColGroup);
              }
              default: {
                throw new Error("Unknown insertion mode. This is a bug in React.");
              }
            }
          }
          var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}";
          var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
          var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
          var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
          var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
          var completeSegmentScript2 = stringToPrecomputedChunk('","');
          var completeSegmentScript3 = stringToPrecomputedChunk('")<\/script>');
          function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
            writeChunk(destination, responseState.startInlineScript);
            if (!responseState.sentCompleteSegmentFunction) {
              responseState.sentCompleteSegmentFunction = true;
              writeChunk(destination, completeSegmentScript1Full);
            } else {
              writeChunk(destination, completeSegmentScript1Partial);
            }
            writeChunk(destination, responseState.segmentPrefix);
            var formattedID = stringToChunk(contentSegmentID.toString(16));
            writeChunk(destination, formattedID);
            writeChunk(destination, completeSegmentScript2);
            writeChunk(destination, responseState.placeholderPrefix);
            writeChunk(destination, formattedID);
            return writeChunkAndReturn(destination, completeSegmentScript3);
          }
          var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
          var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
          var completeBoundaryScript2 = stringToPrecomputedChunk('","');
          var completeBoundaryScript3 = stringToPrecomputedChunk('")<\/script>');
          function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
            writeChunk(destination, responseState.startInlineScript);
            if (!responseState.sentCompleteBoundaryFunction) {
              responseState.sentCompleteBoundaryFunction = true;
              writeChunk(destination, completeBoundaryScript1Full);
            } else {
              writeChunk(destination, completeBoundaryScript1Partial);
            }
            if (boundaryID === null) {
              throw new Error("An ID must have been assigned before we can complete the boundary.");
            }
            var formattedContentID = stringToChunk(contentSegmentID.toString(16));
            writeChunk(destination, boundaryID);
            writeChunk(destination, completeBoundaryScript2);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, formattedContentID);
            return writeChunkAndReturn(destination, completeBoundaryScript3);
          }
          var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
          var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
          var clientRenderScript1A = stringToPrecomputedChunk('"');
          var clientRenderScript2 = stringToPrecomputedChunk(")<\/script>");
          var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
          function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
            writeChunk(destination, responseState.startInlineScript);
            if (!responseState.sentClientRenderFunction) {
              responseState.sentClientRenderFunction = true;
              writeChunk(destination, clientRenderScript1Full);
            } else {
              writeChunk(destination, clientRenderScript1Partial);
            }
            if (boundaryID === null) {
              throw new Error("An ID must have been assigned before we can complete the boundary.");
            }
            writeChunk(destination, boundaryID);
            writeChunk(destination, clientRenderScript1A);
            if (errorDigest || errorMessage || errorComponentStack) {
              writeChunk(destination, clientRenderErrorScriptArgInterstitial);
              writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || "")));
            }
            if (errorMessage || errorComponentStack) {
              writeChunk(destination, clientRenderErrorScriptArgInterstitial);
              writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || "")));
            }
            if (errorComponentStack) {
              writeChunk(destination, clientRenderErrorScriptArgInterstitial);
              writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));
            }
            return writeChunkAndReturn(destination, clientRenderScript2);
          }
          var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
          function escapeJSStringsForInstructionScripts(input) {
            var escaped = JSON.stringify(input);
            return escaped.replace(regexForJSStringsInScripts, function(match) {
              switch (match) {
                case "<":
                  return "\\u003c";
                case "\u2028":
                  return "\\u2028";
                case "\u2029":
                  return "\\u2029";
                default: {
                  throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
                }
              }
            });
          }
          function createResponseState$1(generateStaticMarkup, identifierPrefix) {
            var responseState = createResponseState(identifierPrefix, void 0);
            return {
              bootstrapChunks: responseState.bootstrapChunks,
              startInlineScript: responseState.startInlineScript,
              placeholderPrefix: responseState.placeholderPrefix,
              segmentPrefix: responseState.segmentPrefix,
              boundaryPrefix: responseState.boundaryPrefix,
              idPrefix: responseState.idPrefix,
              nextSuspenseID: responseState.nextSuspenseID,
              sentCompleteSegmentFunction: responseState.sentCompleteSegmentFunction,
              sentCompleteBoundaryFunction: responseState.sentCompleteBoundaryFunction,
              sentClientRenderFunction: responseState.sentClientRenderFunction,
              generateStaticMarkup
            };
          }
          function createRootFormatContext() {
            return {
              insertionMode: HTML_MODE,
              selectedValue: null
            };
          }
          function pushTextInstance$1(target5, text5, responseState, textEmbedded) {
            if (responseState.generateStaticMarkup) {
              target5.push(stringToChunk(escapeTextForBrowser(text5)));
              return false;
            } else {
              return pushTextInstance(target5, text5, responseState, textEmbedded);
            }
          }
          function pushSegmentFinale$1(target5, responseState, lastPushedText, textEmbedded) {
            if (responseState.generateStaticMarkup) {
              return;
            } else {
              return pushSegmentFinale(target5, responseState, lastPushedText, textEmbedded);
            }
          }
          function writeStartCompletedSuspenseBoundary$1(destination, responseState) {
            if (responseState.generateStaticMarkup) {
              return true;
            }
            return writeStartCompletedSuspenseBoundary(destination);
          }
          function writeStartClientRenderedSuspenseBoundary$1(destination, responseState, errorDigest, errorMessage, errorComponentStack) {
            if (responseState.generateStaticMarkup) {
              return true;
            }
            return writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMessage, errorComponentStack);
          }
          function writeEndCompletedSuspenseBoundary$1(destination, responseState) {
            if (responseState.generateStaticMarkup) {
              return true;
            }
            return writeEndCompletedSuspenseBoundary(destination);
          }
          function writeEndClientRenderedSuspenseBoundary$1(destination, responseState) {
            if (responseState.generateStaticMarkup) {
              return true;
            }
            return writeEndClientRenderedSuspenseBoundary(destination);
          }
          var assign2 = Object.assign;
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_SCOPE_TYPE = Symbol.for("react.scope");
          var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
          var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
          var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error3("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init3 = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init3(payload));
                  } catch (x) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign2({}, props, {
                    value: prevLog
                  }),
                  info: assign2({}, props, {
                    value: prevInfo
                  }),
                  warn: assign2({}, props, {
                    value: prevWarn
                  }),
                  error: assign2({}, props, {
                    value: prevError
                  }),
                  group: assign2({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign2({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign2({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error3("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name16, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x) {
                  var match = x.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name16;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x) {
                    control = x;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x) {
                  control = x;
                }
                fn();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                  c--;
                }
                for (; s >= 1 && c >= 0; s--, c--) {
                  if (sampleLines[s] !== controlLines[c]) {
                    if (s !== 1 || c !== 1) {
                      do {
                        s--;
                        c--;
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                          var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                          if (fn.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn.displayName);
                          }
                          {
                            if (typeof fn === "function") {
                              componentFrameCache.set(fn, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s >= 1 && c >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name16 = fn ? fn.displayName || fn.name : "";
            var syntheticFrame = name16 ? describeBuiltInComponentFrame(name16) : "";
            {
              if (typeof fn === "function") {
                componentFrameCache.set(fn, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeClassComponentFrame(ctor, source, ownerFn) {
            {
              return describeNativeComponentFrame(ctor, true);
            }
          }
          function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn, false);
            }
          }
          function shouldConstruct(Component2) {
            var prototype = Component2.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init3 = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init3(payload), source, ownerFn);
                  } catch (x) {
                  }
                }
              }
            }
            return "";
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes3(typeSpecs, values2, location2, componentName, element) {
            {
              var has = Function.call.bind(hasOwnProperty3);
              for (var typeSpecName in typeSpecs) {
                if (has(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error3("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error3("Failed %s type: %s", location2, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          var warnedAboutMissingGetChildContext;
          {
            warnedAboutMissingGetChildContext = {};
          }
          var emptyContextObject = {};
          {
            Object.freeze(emptyContextObject);
          }
          function getMaskedContext(type, unmaskedContext) {
            {
              var contextTypes = type.contextTypes;
              if (!contextTypes) {
                return emptyContextObject;
              }
              var context = {};
              for (var key in contextTypes) {
                context[key] = unmaskedContext[key];
              }
              {
                var name16 = getComponentNameFromType(type) || "Unknown";
                checkPropTypes3(contextTypes, context, "context", name16);
              }
              return context;
            }
          }
          function processChildContext(instance, type, parentContext, childContextTypes) {
            {
              if (typeof instance.getChildContext !== "function") {
                {
                  var componentName = getComponentNameFromType(type) || "Unknown";
                  if (!warnedAboutMissingGetChildContext[componentName]) {
                    warnedAboutMissingGetChildContext[componentName] = true;
                    error3("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                  }
                }
                return parentContext;
              }
              var childContext = instance.getChildContext();
              for (var contextKey in childContext) {
                if (!(contextKey in childContextTypes)) {
                  throw new Error((getComponentNameFromType(type) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
                }
              }
              {
                var name16 = getComponentNameFromType(type) || "Unknown";
                checkPropTypes3(childContextTypes, childContext, "child context", name16);
              }
              return assign2({}, parentContext, childContext);
            }
          }
          var rendererSigil;
          {
            rendererSigil = {};
          }
          var rootContextSnapshot = null;
          var currentActiveSnapshot = null;
          function popNode(prev) {
            {
              prev.context._currentValue2 = prev.parentValue;
            }
          }
          function pushNode(next) {
            {
              next.context._currentValue2 = next.value;
            }
          }
          function popToNearestCommonAncestor(prev, next) {
            if (prev === next)
              ;
            else {
              popNode(prev);
              var parentPrev = prev.parent;
              var parentNext = next.parent;
              if (parentPrev === null) {
                if (parentNext !== null) {
                  throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
                }
              } else {
                if (parentNext === null) {
                  throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
                }
                popToNearestCommonAncestor(parentPrev, parentNext);
              }
              pushNode(next);
            }
          }
          function popAllPrevious(prev) {
            popNode(prev);
            var parentPrev = prev.parent;
            if (parentPrev !== null) {
              popAllPrevious(parentPrev);
            }
          }
          function pushAllNext(next) {
            var parentNext = next.parent;
            if (parentNext !== null) {
              pushAllNext(parentNext);
            }
            pushNode(next);
          }
          function popPreviousToCommonLevel(prev, next) {
            popNode(prev);
            var parentPrev = prev.parent;
            if (parentPrev === null) {
              throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
            }
            if (parentPrev.depth === next.depth) {
              popToNearestCommonAncestor(parentPrev, next);
            } else {
              popPreviousToCommonLevel(parentPrev, next);
            }
          }
          function popNextToCommonLevel(prev, next) {
            var parentNext = next.parent;
            if (parentNext === null) {
              throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
            }
            if (prev.depth === parentNext.depth) {
              popToNearestCommonAncestor(prev, parentNext);
            } else {
              popNextToCommonLevel(prev, parentNext);
            }
            pushNode(next);
          }
          function switchContext(newSnapshot) {
            var prev = currentActiveSnapshot;
            var next = newSnapshot;
            if (prev !== next) {
              if (prev === null) {
                pushAllNext(next);
              } else if (next === null) {
                popAllPrevious(prev);
              } else if (prev.depth === next.depth) {
                popToNearestCommonAncestor(prev, next);
              } else if (prev.depth > next.depth) {
                popPreviousToCommonLevel(prev, next);
              } else {
                popNextToCommonLevel(prev, next);
              }
              currentActiveSnapshot = next;
            }
          }
          function pushProvider(context, nextValue) {
            var prevValue;
            {
              prevValue = context._currentValue2;
              context._currentValue2 = nextValue;
              {
                if (context._currentRenderer2 !== void 0 && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {
                  error3("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
                }
                context._currentRenderer2 = rendererSigil;
              }
            }
            var prevNode = currentActiveSnapshot;
            var newNode = {
              parent: prevNode,
              depth: prevNode === null ? 0 : prevNode.depth + 1,
              context,
              parentValue: prevValue,
              value: nextValue
            };
            currentActiveSnapshot = newNode;
            return newNode;
          }
          function popProvider(context) {
            var prevSnapshot = currentActiveSnapshot;
            if (prevSnapshot === null) {
              throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
            }
            {
              if (prevSnapshot.context !== context) {
                error3("The parent context is not the expected context. This is probably a bug in React.");
              }
            }
            {
              var _value = prevSnapshot.parentValue;
              if (_value === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
                prevSnapshot.context._currentValue2 = prevSnapshot.context._defaultValue;
              } else {
                prevSnapshot.context._currentValue2 = _value;
              }
              {
                if (context._currentRenderer2 !== void 0 && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {
                  error3("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
                }
                context._currentRenderer2 = rendererSigil;
              }
            }
            return currentActiveSnapshot = prevSnapshot.parent;
          }
          function getActiveContext() {
            return currentActiveSnapshot;
          }
          function readContext(context) {
            var value13 = context._currentValue2;
            return value13;
          }
          function get3(key) {
            return key._reactInternals;
          }
          function set(key, value13) {
            key._reactInternals = value13;
          }
          var didWarnAboutNoopUpdateForComponent = {};
          var didWarnAboutDeprecatedWillMount = {};
          var didWarnAboutUninitializedState;
          var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
          var didWarnAboutLegacyLifecyclesAndDerivedState;
          var didWarnAboutUndefinedDerivedState;
          var warnOnUndefinedDerivedState;
          var warnOnInvalidCallback;
          var didWarnAboutDirectlyAssigningPropsToState;
          var didWarnAboutContextTypeAndContextTypes;
          var didWarnAboutInvalidateContextType;
          {
            didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
            didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
            didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
            didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
            var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
            warnOnInvalidCallback = function(callback, callerName) {
              if (callback === null || typeof callback === "function") {
                return;
              }
              var key = callerName + "_" + callback;
              if (!didWarnOnInvalidCallback.has(key)) {
                didWarnOnInvalidCallback.add(key);
                error3("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            };
            warnOnUndefinedDerivedState = function(type, partialState) {
              if (partialState === void 0) {
                var componentName = getComponentNameFromType(type) || "Component";
                if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                  didWarnAboutUndefinedDerivedState.add(componentName);
                  error3("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
                }
              }
            };
          }
          function warnNoop(publicInstance, callerName) {
            {
              var _constructor = publicInstance.constructor;
              var componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass";
              var warningKey = componentName + "." + callerName;
              if (didWarnAboutNoopUpdateForComponent[warningKey]) {
                return;
              }
              error3("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
              didWarnAboutNoopUpdateForComponent[warningKey] = true;
            }
          }
          var classComponentUpdater = {
            isMounted: function(inst) {
              return false;
            },
            enqueueSetState: function(inst, payload, callback) {
              var internals = get3(inst);
              if (internals.queue === null) {
                warnNoop(inst, "setState");
              } else {
                internals.queue.push(payload);
                {
                  if (callback !== void 0 && callback !== null) {
                    warnOnInvalidCallback(callback, "setState");
                  }
                }
              }
            },
            enqueueReplaceState: function(inst, payload, callback) {
              var internals = get3(inst);
              internals.replace = true;
              internals.queue = [payload];
              {
                if (callback !== void 0 && callback !== null) {
                  warnOnInvalidCallback(callback, "setState");
                }
              }
            },
            enqueueForceUpdate: function(inst, callback) {
              var internals = get3(inst);
              if (internals.queue === null) {
                warnNoop(inst, "forceUpdate");
              } else {
                {
                  if (callback !== void 0 && callback !== null) {
                    warnOnInvalidCallback(callback, "setState");
                  }
                }
              }
            }
          };
          function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
            var partialState = getDerivedStateFromProps(nextProps, prevState);
            {
              warnOnUndefinedDerivedState(ctor, partialState);
            }
            var newState = partialState === null || partialState === void 0 ? prevState : assign2({}, prevState, partialState);
            return newState;
          }
          function constructClassInstance(ctor, props, maskedLegacyContext) {
            var context = emptyContextObject;
            var contextType = ctor.contextType;
            {
              if ("contextType" in ctor) {
                var isValid3 = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
                if (!isValid3 && !didWarnAboutInvalidateContextType.has(ctor)) {
                  didWarnAboutInvalidateContextType.add(ctor);
                  var addendum = "";
                  if (contextType === void 0) {
                    addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                  } else if (typeof contextType !== "object") {
                    addendum = " However, it is set to a " + typeof contextType + ".";
                  } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                    addendum = " Did you accidentally pass the Context.Provider instead?";
                  } else if (contextType._context !== void 0) {
                    addendum = " Did you accidentally pass the Context.Consumer instead?";
                  } else {
                    addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                  }
                  error3("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
                }
              }
            }
            if (typeof contextType === "object" && contextType !== null) {
              context = readContext(contextType);
            } else {
              context = maskedLegacyContext;
            }
            var instance = new ctor(props, context);
            {
              if (typeof ctor.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === void 0)) {
                var componentName = getComponentNameFromType(ctor) || "Component";
                if (!didWarnAboutUninitializedState.has(componentName)) {
                  didWarnAboutUninitializedState.add(componentName);
                  error3("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
                }
              }
              if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
                var foundWillMountName = null;
                var foundWillReceivePropsName = null;
                var foundWillUpdateName = null;
                if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                  foundWillMountName = "componentWillMount";
                } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                  foundWillMountName = "UNSAFE_componentWillMount";
                }
                if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                  foundWillReceivePropsName = "componentWillReceiveProps";
                } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                  foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
                }
                if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                  foundWillUpdateName = "componentWillUpdate";
                } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  foundWillUpdateName = "UNSAFE_componentWillUpdate";
                }
                if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                  var _componentName = getComponentNameFromType(ctor) || "Component";
                  var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                  if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                    didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                    error3("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                  }
                }
              }
            }
            return instance;
          }
          function checkClassInstance(instance, ctor, newProps) {
            {
              var name16 = getComponentNameFromType(ctor) || "Component";
              var renderPresent = instance.render;
              if (!renderPresent) {
                if (ctor.prototype && typeof ctor.prototype.render === "function") {
                  error3("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name16);
                } else {
                  error3("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name16);
                }
              }
              if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
                error3("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name16);
              }
              if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
                error3("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name16);
              }
              if (instance.propTypes) {
                error3("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name16);
              }
              if (instance.contextType) {
                error3("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name16);
              }
              {
                if (instance.contextTypes) {
                  error3("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name16);
                }
                if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                  didWarnAboutContextTypeAndContextTypes.add(ctor);
                  error3("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name16);
                }
              }
              if (typeof instance.componentShouldUpdate === "function") {
                error3("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name16);
              }
              if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
                error3("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
              }
              if (typeof instance.componentDidUnmount === "function") {
                error3("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name16);
              }
              if (typeof instance.componentDidReceiveProps === "function") {
                error3("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name16);
              }
              if (typeof instance.componentWillRecieveProps === "function") {
                error3("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name16);
              }
              if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
                error3("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name16);
              }
              var hasMutatedProps = instance.props !== newProps;
              if (instance.props !== void 0 && hasMutatedProps) {
                error3("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name16, name16);
              }
              if (instance.defaultProps) {
                error3("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name16, name16);
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
                didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
                error3("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
              }
              if (typeof instance.getDerivedStateFromProps === "function") {
                error3("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name16);
              }
              if (typeof instance.getDerivedStateFromError === "function") {
                error3("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name16);
              }
              if (typeof ctor.getSnapshotBeforeUpdate === "function") {
                error3("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name16);
              }
              var _state = instance.state;
              if (_state && (typeof _state !== "object" || isArray6(_state))) {
                error3("%s.state: must be set to an object or null", name16);
              }
              if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
                error3("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name16);
              }
            }
          }
          function callComponentWillMount(type, instance) {
            var oldState = instance.state;
            if (typeof instance.componentWillMount === "function") {
              {
                if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
                  var componentName = getComponentNameFromType(type) || "Unknown";
                  if (!didWarnAboutDeprecatedWillMount[componentName]) {
                    warn(
                      "componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s",
                      componentName
                    );
                    didWarnAboutDeprecatedWillMount[componentName] = true;
                  }
                }
              }
              instance.componentWillMount();
            }
            if (typeof instance.UNSAFE_componentWillMount === "function") {
              instance.UNSAFE_componentWillMount();
            }
            if (oldState !== instance.state) {
              {
                error3("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type) || "Component");
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
            if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
              var oldQueue = internalInstance.queue;
              var oldReplace = internalInstance.replace;
              internalInstance.queue = null;
              internalInstance.replace = false;
              if (oldReplace && oldQueue.length === 1) {
                inst.state = oldQueue[0];
              } else {
                var nextState = oldReplace ? oldQueue[0] : inst.state;
                var dontMutate = true;
                for (var i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {
                  var partial = oldQueue[i];
                  var partialState = typeof partial === "function" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;
                  if (partialState != null) {
                    if (dontMutate) {
                      dontMutate = false;
                      nextState = assign2({}, nextState, partialState);
                    } else {
                      assign2(nextState, partialState);
                    }
                  }
                }
                inst.state = nextState;
              }
            } else {
              internalInstance.queue = null;
            }
          }
          function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
            {
              checkClassInstance(instance, ctor, newProps);
            }
            var initialState = instance.state !== void 0 ? instance.state : null;
            instance.updater = classComponentUpdater;
            instance.props = newProps;
            instance.state = initialState;
            var internalInstance = {
              queue: [],
              replace: false
            };
            set(instance, internalInstance);
            var contextType = ctor.contextType;
            if (typeof contextType === "object" && contextType !== null) {
              instance.context = readContext(contextType);
            } else {
              instance.context = maskedLegacyContext;
            }
            {
              if (instance.state === newProps) {
                var componentName = getComponentNameFromType(ctor) || "Component";
                if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                  didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                  error3("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
                }
              }
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            if (typeof getDerivedStateFromProps === "function") {
              instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);
            }
            if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
              callComponentWillMount(ctor, instance);
              processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);
            }
          }
          var emptyTreeContext = {
            id: 1,
            overflow: ""
          };
          function getTreeId(context) {
            var overflow = context.overflow;
            var idWithLeadingBit = context.id;
            var id2 = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
            return id2.toString(32) + overflow;
          }
          function pushTreeContext(baseContext, totalChildren, index5) {
            var baseIdWithLeadingBit = baseContext.id;
            var baseOverflow = baseContext.overflow;
            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
            var slot = index5 + 1;
            var length7 = getBitLength(totalChildren) + baseLength;
            if (length7 > 30) {
              var numberOfOverflowBits = baseLength - baseLength % 5;
              var newOverflowBits = (1 << numberOfOverflowBits) - 1;
              var newOverflow = (baseId & newOverflowBits).toString(32);
              var restOfBaseId = baseId >> numberOfOverflowBits;
              var restOfBaseLength = baseLength - numberOfOverflowBits;
              var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
              var restOfNewBits = slot << restOfBaseLength;
              var id2 = restOfNewBits | restOfBaseId;
              var overflow = newOverflow + baseOverflow;
              return {
                id: 1 << restOfLength | id2,
                overflow
              };
            } else {
              var newBits = slot << baseLength;
              var _id = newBits | baseId;
              var _overflow = baseOverflow;
              return {
                id: 1 << length7 | _id,
                overflow: _overflow
              };
            }
          }
          function getBitLength(number8) {
            return 32 - clz32(number8);
          }
          function getLeadingBit(id2) {
            return 1 << getBitLength(id2) - 1;
          }
          var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
          var log5 = Math.log;
          var LN2 = Math.LN2;
          function clz32Fallback(x) {
            var asUint = x >>> 0;
            if (asUint === 0) {
              return 32;
            }
            return 31 - (log5(asUint) / LN2 | 0) | 0;
          }
          function is(x, y) {
            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is;
          var currentlyRenderingComponent = null;
          var currentlyRenderingTask = null;
          var firstWorkInProgressHook = null;
          var workInProgressHook = null;
          var isReRender = false;
          var didScheduleRenderPhaseUpdate = false;
          var localIdCounter = 0;
          var renderPhaseUpdates = null;
          var numberOfReRenders = 0;
          var RE_RENDER_LIMIT = 25;
          var isInHookUserCodeInDev = false;
          var currentHookNameInDev;
          function resolveCurrentlyRenderingComponent() {
            if (currentlyRenderingComponent === null) {
              throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
            {
              if (isInHookUserCodeInDev) {
                error3("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
              }
            }
            return currentlyRenderingComponent;
          }
          function areHookInputsEqual(nextDeps, prevDeps) {
            if (prevDeps === null) {
              {
                error3("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
              }
              return false;
            }
            {
              if (nextDeps.length !== prevDeps.length) {
                error3("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
              }
            }
            for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
              if (objectIs(nextDeps[i], prevDeps[i])) {
                continue;
              }
              return false;
            }
            return true;
          }
          function createHook() {
            if (numberOfReRenders > 0) {
              throw new Error("Rendered more hooks than during the previous render");
            }
            return {
              memoizedState: null,
              queue: null,
              next: null
            };
          }
          function createWorkInProgressHook() {
            if (workInProgressHook === null) {
              if (firstWorkInProgressHook === null) {
                isReRender = false;
                firstWorkInProgressHook = workInProgressHook = createHook();
              } else {
                isReRender = true;
                workInProgressHook = firstWorkInProgressHook;
              }
            } else {
              if (workInProgressHook.next === null) {
                isReRender = false;
                workInProgressHook = workInProgressHook.next = createHook();
              } else {
                isReRender = true;
                workInProgressHook = workInProgressHook.next;
              }
            }
            return workInProgressHook;
          }
          function prepareToUseHooks(task, componentIdentity) {
            currentlyRenderingComponent = componentIdentity;
            currentlyRenderingTask = task;
            {
              isInHookUserCodeInDev = false;
            }
            localIdCounter = 0;
          }
          function finishHooks(Component2, props, children, refOrContext) {
            while (didScheduleRenderPhaseUpdate) {
              didScheduleRenderPhaseUpdate = false;
              localIdCounter = 0;
              numberOfReRenders += 1;
              workInProgressHook = null;
              children = Component2(props, refOrContext);
            }
            resetHooksState();
            return children;
          }
          function checkDidRenderIdHook() {
            var didRenderIdHook = localIdCounter !== 0;
            return didRenderIdHook;
          }
          function resetHooksState() {
            {
              isInHookUserCodeInDev = false;
            }
            currentlyRenderingComponent = null;
            currentlyRenderingTask = null;
            didScheduleRenderPhaseUpdate = false;
            firstWorkInProgressHook = null;
            numberOfReRenders = 0;
            renderPhaseUpdates = null;
            workInProgressHook = null;
          }
          function readContext$1(context) {
            {
              if (isInHookUserCodeInDev) {
                error3("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
              }
            }
            return readContext(context);
          }
          function useContext7(context) {
            {
              currentHookNameInDev = "useContext";
            }
            resolveCurrentlyRenderingComponent();
            return readContext(context);
          }
          function basicStateReducer(state3, action2) {
            return typeof action2 === "function" ? action2(state3) : action2;
          }
          function useState13(initialState) {
            {
              currentHookNameInDev = "useState";
            }
            return useReducer(
              basicStateReducer,
              initialState
            );
          }
          function useReducer(reducer, initialArg, init3) {
            {
              if (reducer !== basicStateReducer) {
                currentHookNameInDev = "useReducer";
              }
            }
            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
            workInProgressHook = createWorkInProgressHook();
            if (isReRender) {
              var queue = workInProgressHook.queue;
              var dispatch = queue.dispatch;
              if (renderPhaseUpdates !== null) {
                var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
                if (firstRenderPhaseUpdate !== void 0) {
                  renderPhaseUpdates.delete(queue);
                  var newState = workInProgressHook.memoizedState;
                  var update = firstRenderPhaseUpdate;
                  do {
                    var action2 = update.action;
                    {
                      isInHookUserCodeInDev = true;
                    }
                    newState = reducer(newState, action2);
                    {
                      isInHookUserCodeInDev = false;
                    }
                    update = update.next;
                  } while (update !== null);
                  workInProgressHook.memoizedState = newState;
                  return [newState, dispatch];
                }
              }
              return [workInProgressHook.memoizedState, dispatch];
            } else {
              {
                isInHookUserCodeInDev = true;
              }
              var initialState;
              if (reducer === basicStateReducer) {
                initialState = typeof initialArg === "function" ? initialArg() : initialArg;
              } else {
                initialState = init3 !== void 0 ? init3(initialArg) : initialArg;
              }
              {
                isInHookUserCodeInDev = false;
              }
              workInProgressHook.memoizedState = initialState;
              var _queue = workInProgressHook.queue = {
                last: null,
                dispatch: null
              };
              var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
              return [workInProgressHook.memoizedState, _dispatch];
            }
          }
          function useMemo11(nextCreate, deps) {
            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
            workInProgressHook = createWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            if (workInProgressHook !== null) {
              var prevState = workInProgressHook.memoizedState;
              if (prevState !== null) {
                if (nextDeps !== null) {
                  var prevDeps = prevState[1];
                  if (areHookInputsEqual(nextDeps, prevDeps)) {
                    return prevState[0];
                  }
                }
              }
            }
            {
              isInHookUserCodeInDev = true;
            }
            var nextValue = nextCreate();
            {
              isInHookUserCodeInDev = false;
            }
            workInProgressHook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function useRef10(initialValue) {
            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
            workInProgressHook = createWorkInProgressHook();
            var previousRef = workInProgressHook.memoizedState;
            if (previousRef === null) {
              var ref = {
                current: initialValue
              };
              {
                Object.seal(ref);
              }
              workInProgressHook.memoizedState = ref;
              return ref;
            } else {
              return previousRef;
            }
          }
          function useLayoutEffect3(create6, inputs) {
            {
              currentHookNameInDev = "useLayoutEffect";
              error3("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
            }
          }
          function dispatchAction(componentIdentity, queue, action2) {
            if (numberOfReRenders >= RE_RENDER_LIMIT) {
              throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
            }
            if (componentIdentity === currentlyRenderingComponent) {
              didScheduleRenderPhaseUpdate = true;
              var update = {
                action: action2,
                next: null
              };
              if (renderPhaseUpdates === null) {
                renderPhaseUpdates = /* @__PURE__ */ new Map();
              }
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
              if (firstRenderPhaseUpdate === void 0) {
                renderPhaseUpdates.set(queue, update);
              } else {
                var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
                while (lastRenderPhaseUpdate.next !== null) {
                  lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
                }
                lastRenderPhaseUpdate.next = update;
              }
            }
          }
          function useCallback5(callback, deps) {
            return useMemo11(function() {
              return callback;
            }, deps);
          }
          function useMutableSource(source, getSnapshot, subscribe) {
            resolveCurrentlyRenderingComponent();
            return getSnapshot(source._source);
          }
          function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            if (getServerSnapshot === void 0) {
              throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
            }
            return getServerSnapshot();
          }
          function useDeferredValue(value13) {
            resolveCurrentlyRenderingComponent();
            return value13;
          }
          function unsupportedStartTransition() {
            throw new Error("startTransition cannot be called during server rendering.");
          }
          function useTransition() {
            resolveCurrentlyRenderingComponent();
            return [false, unsupportedStartTransition];
          }
          function useId() {
            var task = currentlyRenderingTask;
            var treeId = getTreeId(task.treeContext);
            var responseState = currentResponseState;
            if (responseState === null) {
              throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
            }
            var localId = localIdCounter++;
            return makeId(responseState, treeId, localId);
          }
          function noop13() {
          }
          var Dispatcher = {
            readContext: readContext$1,
            useContext: useContext7,
            useMemo: useMemo11,
            useReducer,
            useRef: useRef10,
            useState: useState13,
            useInsertionEffect: noop13,
            useLayoutEffect: useLayoutEffect3,
            useCallback: useCallback5,
            useImperativeHandle: noop13,
            useEffect: noop13,
            useDebugValue: noop13,
            useDeferredValue,
            useTransition,
            useId,
            useMutableSource,
            useSyncExternalStore
          };
          var currentResponseState = null;
          function setCurrentResponseState(responseState) {
            currentResponseState = responseState;
          }
          function getStackByComponentStackNode(componentStack) {
            try {
              var info = "";
              var node = componentStack;
              do {
                switch (node.tag) {
                  case 0:
                    info += describeBuiltInComponentFrame(node.type, null, null);
                    break;
                  case 1:
                    info += describeFunctionComponentFrame(node.type, null, null);
                    break;
                  case 2:
                    info += describeClassComponentFrame(node.type, null, null);
                    break;
                }
                node = node.parent;
              } while (node);
              return info;
            } catch (x) {
              return "\nError generating stack: " + x.message + "\n" + x.stack;
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          var PENDING = 0;
          var COMPLETED = 1;
          var FLUSHED = 2;
          var ABORTED = 3;
          var ERRORED = 4;
          var OPEN = 0;
          var CLOSING = 1;
          var CLOSED = 2;
          var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
          function defaultErrorHandler(error4) {
            console["error"](error4);
            return null;
          }
          function noop$1() {
          }
          function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError2, onAllReady, onShellReady, onShellError, onFatalError) {
            var pingedTasks = [];
            var abortSet = /* @__PURE__ */ new Set();
            var request2 = {
              destination: null,
              responseState,
              progressiveChunkSize: progressiveChunkSize === void 0 ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
              status: OPEN,
              fatalError: null,
              nextSegmentId: 0,
              allPendingTasks: 0,
              pendingRootTasks: 0,
              completedRootSegment: null,
              abortableTasks: abortSet,
              pingedTasks,
              clientRenderedBoundaries: [],
              completedBoundaries: [],
              partialBoundaries: [],
              onError: onError2 === void 0 ? defaultErrorHandler : onError2,
              onAllReady: onAllReady === void 0 ? noop$1 : onAllReady,
              onShellReady: onShellReady === void 0 ? noop$1 : onShellReady,
              onShellError: onShellError === void 0 ? noop$1 : onShellError,
              onFatalError: onFatalError === void 0 ? noop$1 : onFatalError
            };
            var rootSegment = createPendingSegment(
              request2,
              0,
              null,
              rootFormatContext,
              false,
              false
            );
            rootSegment.parentFlushed = true;
            var rootTask = createTask(request2, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
            pingedTasks.push(rootTask);
            return request2;
          }
          function pingTask(request2, task) {
            var pingedTasks = request2.pingedTasks;
            pingedTasks.push(task);
            if (pingedTasks.length === 1) {
              scheduleWork(function() {
                return performWork(request2);
              });
            }
          }
          function createSuspenseBoundary(request2, fallbackAbortableTasks) {
            return {
              id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
              rootSegmentID: -1,
              parentFlushed: false,
              pendingTasks: 0,
              forceClientRender: false,
              completedSegments: [],
              byteSize: 0,
              fallbackAbortableTasks,
              errorDigest: null
            };
          }
          function createTask(request2, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {
            request2.allPendingTasks++;
            if (blockedBoundary === null) {
              request2.pendingRootTasks++;
            } else {
              blockedBoundary.pendingTasks++;
            }
            var task = {
              node,
              ping: function() {
                return pingTask(request2, task);
              },
              blockedBoundary,
              blockedSegment,
              abortSet,
              legacyContext,
              context,
              treeContext
            };
            {
              task.componentStack = null;
            }
            abortSet.add(task);
            return task;
          }
          function createPendingSegment(request2, index5, boundary, formatContext, lastPushedText, textEmbedded) {
            return {
              status: PENDING,
              id: -1,
              index: index5,
              parentFlushed: false,
              chunks: [],
              children: [],
              formatContext,
              boundary,
              lastPushedText,
              textEmbedded
            };
          }
          var currentTaskInDEV = null;
          function getCurrentStackInDEV() {
            {
              if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {
                return "";
              }
              return getStackByComponentStackNode(currentTaskInDEV.componentStack);
            }
          }
          function pushBuiltInComponentStackInDEV(task, type) {
            {
              task.componentStack = {
                tag: 0,
                parent: task.componentStack,
                type
              };
            }
          }
          function pushFunctionComponentStackInDEV(task, type) {
            {
              task.componentStack = {
                tag: 1,
                parent: task.componentStack,
                type
              };
            }
          }
          function pushClassComponentStackInDEV(task, type) {
            {
              task.componentStack = {
                tag: 2,
                parent: task.componentStack,
                type
              };
            }
          }
          function popComponentStackInDEV(task) {
            {
              if (task.componentStack === null) {
                error3("Unexpectedly popped too many stack frames. This is a bug in React.");
              } else {
                task.componentStack = task.componentStack.parent;
              }
            }
          }
          var lastBoundaryErrorComponentStackDev = null;
          function captureBoundaryErrorDetailsDev(boundary, error4) {
            {
              var errorMessage;
              if (typeof error4 === "string") {
                errorMessage = error4;
              } else if (error4 && typeof error4.message === "string") {
                errorMessage = error4.message;
              } else {
                errorMessage = String(error4);
              }
              var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
              lastBoundaryErrorComponentStackDev = null;
              boundary.errorMessage = errorMessage;
              boundary.errorComponentStack = errorComponentStack;
            }
          }
          function logRecoverableError(request2, error4) {
            var errorDigest = request2.onError(error4);
            if (errorDigest != null && typeof errorDigest !== "string") {
              throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof errorDigest + '" instead');
            }
            return errorDigest;
          }
          function fatalError(request2, error4) {
            var onShellError = request2.onShellError;
            onShellError(error4);
            var onFatalError = request2.onFatalError;
            onFatalError(error4);
            if (request2.destination !== null) {
              request2.status = CLOSED;
              closeWithError(request2.destination, error4);
            } else {
              request2.status = CLOSING;
              request2.fatalError = error4;
            }
          }
          function renderSuspenseBoundary(request2, task, props) {
            pushBuiltInComponentStackInDEV(task, "Suspense");
            var parentBoundary = task.blockedBoundary;
            var parentSegment = task.blockedSegment;
            var fallback = props.fallback;
            var content3 = props.children;
            var fallbackAbortSet = /* @__PURE__ */ new Set();
            var newBoundary = createSuspenseBoundary(request2, fallbackAbortSet);
            var insertionIndex = parentSegment.chunks.length;
            var boundarySegment = createPendingSegment(
              request2,
              insertionIndex,
              newBoundary,
              parentSegment.formatContext,
              false,
              false
            );
            parentSegment.children.push(boundarySegment);
            parentSegment.lastPushedText = false;
            var contentRootSegment = createPendingSegment(
              request2,
              0,
              null,
              parentSegment.formatContext,
              false,
              false
            );
            contentRootSegment.parentFlushed = true;
            task.blockedBoundary = newBoundary;
            task.blockedSegment = contentRootSegment;
            try {
              renderNode(request2, task, content3);
              pushSegmentFinale$1(contentRootSegment.chunks, request2.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);
              contentRootSegment.status = COMPLETED;
              queueCompletedSegment(newBoundary, contentRootSegment);
              if (newBoundary.pendingTasks === 0) {
                popComponentStackInDEV(task);
                return;
              }
            } catch (error4) {
              contentRootSegment.status = ERRORED;
              newBoundary.forceClientRender = true;
              newBoundary.errorDigest = logRecoverableError(request2, error4);
              {
                captureBoundaryErrorDetailsDev(newBoundary, error4);
              }
            } finally {
              task.blockedBoundary = parentBoundary;
              task.blockedSegment = parentSegment;
            }
            var suspendedFallbackTask = createTask(request2, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
            {
              suspendedFallbackTask.componentStack = task.componentStack;
            }
            request2.pingedTasks.push(suspendedFallbackTask);
            popComponentStackInDEV(task);
          }
          function renderHostElement(request2, task, type, props) {
            pushBuiltInComponentStackInDEV(task, type);
            var segment = task.blockedSegment;
            var children = pushStartInstance(segment.chunks, type, props, request2.responseState, segment.formatContext);
            segment.lastPushedText = false;
            var prevContext = segment.formatContext;
            segment.formatContext = getChildFormatContext(prevContext, type, props);
            renderNode(request2, task, children);
            segment.formatContext = prevContext;
            pushEndInstance(segment.chunks, type);
            segment.lastPushedText = false;
            popComponentStackInDEV(task);
          }
          function shouldConstruct$1(Component2) {
            return Component2.prototype && Component2.prototype.isReactComponent;
          }
          function renderWithHooks(request2, task, Component2, props, secondArg) {
            var componentIdentity = {};
            prepareToUseHooks(task, componentIdentity);
            var result = Component2(props, secondArg);
            return finishHooks(Component2, props, result, secondArg);
          }
          function finishClassComponent(request2, task, instance, Component2, props) {
            var nextChildren = instance.render();
            {
              if (instance.props !== props) {
                if (!didWarnAboutReassigningProps) {
                  error3("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component2) || "a component");
                }
                didWarnAboutReassigningProps = true;
              }
            }
            {
              var childContextTypes = Component2.childContextTypes;
              if (childContextTypes !== null && childContextTypes !== void 0) {
                var previousContext = task.legacyContext;
                var mergedContext = processChildContext(instance, Component2, previousContext, childContextTypes);
                task.legacyContext = mergedContext;
                renderNodeDestructive(request2, task, nextChildren);
                task.legacyContext = previousContext;
                return;
              }
            }
            renderNodeDestructive(request2, task, nextChildren);
          }
          function renderClassComponent(request2, task, Component2, props) {
            pushClassComponentStackInDEV(task, Component2);
            var maskedContext = getMaskedContext(Component2, task.legacyContext);
            var instance = constructClassInstance(Component2, props, maskedContext);
            mountClassInstance(instance, Component2, props, maskedContext);
            finishClassComponent(request2, task, instance, Component2, props);
            popComponentStackInDEV(task);
          }
          var didWarnAboutBadClass = {};
          var didWarnAboutModulePatternComponent = {};
          var didWarnAboutContextTypeOnFunctionComponent = {};
          var didWarnAboutGetDerivedStateOnFunctionComponent = {};
          var didWarnAboutReassigningProps = false;
          var didWarnAboutGenerators = false;
          var didWarnAboutMaps = false;
          var hasWarnedAboutUsingContextAsConsumer = false;
          function renderIndeterminateComponent(request2, task, Component2, props) {
            var legacyContext;
            {
              legacyContext = getMaskedContext(Component2, task.legacyContext);
            }
            pushFunctionComponentStackInDEV(task, Component2);
            {
              if (Component2.prototype && typeof Component2.prototype.render === "function") {
                var componentName = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutBadClass[componentName]) {
                  error3("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                  didWarnAboutBadClass[componentName] = true;
                }
              }
            }
            var value13 = renderWithHooks(request2, task, Component2, props, legacyContext);
            var hasId = checkDidRenderIdHook();
            {
              if (typeof value13 === "object" && value13 !== null && typeof value13.render === "function" && value13.$$typeof === void 0) {
                var _componentName = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName]) {
                  error3("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                  didWarnAboutModulePatternComponent[_componentName] = true;
                }
              }
            }
            if (typeof value13 === "object" && value13 !== null && typeof value13.render === "function" && value13.$$typeof === void 0) {
              {
                var _componentName2 = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName2]) {
                  error3("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                  didWarnAboutModulePatternComponent[_componentName2] = true;
                }
              }
              mountClassInstance(value13, Component2, props, legacyContext);
              finishClassComponent(request2, task, value13, Component2, props);
            } else {
              {
                validateFunctionComponentInDev(Component2);
              }
              if (hasId) {
                var prevTreeContext = task.treeContext;
                var totalChildren = 1;
                var index5 = 0;
                task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index5);
                try {
                  renderNodeDestructive(request2, task, value13);
                } finally {
                  task.treeContext = prevTreeContext;
                }
              } else {
                renderNodeDestructive(request2, task, value13);
              }
            }
            popComponentStackInDEV(task);
          }
          function validateFunctionComponentInDev(Component2) {
            {
              if (Component2) {
                if (Component2.childContextTypes) {
                  error3("%s(...): childContextTypes cannot be defined on a function component.", Component2.displayName || Component2.name || "Component");
                }
              }
              if (typeof Component2.getDerivedStateFromProps === "function") {
                var _componentName3 = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                  error3("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                  didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
                }
              }
              if (typeof Component2.contextType === "object" && Component2.contextType !== null) {
                var _componentName4 = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                  error3("%s: Function components do not support contextType.", _componentName4);
                  didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
                }
              }
            }
          }
          function resolveDefaultProps(Component2, baseProps) {
            if (Component2 && Component2.defaultProps) {
              var props = assign2({}, baseProps);
              var defaultProps19 = Component2.defaultProps;
              for (var propName in defaultProps19) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps19[propName];
                }
              }
              return props;
            }
            return baseProps;
          }
          function renderForwardRef(request2, task, type, props, ref) {
            pushFunctionComponentStackInDEV(task, type.render);
            var children = renderWithHooks(request2, task, type.render, props, ref);
            var hasId = checkDidRenderIdHook();
            if (hasId) {
              var prevTreeContext = task.treeContext;
              var totalChildren = 1;
              var index5 = 0;
              task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index5);
              try {
                renderNodeDestructive(request2, task, children);
              } finally {
                task.treeContext = prevTreeContext;
              }
            } else {
              renderNodeDestructive(request2, task, children);
            }
            popComponentStackInDEV(task);
          }
          function renderMemo(request2, task, type, props, ref) {
            var innerType = type.type;
            var resolvedProps = resolveDefaultProps(innerType, props);
            renderElement(request2, task, innerType, resolvedProps, ref);
          }
          function renderContextConsumer(request2, task, context, props) {
            {
              if (context._context === void 0) {
                if (context !== context.Consumer) {
                  if (!hasWarnedAboutUsingContextAsConsumer) {
                    hasWarnedAboutUsingContextAsConsumer = true;
                    error3("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                }
              } else {
                context = context._context;
              }
            }
            var render2 = props.children;
            {
              if (typeof render2 !== "function") {
                error3("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
              }
            }
            var newValue = readContext(context);
            var newChildren = render2(newValue);
            renderNodeDestructive(request2, task, newChildren);
          }
          function renderContextProvider(request2, task, type, props) {
            var context = type._context;
            var value13 = props.value;
            var children = props.children;
            var prevSnapshot;
            {
              prevSnapshot = task.context;
            }
            task.context = pushProvider(context, value13);
            renderNodeDestructive(request2, task, children);
            task.context = popProvider(context);
            {
              if (prevSnapshot !== task.context) {
                error3("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
              }
            }
          }
          function renderLazyComponent(request2, task, lazyComponent, props, ref) {
            pushBuiltInComponentStackInDEV(task, "Lazy");
            var payload = lazyComponent._payload;
            var init3 = lazyComponent._init;
            var Component2 = init3(payload);
            var resolvedProps = resolveDefaultProps(Component2, props);
            renderElement(request2, task, Component2, resolvedProps, ref);
            popComponentStackInDEV(task);
          }
          function renderElement(request2, task, type, props, ref) {
            if (typeof type === "function") {
              if (shouldConstruct$1(type)) {
                renderClassComponent(request2, task, type, props);
                return;
              } else {
                renderIndeterminateComponent(request2, task, type, props);
                return;
              }
            }
            if (typeof type === "string") {
              renderHostElement(request2, task, type, props);
              return;
            }
            switch (type) {
              case REACT_LEGACY_HIDDEN_TYPE:
              case REACT_DEBUG_TRACING_MODE_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_FRAGMENT_TYPE: {
                renderNodeDestructive(request2, task, props.children);
                return;
              }
              case REACT_SUSPENSE_LIST_TYPE: {
                pushBuiltInComponentStackInDEV(task, "SuspenseList");
                renderNodeDestructive(request2, task, props.children);
                popComponentStackInDEV(task);
                return;
              }
              case REACT_SCOPE_TYPE: {
                throw new Error("ReactDOMServer does not yet support scope components.");
              }
              case REACT_SUSPENSE_TYPE: {
                {
                  renderSuspenseBoundary(request2, task, props);
                }
                return;
              }
            }
            if (typeof type === "object" && type !== null) {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE: {
                  renderForwardRef(request2, task, type, props, ref);
                  return;
                }
                case REACT_MEMO_TYPE: {
                  renderMemo(request2, task, type, props, ref);
                  return;
                }
                case REACT_PROVIDER_TYPE: {
                  renderContextProvider(request2, task, type, props);
                  return;
                }
                case REACT_CONTEXT_TYPE: {
                  renderContextConsumer(request2, task, type, props);
                  return;
                }
                case REACT_LAZY_TYPE: {
                  renderLazyComponent(request2, task, type, props);
                  return;
                }
              }
            }
            var info = "";
            {
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
            }
            throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
          }
          function validateIterable(iterable, iteratorFn) {
            {
              if (typeof Symbol === "function" && iterable[Symbol.toStringTag] === "Generator") {
                if (!didWarnAboutGenerators) {
                  error3("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                }
                didWarnAboutGenerators = true;
              }
              if (iterable.entries === iteratorFn) {
                if (!didWarnAboutMaps) {
                  error3("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                }
                didWarnAboutMaps = true;
              }
            }
          }
          function renderNodeDestructive(request2, task, node) {
            {
              try {
                return renderNodeDestructiveImpl(request2, task, node);
              } catch (x) {
                if (typeof x === "object" && x !== null && typeof x.then === "function")
                  ;
                else {
                  lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();
                }
                throw x;
              }
            }
          }
          function renderNodeDestructiveImpl(request2, task, node) {
            task.node = node;
            if (typeof node === "object" && node !== null) {
              switch (node.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  var element = node;
                  var type = element.type;
                  var props = element.props;
                  var ref = element.ref;
                  renderElement(request2, task, type, props, ref);
                  return;
                }
                case REACT_PORTAL_TYPE:
                  throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
                case REACT_LAZY_TYPE: {
                  var lazyNode = node;
                  var payload = lazyNode._payload;
                  var init3 = lazyNode._init;
                  var resolvedNode;
                  {
                    try {
                      resolvedNode = init3(payload);
                    } catch (x) {
                      if (typeof x === "object" && x !== null && typeof x.then === "function") {
                        pushBuiltInComponentStackInDEV(task, "Lazy");
                      }
                      throw x;
                    }
                  }
                  renderNodeDestructive(request2, task, resolvedNode);
                  return;
                }
              }
              if (isArray6(node)) {
                renderChildrenArray(request2, task, node);
                return;
              }
              var iteratorFn = getIteratorFn(node);
              if (iteratorFn) {
                {
                  validateIterable(node, iteratorFn);
                }
                var iterator2 = iteratorFn.call(node);
                if (iterator2) {
                  var step2 = iterator2.next();
                  if (!step2.done) {
                    var children = [];
                    do {
                      children.push(step2.value);
                      step2 = iterator2.next();
                    } while (!step2.done);
                    renderChildrenArray(request2, task, children);
                    return;
                  }
                  return;
                }
              }
              var childString = Object.prototype.toString.call(node);
              throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
            }
            if (typeof node === "string") {
              var segment = task.blockedSegment;
              segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, node, request2.responseState, segment.lastPushedText);
              return;
            }
            if (typeof node === "number") {
              var _segment = task.blockedSegment;
              _segment.lastPushedText = pushTextInstance$1(task.blockedSegment.chunks, "" + node, request2.responseState, _segment.lastPushedText);
              return;
            }
            {
              if (typeof node === "function") {
                error3("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
              }
            }
          }
          function renderChildrenArray(request2, task, children) {
            var totalChildren = children.length;
            for (var i = 0; i < totalChildren; i++) {
              var prevTreeContext = task.treeContext;
              task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i);
              try {
                renderNode(request2, task, children[i]);
              } finally {
                task.treeContext = prevTreeContext;
              }
            }
          }
          function spawnNewSuspendedTask(request2, task, x) {
            var segment = task.blockedSegment;
            var insertionIndex = segment.chunks.length;
            var newSegment = createPendingSegment(
              request2,
              insertionIndex,
              null,
              segment.formatContext,
              segment.lastPushedText,
              true
            );
            segment.children.push(newSegment);
            segment.lastPushedText = false;
            var newTask = createTask(request2, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
            {
              if (task.componentStack !== null) {
                newTask.componentStack = task.componentStack.parent;
              }
            }
            var ping = newTask.ping;
            x.then(ping, ping);
          }
          function renderNode(request2, task, node) {
            var previousFormatContext = task.blockedSegment.formatContext;
            var previousLegacyContext = task.legacyContext;
            var previousContext = task.context;
            var previousComponentStack = null;
            {
              previousComponentStack = task.componentStack;
            }
            try {
              return renderNodeDestructive(request2, task, node);
            } catch (x) {
              resetHooksState();
              if (typeof x === "object" && x !== null && typeof x.then === "function") {
                spawnNewSuspendedTask(request2, task, x);
                task.blockedSegment.formatContext = previousFormatContext;
                task.legacyContext = previousLegacyContext;
                task.context = previousContext;
                switchContext(previousContext);
                {
                  task.componentStack = previousComponentStack;
                }
                return;
              } else {
                task.blockedSegment.formatContext = previousFormatContext;
                task.legacyContext = previousLegacyContext;
                task.context = previousContext;
                switchContext(previousContext);
                {
                  task.componentStack = previousComponentStack;
                }
                throw x;
              }
            }
          }
          function erroredTask(request2, boundary, segment, error4) {
            var errorDigest = logRecoverableError(request2, error4);
            if (boundary === null) {
              fatalError(request2, error4);
            } else {
              boundary.pendingTasks--;
              if (!boundary.forceClientRender) {
                boundary.forceClientRender = true;
                boundary.errorDigest = errorDigest;
                {
                  captureBoundaryErrorDetailsDev(boundary, error4);
                }
                if (boundary.parentFlushed) {
                  request2.clientRenderedBoundaries.push(boundary);
                }
              }
            }
            request2.allPendingTasks--;
            if (request2.allPendingTasks === 0) {
              var onAllReady = request2.onAllReady;
              onAllReady();
            }
          }
          function abortTaskSoft(task) {
            var request2 = this;
            var boundary = task.blockedBoundary;
            var segment = task.blockedSegment;
            segment.status = ABORTED;
            finishedTask(request2, boundary, segment);
          }
          function abortTask(task, request2, reason) {
            var boundary = task.blockedBoundary;
            var segment = task.blockedSegment;
            segment.status = ABORTED;
            if (boundary === null) {
              request2.allPendingTasks--;
              if (request2.status !== CLOSED) {
                request2.status = CLOSED;
                if (request2.destination !== null) {
                  close2(request2.destination);
                }
              }
            } else {
              boundary.pendingTasks--;
              if (!boundary.forceClientRender) {
                boundary.forceClientRender = true;
                var _error = reason === void 0 ? new Error("The render was aborted by the server without a reason.") : reason;
                boundary.errorDigest = request2.onError(_error);
                {
                  var errorPrefix = "The server did not finish this Suspense boundary: ";
                  if (_error && typeof _error.message === "string") {
                    _error = errorPrefix + _error.message;
                  } else {
                    _error = errorPrefix + String(_error);
                  }
                  var previousTaskInDev = currentTaskInDEV;
                  currentTaskInDEV = task;
                  try {
                    captureBoundaryErrorDetailsDev(boundary, _error);
                  } finally {
                    currentTaskInDEV = previousTaskInDev;
                  }
                }
                if (boundary.parentFlushed) {
                  request2.clientRenderedBoundaries.push(boundary);
                }
              }
              boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
                return abortTask(fallbackTask, request2, reason);
              });
              boundary.fallbackAbortableTasks.clear();
              request2.allPendingTasks--;
              if (request2.allPendingTasks === 0) {
                var onAllReady = request2.onAllReady;
                onAllReady();
              }
            }
          }
          function queueCompletedSegment(boundary, segment) {
            if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
              var childSegment = segment.children[0];
              childSegment.id = segment.id;
              childSegment.parentFlushed = true;
              if (childSegment.status === COMPLETED) {
                queueCompletedSegment(boundary, childSegment);
              }
            } else {
              var completedSegments = boundary.completedSegments;
              completedSegments.push(segment);
            }
          }
          function finishedTask(request2, boundary, segment) {
            if (boundary === null) {
              if (segment.parentFlushed) {
                if (request2.completedRootSegment !== null) {
                  throw new Error("There can only be one root segment. This is a bug in React.");
                }
                request2.completedRootSegment = segment;
              }
              request2.pendingRootTasks--;
              if (request2.pendingRootTasks === 0) {
                request2.onShellError = noop$1;
                var onShellReady = request2.onShellReady;
                onShellReady();
              }
            } else {
              boundary.pendingTasks--;
              if (boundary.forceClientRender)
                ;
              else if (boundary.pendingTasks === 0) {
                if (segment.parentFlushed) {
                  if (segment.status === COMPLETED) {
                    queueCompletedSegment(boundary, segment);
                  }
                }
                if (boundary.parentFlushed) {
                  request2.completedBoundaries.push(boundary);
                }
                boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request2);
                boundary.fallbackAbortableTasks.clear();
              } else {
                if (segment.parentFlushed) {
                  if (segment.status === COMPLETED) {
                    queueCompletedSegment(boundary, segment);
                    var completedSegments = boundary.completedSegments;
                    if (completedSegments.length === 1) {
                      if (boundary.parentFlushed) {
                        request2.partialBoundaries.push(boundary);
                      }
                    }
                  }
                }
              }
            }
            request2.allPendingTasks--;
            if (request2.allPendingTasks === 0) {
              var onAllReady = request2.onAllReady;
              onAllReady();
            }
          }
          function retryTask(request2, task) {
            var segment = task.blockedSegment;
            if (segment.status !== PENDING) {
              return;
            }
            switchContext(task.context);
            var prevTaskInDEV = null;
            {
              prevTaskInDEV = currentTaskInDEV;
              currentTaskInDEV = task;
            }
            try {
              renderNodeDestructive(request2, task, task.node);
              pushSegmentFinale$1(segment.chunks, request2.responseState, segment.lastPushedText, segment.textEmbedded);
              task.abortSet.delete(task);
              segment.status = COMPLETED;
              finishedTask(request2, task.blockedBoundary, segment);
            } catch (x) {
              resetHooksState();
              if (typeof x === "object" && x !== null && typeof x.then === "function") {
                var ping = task.ping;
                x.then(ping, ping);
              } else {
                task.abortSet.delete(task);
                segment.status = ERRORED;
                erroredTask(request2, task.blockedBoundary, segment, x);
              }
            } finally {
              {
                currentTaskInDEV = prevTaskInDEV;
              }
            }
          }
          function performWork(request2) {
            if (request2.status === CLOSED) {
              return;
            }
            var prevContext = getActiveContext();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = Dispatcher;
            var prevGetCurrentStackImpl;
            {
              prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
              ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
            }
            var prevResponseState = currentResponseState;
            setCurrentResponseState(request2.responseState);
            try {
              var pingedTasks = request2.pingedTasks;
              var i;
              for (i = 0; i < pingedTasks.length; i++) {
                var task = pingedTasks[i];
                retryTask(request2, task);
              }
              pingedTasks.splice(0, i);
              if (request2.destination !== null) {
                flushCompletedQueues(request2, request2.destination);
              }
            } catch (error4) {
              logRecoverableError(request2, error4);
              fatalError(request2, error4);
            } finally {
              setCurrentResponseState(prevResponseState);
              ReactCurrentDispatcher$1.current = prevDispatcher;
              {
                ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
              }
              if (prevDispatcher === Dispatcher) {
                switchContext(prevContext);
              }
            }
          }
          function flushSubtree(request2, destination, segment) {
            segment.parentFlushed = true;
            switch (segment.status) {
              case PENDING: {
                var segmentID = segment.id = request2.nextSegmentId++;
                segment.lastPushedText = false;
                segment.textEmbedded = false;
                return writePlaceholder(destination, request2.responseState, segmentID);
              }
              case COMPLETED: {
                segment.status = FLUSHED;
                var r = true;
                var chunks = segment.chunks;
                var chunkIdx = 0;
                var children = segment.children;
                for (var childIdx = 0; childIdx < children.length; childIdx++) {
                  var nextChild = children[childIdx];
                  for (; chunkIdx < nextChild.index; chunkIdx++) {
                    writeChunk(destination, chunks[chunkIdx]);
                  }
                  r = flushSegment(request2, destination, nextChild);
                }
                for (; chunkIdx < chunks.length - 1; chunkIdx++) {
                  writeChunk(destination, chunks[chunkIdx]);
                }
                if (chunkIdx < chunks.length) {
                  r = writeChunkAndReturn(destination, chunks[chunkIdx]);
                }
                return r;
              }
              default: {
                throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
              }
            }
          }
          function flushSegment(request2, destination, segment) {
            var boundary = segment.boundary;
            if (boundary === null) {
              return flushSubtree(request2, destination, segment);
            }
            boundary.parentFlushed = true;
            if (boundary.forceClientRender) {
              writeStartClientRenderedSuspenseBoundary$1(destination, request2.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
              flushSubtree(request2, destination, segment);
              return writeEndClientRenderedSuspenseBoundary$1(destination, request2.responseState);
            } else if (boundary.pendingTasks > 0) {
              boundary.rootSegmentID = request2.nextSegmentId++;
              if (boundary.completedSegments.length > 0) {
                request2.partialBoundaries.push(boundary);
              }
              var id2 = boundary.id = assignSuspenseBoundaryID(request2.responseState);
              writeStartPendingSuspenseBoundary(destination, request2.responseState, id2);
              flushSubtree(request2, destination, segment);
              return writeEndPendingSuspenseBoundary(destination, request2.responseState);
            } else if (boundary.byteSize > request2.progressiveChunkSize) {
              boundary.rootSegmentID = request2.nextSegmentId++;
              request2.completedBoundaries.push(boundary);
              writeStartPendingSuspenseBoundary(destination, request2.responseState, boundary.id);
              flushSubtree(request2, destination, segment);
              return writeEndPendingSuspenseBoundary(destination, request2.responseState);
            } else {
              writeStartCompletedSuspenseBoundary$1(destination, request2.responseState);
              var completedSegments = boundary.completedSegments;
              if (completedSegments.length !== 1) {
                throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
              }
              var contentSegment = completedSegments[0];
              flushSegment(request2, destination, contentSegment);
              return writeEndCompletedSuspenseBoundary$1(destination, request2.responseState);
            }
          }
          function flushClientRenderedBoundary(request2, destination, boundary) {
            return writeClientRenderBoundaryInstruction(destination, request2.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
          }
          function flushSegmentContainer(request2, destination, segment) {
            writeStartSegment(destination, request2.responseState, segment.formatContext, segment.id);
            flushSegment(request2, destination, segment);
            return writeEndSegment(destination, segment.formatContext);
          }
          function flushCompletedBoundary(request2, destination, boundary) {
            var completedSegments = boundary.completedSegments;
            var i = 0;
            for (; i < completedSegments.length; i++) {
              var segment = completedSegments[i];
              flushPartiallyCompletedSegment(request2, destination, boundary, segment);
            }
            completedSegments.length = 0;
            return writeCompletedBoundaryInstruction(destination, request2.responseState, boundary.id, boundary.rootSegmentID);
          }
          function flushPartialBoundary(request2, destination, boundary) {
            var completedSegments = boundary.completedSegments;
            var i = 0;
            for (; i < completedSegments.length; i++) {
              var segment = completedSegments[i];
              if (!flushPartiallyCompletedSegment(request2, destination, boundary, segment)) {
                i++;
                completedSegments.splice(0, i);
                return false;
              }
            }
            completedSegments.splice(0, i);
            return true;
          }
          function flushPartiallyCompletedSegment(request2, destination, boundary, segment) {
            if (segment.status === FLUSHED) {
              return true;
            }
            var segmentID = segment.id;
            if (segmentID === -1) {
              var rootSegmentID = segment.id = boundary.rootSegmentID;
              if (rootSegmentID === -1) {
                throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
              }
              return flushSegmentContainer(request2, destination, segment);
            } else {
              flushSegmentContainer(request2, destination, segment);
              return writeCompletedSegmentInstruction(destination, request2.responseState, segmentID);
            }
          }
          function flushCompletedQueues(request2, destination) {
            try {
              var completedRootSegment = request2.completedRootSegment;
              if (completedRootSegment !== null && request2.pendingRootTasks === 0) {
                flushSegment(request2, destination, completedRootSegment);
                request2.completedRootSegment = null;
                writeCompletedRoot(destination, request2.responseState);
              }
              var clientRenderedBoundaries = request2.clientRenderedBoundaries;
              var i;
              for (i = 0; i < clientRenderedBoundaries.length; i++) {
                var boundary = clientRenderedBoundaries[i];
                if (!flushClientRenderedBoundary(request2, destination, boundary)) {
                  request2.destination = null;
                  i++;
                  clientRenderedBoundaries.splice(0, i);
                  return;
                }
              }
              clientRenderedBoundaries.splice(0, i);
              var completedBoundaries = request2.completedBoundaries;
              for (i = 0; i < completedBoundaries.length; i++) {
                var _boundary = completedBoundaries[i];
                if (!flushCompletedBoundary(request2, destination, _boundary)) {
                  request2.destination = null;
                  i++;
                  completedBoundaries.splice(0, i);
                  return;
                }
              }
              completedBoundaries.splice(0, i);
              completeWriting(destination);
              beginWriting(destination);
              var partialBoundaries = request2.partialBoundaries;
              for (i = 0; i < partialBoundaries.length; i++) {
                var _boundary2 = partialBoundaries[i];
                if (!flushPartialBoundary(request2, destination, _boundary2)) {
                  request2.destination = null;
                  i++;
                  partialBoundaries.splice(0, i);
                  return;
                }
              }
              partialBoundaries.splice(0, i);
              var largeBoundaries = request2.completedBoundaries;
              for (i = 0; i < largeBoundaries.length; i++) {
                var _boundary3 = largeBoundaries[i];
                if (!flushCompletedBoundary(request2, destination, _boundary3)) {
                  request2.destination = null;
                  i++;
                  largeBoundaries.splice(0, i);
                  return;
                }
              }
              largeBoundaries.splice(0, i);
            } finally {
              if (request2.allPendingTasks === 0 && request2.pingedTasks.length === 0 && request2.clientRenderedBoundaries.length === 0 && request2.completedBoundaries.length === 0) {
                {
                  if (request2.abortableTasks.size !== 0) {
                    error3("There was still abortable task at the root when we closed. This is a bug in React.");
                  }
                }
                close2(destination);
              }
            }
          }
          function startWork(request2) {
            scheduleWork(function() {
              return performWork(request2);
            });
          }
          function startFlowing(request2, destination) {
            if (request2.status === CLOSING) {
              request2.status = CLOSED;
              closeWithError(destination, request2.fatalError);
              return;
            }
            if (request2.status === CLOSED) {
              return;
            }
            if (request2.destination !== null) {
              return;
            }
            request2.destination = destination;
            try {
              flushCompletedQueues(request2, destination);
            } catch (error4) {
              logRecoverableError(request2, error4);
              fatalError(request2, error4);
            }
          }
          function abort(request2, reason) {
            try {
              var abortableTasks = request2.abortableTasks;
              abortableTasks.forEach(function(task) {
                return abortTask(task, request2, reason);
              });
              abortableTasks.clear();
              if (request2.destination !== null) {
                flushCompletedQueues(request2, request2.destination);
              }
            } catch (error4) {
              logRecoverableError(request2, error4);
              fatalError(request2, error4);
            }
          }
          function onError() {
          }
          function renderToStringImpl2(children, options2, generateStaticMarkup, abortReason) {
            var didFatal = false;
            var fatalError2 = null;
            var result = "";
            var destination = {
              push: function(chunk) {
                if (chunk !== null) {
                  result += chunk;
                }
                return true;
              },
              destroy: function(error4) {
                didFatal = true;
                fatalError2 = error4;
              }
            };
            var readyToStream = false;
            function onShellReady() {
              readyToStream = true;
            }
            var request2 = createRequest(children, createResponseState$1(generateStaticMarkup, options2 ? options2.identifierPrefix : void 0), createRootFormatContext(), Infinity, onError, void 0, onShellReady, void 0, void 0);
            startWork(request2);
            abort(request2, abortReason);
            startFlowing(request2, destination);
            if (didFatal) {
              throw fatalError2;
            }
            if (!readyToStream) {
              throw new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
            }
            return result;
          }
          function renderToString(children, options2) {
            return renderToStringImpl2(children, options2, false, 'The server used "renderToString" which does not support Suspense. If you intended for this Suspense boundary to render the fallback content on the server consider throwing an Error somewhere within the Suspense boundary. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
          }
          function renderToStaticMarkup(children, options2) {
            return renderToStringImpl2(children, options2, true, 'The server used "renderToStaticMarkup" which does not support Suspense. If you intended to have the server wait for the suspended component please switch to "renderToReadableStream" which supports Suspense on the server');
          }
          function renderToNodeStream() {
            throw new Error("ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.");
          }
          function renderToStaticNodeStream() {
            throw new Error("ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.");
          }
          exports.renderToNodeStream = renderToNodeStream;
          exports.renderToStaticMarkup = renderToStaticMarkup;
          exports.renderToStaticNodeStream = renderToStaticNodeStream;
          exports.renderToString = renderToString;
          exports.version = ReactVersion;
        })();
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom-server.browser.development.js
  var require_react_dom_server_browser_development = __commonJS({
    "node_modules/react-dom/cjs/react-dom-server.browser.development.js"(exports) {
      "use strict";
      if (true) {
        (function() {
          "use strict";
          var React18 = require_react();
          var ReactVersion = "18.2.0";
          var ReactSharedInternals = React18.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
          function warn(format) {
            {
              {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }
                printWarning("warn", format, args);
              }
            }
          }
          function error3(format) {
            {
              {
                for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                  args[_key2 - 1] = arguments[_key2];
                }
                printWarning("error", format, args);
              }
            }
          }
          function printWarning(level, format, args) {
            {
              var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
              var stack = ReactDebugCurrentFrame2.getStackAddendum();
              if (stack !== "") {
                format += "%s";
                args = args.concat([stack]);
              }
              var argsWithFormat = args.map(function(item) {
                return String(item);
              });
              argsWithFormat.unshift("Warning: " + format);
              Function.prototype.apply.call(console[level], console, argsWithFormat);
            }
          }
          function scheduleWork(callback) {
            callback();
          }
          var VIEW_SIZE = 512;
          var currentView = null;
          var writtenBytes = 0;
          function beginWriting(destination) {
            currentView = new Uint8Array(VIEW_SIZE);
            writtenBytes = 0;
          }
          function writeChunk(destination, chunk) {
            if (chunk.length === 0) {
              return;
            }
            if (chunk.length > VIEW_SIZE) {
              if (writtenBytes > 0) {
                destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
                currentView = new Uint8Array(VIEW_SIZE);
                writtenBytes = 0;
              }
              destination.enqueue(chunk);
              return;
            }
            var bytesToWrite = chunk;
            var allowableBytes = currentView.length - writtenBytes;
            if (allowableBytes < bytesToWrite.length) {
              if (allowableBytes === 0) {
                destination.enqueue(currentView);
              } else {
                currentView.set(bytesToWrite.subarray(0, allowableBytes), writtenBytes);
                destination.enqueue(currentView);
                bytesToWrite = bytesToWrite.subarray(allowableBytes);
              }
              currentView = new Uint8Array(VIEW_SIZE);
              writtenBytes = 0;
            }
            currentView.set(bytesToWrite, writtenBytes);
            writtenBytes += bytesToWrite.length;
          }
          function writeChunkAndReturn(destination, chunk) {
            writeChunk(destination, chunk);
            return true;
          }
          function completeWriting(destination) {
            if (currentView && writtenBytes > 0) {
              destination.enqueue(new Uint8Array(currentView.buffer, 0, writtenBytes));
              currentView = null;
              writtenBytes = 0;
            }
          }
          function close2(destination) {
            destination.close();
          }
          var textEncoder = new TextEncoder();
          function stringToChunk(content3) {
            return textEncoder.encode(content3);
          }
          function stringToPrecomputedChunk(content3) {
            return textEncoder.encode(content3);
          }
          function closeWithError(destination, error4) {
            if (typeof destination.error === "function") {
              destination.error(error4);
            } else {
              destination.close();
            }
          }
          function typeName(value13) {
            {
              var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
              var type = hasToStringTag && value13[Symbol.toStringTag] || value13.constructor.name || "Object";
              return type;
            }
          }
          function willCoercionThrow(value13) {
            {
              try {
                testStringCoercion(value13);
                return false;
              } catch (e) {
                return true;
              }
            }
          }
          function testStringCoercion(value13) {
            return "" + value13;
          }
          function checkAttributeStringCoercion(value13, attributeName) {
            {
              if (willCoercionThrow(value13)) {
                error3("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value13));
                return testStringCoercion(value13);
              }
            }
          }
          function checkCSSPropertyStringCoercion(value13, propName) {
            {
              if (willCoercionThrow(value13)) {
                error3("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value13));
                return testStringCoercion(value13);
              }
            }
          }
          function checkHtmlStringCoercion(value13) {
            {
              if (willCoercionThrow(value13)) {
                error3("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value13));
                return testStringCoercion(value13);
              }
            }
          }
          var hasOwnProperty3 = Object.prototype.hasOwnProperty;
          var RESERVED = 0;
          var STRING = 1;
          var BOOLEANISH_STRING = 2;
          var BOOLEAN = 3;
          var OVERLOADED_BOOLEAN = 4;
          var NUMERIC = 5;
          var POSITIVE_NUMERIC = 6;
          var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
          var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
          var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
          var illegalAttributeNameCache = {};
          var validatedAttributeNameCache = {};
          function isAttributeNameSafe(attributeName) {
            if (hasOwnProperty3.call(validatedAttributeNameCache, attributeName)) {
              return true;
            }
            if (hasOwnProperty3.call(illegalAttributeNameCache, attributeName)) {
              return false;
            }
            if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
              validatedAttributeNameCache[attributeName] = true;
              return true;
            }
            illegalAttributeNameCache[attributeName] = true;
            {
              error3("Invalid attribute name: `%s`", attributeName);
            }
            return false;
          }
          function shouldRemoveAttributeWithWarning(name16, value13, propertyInfo, isCustomComponentTag) {
            if (propertyInfo !== null && propertyInfo.type === RESERVED) {
              return false;
            }
            switch (typeof value13) {
              case "function":
              case "symbol":
                return true;
              case "boolean": {
                if (isCustomComponentTag) {
                  return false;
                }
                if (propertyInfo !== null) {
                  return !propertyInfo.acceptsBooleans;
                } else {
                  var prefix2 = name16.toLowerCase().slice(0, 5);
                  return prefix2 !== "data-" && prefix2 !== "aria-";
                }
              }
              default:
                return false;
            }
          }
          function getPropertyInfo(name16) {
            return properties.hasOwnProperty(name16) ? properties[name16] : null;
          }
          function PropertyInfoRecord(name16, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
            this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
            this.attributeName = attributeName;
            this.attributeNamespace = attributeNamespace;
            this.mustUseProperty = mustUseProperty;
            this.propertyName = name16;
            this.type = type;
            this.sanitizeURL = sanitizeURL2;
            this.removeEmptyString = removeEmptyString;
          }
          var properties = {};
          var reservedProps = [
            "children",
            "dangerouslySetInnerHTML",
            "defaultValue",
            "defaultChecked",
            "innerHTML",
            "suppressContentEditableWarning",
            "suppressHydrationWarning",
            "style"
          ];
          reservedProps.forEach(function(name16) {
            properties[name16] = new PropertyInfoRecord(
              name16,
              RESERVED,
              false,
              name16,
              null,
              false,
              false
            );
          });
          [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
            var name16 = _ref[0], attributeName = _ref[1];
            properties[name16] = new PropertyInfoRecord(
              name16,
              STRING,
              false,
              attributeName,
              null,
              false,
              false
            );
          });
          ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name16) {
            properties[name16] = new PropertyInfoRecord(
              name16,
              BOOLEANISH_STRING,
              false,
              name16.toLowerCase(),
              null,
              false,
              false
            );
          });
          ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name16) {
            properties[name16] = new PropertyInfoRecord(
              name16,
              BOOLEANISH_STRING,
              false,
              name16,
              null,
              false,
              false
            );
          });
          [
            "allowFullScreen",
            "async",
            "autoFocus",
            "autoPlay",
            "controls",
            "default",
            "defer",
            "disabled",
            "disablePictureInPicture",
            "disableRemotePlayback",
            "formNoValidate",
            "hidden",
            "loop",
            "noModule",
            "noValidate",
            "open",
            "playsInline",
            "readOnly",
            "required",
            "reversed",
            "scoped",
            "seamless",
            "itemScope"
          ].forEach(function(name16) {
            properties[name16] = new PropertyInfoRecord(
              name16,
              BOOLEAN,
              false,
              name16.toLowerCase(),
              null,
              false,
              false
            );
          });
          [
            "checked",
            "multiple",
            "muted",
            "selected"
          ].forEach(function(name16) {
            properties[name16] = new PropertyInfoRecord(
              name16,
              BOOLEAN,
              true,
              name16,
              null,
              false,
              false
            );
          });
          [
            "capture",
            "download"
          ].forEach(function(name16) {
            properties[name16] = new PropertyInfoRecord(
              name16,
              OVERLOADED_BOOLEAN,
              false,
              name16,
              null,
              false,
              false
            );
          });
          [
            "cols",
            "rows",
            "size",
            "span"
          ].forEach(function(name16) {
            properties[name16] = new PropertyInfoRecord(
              name16,
              POSITIVE_NUMERIC,
              false,
              name16,
              null,
              false,
              false
            );
          });
          ["rowSpan", "start"].forEach(function(name16) {
            properties[name16] = new PropertyInfoRecord(
              name16,
              NUMERIC,
              false,
              name16.toLowerCase(),
              null,
              false,
              false
            );
          });
          var CAMELIZE = /[\-\:]([a-z])/g;
          var capitalize = function(token) {
            return token[1].toUpperCase();
          };
          [
            "accent-height",
            "alignment-baseline",
            "arabic-form",
            "baseline-shift",
            "cap-height",
            "clip-path",
            "clip-rule",
            "color-interpolation",
            "color-interpolation-filters",
            "color-profile",
            "color-rendering",
            "dominant-baseline",
            "enable-background",
            "fill-opacity",
            "fill-rule",
            "flood-color",
            "flood-opacity",
            "font-family",
            "font-size",
            "font-size-adjust",
            "font-stretch",
            "font-style",
            "font-variant",
            "font-weight",
            "glyph-name",
            "glyph-orientation-horizontal",
            "glyph-orientation-vertical",
            "horiz-adv-x",
            "horiz-origin-x",
            "image-rendering",
            "letter-spacing",
            "lighting-color",
            "marker-end",
            "marker-mid",
            "marker-start",
            "overline-position",
            "overline-thickness",
            "paint-order",
            "panose-1",
            "pointer-events",
            "rendering-intent",
            "shape-rendering",
            "stop-color",
            "stop-opacity",
            "strikethrough-position",
            "strikethrough-thickness",
            "stroke-dasharray",
            "stroke-dashoffset",
            "stroke-linecap",
            "stroke-linejoin",
            "stroke-miterlimit",
            "stroke-opacity",
            "stroke-width",
            "text-anchor",
            "text-decoration",
            "text-rendering",
            "underline-position",
            "underline-thickness",
            "unicode-bidi",
            "unicode-range",
            "units-per-em",
            "v-alphabetic",
            "v-hanging",
            "v-ideographic",
            "v-mathematical",
            "vector-effect",
            "vert-adv-y",
            "vert-origin-x",
            "vert-origin-y",
            "word-spacing",
            "writing-mode",
            "xmlns:xlink",
            "x-height"
          ].forEach(function(attributeName) {
            var name16 = attributeName.replace(CAMELIZE, capitalize);
            properties[name16] = new PropertyInfoRecord(
              name16,
              STRING,
              false,
              attributeName,
              null,
              false,
              false
            );
          });
          [
            "xlink:actuate",
            "xlink:arcrole",
            "xlink:role",
            "xlink:show",
            "xlink:title",
            "xlink:type"
          ].forEach(function(attributeName) {
            var name16 = attributeName.replace(CAMELIZE, capitalize);
            properties[name16] = new PropertyInfoRecord(
              name16,
              STRING,
              false,
              attributeName,
              "http://www.w3.org/1999/xlink",
              false,
              false
            );
          });
          [
            "xml:base",
            "xml:lang",
            "xml:space"
          ].forEach(function(attributeName) {
            var name16 = attributeName.replace(CAMELIZE, capitalize);
            properties[name16] = new PropertyInfoRecord(
              name16,
              STRING,
              false,
              attributeName,
              "http://www.w3.org/XML/1998/namespace",
              false,
              false
            );
          });
          ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(
              attributeName,
              STRING,
              false,
              attributeName.toLowerCase(),
              null,
              false,
              false
            );
          });
          var xlinkHref = "xlinkHref";
          properties[xlinkHref] = new PropertyInfoRecord(
            "xlinkHref",
            STRING,
            false,
            "xlink:href",
            "http://www.w3.org/1999/xlink",
            true,
            false
          );
          ["src", "href", "action", "formAction"].forEach(function(attributeName) {
            properties[attributeName] = new PropertyInfoRecord(
              attributeName,
              STRING,
              false,
              attributeName.toLowerCase(),
              null,
              true,
              true
            );
          });
          var isUnitlessNumber = {
            animationIterationCount: true,
            aspectRatio: true,
            borderImageOutset: true,
            borderImageSlice: true,
            borderImageWidth: true,
            boxFlex: true,
            boxFlexGroup: true,
            boxOrdinalGroup: true,
            columnCount: true,
            columns: true,
            flex: true,
            flexGrow: true,
            flexPositive: true,
            flexShrink: true,
            flexNegative: true,
            flexOrder: true,
            gridArea: true,
            gridRow: true,
            gridRowEnd: true,
            gridRowSpan: true,
            gridRowStart: true,
            gridColumn: true,
            gridColumnEnd: true,
            gridColumnSpan: true,
            gridColumnStart: true,
            fontWeight: true,
            lineClamp: true,
            lineHeight: true,
            opacity: true,
            order: true,
            orphans: true,
            tabSize: true,
            widows: true,
            zIndex: true,
            zoom: true,
            fillOpacity: true,
            floodOpacity: true,
            stopOpacity: true,
            strokeDasharray: true,
            strokeDashoffset: true,
            strokeMiterlimit: true,
            strokeOpacity: true,
            strokeWidth: true
          };
          function prefixKey(prefix2, key) {
            return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
          }
          var prefixes = ["Webkit", "ms", "Moz", "O"];
          Object.keys(isUnitlessNumber).forEach(function(prop) {
            prefixes.forEach(function(prefix2) {
              isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
            });
          });
          var hasReadOnlyValue = {
            button: true,
            checkbox: true,
            image: true,
            hidden: true,
            radio: true,
            reset: true,
            submit: true
          };
          function checkControlledValueProps(tagName, props) {
            {
              if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
                error3("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
              }
              if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
                error3("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
              }
            }
          }
          function isCustomComponent(tagName, props) {
            if (tagName.indexOf("-") === -1) {
              return typeof props.is === "string";
            }
            switch (tagName) {
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph":
                return false;
              default:
                return true;
            }
          }
          var ariaProperties = {
            "aria-current": 0,
            "aria-description": 0,
            "aria-details": 0,
            "aria-disabled": 0,
            "aria-hidden": 0,
            "aria-invalid": 0,
            "aria-keyshortcuts": 0,
            "aria-label": 0,
            "aria-roledescription": 0,
            "aria-autocomplete": 0,
            "aria-checked": 0,
            "aria-expanded": 0,
            "aria-haspopup": 0,
            "aria-level": 0,
            "aria-modal": 0,
            "aria-multiline": 0,
            "aria-multiselectable": 0,
            "aria-orientation": 0,
            "aria-placeholder": 0,
            "aria-pressed": 0,
            "aria-readonly": 0,
            "aria-required": 0,
            "aria-selected": 0,
            "aria-sort": 0,
            "aria-valuemax": 0,
            "aria-valuemin": 0,
            "aria-valuenow": 0,
            "aria-valuetext": 0,
            "aria-atomic": 0,
            "aria-busy": 0,
            "aria-live": 0,
            "aria-relevant": 0,
            "aria-dropeffect": 0,
            "aria-grabbed": 0,
            "aria-activedescendant": 0,
            "aria-colcount": 0,
            "aria-colindex": 0,
            "aria-colspan": 0,
            "aria-controls": 0,
            "aria-describedby": 0,
            "aria-errormessage": 0,
            "aria-flowto": 0,
            "aria-labelledby": 0,
            "aria-owns": 0,
            "aria-posinset": 0,
            "aria-rowcount": 0,
            "aria-rowindex": 0,
            "aria-rowspan": 0,
            "aria-setsize": 0
          };
          var warnedProperties = {};
          var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          function validateProperty(tagName, name16) {
            {
              if (hasOwnProperty3.call(warnedProperties, name16) && warnedProperties[name16]) {
                return true;
              }
              if (rARIACamel.test(name16)) {
                var ariaName = "aria-" + name16.slice(4).toLowerCase();
                var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
                if (correctName == null) {
                  error3("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name16);
                  warnedProperties[name16] = true;
                  return true;
                }
                if (name16 !== correctName) {
                  error3("Invalid ARIA attribute `%s`. Did you mean `%s`?", name16, correctName);
                  warnedProperties[name16] = true;
                  return true;
                }
              }
              if (rARIA.test(name16)) {
                var lowerCasedName = name16.toLowerCase();
                var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
                if (standardName == null) {
                  warnedProperties[name16] = true;
                  return false;
                }
                if (name16 !== standardName) {
                  error3("Unknown ARIA attribute `%s`. Did you mean `%s`?", name16, standardName);
                  warnedProperties[name16] = true;
                  return true;
                }
              }
            }
            return true;
          }
          function warnInvalidARIAProps(type, props) {
            {
              var invalidProps = [];
              for (var key in props) {
                var isValid3 = validateProperty(type, key);
                if (!isValid3) {
                  invalidProps.push(key);
                }
              }
              var unknownPropString = invalidProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (invalidProps.length === 1) {
                error3("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              } else if (invalidProps.length > 1) {
                error3("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
              }
            }
          }
          function validateProperties(type, props) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnInvalidARIAProps(type, props);
          }
          var didWarnValueNull = false;
          function validateProperties$1(type, props) {
            {
              if (type !== "input" && type !== "textarea" && type !== "select") {
                return;
              }
              if (props != null && props.value === null && !didWarnValueNull) {
                didWarnValueNull = true;
                if (type === "select" && props.multiple) {
                  error3("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
                } else {
                  error3("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
                }
              }
            }
          }
          var possibleStandardNames = {
            accept: "accept",
            acceptcharset: "acceptCharset",
            "accept-charset": "acceptCharset",
            accesskey: "accessKey",
            action: "action",
            allowfullscreen: "allowFullScreen",
            alt: "alt",
            as: "as",
            async: "async",
            autocapitalize: "autoCapitalize",
            autocomplete: "autoComplete",
            autocorrect: "autoCorrect",
            autofocus: "autoFocus",
            autoplay: "autoPlay",
            autosave: "autoSave",
            capture: "capture",
            cellpadding: "cellPadding",
            cellspacing: "cellSpacing",
            challenge: "challenge",
            charset: "charSet",
            checked: "checked",
            children: "children",
            cite: "cite",
            class: "className",
            classid: "classID",
            classname: "className",
            cols: "cols",
            colspan: "colSpan",
            content: "content",
            contenteditable: "contentEditable",
            contextmenu: "contextMenu",
            controls: "controls",
            controlslist: "controlsList",
            coords: "coords",
            crossorigin: "crossOrigin",
            dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
            data: "data",
            datetime: "dateTime",
            default: "default",
            defaultchecked: "defaultChecked",
            defaultvalue: "defaultValue",
            defer: "defer",
            dir: "dir",
            disabled: "disabled",
            disablepictureinpicture: "disablePictureInPicture",
            disableremoteplayback: "disableRemotePlayback",
            download: "download",
            draggable: "draggable",
            enctype: "encType",
            enterkeyhint: "enterKeyHint",
            for: "htmlFor",
            form: "form",
            formmethod: "formMethod",
            formaction: "formAction",
            formenctype: "formEncType",
            formnovalidate: "formNoValidate",
            formtarget: "formTarget",
            frameborder: "frameBorder",
            headers: "headers",
            height: "height",
            hidden: "hidden",
            high: "high",
            href: "href",
            hreflang: "hrefLang",
            htmlfor: "htmlFor",
            httpequiv: "httpEquiv",
            "http-equiv": "httpEquiv",
            icon: "icon",
            id: "id",
            imagesizes: "imageSizes",
            imagesrcset: "imageSrcSet",
            innerhtml: "innerHTML",
            inputmode: "inputMode",
            integrity: "integrity",
            is: "is",
            itemid: "itemID",
            itemprop: "itemProp",
            itemref: "itemRef",
            itemscope: "itemScope",
            itemtype: "itemType",
            keyparams: "keyParams",
            keytype: "keyType",
            kind: "kind",
            label: "label",
            lang: "lang",
            list: "list",
            loop: "loop",
            low: "low",
            manifest: "manifest",
            marginwidth: "marginWidth",
            marginheight: "marginHeight",
            max: "max",
            maxlength: "maxLength",
            media: "media",
            mediagroup: "mediaGroup",
            method: "method",
            min: "min",
            minlength: "minLength",
            multiple: "multiple",
            muted: "muted",
            name: "name",
            nomodule: "noModule",
            nonce: "nonce",
            novalidate: "noValidate",
            open: "open",
            optimum: "optimum",
            pattern: "pattern",
            placeholder: "placeholder",
            playsinline: "playsInline",
            poster: "poster",
            preload: "preload",
            profile: "profile",
            radiogroup: "radioGroup",
            readonly: "readOnly",
            referrerpolicy: "referrerPolicy",
            rel: "rel",
            required: "required",
            reversed: "reversed",
            role: "role",
            rows: "rows",
            rowspan: "rowSpan",
            sandbox: "sandbox",
            scope: "scope",
            scoped: "scoped",
            scrolling: "scrolling",
            seamless: "seamless",
            selected: "selected",
            shape: "shape",
            size: "size",
            sizes: "sizes",
            span: "span",
            spellcheck: "spellCheck",
            src: "src",
            srcdoc: "srcDoc",
            srclang: "srcLang",
            srcset: "srcSet",
            start: "start",
            step: "step",
            style: "style",
            summary: "summary",
            tabindex: "tabIndex",
            target: "target",
            title: "title",
            type: "type",
            usemap: "useMap",
            value: "value",
            width: "width",
            wmode: "wmode",
            wrap: "wrap",
            about: "about",
            accentheight: "accentHeight",
            "accent-height": "accentHeight",
            accumulate: "accumulate",
            additive: "additive",
            alignmentbaseline: "alignmentBaseline",
            "alignment-baseline": "alignmentBaseline",
            allowreorder: "allowReorder",
            alphabetic: "alphabetic",
            amplitude: "amplitude",
            arabicform: "arabicForm",
            "arabic-form": "arabicForm",
            ascent: "ascent",
            attributename: "attributeName",
            attributetype: "attributeType",
            autoreverse: "autoReverse",
            azimuth: "azimuth",
            basefrequency: "baseFrequency",
            baselineshift: "baselineShift",
            "baseline-shift": "baselineShift",
            baseprofile: "baseProfile",
            bbox: "bbox",
            begin: "begin",
            bias: "bias",
            by: "by",
            calcmode: "calcMode",
            capheight: "capHeight",
            "cap-height": "capHeight",
            clip: "clip",
            clippath: "clipPath",
            "clip-path": "clipPath",
            clippathunits: "clipPathUnits",
            cliprule: "clipRule",
            "clip-rule": "clipRule",
            color: "color",
            colorinterpolation: "colorInterpolation",
            "color-interpolation": "colorInterpolation",
            colorinterpolationfilters: "colorInterpolationFilters",
            "color-interpolation-filters": "colorInterpolationFilters",
            colorprofile: "colorProfile",
            "color-profile": "colorProfile",
            colorrendering: "colorRendering",
            "color-rendering": "colorRendering",
            contentscripttype: "contentScriptType",
            contentstyletype: "contentStyleType",
            cursor: "cursor",
            cx: "cx",
            cy: "cy",
            d: "d",
            datatype: "datatype",
            decelerate: "decelerate",
            descent: "descent",
            diffuseconstant: "diffuseConstant",
            direction: "direction",
            display: "display",
            divisor: "divisor",
            dominantbaseline: "dominantBaseline",
            "dominant-baseline": "dominantBaseline",
            dur: "dur",
            dx: "dx",
            dy: "dy",
            edgemode: "edgeMode",
            elevation: "elevation",
            enablebackground: "enableBackground",
            "enable-background": "enableBackground",
            end: "end",
            exponent: "exponent",
            externalresourcesrequired: "externalResourcesRequired",
            fill: "fill",
            fillopacity: "fillOpacity",
            "fill-opacity": "fillOpacity",
            fillrule: "fillRule",
            "fill-rule": "fillRule",
            filter: "filter",
            filterres: "filterRes",
            filterunits: "filterUnits",
            floodopacity: "floodOpacity",
            "flood-opacity": "floodOpacity",
            floodcolor: "floodColor",
            "flood-color": "floodColor",
            focusable: "focusable",
            fontfamily: "fontFamily",
            "font-family": "fontFamily",
            fontsize: "fontSize",
            "font-size": "fontSize",
            fontsizeadjust: "fontSizeAdjust",
            "font-size-adjust": "fontSizeAdjust",
            fontstretch: "fontStretch",
            "font-stretch": "fontStretch",
            fontstyle: "fontStyle",
            "font-style": "fontStyle",
            fontvariant: "fontVariant",
            "font-variant": "fontVariant",
            fontweight: "fontWeight",
            "font-weight": "fontWeight",
            format: "format",
            from: "from",
            fx: "fx",
            fy: "fy",
            g1: "g1",
            g2: "g2",
            glyphname: "glyphName",
            "glyph-name": "glyphName",
            glyphorientationhorizontal: "glyphOrientationHorizontal",
            "glyph-orientation-horizontal": "glyphOrientationHorizontal",
            glyphorientationvertical: "glyphOrientationVertical",
            "glyph-orientation-vertical": "glyphOrientationVertical",
            glyphref: "glyphRef",
            gradienttransform: "gradientTransform",
            gradientunits: "gradientUnits",
            hanging: "hanging",
            horizadvx: "horizAdvX",
            "horiz-adv-x": "horizAdvX",
            horizoriginx: "horizOriginX",
            "horiz-origin-x": "horizOriginX",
            ideographic: "ideographic",
            imagerendering: "imageRendering",
            "image-rendering": "imageRendering",
            in2: "in2",
            in: "in",
            inlist: "inlist",
            intercept: "intercept",
            k1: "k1",
            k2: "k2",
            k3: "k3",
            k4: "k4",
            k: "k",
            kernelmatrix: "kernelMatrix",
            kernelunitlength: "kernelUnitLength",
            kerning: "kerning",
            keypoints: "keyPoints",
            keysplines: "keySplines",
            keytimes: "keyTimes",
            lengthadjust: "lengthAdjust",
            letterspacing: "letterSpacing",
            "letter-spacing": "letterSpacing",
            lightingcolor: "lightingColor",
            "lighting-color": "lightingColor",
            limitingconeangle: "limitingConeAngle",
            local: "local",
            markerend: "markerEnd",
            "marker-end": "markerEnd",
            markerheight: "markerHeight",
            markermid: "markerMid",
            "marker-mid": "markerMid",
            markerstart: "markerStart",
            "marker-start": "markerStart",
            markerunits: "markerUnits",
            markerwidth: "markerWidth",
            mask: "mask",
            maskcontentunits: "maskContentUnits",
            maskunits: "maskUnits",
            mathematical: "mathematical",
            mode: "mode",
            numoctaves: "numOctaves",
            offset: "offset",
            opacity: "opacity",
            operator: "operator",
            order: "order",
            orient: "orient",
            orientation: "orientation",
            origin: "origin",
            overflow: "overflow",
            overlineposition: "overlinePosition",
            "overline-position": "overlinePosition",
            overlinethickness: "overlineThickness",
            "overline-thickness": "overlineThickness",
            paintorder: "paintOrder",
            "paint-order": "paintOrder",
            panose1: "panose1",
            "panose-1": "panose1",
            pathlength: "pathLength",
            patterncontentunits: "patternContentUnits",
            patterntransform: "patternTransform",
            patternunits: "patternUnits",
            pointerevents: "pointerEvents",
            "pointer-events": "pointerEvents",
            points: "points",
            pointsatx: "pointsAtX",
            pointsaty: "pointsAtY",
            pointsatz: "pointsAtZ",
            prefix: "prefix",
            preservealpha: "preserveAlpha",
            preserveaspectratio: "preserveAspectRatio",
            primitiveunits: "primitiveUnits",
            property: "property",
            r: "r",
            radius: "radius",
            refx: "refX",
            refy: "refY",
            renderingintent: "renderingIntent",
            "rendering-intent": "renderingIntent",
            repeatcount: "repeatCount",
            repeatdur: "repeatDur",
            requiredextensions: "requiredExtensions",
            requiredfeatures: "requiredFeatures",
            resource: "resource",
            restart: "restart",
            result: "result",
            results: "results",
            rotate: "rotate",
            rx: "rx",
            ry: "ry",
            scale: "scale",
            security: "security",
            seed: "seed",
            shaperendering: "shapeRendering",
            "shape-rendering": "shapeRendering",
            slope: "slope",
            spacing: "spacing",
            specularconstant: "specularConstant",
            specularexponent: "specularExponent",
            speed: "speed",
            spreadmethod: "spreadMethod",
            startoffset: "startOffset",
            stddeviation: "stdDeviation",
            stemh: "stemh",
            stemv: "stemv",
            stitchtiles: "stitchTiles",
            stopcolor: "stopColor",
            "stop-color": "stopColor",
            stopopacity: "stopOpacity",
            "stop-opacity": "stopOpacity",
            strikethroughposition: "strikethroughPosition",
            "strikethrough-position": "strikethroughPosition",
            strikethroughthickness: "strikethroughThickness",
            "strikethrough-thickness": "strikethroughThickness",
            string: "string",
            stroke: "stroke",
            strokedasharray: "strokeDasharray",
            "stroke-dasharray": "strokeDasharray",
            strokedashoffset: "strokeDashoffset",
            "stroke-dashoffset": "strokeDashoffset",
            strokelinecap: "strokeLinecap",
            "stroke-linecap": "strokeLinecap",
            strokelinejoin: "strokeLinejoin",
            "stroke-linejoin": "strokeLinejoin",
            strokemiterlimit: "strokeMiterlimit",
            "stroke-miterlimit": "strokeMiterlimit",
            strokewidth: "strokeWidth",
            "stroke-width": "strokeWidth",
            strokeopacity: "strokeOpacity",
            "stroke-opacity": "strokeOpacity",
            suppresscontenteditablewarning: "suppressContentEditableWarning",
            suppresshydrationwarning: "suppressHydrationWarning",
            surfacescale: "surfaceScale",
            systemlanguage: "systemLanguage",
            tablevalues: "tableValues",
            targetx: "targetX",
            targety: "targetY",
            textanchor: "textAnchor",
            "text-anchor": "textAnchor",
            textdecoration: "textDecoration",
            "text-decoration": "textDecoration",
            textlength: "textLength",
            textrendering: "textRendering",
            "text-rendering": "textRendering",
            to: "to",
            transform: "transform",
            typeof: "typeof",
            u1: "u1",
            u2: "u2",
            underlineposition: "underlinePosition",
            "underline-position": "underlinePosition",
            underlinethickness: "underlineThickness",
            "underline-thickness": "underlineThickness",
            unicode: "unicode",
            unicodebidi: "unicodeBidi",
            "unicode-bidi": "unicodeBidi",
            unicoderange: "unicodeRange",
            "unicode-range": "unicodeRange",
            unitsperem: "unitsPerEm",
            "units-per-em": "unitsPerEm",
            unselectable: "unselectable",
            valphabetic: "vAlphabetic",
            "v-alphabetic": "vAlphabetic",
            values: "values",
            vectoreffect: "vectorEffect",
            "vector-effect": "vectorEffect",
            version: "version",
            vertadvy: "vertAdvY",
            "vert-adv-y": "vertAdvY",
            vertoriginx: "vertOriginX",
            "vert-origin-x": "vertOriginX",
            vertoriginy: "vertOriginY",
            "vert-origin-y": "vertOriginY",
            vhanging: "vHanging",
            "v-hanging": "vHanging",
            videographic: "vIdeographic",
            "v-ideographic": "vIdeographic",
            viewbox: "viewBox",
            viewtarget: "viewTarget",
            visibility: "visibility",
            vmathematical: "vMathematical",
            "v-mathematical": "vMathematical",
            vocab: "vocab",
            widths: "widths",
            wordspacing: "wordSpacing",
            "word-spacing": "wordSpacing",
            writingmode: "writingMode",
            "writing-mode": "writingMode",
            x1: "x1",
            x2: "x2",
            x: "x",
            xchannelselector: "xChannelSelector",
            xheight: "xHeight",
            "x-height": "xHeight",
            xlinkactuate: "xlinkActuate",
            "xlink:actuate": "xlinkActuate",
            xlinkarcrole: "xlinkArcrole",
            "xlink:arcrole": "xlinkArcrole",
            xlinkhref: "xlinkHref",
            "xlink:href": "xlinkHref",
            xlinkrole: "xlinkRole",
            "xlink:role": "xlinkRole",
            xlinkshow: "xlinkShow",
            "xlink:show": "xlinkShow",
            xlinktitle: "xlinkTitle",
            "xlink:title": "xlinkTitle",
            xlinktype: "xlinkType",
            "xlink:type": "xlinkType",
            xmlbase: "xmlBase",
            "xml:base": "xmlBase",
            xmllang: "xmlLang",
            "xml:lang": "xmlLang",
            xmlns: "xmlns",
            "xml:space": "xmlSpace",
            xmlnsxlink: "xmlnsXlink",
            "xmlns:xlink": "xmlnsXlink",
            xmlspace: "xmlSpace",
            y1: "y1",
            y2: "y2",
            y: "y",
            ychannelselector: "yChannelSelector",
            z: "z",
            zoomandpan: "zoomAndPan"
          };
          var validateProperty$1 = function() {
          };
          {
            var warnedProperties$1 = {};
            var EVENT_NAME_REGEX = /^on./;
            var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
            var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
            var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
            validateProperty$1 = function(tagName, name16, value13, eventRegistry) {
              if (hasOwnProperty3.call(warnedProperties$1, name16) && warnedProperties$1[name16]) {
                return true;
              }
              var lowerCasedName = name16.toLowerCase();
              if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
                error3("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
                warnedProperties$1[name16] = true;
                return true;
              }
              if (eventRegistry != null) {
                var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
                if (registrationNameDependencies.hasOwnProperty(name16)) {
                  return true;
                }
                var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
                if (registrationName != null) {
                  error3("Invalid event handler property `%s`. Did you mean `%s`?", name16, registrationName);
                  warnedProperties$1[name16] = true;
                  return true;
                }
                if (EVENT_NAME_REGEX.test(name16)) {
                  error3("Unknown event handler property `%s`. It will be ignored.", name16);
                  warnedProperties$1[name16] = true;
                  return true;
                }
              } else if (EVENT_NAME_REGEX.test(name16)) {
                if (INVALID_EVENT_NAME_REGEX.test(name16)) {
                  error3("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name16);
                }
                warnedProperties$1[name16] = true;
                return true;
              }
              if (rARIA$1.test(name16) || rARIACamel$1.test(name16)) {
                return true;
              }
              if (lowerCasedName === "innerhtml") {
                error3("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
                warnedProperties$1[name16] = true;
                return true;
              }
              if (lowerCasedName === "aria") {
                error3("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
                warnedProperties$1[name16] = true;
                return true;
              }
              if (lowerCasedName === "is" && value13 !== null && value13 !== void 0 && typeof value13 !== "string") {
                error3("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value13);
                warnedProperties$1[name16] = true;
                return true;
              }
              if (typeof value13 === "number" && isNaN(value13)) {
                error3("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name16);
                warnedProperties$1[name16] = true;
                return true;
              }
              var propertyInfo = getPropertyInfo(name16);
              var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
              if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
                var standardName = possibleStandardNames[lowerCasedName];
                if (standardName !== name16) {
                  error3("Invalid DOM property `%s`. Did you mean `%s`?", name16, standardName);
                  warnedProperties$1[name16] = true;
                  return true;
                }
              } else if (!isReserved && name16 !== lowerCasedName) {
                error3("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name16, lowerCasedName);
                warnedProperties$1[name16] = true;
                return true;
              }
              if (typeof value13 === "boolean" && shouldRemoveAttributeWithWarning(name16, value13, propertyInfo, false)) {
                if (value13) {
                  error3('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value13, name16, name16, value13, name16);
                } else {
                  error3('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value13, name16, name16, value13, name16, name16, name16);
                }
                warnedProperties$1[name16] = true;
                return true;
              }
              if (isReserved) {
                return true;
              }
              if (shouldRemoveAttributeWithWarning(name16, value13, propertyInfo, false)) {
                warnedProperties$1[name16] = true;
                return false;
              }
              if ((value13 === "false" || value13 === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
                error3("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value13, name16, value13 === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name16, value13);
                warnedProperties$1[name16] = true;
                return true;
              }
              return true;
            };
          }
          var warnUnknownProperties = function(type, props, eventRegistry) {
            {
              var unknownProps = [];
              for (var key in props) {
                var isValid3 = validateProperty$1(type, key, props[key], eventRegistry);
                if (!isValid3) {
                  unknownProps.push(key);
                }
              }
              var unknownPropString = unknownProps.map(function(prop) {
                return "`" + prop + "`";
              }).join(", ");
              if (unknownProps.length === 1) {
                error3("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              } else if (unknownProps.length > 1) {
                error3("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
              }
            }
          };
          function validateProperties$2(type, props, eventRegistry) {
            if (isCustomComponent(type, props)) {
              return;
            }
            warnUnknownProperties(type, props, eventRegistry);
          }
          var warnValidStyle = function() {
          };
          {
            var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
            var msPattern = /^-ms-/;
            var hyphenPattern = /-(.)/g;
            var badStyleValueWithSemicolonPattern = /;\s*$/;
            var warnedStyleNames = {};
            var warnedStyleValues = {};
            var warnedForNaNValue = false;
            var warnedForInfinityValue = false;
            var camelize = function(string13) {
              return string13.replace(hyphenPattern, function(_, character) {
                return character.toUpperCase();
              });
            };
            var warnHyphenatedStyleName = function(name16) {
              if (warnedStyleNames.hasOwnProperty(name16) && warnedStyleNames[name16]) {
                return;
              }
              warnedStyleNames[name16] = true;
              error3(
                "Unsupported style property %s. Did you mean %s?",
                name16,
                camelize(name16.replace(msPattern, "ms-"))
              );
            };
            var warnBadVendoredStyleName = function(name16) {
              if (warnedStyleNames.hasOwnProperty(name16) && warnedStyleNames[name16]) {
                return;
              }
              warnedStyleNames[name16] = true;
              error3("Unsupported vendor-prefixed style property %s. Did you mean %s?", name16, name16.charAt(0).toUpperCase() + name16.slice(1));
            };
            var warnStyleValueWithSemicolon = function(name16, value13) {
              if (warnedStyleValues.hasOwnProperty(value13) && warnedStyleValues[value13]) {
                return;
              }
              warnedStyleValues[value13] = true;
              error3(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name16, value13.replace(badStyleValueWithSemicolonPattern, ""));
            };
            var warnStyleValueIsNaN = function(name16, value13) {
              if (warnedForNaNValue) {
                return;
              }
              warnedForNaNValue = true;
              error3("`NaN` is an invalid value for the `%s` css style property.", name16);
            };
            var warnStyleValueIsInfinity = function(name16, value13) {
              if (warnedForInfinityValue) {
                return;
              }
              warnedForInfinityValue = true;
              error3("`Infinity` is an invalid value for the `%s` css style property.", name16);
            };
            warnValidStyle = function(name16, value13) {
              if (name16.indexOf("-") > -1) {
                warnHyphenatedStyleName(name16);
              } else if (badVendoredStyleNamePattern.test(name16)) {
                warnBadVendoredStyleName(name16);
              } else if (badStyleValueWithSemicolonPattern.test(value13)) {
                warnStyleValueWithSemicolon(name16, value13);
              }
              if (typeof value13 === "number") {
                if (isNaN(value13)) {
                  warnStyleValueIsNaN(name16, value13);
                } else if (!isFinite(value13)) {
                  warnStyleValueIsInfinity(name16, value13);
                }
              }
            };
          }
          var warnValidStyle$1 = warnValidStyle;
          var matchHtmlRegExp = /["'&<>]/;
          function escapeHtml(string13) {
            {
              checkHtmlStringCoercion(string13);
            }
            var str = "" + string13;
            var match = matchHtmlRegExp.exec(str);
            if (!match) {
              return str;
            }
            var escape;
            var html = "";
            var index5;
            var lastIndex = 0;
            for (index5 = match.index; index5 < str.length; index5++) {
              switch (str.charCodeAt(index5)) {
                case 34:
                  escape = "&quot;";
                  break;
                case 38:
                  escape = "&amp;";
                  break;
                case 39:
                  escape = "&#x27;";
                  break;
                case 60:
                  escape = "&lt;";
                  break;
                case 62:
                  escape = "&gt;";
                  break;
                default:
                  continue;
              }
              if (lastIndex !== index5) {
                html += str.substring(lastIndex, index5);
              }
              lastIndex = index5 + 1;
              html += escape;
            }
            return lastIndex !== index5 ? html + str.substring(lastIndex, index5) : html;
          }
          function escapeTextForBrowser(text5) {
            if (typeof text5 === "boolean" || typeof text5 === "number") {
              return "" + text5;
            }
            return escapeHtml(text5);
          }
          var uppercasePattern = /([A-Z])/g;
          var msPattern$1 = /^ms-/;
          function hyphenateStyleName(name16) {
            return name16.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-");
          }
          var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
          var didWarn = false;
          function sanitizeURL(url) {
            {
              if (!didWarn && isJavaScriptProtocol.test(url)) {
                didWarn = true;
                error3("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
              }
            }
          }
          var isArrayImpl = Array.isArray;
          function isArray6(a) {
            return isArrayImpl(a);
          }
          var startInlineScript = stringToPrecomputedChunk("<script>");
          var endInlineScript = stringToPrecomputedChunk("<\/script>");
          var startScriptSrc = stringToPrecomputedChunk('<script src="');
          var startModuleSrc = stringToPrecomputedChunk('<script type="module" src="');
          var endAsyncScript = stringToPrecomputedChunk('" async=""><\/script>');
          function escapeBootstrapScriptContent(scriptText) {
            {
              checkHtmlStringCoercion(scriptText);
            }
            return ("" + scriptText).replace(scriptRegex, scriptReplacer);
          }
          var scriptRegex = /(<\/|<)(s)(cript)/gi;
          var scriptReplacer = function(match, prefix2, s, suffix) {
            return "" + prefix2 + (s === "s" ? "\\u0073" : "\\u0053") + suffix;
          };
          function createResponseState(identifierPrefix, nonce, bootstrapScriptContent, bootstrapScripts, bootstrapModules) {
            var idPrefix = identifierPrefix === void 0 ? "" : identifierPrefix;
            var inlineScriptWithNonce = nonce === void 0 ? startInlineScript : stringToPrecomputedChunk('<script nonce="' + escapeTextForBrowser(nonce) + '">');
            var bootstrapChunks = [];
            if (bootstrapScriptContent !== void 0) {
              bootstrapChunks.push(inlineScriptWithNonce, stringToChunk(escapeBootstrapScriptContent(bootstrapScriptContent)), endInlineScript);
            }
            if (bootstrapScripts !== void 0) {
              for (var i = 0; i < bootstrapScripts.length; i++) {
                bootstrapChunks.push(startScriptSrc, stringToChunk(escapeTextForBrowser(bootstrapScripts[i])), endAsyncScript);
              }
            }
            if (bootstrapModules !== void 0) {
              for (var _i = 0; _i < bootstrapModules.length; _i++) {
                bootstrapChunks.push(startModuleSrc, stringToChunk(escapeTextForBrowser(bootstrapModules[_i])), endAsyncScript);
              }
            }
            return {
              bootstrapChunks,
              startInlineScript: inlineScriptWithNonce,
              placeholderPrefix: stringToPrecomputedChunk(idPrefix + "P:"),
              segmentPrefix: stringToPrecomputedChunk(idPrefix + "S:"),
              boundaryPrefix: idPrefix + "B:",
              idPrefix,
              nextSuspenseID: 0,
              sentCompleteSegmentFunction: false,
              sentCompleteBoundaryFunction: false,
              sentClientRenderFunction: false
            };
          }
          var ROOT_HTML_MODE = 0;
          var HTML_MODE = 1;
          var SVG_MODE = 2;
          var MATHML_MODE = 3;
          var HTML_TABLE_MODE = 4;
          var HTML_TABLE_BODY_MODE = 5;
          var HTML_TABLE_ROW_MODE = 6;
          var HTML_COLGROUP_MODE = 7;
          function createFormatContext(insertionMode, selectedValue) {
            return {
              insertionMode,
              selectedValue
            };
          }
          function createRootFormatContext(namespaceURI) {
            var insertionMode = namespaceURI === "http://www.w3.org/2000/svg" ? SVG_MODE : namespaceURI === "http://www.w3.org/1998/Math/MathML" ? MATHML_MODE : ROOT_HTML_MODE;
            return createFormatContext(insertionMode, null);
          }
          function getChildFormatContext(parentContext, type, props) {
            switch (type) {
              case "select":
                return createFormatContext(HTML_MODE, props.value != null ? props.value : props.defaultValue);
              case "svg":
                return createFormatContext(SVG_MODE, null);
              case "math":
                return createFormatContext(MATHML_MODE, null);
              case "foreignObject":
                return createFormatContext(HTML_MODE, null);
              case "table":
                return createFormatContext(HTML_TABLE_MODE, null);
              case "thead":
              case "tbody":
              case "tfoot":
                return createFormatContext(HTML_TABLE_BODY_MODE, null);
              case "colgroup":
                return createFormatContext(HTML_COLGROUP_MODE, null);
              case "tr":
                return createFormatContext(HTML_TABLE_ROW_MODE, null);
            }
            if (parentContext.insertionMode >= HTML_TABLE_MODE) {
              return createFormatContext(HTML_MODE, null);
            }
            if (parentContext.insertionMode === ROOT_HTML_MODE) {
              return createFormatContext(HTML_MODE, null);
            }
            return parentContext;
          }
          var UNINITIALIZED_SUSPENSE_BOUNDARY_ID = null;
          function assignSuspenseBoundaryID(responseState) {
            var generatedID = responseState.nextSuspenseID++;
            return stringToPrecomputedChunk(responseState.boundaryPrefix + generatedID.toString(16));
          }
          function makeId(responseState, treeId, localId) {
            var idPrefix = responseState.idPrefix;
            var id2 = ":" + idPrefix + "R" + treeId;
            if (localId > 0) {
              id2 += "H" + localId.toString(32);
            }
            return id2 + ":";
          }
          function encodeHTMLTextNode(text5) {
            return escapeTextForBrowser(text5);
          }
          var textSeparator = stringToPrecomputedChunk("<!-- -->");
          function pushTextInstance(target5, text5, responseState, textEmbedded) {
            if (text5 === "") {
              return textEmbedded;
            }
            if (textEmbedded) {
              target5.push(textSeparator);
            }
            target5.push(stringToChunk(encodeHTMLTextNode(text5)));
            return true;
          }
          function pushSegmentFinale(target5, responseState, lastPushedText, textEmbedded) {
            if (lastPushedText && textEmbedded) {
              target5.push(textSeparator);
            }
          }
          var styleNameCache = /* @__PURE__ */ new Map();
          function processStyleName(styleName) {
            var chunk = styleNameCache.get(styleName);
            if (chunk !== void 0) {
              return chunk;
            }
            var result = stringToPrecomputedChunk(escapeTextForBrowser(hyphenateStyleName(styleName)));
            styleNameCache.set(styleName, result);
            return result;
          }
          var styleAttributeStart = stringToPrecomputedChunk(' style="');
          var styleAssign = stringToPrecomputedChunk(":");
          var styleSeparator = stringToPrecomputedChunk(";");
          function pushStyle(target5, responseState, style) {
            if (typeof style !== "object") {
              throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
            }
            var isFirst = true;
            for (var styleName in style) {
              if (!hasOwnProperty3.call(style, styleName)) {
                continue;
              }
              var styleValue = style[styleName];
              if (styleValue == null || typeof styleValue === "boolean" || styleValue === "") {
                continue;
              }
              var nameChunk = void 0;
              var valueChunk = void 0;
              var isCustomProperty = styleName.indexOf("--") === 0;
              if (isCustomProperty) {
                nameChunk = stringToChunk(escapeTextForBrowser(styleName));
                {
                  checkCSSPropertyStringCoercion(styleValue, styleName);
                }
                valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
              } else {
                {
                  warnValidStyle$1(styleName, styleValue);
                }
                nameChunk = processStyleName(styleName);
                if (typeof styleValue === "number") {
                  if (styleValue !== 0 && !hasOwnProperty3.call(isUnitlessNumber, styleName)) {
                    valueChunk = stringToChunk(styleValue + "px");
                  } else {
                    valueChunk = stringToChunk("" + styleValue);
                  }
                } else {
                  {
                    checkCSSPropertyStringCoercion(styleValue, styleName);
                  }
                  valueChunk = stringToChunk(escapeTextForBrowser(("" + styleValue).trim()));
                }
              }
              if (isFirst) {
                isFirst = false;
                target5.push(styleAttributeStart, nameChunk, styleAssign, valueChunk);
              } else {
                target5.push(styleSeparator, nameChunk, styleAssign, valueChunk);
              }
            }
            if (!isFirst) {
              target5.push(attributeEnd);
            }
          }
          var attributeSeparator = stringToPrecomputedChunk(" ");
          var attributeAssign = stringToPrecomputedChunk('="');
          var attributeEnd = stringToPrecomputedChunk('"');
          var attributeEmptyString = stringToPrecomputedChunk('=""');
          function pushAttribute(target5, responseState, name16, value13) {
            switch (name16) {
              case "style": {
                pushStyle(target5, responseState, value13);
                return;
              }
              case "defaultValue":
              case "defaultChecked":
              case "innerHTML":
              case "suppressContentEditableWarning":
              case "suppressHydrationWarning":
                return;
            }
            if (name16.length > 2 && (name16[0] === "o" || name16[0] === "O") && (name16[1] === "n" || name16[1] === "N")) {
              return;
            }
            var propertyInfo = getPropertyInfo(name16);
            if (propertyInfo !== null) {
              switch (typeof value13) {
                case "function":
                case "symbol":
                  return;
                case "boolean": {
                  if (!propertyInfo.acceptsBooleans) {
                    return;
                  }
                }
              }
              var attributeName = propertyInfo.attributeName;
              var attributeNameChunk = stringToChunk(attributeName);
              switch (propertyInfo.type) {
                case BOOLEAN:
                  if (value13) {
                    target5.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                  }
                  return;
                case OVERLOADED_BOOLEAN:
                  if (value13 === true) {
                    target5.push(attributeSeparator, attributeNameChunk, attributeEmptyString);
                  } else if (value13 === false)
                    ;
                  else {
                    target5.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value13)), attributeEnd);
                  }
                  return;
                case NUMERIC:
                  if (!isNaN(value13)) {
                    target5.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value13)), attributeEnd);
                  }
                  break;
                case POSITIVE_NUMERIC:
                  if (!isNaN(value13) && value13 >= 1) {
                    target5.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value13)), attributeEnd);
                  }
                  break;
                default:
                  if (propertyInfo.sanitizeURL) {
                    {
                      checkAttributeStringCoercion(value13, attributeName);
                    }
                    value13 = "" + value13;
                    sanitizeURL(value13);
                  }
                  target5.push(attributeSeparator, attributeNameChunk, attributeAssign, stringToChunk(escapeTextForBrowser(value13)), attributeEnd);
              }
            } else if (isAttributeNameSafe(name16)) {
              switch (typeof value13) {
                case "function":
                case "symbol":
                  return;
                case "boolean": {
                  var prefix2 = name16.toLowerCase().slice(0, 5);
                  if (prefix2 !== "data-" && prefix2 !== "aria-") {
                    return;
                  }
                }
              }
              target5.push(attributeSeparator, stringToChunk(name16), attributeAssign, stringToChunk(escapeTextForBrowser(value13)), attributeEnd);
            }
          }
          var endOfStartTag = stringToPrecomputedChunk(">");
          var endOfStartTagSelfClosing = stringToPrecomputedChunk("/>");
          function pushInnerHTML(target5, innerHTML, children) {
            if (innerHTML != null) {
              if (children != null) {
                throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              }
              if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
                throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
              }
              var html = innerHTML.__html;
              if (html !== null && html !== void 0) {
                {
                  checkHtmlStringCoercion(html);
                }
                target5.push(stringToChunk("" + html));
              }
            }
          }
          var didWarnDefaultInputValue = false;
          var didWarnDefaultChecked = false;
          var didWarnDefaultSelectValue = false;
          var didWarnDefaultTextareaValue = false;
          var didWarnInvalidOptionChildren = false;
          var didWarnInvalidOptionInnerHTML = false;
          var didWarnSelectedSetOnOption = false;
          function checkSelectProp(props, propName) {
            {
              var value13 = props[propName];
              if (value13 != null) {
                var array2 = isArray6(value13);
                if (props.multiple && !array2) {
                  error3("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
                } else if (!props.multiple && array2) {
                  error3("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
                }
              }
            }
          }
          function pushStartSelect(target5, props, responseState) {
            {
              checkControlledValueProps("select", props);
              checkSelectProp(props, "value");
              checkSelectProp(props, "defaultValue");
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue) {
                error3("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                didWarnDefaultSelectValue = true;
              }
            }
            target5.push(startChunkForTag("select"));
            var children = null;
            var innerHTML = null;
            for (var propKey in props) {
              if (hasOwnProperty3.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  case "defaultValue":
                  case "value":
                    break;
                  default:
                    pushAttribute(target5, responseState, propKey, propValue);
                    break;
                }
              }
            }
            target5.push(endOfStartTag);
            pushInnerHTML(target5, innerHTML, children);
            return children;
          }
          function flattenOptionChildren(children) {
            var content3 = "";
            React18.Children.forEach(children, function(child) {
              if (child == null) {
                return;
              }
              content3 += child;
              {
                if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
                  didWarnInvalidOptionChildren = true;
                  error3("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.");
                }
              }
            });
            return content3;
          }
          var selectedMarkerAttribute = stringToPrecomputedChunk(' selected=""');
          function pushStartOption(target5, props, responseState, formatContext) {
            var selectedValue = formatContext.selectedValue;
            target5.push(startChunkForTag("option"));
            var children = null;
            var value13 = null;
            var selected2 = null;
            var innerHTML = null;
            for (var propKey in props) {
              if (hasOwnProperty3.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "selected":
                    selected2 = propValue;
                    {
                      if (!didWarnSelectedSetOnOption) {
                        error3("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>.");
                        didWarnSelectedSetOnOption = true;
                      }
                    }
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  case "value":
                    value13 = propValue;
                  default:
                    pushAttribute(target5, responseState, propKey, propValue);
                    break;
                }
              }
            }
            if (selectedValue != null) {
              var stringValue;
              if (value13 !== null) {
                {
                  checkAttributeStringCoercion(value13, "value");
                }
                stringValue = "" + value13;
              } else {
                {
                  if (innerHTML !== null) {
                    if (!didWarnInvalidOptionInnerHTML) {
                      didWarnInvalidOptionInnerHTML = true;
                      error3("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.");
                    }
                  }
                }
                stringValue = flattenOptionChildren(children);
              }
              if (isArray6(selectedValue)) {
                for (var i = 0; i < selectedValue.length; i++) {
                  {
                    checkAttributeStringCoercion(selectedValue[i], "value");
                  }
                  var v = "" + selectedValue[i];
                  if (v === stringValue) {
                    target5.push(selectedMarkerAttribute);
                    break;
                  }
                }
              } else {
                {
                  checkAttributeStringCoercion(selectedValue, "select.value");
                }
                if ("" + selectedValue === stringValue) {
                  target5.push(selectedMarkerAttribute);
                }
              }
            } else if (selected2) {
              target5.push(selectedMarkerAttribute);
            }
            target5.push(endOfStartTag);
            pushInnerHTML(target5, innerHTML, children);
            return children;
          }
          function pushInput(target5, props, responseState) {
            {
              checkControlledValueProps("input", props);
              if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked) {
                error3("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
                didWarnDefaultChecked = true;
              }
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue) {
                error3("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
                didWarnDefaultInputValue = true;
              }
            }
            target5.push(startChunkForTag("input"));
            var value13 = null;
            var defaultValue4 = null;
            var checked2 = null;
            var defaultChecked2 = null;
            for (var propKey in props) {
              if (hasOwnProperty3.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw new Error("input is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                  case "defaultChecked":
                    defaultChecked2 = propValue;
                    break;
                  case "defaultValue":
                    defaultValue4 = propValue;
                    break;
                  case "checked":
                    checked2 = propValue;
                    break;
                  case "value":
                    value13 = propValue;
                    break;
                  default:
                    pushAttribute(target5, responseState, propKey, propValue);
                    break;
                }
              }
            }
            if (checked2 !== null) {
              pushAttribute(target5, responseState, "checked", checked2);
            } else if (defaultChecked2 !== null) {
              pushAttribute(target5, responseState, "checked", defaultChecked2);
            }
            if (value13 !== null) {
              pushAttribute(target5, responseState, "value", value13);
            } else if (defaultValue4 !== null) {
              pushAttribute(target5, responseState, "value", defaultValue4);
            }
            target5.push(endOfStartTagSelfClosing);
            return null;
          }
          function pushStartTextArea(target5, props, responseState) {
            {
              checkControlledValueProps("textarea", props);
              if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue) {
                error3("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                didWarnDefaultTextareaValue = true;
              }
            }
            target5.push(startChunkForTag("textarea"));
            var value13 = null;
            var defaultValue4 = null;
            var children = null;
            for (var propKey in props) {
              if (hasOwnProperty3.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "value":
                    value13 = propValue;
                    break;
                  case "defaultValue":
                    defaultValue4 = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
                  default:
                    pushAttribute(target5, responseState, propKey, propValue);
                    break;
                }
              }
            }
            if (value13 === null && defaultValue4 !== null) {
              value13 = defaultValue4;
            }
            target5.push(endOfStartTag);
            if (children != null) {
              {
                error3("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
              }
              if (value13 != null) {
                throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
              }
              if (isArray6(children)) {
                if (children.length > 1) {
                  throw new Error("<textarea> can only have at most one child.");
                }
                {
                  checkHtmlStringCoercion(children[0]);
                }
                value13 = "" + children[0];
              }
              {
                checkHtmlStringCoercion(children);
              }
              value13 = "" + children;
            }
            if (typeof value13 === "string" && value13[0] === "\n") {
              target5.push(leadingNewline);
            }
            if (value13 !== null) {
              {
                checkAttributeStringCoercion(value13, "value");
              }
              target5.push(stringToChunk(encodeHTMLTextNode("" + value13)));
            }
            return null;
          }
          function pushSelfClosing(target5, props, tag, responseState) {
            target5.push(startChunkForTag(tag));
            for (var propKey in props) {
              if (hasOwnProperty3.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw new Error(tag + " is a self-closing tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
                  default:
                    pushAttribute(target5, responseState, propKey, propValue);
                    break;
                }
              }
            }
            target5.push(endOfStartTagSelfClosing);
            return null;
          }
          function pushStartMenuItem(target5, props, responseState) {
            target5.push(startChunkForTag("menuitem"));
            for (var propKey in props) {
              if (hasOwnProperty3.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw new Error("menuitems cannot have `children` nor `dangerouslySetInnerHTML`.");
                  default:
                    pushAttribute(target5, responseState, propKey, propValue);
                    break;
                }
              }
            }
            target5.push(endOfStartTag);
            return null;
          }
          function pushStartTitle(target5, props, responseState) {
            target5.push(startChunkForTag("title"));
            var children = null;
            for (var propKey in props) {
              if (hasOwnProperty3.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    throw new Error("`dangerouslySetInnerHTML` does not make sense on <title>.");
                  default:
                    pushAttribute(target5, responseState, propKey, propValue);
                    break;
                }
              }
            }
            target5.push(endOfStartTag);
            {
              var child = Array.isArray(children) && children.length < 2 ? children[0] || null : children;
              if (Array.isArray(children) && children.length > 1) {
                error3("A title element received an array with more than 1 element as children. In browsers title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
              } else if (child != null && child.$$typeof != null) {
                error3("A title element received a React element for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
              } else if (child != null && typeof child !== "string" && typeof child !== "number") {
                error3("A title element received a value that was not a string or number for children. In the browser title Elements can only have Text Nodes as children. If the children being rendered output more than a single text node in aggregate the browser will display markup and comments as text in the title and hydration will likely fail and fall back to client rendering");
              }
            }
            return children;
          }
          function pushStartGenericElement(target5, props, tag, responseState) {
            target5.push(startChunkForTag(tag));
            var children = null;
            var innerHTML = null;
            for (var propKey in props) {
              if (hasOwnProperty3.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  default:
                    pushAttribute(target5, responseState, propKey, propValue);
                    break;
                }
              }
            }
            target5.push(endOfStartTag);
            pushInnerHTML(target5, innerHTML, children);
            if (typeof children === "string") {
              target5.push(stringToChunk(encodeHTMLTextNode(children)));
              return null;
            }
            return children;
          }
          function pushStartCustomElement(target5, props, tag, responseState) {
            target5.push(startChunkForTag(tag));
            var children = null;
            var innerHTML = null;
            for (var propKey in props) {
              if (hasOwnProperty3.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  case "style":
                    pushStyle(target5, responseState, propValue);
                    break;
                  case "suppressContentEditableWarning":
                  case "suppressHydrationWarning":
                    break;
                  default:
                    if (isAttributeNameSafe(propKey) && typeof propValue !== "function" && typeof propValue !== "symbol") {
                      target5.push(attributeSeparator, stringToChunk(propKey), attributeAssign, stringToChunk(escapeTextForBrowser(propValue)), attributeEnd);
                    }
                    break;
                }
              }
            }
            target5.push(endOfStartTag);
            pushInnerHTML(target5, innerHTML, children);
            return children;
          }
          var leadingNewline = stringToPrecomputedChunk("\n");
          function pushStartPreformattedElement(target5, props, tag, responseState) {
            target5.push(startChunkForTag(tag));
            var children = null;
            var innerHTML = null;
            for (var propKey in props) {
              if (hasOwnProperty3.call(props, propKey)) {
                var propValue = props[propKey];
                if (propValue == null) {
                  continue;
                }
                switch (propKey) {
                  case "children":
                    children = propValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    innerHTML = propValue;
                    break;
                  default:
                    pushAttribute(target5, responseState, propKey, propValue);
                    break;
                }
              }
            }
            target5.push(endOfStartTag);
            if (innerHTML != null) {
              if (children != null) {
                throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              }
              if (typeof innerHTML !== "object" || !("__html" in innerHTML)) {
                throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
              }
              var html = innerHTML.__html;
              if (html !== null && html !== void 0) {
                if (typeof html === "string" && html.length > 0 && html[0] === "\n") {
                  target5.push(leadingNewline, stringToChunk(html));
                } else {
                  {
                    checkHtmlStringCoercion(html);
                  }
                  target5.push(stringToChunk("" + html));
                }
              }
            }
            if (typeof children === "string" && children[0] === "\n") {
              target5.push(leadingNewline);
            }
            return children;
          }
          var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
          var validatedTagCache = /* @__PURE__ */ new Map();
          function startChunkForTag(tag) {
            var tagStartChunk = validatedTagCache.get(tag);
            if (tagStartChunk === void 0) {
              if (!VALID_TAG_REGEX.test(tag)) {
                throw new Error("Invalid tag: " + tag);
              }
              tagStartChunk = stringToPrecomputedChunk("<" + tag);
              validatedTagCache.set(tag, tagStartChunk);
            }
            return tagStartChunk;
          }
          var DOCTYPE = stringToPrecomputedChunk("<!DOCTYPE html>");
          function pushStartInstance(target5, type, props, responseState, formatContext) {
            {
              validateProperties(type, props);
              validateProperties$1(type, props);
              validateProperties$2(type, props, null);
              if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
                error3("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
              }
              if (formatContext.insertionMode !== SVG_MODE && formatContext.insertionMode !== MATHML_MODE) {
                if (type.indexOf("-") === -1 && typeof props.is !== "string" && type.toLowerCase() !== type) {
                  error3("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type);
                }
              }
            }
            switch (type) {
              case "select":
                return pushStartSelect(target5, props, responseState);
              case "option":
                return pushStartOption(target5, props, responseState, formatContext);
              case "textarea":
                return pushStartTextArea(target5, props, responseState);
              case "input":
                return pushInput(target5, props, responseState);
              case "menuitem":
                return pushStartMenuItem(target5, props, responseState);
              case "title":
                return pushStartTitle(target5, props, responseState);
              case "listing":
              case "pre": {
                return pushStartPreformattedElement(target5, props, type, responseState);
              }
              case "area":
              case "base":
              case "br":
              case "col":
              case "embed":
              case "hr":
              case "img":
              case "keygen":
              case "link":
              case "meta":
              case "param":
              case "source":
              case "track":
              case "wbr": {
                return pushSelfClosing(target5, props, type, responseState);
              }
              case "annotation-xml":
              case "color-profile":
              case "font-face":
              case "font-face-src":
              case "font-face-uri":
              case "font-face-format":
              case "font-face-name":
              case "missing-glyph": {
                return pushStartGenericElement(target5, props, type, responseState);
              }
              case "html": {
                if (formatContext.insertionMode === ROOT_HTML_MODE) {
                  target5.push(DOCTYPE);
                }
                return pushStartGenericElement(target5, props, type, responseState);
              }
              default: {
                if (type.indexOf("-") === -1 && typeof props.is !== "string") {
                  return pushStartGenericElement(target5, props, type, responseState);
                } else {
                  return pushStartCustomElement(target5, props, type, responseState);
                }
              }
            }
          }
          var endTag1 = stringToPrecomputedChunk("</");
          var endTag2 = stringToPrecomputedChunk(">");
          function pushEndInstance(target5, type, props) {
            switch (type) {
              case "area":
              case "base":
              case "br":
              case "col":
              case "embed":
              case "hr":
              case "img":
              case "input":
              case "keygen":
              case "link":
              case "meta":
              case "param":
              case "source":
              case "track":
              case "wbr": {
                break;
              }
              default: {
                target5.push(endTag1, stringToChunk(type), endTag2);
              }
            }
          }
          function writeCompletedRoot(destination, responseState) {
            var bootstrapChunks = responseState.bootstrapChunks;
            var i = 0;
            for (; i < bootstrapChunks.length - 1; i++) {
              writeChunk(destination, bootstrapChunks[i]);
            }
            if (i < bootstrapChunks.length) {
              return writeChunkAndReturn(destination, bootstrapChunks[i]);
            }
            return true;
          }
          var placeholder1 = stringToPrecomputedChunk('<template id="');
          var placeholder22 = stringToPrecomputedChunk('"></template>');
          function writePlaceholder(destination, responseState, id2) {
            writeChunk(destination, placeholder1);
            writeChunk(destination, responseState.placeholderPrefix);
            var formattedID = stringToChunk(id2.toString(16));
            writeChunk(destination, formattedID);
            return writeChunkAndReturn(destination, placeholder22);
          }
          var startCompletedSuspenseBoundary = stringToPrecomputedChunk("<!--$-->");
          var startPendingSuspenseBoundary1 = stringToPrecomputedChunk('<!--$?--><template id="');
          var startPendingSuspenseBoundary2 = stringToPrecomputedChunk('"></template>');
          var startClientRenderedSuspenseBoundary = stringToPrecomputedChunk("<!--$!-->");
          var endSuspenseBoundary = stringToPrecomputedChunk("<!--/$-->");
          var clientRenderedSuspenseBoundaryError1 = stringToPrecomputedChunk("<template");
          var clientRenderedSuspenseBoundaryErrorAttrInterstitial = stringToPrecomputedChunk('"');
          var clientRenderedSuspenseBoundaryError1A = stringToPrecomputedChunk(' data-dgst="');
          var clientRenderedSuspenseBoundaryError1B = stringToPrecomputedChunk(' data-msg="');
          var clientRenderedSuspenseBoundaryError1C = stringToPrecomputedChunk(' data-stck="');
          var clientRenderedSuspenseBoundaryError2 = stringToPrecomputedChunk("></template>");
          function writeStartCompletedSuspenseBoundary(destination, responseState) {
            return writeChunkAndReturn(destination, startCompletedSuspenseBoundary);
          }
          function writeStartPendingSuspenseBoundary(destination, responseState, id2) {
            writeChunk(destination, startPendingSuspenseBoundary1);
            if (id2 === null) {
              throw new Error("An ID must have been assigned before we can complete the boundary.");
            }
            writeChunk(destination, id2);
            return writeChunkAndReturn(destination, startPendingSuspenseBoundary2);
          }
          function writeStartClientRenderedSuspenseBoundary(destination, responseState, errorDigest, errorMesssage, errorComponentStack) {
            var result;
            result = writeChunkAndReturn(destination, startClientRenderedSuspenseBoundary);
            writeChunk(destination, clientRenderedSuspenseBoundaryError1);
            if (errorDigest) {
              writeChunk(destination, clientRenderedSuspenseBoundaryError1A);
              writeChunk(destination, stringToChunk(escapeTextForBrowser(errorDigest)));
              writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
            }
            {
              if (errorMesssage) {
                writeChunk(destination, clientRenderedSuspenseBoundaryError1B);
                writeChunk(destination, stringToChunk(escapeTextForBrowser(errorMesssage)));
                writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
              }
              if (errorComponentStack) {
                writeChunk(destination, clientRenderedSuspenseBoundaryError1C);
                writeChunk(destination, stringToChunk(escapeTextForBrowser(errorComponentStack)));
                writeChunk(destination, clientRenderedSuspenseBoundaryErrorAttrInterstitial);
              }
            }
            result = writeChunkAndReturn(destination, clientRenderedSuspenseBoundaryError2);
            return result;
          }
          function writeEndCompletedSuspenseBoundary(destination, responseState) {
            return writeChunkAndReturn(destination, endSuspenseBoundary);
          }
          function writeEndPendingSuspenseBoundary(destination, responseState) {
            return writeChunkAndReturn(destination, endSuspenseBoundary);
          }
          function writeEndClientRenderedSuspenseBoundary(destination, responseState) {
            return writeChunkAndReturn(destination, endSuspenseBoundary);
          }
          var startSegmentHTML = stringToPrecomputedChunk('<div hidden id="');
          var startSegmentHTML2 = stringToPrecomputedChunk('">');
          var endSegmentHTML = stringToPrecomputedChunk("</div>");
          var startSegmentSVG = stringToPrecomputedChunk('<svg aria-hidden="true" style="display:none" id="');
          var startSegmentSVG2 = stringToPrecomputedChunk('">');
          var endSegmentSVG = stringToPrecomputedChunk("</svg>");
          var startSegmentMathML = stringToPrecomputedChunk('<math aria-hidden="true" style="display:none" id="');
          var startSegmentMathML2 = stringToPrecomputedChunk('">');
          var endSegmentMathML = stringToPrecomputedChunk("</math>");
          var startSegmentTable = stringToPrecomputedChunk('<table hidden id="');
          var startSegmentTable2 = stringToPrecomputedChunk('">');
          var endSegmentTable = stringToPrecomputedChunk("</table>");
          var startSegmentTableBody = stringToPrecomputedChunk('<table hidden><tbody id="');
          var startSegmentTableBody2 = stringToPrecomputedChunk('">');
          var endSegmentTableBody = stringToPrecomputedChunk("</tbody></table>");
          var startSegmentTableRow = stringToPrecomputedChunk('<table hidden><tr id="');
          var startSegmentTableRow2 = stringToPrecomputedChunk('">');
          var endSegmentTableRow = stringToPrecomputedChunk("</tr></table>");
          var startSegmentColGroup = stringToPrecomputedChunk('<table hidden><colgroup id="');
          var startSegmentColGroup2 = stringToPrecomputedChunk('">');
          var endSegmentColGroup = stringToPrecomputedChunk("</colgroup></table>");
          function writeStartSegment(destination, responseState, formatContext, id2) {
            switch (formatContext.insertionMode) {
              case ROOT_HTML_MODE:
              case HTML_MODE: {
                writeChunk(destination, startSegmentHTML);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id2.toString(16)));
                return writeChunkAndReturn(destination, startSegmentHTML2);
              }
              case SVG_MODE: {
                writeChunk(destination, startSegmentSVG);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id2.toString(16)));
                return writeChunkAndReturn(destination, startSegmentSVG2);
              }
              case MATHML_MODE: {
                writeChunk(destination, startSegmentMathML);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id2.toString(16)));
                return writeChunkAndReturn(destination, startSegmentMathML2);
              }
              case HTML_TABLE_MODE: {
                writeChunk(destination, startSegmentTable);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id2.toString(16)));
                return writeChunkAndReturn(destination, startSegmentTable2);
              }
              case HTML_TABLE_BODY_MODE: {
                writeChunk(destination, startSegmentTableBody);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id2.toString(16)));
                return writeChunkAndReturn(destination, startSegmentTableBody2);
              }
              case HTML_TABLE_ROW_MODE: {
                writeChunk(destination, startSegmentTableRow);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id2.toString(16)));
                return writeChunkAndReturn(destination, startSegmentTableRow2);
              }
              case HTML_COLGROUP_MODE: {
                writeChunk(destination, startSegmentColGroup);
                writeChunk(destination, responseState.segmentPrefix);
                writeChunk(destination, stringToChunk(id2.toString(16)));
                return writeChunkAndReturn(destination, startSegmentColGroup2);
              }
              default: {
                throw new Error("Unknown insertion mode. This is a bug in React.");
              }
            }
          }
          function writeEndSegment(destination, formatContext) {
            switch (formatContext.insertionMode) {
              case ROOT_HTML_MODE:
              case HTML_MODE: {
                return writeChunkAndReturn(destination, endSegmentHTML);
              }
              case SVG_MODE: {
                return writeChunkAndReturn(destination, endSegmentSVG);
              }
              case MATHML_MODE: {
                return writeChunkAndReturn(destination, endSegmentMathML);
              }
              case HTML_TABLE_MODE: {
                return writeChunkAndReturn(destination, endSegmentTable);
              }
              case HTML_TABLE_BODY_MODE: {
                return writeChunkAndReturn(destination, endSegmentTableBody);
              }
              case HTML_TABLE_ROW_MODE: {
                return writeChunkAndReturn(destination, endSegmentTableRow);
              }
              case HTML_COLGROUP_MODE: {
                return writeChunkAndReturn(destination, endSegmentColGroup);
              }
              default: {
                throw new Error("Unknown insertion mode. This is a bug in React.");
              }
            }
          }
          var completeSegmentFunction = "function $RS(a,b){a=document.getElementById(a);b=document.getElementById(b);for(a.parentNode.removeChild(a);a.firstChild;)b.parentNode.insertBefore(a.firstChild,b);b.parentNode.removeChild(b)}";
          var completeBoundaryFunction = 'function $RC(a,b){a=document.getElementById(a);b=document.getElementById(b);b.parentNode.removeChild(b);if(a){a=a.previousSibling;var f=a.parentNode,c=a.nextSibling,e=0;do{if(c&&8===c.nodeType){var d=c.data;if("/$"===d)if(0===e)break;else e--;else"$"!==d&&"$?"!==d&&"$!"!==d||e++}d=c.nextSibling;f.removeChild(c);c=d}while(c);for(;b.firstChild;)f.insertBefore(b.firstChild,c);a.data="$";a._reactRetry&&a._reactRetry()}}';
          var clientRenderFunction = 'function $RX(b,c,d,e){var a=document.getElementById(b);a&&(b=a.previousSibling,b.data="$!",a=a.dataset,c&&(a.dgst=c),d&&(a.msg=d),e&&(a.stck=e),b._reactRetry&&b._reactRetry())}';
          var completeSegmentScript1Full = stringToPrecomputedChunk(completeSegmentFunction + ';$RS("');
          var completeSegmentScript1Partial = stringToPrecomputedChunk('$RS("');
          var completeSegmentScript2 = stringToPrecomputedChunk('","');
          var completeSegmentScript3 = stringToPrecomputedChunk('")<\/script>');
          function writeCompletedSegmentInstruction(destination, responseState, contentSegmentID) {
            writeChunk(destination, responseState.startInlineScript);
            if (!responseState.sentCompleteSegmentFunction) {
              responseState.sentCompleteSegmentFunction = true;
              writeChunk(destination, completeSegmentScript1Full);
            } else {
              writeChunk(destination, completeSegmentScript1Partial);
            }
            writeChunk(destination, responseState.segmentPrefix);
            var formattedID = stringToChunk(contentSegmentID.toString(16));
            writeChunk(destination, formattedID);
            writeChunk(destination, completeSegmentScript2);
            writeChunk(destination, responseState.placeholderPrefix);
            writeChunk(destination, formattedID);
            return writeChunkAndReturn(destination, completeSegmentScript3);
          }
          var completeBoundaryScript1Full = stringToPrecomputedChunk(completeBoundaryFunction + ';$RC("');
          var completeBoundaryScript1Partial = stringToPrecomputedChunk('$RC("');
          var completeBoundaryScript2 = stringToPrecomputedChunk('","');
          var completeBoundaryScript3 = stringToPrecomputedChunk('")<\/script>');
          function writeCompletedBoundaryInstruction(destination, responseState, boundaryID, contentSegmentID) {
            writeChunk(destination, responseState.startInlineScript);
            if (!responseState.sentCompleteBoundaryFunction) {
              responseState.sentCompleteBoundaryFunction = true;
              writeChunk(destination, completeBoundaryScript1Full);
            } else {
              writeChunk(destination, completeBoundaryScript1Partial);
            }
            if (boundaryID === null) {
              throw new Error("An ID must have been assigned before we can complete the boundary.");
            }
            var formattedContentID = stringToChunk(contentSegmentID.toString(16));
            writeChunk(destination, boundaryID);
            writeChunk(destination, completeBoundaryScript2);
            writeChunk(destination, responseState.segmentPrefix);
            writeChunk(destination, formattedContentID);
            return writeChunkAndReturn(destination, completeBoundaryScript3);
          }
          var clientRenderScript1Full = stringToPrecomputedChunk(clientRenderFunction + ';$RX("');
          var clientRenderScript1Partial = stringToPrecomputedChunk('$RX("');
          var clientRenderScript1A = stringToPrecomputedChunk('"');
          var clientRenderScript2 = stringToPrecomputedChunk(")<\/script>");
          var clientRenderErrorScriptArgInterstitial = stringToPrecomputedChunk(",");
          function writeClientRenderBoundaryInstruction(destination, responseState, boundaryID, errorDigest, errorMessage, errorComponentStack) {
            writeChunk(destination, responseState.startInlineScript);
            if (!responseState.sentClientRenderFunction) {
              responseState.sentClientRenderFunction = true;
              writeChunk(destination, clientRenderScript1Full);
            } else {
              writeChunk(destination, clientRenderScript1Partial);
            }
            if (boundaryID === null) {
              throw new Error("An ID must have been assigned before we can complete the boundary.");
            }
            writeChunk(destination, boundaryID);
            writeChunk(destination, clientRenderScript1A);
            if (errorDigest || errorMessage || errorComponentStack) {
              writeChunk(destination, clientRenderErrorScriptArgInterstitial);
              writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorDigest || "")));
            }
            if (errorMessage || errorComponentStack) {
              writeChunk(destination, clientRenderErrorScriptArgInterstitial);
              writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorMessage || "")));
            }
            if (errorComponentStack) {
              writeChunk(destination, clientRenderErrorScriptArgInterstitial);
              writeChunk(destination, stringToChunk(escapeJSStringsForInstructionScripts(errorComponentStack)));
            }
            return writeChunkAndReturn(destination, clientRenderScript2);
          }
          var regexForJSStringsInScripts = /[<\u2028\u2029]/g;
          function escapeJSStringsForInstructionScripts(input) {
            var escaped = JSON.stringify(input);
            return escaped.replace(regexForJSStringsInScripts, function(match) {
              switch (match) {
                case "<":
                  return "\\u003c";
                case "\u2028":
                  return "\\u2028";
                case "\u2029":
                  return "\\u2029";
                default: {
                  throw new Error("escapeJSStringsForInstructionScripts encountered a match it does not know how to replace. this means the match regex and the replacement characters are no longer in sync. This is a bug in React");
                }
              }
            });
          }
          var assign2 = Object.assign;
          var REACT_ELEMENT_TYPE = Symbol.for("react.element");
          var REACT_PORTAL_TYPE = Symbol.for("react.portal");
          var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
          var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
          var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
          var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
          var REACT_CONTEXT_TYPE = Symbol.for("react.context");
          var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
          var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
          var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
          var REACT_MEMO_TYPE = Symbol.for("react.memo");
          var REACT_LAZY_TYPE = Symbol.for("react.lazy");
          var REACT_SCOPE_TYPE = Symbol.for("react.scope");
          var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
          var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
          var REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED = Symbol.for("react.default_value");
          var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
          var FAUX_ITERATOR_SYMBOL = "@@iterator";
          function getIteratorFn(maybeIterable) {
            if (maybeIterable === null || typeof maybeIterable !== "object") {
              return null;
            }
            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
            if (typeof maybeIterator === "function") {
              return maybeIterator;
            }
            return null;
          }
          function getWrappedName(outerType, innerType, wrapperName) {
            var displayName = outerType.displayName;
            if (displayName) {
              return displayName;
            }
            var functionName = innerType.displayName || innerType.name || "";
            return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
          }
          function getContextName(type) {
            return type.displayName || "Context";
          }
          function getComponentNameFromType(type) {
            if (type == null) {
              return null;
            }
            {
              if (typeof type.tag === "number") {
                error3("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");
              }
            }
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return "Fragment";
              case REACT_PORTAL_TYPE:
                return "Portal";
              case REACT_PROFILER_TYPE:
                return "Profiler";
              case REACT_STRICT_MODE_TYPE:
                return "StrictMode";
              case REACT_SUSPENSE_TYPE:
                return "Suspense";
              case REACT_SUSPENSE_LIST_TYPE:
                return "SuspenseList";
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_CONTEXT_TYPE:
                  var context = type;
                  return getContextName(context) + ".Consumer";
                case REACT_PROVIDER_TYPE:
                  var provider = type;
                  return getContextName(provider._context) + ".Provider";
                case REACT_FORWARD_REF_TYPE:
                  return getWrappedName(type, type.render, "ForwardRef");
                case REACT_MEMO_TYPE:
                  var outerName = type.displayName || null;
                  if (outerName !== null) {
                    return outerName;
                  }
                  return getComponentNameFromType(type.type) || "Memo";
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init3 = lazyComponent._init;
                  try {
                    return getComponentNameFromType(init3(payload));
                  } catch (x) {
                    return null;
                  }
                }
              }
            }
            return null;
          }
          var disabledDepth = 0;
          var prevLog;
          var prevInfo;
          var prevWarn;
          var prevError;
          var prevGroup;
          var prevGroupCollapsed;
          var prevGroupEnd;
          function disabledLog() {
          }
          disabledLog.__reactDisabledLog = true;
          function disableLogs() {
            {
              if (disabledDepth === 0) {
                prevLog = console.log;
                prevInfo = console.info;
                prevWarn = console.warn;
                prevError = console.error;
                prevGroup = console.group;
                prevGroupCollapsed = console.groupCollapsed;
                prevGroupEnd = console.groupEnd;
                var props = {
                  configurable: true,
                  enumerable: true,
                  value: disabledLog,
                  writable: true
                };
                Object.defineProperties(console, {
                  info: props,
                  log: props,
                  warn: props,
                  error: props,
                  group: props,
                  groupCollapsed: props,
                  groupEnd: props
                });
              }
              disabledDepth++;
            }
          }
          function reenableLogs() {
            {
              disabledDepth--;
              if (disabledDepth === 0) {
                var props = {
                  configurable: true,
                  enumerable: true,
                  writable: true
                };
                Object.defineProperties(console, {
                  log: assign2({}, props, {
                    value: prevLog
                  }),
                  info: assign2({}, props, {
                    value: prevInfo
                  }),
                  warn: assign2({}, props, {
                    value: prevWarn
                  }),
                  error: assign2({}, props, {
                    value: prevError
                  }),
                  group: assign2({}, props, {
                    value: prevGroup
                  }),
                  groupCollapsed: assign2({}, props, {
                    value: prevGroupCollapsed
                  }),
                  groupEnd: assign2({}, props, {
                    value: prevGroupEnd
                  })
                });
              }
              if (disabledDepth < 0) {
                error3("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
              }
            }
          }
          var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
          var prefix;
          function describeBuiltInComponentFrame(name16, source, ownerFn) {
            {
              if (prefix === void 0) {
                try {
                  throw Error();
                } catch (x) {
                  var match = x.stack.trim().match(/\n( *(at )?)/);
                  prefix = match && match[1] || "";
                }
              }
              return "\n" + prefix + name16;
            }
          }
          var reentry = false;
          var componentFrameCache;
          {
            var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
            componentFrameCache = new PossiblyWeakMap();
          }
          function describeNativeComponentFrame(fn, construct) {
            if (!fn || reentry) {
              return "";
            }
            {
              var frame = componentFrameCache.get(fn);
              if (frame !== void 0) {
                return frame;
              }
            }
            var control;
            reentry = true;
            var previousPrepareStackTrace = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            var previousDispatcher;
            {
              previousDispatcher = ReactCurrentDispatcher.current;
              ReactCurrentDispatcher.current = null;
              disableLogs();
            }
            try {
              if (construct) {
                var Fake = function() {
                  throw Error();
                };
                Object.defineProperty(Fake.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                });
                if (typeof Reflect === "object" && Reflect.construct) {
                  try {
                    Reflect.construct(Fake, []);
                  } catch (x) {
                    control = x;
                  }
                  Reflect.construct(fn, [], Fake);
                } else {
                  try {
                    Fake.call();
                  } catch (x) {
                    control = x;
                  }
                  fn.call(Fake.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (x) {
                  control = x;
                }
                fn();
              }
            } catch (sample) {
              if (sample && control && typeof sample.stack === "string") {
                var sampleLines = sample.stack.split("\n");
                var controlLines = control.stack.split("\n");
                var s = sampleLines.length - 1;
                var c = controlLines.length - 1;
                while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
                  c--;
                }
                for (; s >= 1 && c >= 0; s--, c--) {
                  if (sampleLines[s] !== controlLines[c]) {
                    if (s !== 1 || c !== 1) {
                      do {
                        s--;
                        c--;
                        if (c < 0 || sampleLines[s] !== controlLines[c]) {
                          var _frame = "\n" + sampleLines[s].replace(" at new ", " at ");
                          if (fn.displayName && _frame.includes("<anonymous>")) {
                            _frame = _frame.replace("<anonymous>", fn.displayName);
                          }
                          {
                            if (typeof fn === "function") {
                              componentFrameCache.set(fn, _frame);
                            }
                          }
                          return _frame;
                        }
                      } while (s >= 1 && c >= 0);
                    }
                    break;
                  }
                }
              }
            } finally {
              reentry = false;
              {
                ReactCurrentDispatcher.current = previousDispatcher;
                reenableLogs();
              }
              Error.prepareStackTrace = previousPrepareStackTrace;
            }
            var name16 = fn ? fn.displayName || fn.name : "";
            var syntheticFrame = name16 ? describeBuiltInComponentFrame(name16) : "";
            {
              if (typeof fn === "function") {
                componentFrameCache.set(fn, syntheticFrame);
              }
            }
            return syntheticFrame;
          }
          function describeClassComponentFrame(ctor, source, ownerFn) {
            {
              return describeNativeComponentFrame(ctor, true);
            }
          }
          function describeFunctionComponentFrame(fn, source, ownerFn) {
            {
              return describeNativeComponentFrame(fn, false);
            }
          }
          function shouldConstruct(Component2) {
            var prototype = Component2.prototype;
            return !!(prototype && prototype.isReactComponent);
          }
          function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
            if (type == null) {
              return "";
            }
            if (typeof type === "function") {
              {
                return describeNativeComponentFrame(type, shouldConstruct(type));
              }
            }
            if (typeof type === "string") {
              return describeBuiltInComponentFrame(type);
            }
            switch (type) {
              case REACT_SUSPENSE_TYPE:
                return describeBuiltInComponentFrame("Suspense");
              case REACT_SUSPENSE_LIST_TYPE:
                return describeBuiltInComponentFrame("SuspenseList");
            }
            if (typeof type === "object") {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE:
                  return describeFunctionComponentFrame(type.render);
                case REACT_MEMO_TYPE:
                  return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
                case REACT_LAZY_TYPE: {
                  var lazyComponent = type;
                  var payload = lazyComponent._payload;
                  var init3 = lazyComponent._init;
                  try {
                    return describeUnknownElementTypeFrameInDEV(init3(payload), source, ownerFn);
                  } catch (x) {
                  }
                }
              }
            }
            return "";
          }
          var loggedTypeFailures = {};
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          function setCurrentlyValidatingElement(element) {
            {
              if (element) {
                var owner = element._owner;
                var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
                ReactDebugCurrentFrame.setExtraStackFrame(stack);
              } else {
                ReactDebugCurrentFrame.setExtraStackFrame(null);
              }
            }
          }
          function checkPropTypes3(typeSpecs, values2, location2, componentName, element) {
            {
              var has = Function.call.bind(hasOwnProperty3);
              for (var typeSpecName in typeSpecs) {
                if (has(typeSpecs, typeSpecName)) {
                  var error$1 = void 0;
                  try {
                    if (typeof typeSpecs[typeSpecName] !== "function") {
                      var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                      err.name = "Invariant Violation";
                      throw err;
                    }
                    error$1 = typeSpecs[typeSpecName](values2, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                  } catch (ex) {
                    error$1 = ex;
                  }
                  if (error$1 && !(error$1 instanceof Error)) {
                    setCurrentlyValidatingElement(element);
                    error3("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                    setCurrentlyValidatingElement(null);
                  }
                  if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                    loggedTypeFailures[error$1.message] = true;
                    setCurrentlyValidatingElement(element);
                    error3("Failed %s type: %s", location2, error$1.message);
                    setCurrentlyValidatingElement(null);
                  }
                }
              }
            }
          }
          var warnedAboutMissingGetChildContext;
          {
            warnedAboutMissingGetChildContext = {};
          }
          var emptyContextObject = {};
          {
            Object.freeze(emptyContextObject);
          }
          function getMaskedContext(type, unmaskedContext) {
            {
              var contextTypes = type.contextTypes;
              if (!contextTypes) {
                return emptyContextObject;
              }
              var context = {};
              for (var key in contextTypes) {
                context[key] = unmaskedContext[key];
              }
              {
                var name16 = getComponentNameFromType(type) || "Unknown";
                checkPropTypes3(contextTypes, context, "context", name16);
              }
              return context;
            }
          }
          function processChildContext(instance, type, parentContext, childContextTypes) {
            {
              if (typeof instance.getChildContext !== "function") {
                {
                  var componentName = getComponentNameFromType(type) || "Unknown";
                  if (!warnedAboutMissingGetChildContext[componentName]) {
                    warnedAboutMissingGetChildContext[componentName] = true;
                    error3("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName);
                  }
                }
                return parentContext;
              }
              var childContext = instance.getChildContext();
              for (var contextKey in childContext) {
                if (!(contextKey in childContextTypes)) {
                  throw new Error((getComponentNameFromType(type) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
                }
              }
              {
                var name16 = getComponentNameFromType(type) || "Unknown";
                checkPropTypes3(childContextTypes, childContext, "child context", name16);
              }
              return assign2({}, parentContext, childContext);
            }
          }
          var rendererSigil;
          {
            rendererSigil = {};
          }
          var rootContextSnapshot = null;
          var currentActiveSnapshot = null;
          function popNode(prev) {
            {
              prev.context._currentValue = prev.parentValue;
            }
          }
          function pushNode(next) {
            {
              next.context._currentValue = next.value;
            }
          }
          function popToNearestCommonAncestor(prev, next) {
            if (prev === next)
              ;
            else {
              popNode(prev);
              var parentPrev = prev.parent;
              var parentNext = next.parent;
              if (parentPrev === null) {
                if (parentNext !== null) {
                  throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
                }
              } else {
                if (parentNext === null) {
                  throw new Error("The stacks must reach the root at the same time. This is a bug in React.");
                }
                popToNearestCommonAncestor(parentPrev, parentNext);
              }
              pushNode(next);
            }
          }
          function popAllPrevious(prev) {
            popNode(prev);
            var parentPrev = prev.parent;
            if (parentPrev !== null) {
              popAllPrevious(parentPrev);
            }
          }
          function pushAllNext(next) {
            var parentNext = next.parent;
            if (parentNext !== null) {
              pushAllNext(parentNext);
            }
            pushNode(next);
          }
          function popPreviousToCommonLevel(prev, next) {
            popNode(prev);
            var parentPrev = prev.parent;
            if (parentPrev === null) {
              throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
            }
            if (parentPrev.depth === next.depth) {
              popToNearestCommonAncestor(parentPrev, next);
            } else {
              popPreviousToCommonLevel(parentPrev, next);
            }
          }
          function popNextToCommonLevel(prev, next) {
            var parentNext = next.parent;
            if (parentNext === null) {
              throw new Error("The depth must equal at least at zero before reaching the root. This is a bug in React.");
            }
            if (prev.depth === parentNext.depth) {
              popToNearestCommonAncestor(prev, parentNext);
            } else {
              popNextToCommonLevel(prev, parentNext);
            }
            pushNode(next);
          }
          function switchContext(newSnapshot) {
            var prev = currentActiveSnapshot;
            var next = newSnapshot;
            if (prev !== next) {
              if (prev === null) {
                pushAllNext(next);
              } else if (next === null) {
                popAllPrevious(prev);
              } else if (prev.depth === next.depth) {
                popToNearestCommonAncestor(prev, next);
              } else if (prev.depth > next.depth) {
                popPreviousToCommonLevel(prev, next);
              } else {
                popNextToCommonLevel(prev, next);
              }
              currentActiveSnapshot = next;
            }
          }
          function pushProvider(context, nextValue) {
            var prevValue;
            {
              prevValue = context._currentValue;
              context._currentValue = nextValue;
              {
                if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                  error3("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
                }
                context._currentRenderer = rendererSigil;
              }
            }
            var prevNode = currentActiveSnapshot;
            var newNode = {
              parent: prevNode,
              depth: prevNode === null ? 0 : prevNode.depth + 1,
              context,
              parentValue: prevValue,
              value: nextValue
            };
            currentActiveSnapshot = newNode;
            return newNode;
          }
          function popProvider(context) {
            var prevSnapshot = currentActiveSnapshot;
            if (prevSnapshot === null) {
              throw new Error("Tried to pop a Context at the root of the app. This is a bug in React.");
            }
            {
              if (prevSnapshot.context !== context) {
                error3("The parent context is not the expected context. This is probably a bug in React.");
              }
            }
            {
              var value13 = prevSnapshot.parentValue;
              if (value13 === REACT_SERVER_CONTEXT_DEFAULT_VALUE_NOT_LOADED) {
                prevSnapshot.context._currentValue = prevSnapshot.context._defaultValue;
              } else {
                prevSnapshot.context._currentValue = value13;
              }
              {
                if (context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
                  error3("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported.");
                }
                context._currentRenderer = rendererSigil;
              }
            }
            return currentActiveSnapshot = prevSnapshot.parent;
          }
          function getActiveContext() {
            return currentActiveSnapshot;
          }
          function readContext(context) {
            var value13 = context._currentValue;
            return value13;
          }
          function get3(key) {
            return key._reactInternals;
          }
          function set(key, value13) {
            key._reactInternals = value13;
          }
          var didWarnAboutNoopUpdateForComponent = {};
          var didWarnAboutDeprecatedWillMount = {};
          var didWarnAboutUninitializedState;
          var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
          var didWarnAboutLegacyLifecyclesAndDerivedState;
          var didWarnAboutUndefinedDerivedState;
          var warnOnUndefinedDerivedState;
          var warnOnInvalidCallback;
          var didWarnAboutDirectlyAssigningPropsToState;
          var didWarnAboutContextTypeAndContextTypes;
          var didWarnAboutInvalidateContextType;
          {
            didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
            didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
            didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
            didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set();
            didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
            var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
            warnOnInvalidCallback = function(callback, callerName) {
              if (callback === null || typeof callback === "function") {
                return;
              }
              var key = callerName + "_" + callback;
              if (!didWarnOnInvalidCallback.has(key)) {
                didWarnOnInvalidCallback.add(key);
                error3("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
              }
            };
            warnOnUndefinedDerivedState = function(type, partialState) {
              if (partialState === void 0) {
                var componentName = getComponentNameFromType(type) || "Component";
                if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
                  didWarnAboutUndefinedDerivedState.add(componentName);
                  error3("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName);
                }
              }
            };
          }
          function warnNoop(publicInstance, callerName) {
            {
              var _constructor = publicInstance.constructor;
              var componentName = _constructor && getComponentNameFromType(_constructor) || "ReactClass";
              var warningKey = componentName + "." + callerName;
              if (didWarnAboutNoopUpdateForComponent[warningKey]) {
                return;
              }
              error3("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
              didWarnAboutNoopUpdateForComponent[warningKey] = true;
            }
          }
          var classComponentUpdater = {
            isMounted: function(inst) {
              return false;
            },
            enqueueSetState: function(inst, payload, callback) {
              var internals = get3(inst);
              if (internals.queue === null) {
                warnNoop(inst, "setState");
              } else {
                internals.queue.push(payload);
                {
                  if (callback !== void 0 && callback !== null) {
                    warnOnInvalidCallback(callback, "setState");
                  }
                }
              }
            },
            enqueueReplaceState: function(inst, payload, callback) {
              var internals = get3(inst);
              internals.replace = true;
              internals.queue = [payload];
              {
                if (callback !== void 0 && callback !== null) {
                  warnOnInvalidCallback(callback, "setState");
                }
              }
            },
            enqueueForceUpdate: function(inst, callback) {
              var internals = get3(inst);
              if (internals.queue === null) {
                warnNoop(inst, "forceUpdate");
              } else {
                {
                  if (callback !== void 0 && callback !== null) {
                    warnOnInvalidCallback(callback, "setState");
                  }
                }
              }
            }
          };
          function applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, prevState, nextProps) {
            var partialState = getDerivedStateFromProps(nextProps, prevState);
            {
              warnOnUndefinedDerivedState(ctor, partialState);
            }
            var newState = partialState === null || partialState === void 0 ? prevState : assign2({}, prevState, partialState);
            return newState;
          }
          function constructClassInstance(ctor, props, maskedLegacyContext) {
            var context = emptyContextObject;
            var contextType = ctor.contextType;
            {
              if ("contextType" in ctor) {
                var isValid3 = contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0;
                if (!isValid3 && !didWarnAboutInvalidateContextType.has(ctor)) {
                  didWarnAboutInvalidateContextType.add(ctor);
                  var addendum = "";
                  if (contextType === void 0) {
                    addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                  } else if (typeof contextType !== "object") {
                    addendum = " However, it is set to a " + typeof contextType + ".";
                  } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                    addendum = " Did you accidentally pass the Context.Provider instead?";
                  } else if (contextType._context !== void 0) {
                    addendum = " Did you accidentally pass the Context.Consumer instead?";
                  } else {
                    addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                  }
                  error3("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
                }
              }
            }
            if (typeof contextType === "object" && contextType !== null) {
              context = readContext(contextType);
            } else {
              context = maskedLegacyContext;
            }
            var instance = new ctor(props, context);
            {
              if (typeof ctor.getDerivedStateFromProps === "function" && (instance.state === null || instance.state === void 0)) {
                var componentName = getComponentNameFromType(ctor) || "Component";
                if (!didWarnAboutUninitializedState.has(componentName)) {
                  didWarnAboutUninitializedState.add(componentName);
                  error3("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
                }
              }
              if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
                var foundWillMountName = null;
                var foundWillReceivePropsName = null;
                var foundWillUpdateName = null;
                if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
                  foundWillMountName = "componentWillMount";
                } else if (typeof instance.UNSAFE_componentWillMount === "function") {
                  foundWillMountName = "UNSAFE_componentWillMount";
                }
                if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
                  foundWillReceivePropsName = "componentWillReceiveProps";
                } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
                  foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
                }
                if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
                  foundWillUpdateName = "componentWillUpdate";
                } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
                  foundWillUpdateName = "UNSAFE_componentWillUpdate";
                }
                if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
                  var _componentName = getComponentNameFromType(ctor) || "Component";
                  var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                  if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                    didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                    error3("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? "\n  " + foundWillMountName : "", foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "", foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "");
                  }
                }
              }
            }
            return instance;
          }
          function checkClassInstance(instance, ctor, newProps) {
            {
              var name16 = getComponentNameFromType(ctor) || "Component";
              var renderPresent = instance.render;
              if (!renderPresent) {
                if (ctor.prototype && typeof ctor.prototype.render === "function") {
                  error3("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name16);
                } else {
                  error3("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name16);
                }
              }
              if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
                error3("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name16);
              }
              if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
                error3("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name16);
              }
              if (instance.propTypes) {
                error3("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name16);
              }
              if (instance.contextType) {
                error3("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name16);
              }
              {
                if (instance.contextTypes) {
                  error3("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name16);
                }
                if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
                  didWarnAboutContextTypeAndContextTypes.add(ctor);
                  error3("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name16);
                }
              }
              if (typeof instance.componentShouldUpdate === "function") {
                error3("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name16);
              }
              if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
                error3("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
              }
              if (typeof instance.componentDidUnmount === "function") {
                error3("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name16);
              }
              if (typeof instance.componentDidReceiveProps === "function") {
                error3("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name16);
              }
              if (typeof instance.componentWillRecieveProps === "function") {
                error3("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name16);
              }
              if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
                error3("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name16);
              }
              var hasMutatedProps = instance.props !== newProps;
              if (instance.props !== void 0 && hasMutatedProps) {
                error3("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name16, name16);
              }
              if (instance.defaultProps) {
                error3("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name16, name16);
              }
              if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
                didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
                error3("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
              }
              if (typeof instance.getDerivedStateFromProps === "function") {
                error3("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name16);
              }
              if (typeof instance.getDerivedStateFromError === "function") {
                error3("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name16);
              }
              if (typeof ctor.getSnapshotBeforeUpdate === "function") {
                error3("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name16);
              }
              var _state = instance.state;
              if (_state && (typeof _state !== "object" || isArray6(_state))) {
                error3("%s.state: must be set to an object or null", name16);
              }
              if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
                error3("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name16);
              }
            }
          }
          function callComponentWillMount(type, instance) {
            var oldState = instance.state;
            if (typeof instance.componentWillMount === "function") {
              {
                if (instance.componentWillMount.__suppressDeprecationWarning !== true) {
                  var componentName = getComponentNameFromType(type) || "Unknown";
                  if (!didWarnAboutDeprecatedWillMount[componentName]) {
                    warn(
                      "componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s",
                      componentName
                    );
                    didWarnAboutDeprecatedWillMount[componentName] = true;
                  }
                }
              }
              instance.componentWillMount();
            }
            if (typeof instance.UNSAFE_componentWillMount === "function") {
              instance.UNSAFE_componentWillMount();
            }
            if (oldState !== instance.state) {
              {
                error3("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromType(type) || "Component");
              }
              classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
            }
          }
          function processUpdateQueue(internalInstance, inst, props, maskedLegacyContext) {
            if (internalInstance.queue !== null && internalInstance.queue.length > 0) {
              var oldQueue = internalInstance.queue;
              var oldReplace = internalInstance.replace;
              internalInstance.queue = null;
              internalInstance.replace = false;
              if (oldReplace && oldQueue.length === 1) {
                inst.state = oldQueue[0];
              } else {
                var nextState = oldReplace ? oldQueue[0] : inst.state;
                var dontMutate = true;
                for (var i = oldReplace ? 1 : 0; i < oldQueue.length; i++) {
                  var partial = oldQueue[i];
                  var partialState = typeof partial === "function" ? partial.call(inst, nextState, props, maskedLegacyContext) : partial;
                  if (partialState != null) {
                    if (dontMutate) {
                      dontMutate = false;
                      nextState = assign2({}, nextState, partialState);
                    } else {
                      assign2(nextState, partialState);
                    }
                  }
                }
                inst.state = nextState;
              }
            } else {
              internalInstance.queue = null;
            }
          }
          function mountClassInstance(instance, ctor, newProps, maskedLegacyContext) {
            {
              checkClassInstance(instance, ctor, newProps);
            }
            var initialState = instance.state !== void 0 ? instance.state : null;
            instance.updater = classComponentUpdater;
            instance.props = newProps;
            instance.state = initialState;
            var internalInstance = {
              queue: [],
              replace: false
            };
            set(instance, internalInstance);
            var contextType = ctor.contextType;
            if (typeof contextType === "object" && contextType !== null) {
              instance.context = readContext(contextType);
            } else {
              instance.context = maskedLegacyContext;
            }
            {
              if (instance.state === newProps) {
                var componentName = getComponentNameFromType(ctor) || "Component";
                if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
                  didWarnAboutDirectlyAssigningPropsToState.add(componentName);
                  error3("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName);
                }
              }
            }
            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
            if (typeof getDerivedStateFromProps === "function") {
              instance.state = applyDerivedStateFromProps(instance, ctor, getDerivedStateFromProps, initialState, newProps);
            }
            if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
              callComponentWillMount(ctor, instance);
              processUpdateQueue(internalInstance, instance, newProps, maskedLegacyContext);
            }
          }
          var emptyTreeContext = {
            id: 1,
            overflow: ""
          };
          function getTreeId(context) {
            var overflow = context.overflow;
            var idWithLeadingBit = context.id;
            var id2 = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
            return id2.toString(32) + overflow;
          }
          function pushTreeContext(baseContext, totalChildren, index5) {
            var baseIdWithLeadingBit = baseContext.id;
            var baseOverflow = baseContext.overflow;
            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
            var slot = index5 + 1;
            var length7 = getBitLength(totalChildren) + baseLength;
            if (length7 > 30) {
              var numberOfOverflowBits = baseLength - baseLength % 5;
              var newOverflowBits = (1 << numberOfOverflowBits) - 1;
              var newOverflow = (baseId & newOverflowBits).toString(32);
              var restOfBaseId = baseId >> numberOfOverflowBits;
              var restOfBaseLength = baseLength - numberOfOverflowBits;
              var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
              var restOfNewBits = slot << restOfBaseLength;
              var id2 = restOfNewBits | restOfBaseId;
              var overflow = newOverflow + baseOverflow;
              return {
                id: 1 << restOfLength | id2,
                overflow
              };
            } else {
              var newBits = slot << baseLength;
              var _id = newBits | baseId;
              var _overflow = baseOverflow;
              return {
                id: 1 << length7 | _id,
                overflow: _overflow
              };
            }
          }
          function getBitLength(number8) {
            return 32 - clz32(number8);
          }
          function getLeadingBit(id2) {
            return 1 << getBitLength(id2) - 1;
          }
          var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
          var log5 = Math.log;
          var LN2 = Math.LN2;
          function clz32Fallback(x) {
            var asUint = x >>> 0;
            if (asUint === 0) {
              return 32;
            }
            return 31 - (log5(asUint) / LN2 | 0) | 0;
          }
          function is(x, y) {
            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
          }
          var objectIs = typeof Object.is === "function" ? Object.is : is;
          var currentlyRenderingComponent = null;
          var currentlyRenderingTask = null;
          var firstWorkInProgressHook = null;
          var workInProgressHook = null;
          var isReRender = false;
          var didScheduleRenderPhaseUpdate = false;
          var localIdCounter = 0;
          var renderPhaseUpdates = null;
          var numberOfReRenders = 0;
          var RE_RENDER_LIMIT = 25;
          var isInHookUserCodeInDev = false;
          var currentHookNameInDev;
          function resolveCurrentlyRenderingComponent() {
            if (currentlyRenderingComponent === null) {
              throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
            {
              if (isInHookUserCodeInDev) {
                error3("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
              }
            }
            return currentlyRenderingComponent;
          }
          function areHookInputsEqual(nextDeps, prevDeps) {
            if (prevDeps === null) {
              {
                error3("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
              }
              return false;
            }
            {
              if (nextDeps.length !== prevDeps.length) {
                error3("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
              }
            }
            for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
              if (objectIs(nextDeps[i], prevDeps[i])) {
                continue;
              }
              return false;
            }
            return true;
          }
          function createHook() {
            if (numberOfReRenders > 0) {
              throw new Error("Rendered more hooks than during the previous render");
            }
            return {
              memoizedState: null,
              queue: null,
              next: null
            };
          }
          function createWorkInProgressHook() {
            if (workInProgressHook === null) {
              if (firstWorkInProgressHook === null) {
                isReRender = false;
                firstWorkInProgressHook = workInProgressHook = createHook();
              } else {
                isReRender = true;
                workInProgressHook = firstWorkInProgressHook;
              }
            } else {
              if (workInProgressHook.next === null) {
                isReRender = false;
                workInProgressHook = workInProgressHook.next = createHook();
              } else {
                isReRender = true;
                workInProgressHook = workInProgressHook.next;
              }
            }
            return workInProgressHook;
          }
          function prepareToUseHooks(task, componentIdentity) {
            currentlyRenderingComponent = componentIdentity;
            currentlyRenderingTask = task;
            {
              isInHookUserCodeInDev = false;
            }
            localIdCounter = 0;
          }
          function finishHooks(Component2, props, children, refOrContext) {
            while (didScheduleRenderPhaseUpdate) {
              didScheduleRenderPhaseUpdate = false;
              localIdCounter = 0;
              numberOfReRenders += 1;
              workInProgressHook = null;
              children = Component2(props, refOrContext);
            }
            resetHooksState();
            return children;
          }
          function checkDidRenderIdHook() {
            var didRenderIdHook = localIdCounter !== 0;
            return didRenderIdHook;
          }
          function resetHooksState() {
            {
              isInHookUserCodeInDev = false;
            }
            currentlyRenderingComponent = null;
            currentlyRenderingTask = null;
            didScheduleRenderPhaseUpdate = false;
            firstWorkInProgressHook = null;
            numberOfReRenders = 0;
            renderPhaseUpdates = null;
            workInProgressHook = null;
          }
          function readContext$1(context) {
            {
              if (isInHookUserCodeInDev) {
                error3("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
              }
            }
            return readContext(context);
          }
          function useContext7(context) {
            {
              currentHookNameInDev = "useContext";
            }
            resolveCurrentlyRenderingComponent();
            return readContext(context);
          }
          function basicStateReducer(state3, action2) {
            return typeof action2 === "function" ? action2(state3) : action2;
          }
          function useState13(initialState) {
            {
              currentHookNameInDev = "useState";
            }
            return useReducer(
              basicStateReducer,
              initialState
            );
          }
          function useReducer(reducer, initialArg, init3) {
            {
              if (reducer !== basicStateReducer) {
                currentHookNameInDev = "useReducer";
              }
            }
            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
            workInProgressHook = createWorkInProgressHook();
            if (isReRender) {
              var queue = workInProgressHook.queue;
              var dispatch = queue.dispatch;
              if (renderPhaseUpdates !== null) {
                var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
                if (firstRenderPhaseUpdate !== void 0) {
                  renderPhaseUpdates.delete(queue);
                  var newState = workInProgressHook.memoizedState;
                  var update = firstRenderPhaseUpdate;
                  do {
                    var action2 = update.action;
                    {
                      isInHookUserCodeInDev = true;
                    }
                    newState = reducer(newState, action2);
                    {
                      isInHookUserCodeInDev = false;
                    }
                    update = update.next;
                  } while (update !== null);
                  workInProgressHook.memoizedState = newState;
                  return [newState, dispatch];
                }
              }
              return [workInProgressHook.memoizedState, dispatch];
            } else {
              {
                isInHookUserCodeInDev = true;
              }
              var initialState;
              if (reducer === basicStateReducer) {
                initialState = typeof initialArg === "function" ? initialArg() : initialArg;
              } else {
                initialState = init3 !== void 0 ? init3(initialArg) : initialArg;
              }
              {
                isInHookUserCodeInDev = false;
              }
              workInProgressHook.memoizedState = initialState;
              var _queue = workInProgressHook.queue = {
                last: null,
                dispatch: null
              };
              var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
              return [workInProgressHook.memoizedState, _dispatch];
            }
          }
          function useMemo11(nextCreate, deps) {
            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
            workInProgressHook = createWorkInProgressHook();
            var nextDeps = deps === void 0 ? null : deps;
            if (workInProgressHook !== null) {
              var prevState = workInProgressHook.memoizedState;
              if (prevState !== null) {
                if (nextDeps !== null) {
                  var prevDeps = prevState[1];
                  if (areHookInputsEqual(nextDeps, prevDeps)) {
                    return prevState[0];
                  }
                }
              }
            }
            {
              isInHookUserCodeInDev = true;
            }
            var nextValue = nextCreate();
            {
              isInHookUserCodeInDev = false;
            }
            workInProgressHook.memoizedState = [nextValue, nextDeps];
            return nextValue;
          }
          function useRef10(initialValue) {
            currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
            workInProgressHook = createWorkInProgressHook();
            var previousRef = workInProgressHook.memoizedState;
            if (previousRef === null) {
              var ref = {
                current: initialValue
              };
              {
                Object.seal(ref);
              }
              workInProgressHook.memoizedState = ref;
              return ref;
            } else {
              return previousRef;
            }
          }
          function useLayoutEffect3(create6, inputs) {
            {
              currentHookNameInDev = "useLayoutEffect";
              error3("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
            }
          }
          function dispatchAction(componentIdentity, queue, action2) {
            if (numberOfReRenders >= RE_RENDER_LIMIT) {
              throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
            }
            if (componentIdentity === currentlyRenderingComponent) {
              didScheduleRenderPhaseUpdate = true;
              var update = {
                action: action2,
                next: null
              };
              if (renderPhaseUpdates === null) {
                renderPhaseUpdates = /* @__PURE__ */ new Map();
              }
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
              if (firstRenderPhaseUpdate === void 0) {
                renderPhaseUpdates.set(queue, update);
              } else {
                var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
                while (lastRenderPhaseUpdate.next !== null) {
                  lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
                }
                lastRenderPhaseUpdate.next = update;
              }
            }
          }
          function useCallback5(callback, deps) {
            return useMemo11(function() {
              return callback;
            }, deps);
          }
          function useMutableSource(source, getSnapshot, subscribe) {
            resolveCurrentlyRenderingComponent();
            return getSnapshot(source._source);
          }
          function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
            if (getServerSnapshot === void 0) {
              throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
            }
            return getServerSnapshot();
          }
          function useDeferredValue(value13) {
            resolveCurrentlyRenderingComponent();
            return value13;
          }
          function unsupportedStartTransition() {
            throw new Error("startTransition cannot be called during server rendering.");
          }
          function useTransition() {
            resolveCurrentlyRenderingComponent();
            return [false, unsupportedStartTransition];
          }
          function useId() {
            var task = currentlyRenderingTask;
            var treeId = getTreeId(task.treeContext);
            var responseState = currentResponseState;
            if (responseState === null) {
              throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component.");
            }
            var localId = localIdCounter++;
            return makeId(responseState, treeId, localId);
          }
          function noop13() {
          }
          var Dispatcher = {
            readContext: readContext$1,
            useContext: useContext7,
            useMemo: useMemo11,
            useReducer,
            useRef: useRef10,
            useState: useState13,
            useInsertionEffect: noop13,
            useLayoutEffect: useLayoutEffect3,
            useCallback: useCallback5,
            useImperativeHandle: noop13,
            useEffect: noop13,
            useDebugValue: noop13,
            useDeferredValue,
            useTransition,
            useId,
            useMutableSource,
            useSyncExternalStore
          };
          var currentResponseState = null;
          function setCurrentResponseState(responseState) {
            currentResponseState = responseState;
          }
          function getStackByComponentStackNode(componentStack) {
            try {
              var info = "";
              var node = componentStack;
              do {
                switch (node.tag) {
                  case 0:
                    info += describeBuiltInComponentFrame(node.type, null, null);
                    break;
                  case 1:
                    info += describeFunctionComponentFrame(node.type, null, null);
                    break;
                  case 2:
                    info += describeClassComponentFrame(node.type, null, null);
                    break;
                }
                node = node.parent;
              } while (node);
              return info;
            } catch (x) {
              return "\nError generating stack: " + x.message + "\n" + x.stack;
            }
          }
          var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
          var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          var PENDING = 0;
          var COMPLETED = 1;
          var FLUSHED = 2;
          var ABORTED = 3;
          var ERRORED = 4;
          var OPEN = 0;
          var CLOSING = 1;
          var CLOSED = 2;
          var DEFAULT_PROGRESSIVE_CHUNK_SIZE = 12800;
          function defaultErrorHandler(error4) {
            console["error"](error4);
            return null;
          }
          function noop$1() {
          }
          function createRequest(children, responseState, rootFormatContext, progressiveChunkSize, onError, onAllReady, onShellReady, onShellError, onFatalError) {
            var pingedTasks = [];
            var abortSet = /* @__PURE__ */ new Set();
            var request2 = {
              destination: null,
              responseState,
              progressiveChunkSize: progressiveChunkSize === void 0 ? DEFAULT_PROGRESSIVE_CHUNK_SIZE : progressiveChunkSize,
              status: OPEN,
              fatalError: null,
              nextSegmentId: 0,
              allPendingTasks: 0,
              pendingRootTasks: 0,
              completedRootSegment: null,
              abortableTasks: abortSet,
              pingedTasks,
              clientRenderedBoundaries: [],
              completedBoundaries: [],
              partialBoundaries: [],
              onError: onError === void 0 ? defaultErrorHandler : onError,
              onAllReady: onAllReady === void 0 ? noop$1 : onAllReady,
              onShellReady: onShellReady === void 0 ? noop$1 : onShellReady,
              onShellError: onShellError === void 0 ? noop$1 : onShellError,
              onFatalError: onFatalError === void 0 ? noop$1 : onFatalError
            };
            var rootSegment = createPendingSegment(
              request2,
              0,
              null,
              rootFormatContext,
              false,
              false
            );
            rootSegment.parentFlushed = true;
            var rootTask = createTask(request2, children, null, rootSegment, abortSet, emptyContextObject, rootContextSnapshot, emptyTreeContext);
            pingedTasks.push(rootTask);
            return request2;
          }
          function pingTask(request2, task) {
            var pingedTasks = request2.pingedTasks;
            pingedTasks.push(task);
            if (pingedTasks.length === 1) {
              scheduleWork(function() {
                return performWork(request2);
              });
            }
          }
          function createSuspenseBoundary(request2, fallbackAbortableTasks) {
            return {
              id: UNINITIALIZED_SUSPENSE_BOUNDARY_ID,
              rootSegmentID: -1,
              parentFlushed: false,
              pendingTasks: 0,
              forceClientRender: false,
              completedSegments: [],
              byteSize: 0,
              fallbackAbortableTasks,
              errorDigest: null
            };
          }
          function createTask(request2, node, blockedBoundary, blockedSegment, abortSet, legacyContext, context, treeContext) {
            request2.allPendingTasks++;
            if (blockedBoundary === null) {
              request2.pendingRootTasks++;
            } else {
              blockedBoundary.pendingTasks++;
            }
            var task = {
              node,
              ping: function() {
                return pingTask(request2, task);
              },
              blockedBoundary,
              blockedSegment,
              abortSet,
              legacyContext,
              context,
              treeContext
            };
            {
              task.componentStack = null;
            }
            abortSet.add(task);
            return task;
          }
          function createPendingSegment(request2, index5, boundary, formatContext, lastPushedText, textEmbedded) {
            return {
              status: PENDING,
              id: -1,
              index: index5,
              parentFlushed: false,
              chunks: [],
              children: [],
              formatContext,
              boundary,
              lastPushedText,
              textEmbedded
            };
          }
          var currentTaskInDEV = null;
          function getCurrentStackInDEV() {
            {
              if (currentTaskInDEV === null || currentTaskInDEV.componentStack === null) {
                return "";
              }
              return getStackByComponentStackNode(currentTaskInDEV.componentStack);
            }
          }
          function pushBuiltInComponentStackInDEV(task, type) {
            {
              task.componentStack = {
                tag: 0,
                parent: task.componentStack,
                type
              };
            }
          }
          function pushFunctionComponentStackInDEV(task, type) {
            {
              task.componentStack = {
                tag: 1,
                parent: task.componentStack,
                type
              };
            }
          }
          function pushClassComponentStackInDEV(task, type) {
            {
              task.componentStack = {
                tag: 2,
                parent: task.componentStack,
                type
              };
            }
          }
          function popComponentStackInDEV(task) {
            {
              if (task.componentStack === null) {
                error3("Unexpectedly popped too many stack frames. This is a bug in React.");
              } else {
                task.componentStack = task.componentStack.parent;
              }
            }
          }
          var lastBoundaryErrorComponentStackDev = null;
          function captureBoundaryErrorDetailsDev(boundary, error4) {
            {
              var errorMessage;
              if (typeof error4 === "string") {
                errorMessage = error4;
              } else if (error4 && typeof error4.message === "string") {
                errorMessage = error4.message;
              } else {
                errorMessage = String(error4);
              }
              var errorComponentStack = lastBoundaryErrorComponentStackDev || getCurrentStackInDEV();
              lastBoundaryErrorComponentStackDev = null;
              boundary.errorMessage = errorMessage;
              boundary.errorComponentStack = errorComponentStack;
            }
          }
          function logRecoverableError(request2, error4) {
            var errorDigest = request2.onError(error4);
            if (errorDigest != null && typeof errorDigest !== "string") {
              throw new Error('onError returned something with a type other than "string". onError should return a string and may return null or undefined but must not return anything else. It received something of type "' + typeof errorDigest + '" instead');
            }
            return errorDigest;
          }
          function fatalError(request2, error4) {
            var onShellError = request2.onShellError;
            onShellError(error4);
            var onFatalError = request2.onFatalError;
            onFatalError(error4);
            if (request2.destination !== null) {
              request2.status = CLOSED;
              closeWithError(request2.destination, error4);
            } else {
              request2.status = CLOSING;
              request2.fatalError = error4;
            }
          }
          function renderSuspenseBoundary(request2, task, props) {
            pushBuiltInComponentStackInDEV(task, "Suspense");
            var parentBoundary = task.blockedBoundary;
            var parentSegment = task.blockedSegment;
            var fallback = props.fallback;
            var content3 = props.children;
            var fallbackAbortSet = /* @__PURE__ */ new Set();
            var newBoundary = createSuspenseBoundary(request2, fallbackAbortSet);
            var insertionIndex = parentSegment.chunks.length;
            var boundarySegment = createPendingSegment(
              request2,
              insertionIndex,
              newBoundary,
              parentSegment.formatContext,
              false,
              false
            );
            parentSegment.children.push(boundarySegment);
            parentSegment.lastPushedText = false;
            var contentRootSegment = createPendingSegment(
              request2,
              0,
              null,
              parentSegment.formatContext,
              false,
              false
            );
            contentRootSegment.parentFlushed = true;
            task.blockedBoundary = newBoundary;
            task.blockedSegment = contentRootSegment;
            try {
              renderNode(request2, task, content3);
              pushSegmentFinale(contentRootSegment.chunks, request2.responseState, contentRootSegment.lastPushedText, contentRootSegment.textEmbedded);
              contentRootSegment.status = COMPLETED;
              queueCompletedSegment(newBoundary, contentRootSegment);
              if (newBoundary.pendingTasks === 0) {
                popComponentStackInDEV(task);
                return;
              }
            } catch (error4) {
              contentRootSegment.status = ERRORED;
              newBoundary.forceClientRender = true;
              newBoundary.errorDigest = logRecoverableError(request2, error4);
              {
                captureBoundaryErrorDetailsDev(newBoundary, error4);
              }
            } finally {
              task.blockedBoundary = parentBoundary;
              task.blockedSegment = parentSegment;
            }
            var suspendedFallbackTask = createTask(request2, fallback, parentBoundary, boundarySegment, fallbackAbortSet, task.legacyContext, task.context, task.treeContext);
            {
              suspendedFallbackTask.componentStack = task.componentStack;
            }
            request2.pingedTasks.push(suspendedFallbackTask);
            popComponentStackInDEV(task);
          }
          function renderHostElement(request2, task, type, props) {
            pushBuiltInComponentStackInDEV(task, type);
            var segment = task.blockedSegment;
            var children = pushStartInstance(segment.chunks, type, props, request2.responseState, segment.formatContext);
            segment.lastPushedText = false;
            var prevContext = segment.formatContext;
            segment.formatContext = getChildFormatContext(prevContext, type, props);
            renderNode(request2, task, children);
            segment.formatContext = prevContext;
            pushEndInstance(segment.chunks, type);
            segment.lastPushedText = false;
            popComponentStackInDEV(task);
          }
          function shouldConstruct$1(Component2) {
            return Component2.prototype && Component2.prototype.isReactComponent;
          }
          function renderWithHooks(request2, task, Component2, props, secondArg) {
            var componentIdentity = {};
            prepareToUseHooks(task, componentIdentity);
            var result = Component2(props, secondArg);
            return finishHooks(Component2, props, result, secondArg);
          }
          function finishClassComponent(request2, task, instance, Component2, props) {
            var nextChildren = instance.render();
            {
              if (instance.props !== props) {
                if (!didWarnAboutReassigningProps) {
                  error3("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromType(Component2) || "a component");
                }
                didWarnAboutReassigningProps = true;
              }
            }
            {
              var childContextTypes = Component2.childContextTypes;
              if (childContextTypes !== null && childContextTypes !== void 0) {
                var previousContext = task.legacyContext;
                var mergedContext = processChildContext(instance, Component2, previousContext, childContextTypes);
                task.legacyContext = mergedContext;
                renderNodeDestructive(request2, task, nextChildren);
                task.legacyContext = previousContext;
                return;
              }
            }
            renderNodeDestructive(request2, task, nextChildren);
          }
          function renderClassComponent(request2, task, Component2, props) {
            pushClassComponentStackInDEV(task, Component2);
            var maskedContext = getMaskedContext(Component2, task.legacyContext);
            var instance = constructClassInstance(Component2, props, maskedContext);
            mountClassInstance(instance, Component2, props, maskedContext);
            finishClassComponent(request2, task, instance, Component2, props);
            popComponentStackInDEV(task);
          }
          var didWarnAboutBadClass = {};
          var didWarnAboutModulePatternComponent = {};
          var didWarnAboutContextTypeOnFunctionComponent = {};
          var didWarnAboutGetDerivedStateOnFunctionComponent = {};
          var didWarnAboutReassigningProps = false;
          var didWarnAboutGenerators = false;
          var didWarnAboutMaps = false;
          var hasWarnedAboutUsingContextAsConsumer = false;
          function renderIndeterminateComponent(request2, task, Component2, props) {
            var legacyContext;
            {
              legacyContext = getMaskedContext(Component2, task.legacyContext);
            }
            pushFunctionComponentStackInDEV(task, Component2);
            {
              if (Component2.prototype && typeof Component2.prototype.render === "function") {
                var componentName = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutBadClass[componentName]) {
                  error3("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
                  didWarnAboutBadClass[componentName] = true;
                }
              }
            }
            var value13 = renderWithHooks(request2, task, Component2, props, legacyContext);
            var hasId = checkDidRenderIdHook();
            {
              if (typeof value13 === "object" && value13 !== null && typeof value13.render === "function" && value13.$$typeof === void 0) {
                var _componentName = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName]) {
                  error3("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName);
                  didWarnAboutModulePatternComponent[_componentName] = true;
                }
              }
            }
            if (typeof value13 === "object" && value13 !== null && typeof value13.render === "function" && value13.$$typeof === void 0) {
              {
                var _componentName2 = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutModulePatternComponent[_componentName2]) {
                  error3("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
                  didWarnAboutModulePatternComponent[_componentName2] = true;
                }
              }
              mountClassInstance(value13, Component2, props, legacyContext);
              finishClassComponent(request2, task, value13, Component2, props);
            } else {
              {
                validateFunctionComponentInDev(Component2);
              }
              if (hasId) {
                var prevTreeContext = task.treeContext;
                var totalChildren = 1;
                var index5 = 0;
                task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index5);
                try {
                  renderNodeDestructive(request2, task, value13);
                } finally {
                  task.treeContext = prevTreeContext;
                }
              } else {
                renderNodeDestructive(request2, task, value13);
              }
            }
            popComponentStackInDEV(task);
          }
          function validateFunctionComponentInDev(Component2) {
            {
              if (Component2) {
                if (Component2.childContextTypes) {
                  error3("%s(...): childContextTypes cannot be defined on a function component.", Component2.displayName || Component2.name || "Component");
                }
              }
              if (typeof Component2.getDerivedStateFromProps === "function") {
                var _componentName3 = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
                  error3("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
                  didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
                }
              }
              if (typeof Component2.contextType === "object" && Component2.contextType !== null) {
                var _componentName4 = getComponentNameFromType(Component2) || "Unknown";
                if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
                  error3("%s: Function components do not support contextType.", _componentName4);
                  didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
                }
              }
            }
          }
          function resolveDefaultProps(Component2, baseProps) {
            if (Component2 && Component2.defaultProps) {
              var props = assign2({}, baseProps);
              var defaultProps19 = Component2.defaultProps;
              for (var propName in defaultProps19) {
                if (props[propName] === void 0) {
                  props[propName] = defaultProps19[propName];
                }
              }
              return props;
            }
            return baseProps;
          }
          function renderForwardRef(request2, task, type, props, ref) {
            pushFunctionComponentStackInDEV(task, type.render);
            var children = renderWithHooks(request2, task, type.render, props, ref);
            var hasId = checkDidRenderIdHook();
            if (hasId) {
              var prevTreeContext = task.treeContext;
              var totalChildren = 1;
              var index5 = 0;
              task.treeContext = pushTreeContext(prevTreeContext, totalChildren, index5);
              try {
                renderNodeDestructive(request2, task, children);
              } finally {
                task.treeContext = prevTreeContext;
              }
            } else {
              renderNodeDestructive(request2, task, children);
            }
            popComponentStackInDEV(task);
          }
          function renderMemo(request2, task, type, props, ref) {
            var innerType = type.type;
            var resolvedProps = resolveDefaultProps(innerType, props);
            renderElement(request2, task, innerType, resolvedProps, ref);
          }
          function renderContextConsumer(request2, task, context, props) {
            {
              if (context._context === void 0) {
                if (context !== context.Consumer) {
                  if (!hasWarnedAboutUsingContextAsConsumer) {
                    hasWarnedAboutUsingContextAsConsumer = true;
                    error3("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                  }
                }
              } else {
                context = context._context;
              }
            }
            var render2 = props.children;
            {
              if (typeof render2 !== "function") {
                error3("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it.");
              }
            }
            var newValue = readContext(context);
            var newChildren = render2(newValue);
            renderNodeDestructive(request2, task, newChildren);
          }
          function renderContextProvider(request2, task, type, props) {
            var context = type._context;
            var value13 = props.value;
            var children = props.children;
            var prevSnapshot;
            {
              prevSnapshot = task.context;
            }
            task.context = pushProvider(context, value13);
            renderNodeDestructive(request2, task, children);
            task.context = popProvider(context);
            {
              if (prevSnapshot !== task.context) {
                error3("Popping the context provider did not return back to the original snapshot. This is a bug in React.");
              }
            }
          }
          function renderLazyComponent(request2, task, lazyComponent, props, ref) {
            pushBuiltInComponentStackInDEV(task, "Lazy");
            var payload = lazyComponent._payload;
            var init3 = lazyComponent._init;
            var Component2 = init3(payload);
            var resolvedProps = resolveDefaultProps(Component2, props);
            renderElement(request2, task, Component2, resolvedProps, ref);
            popComponentStackInDEV(task);
          }
          function renderElement(request2, task, type, props, ref) {
            if (typeof type === "function") {
              if (shouldConstruct$1(type)) {
                renderClassComponent(request2, task, type, props);
                return;
              } else {
                renderIndeterminateComponent(request2, task, type, props);
                return;
              }
            }
            if (typeof type === "string") {
              renderHostElement(request2, task, type, props);
              return;
            }
            switch (type) {
              case REACT_LEGACY_HIDDEN_TYPE:
              case REACT_DEBUG_TRACING_MODE_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_FRAGMENT_TYPE: {
                renderNodeDestructive(request2, task, props.children);
                return;
              }
              case REACT_SUSPENSE_LIST_TYPE: {
                pushBuiltInComponentStackInDEV(task, "SuspenseList");
                renderNodeDestructive(request2, task, props.children);
                popComponentStackInDEV(task);
                return;
              }
              case REACT_SCOPE_TYPE: {
                throw new Error("ReactDOMServer does not yet support scope components.");
              }
              case REACT_SUSPENSE_TYPE: {
                {
                  renderSuspenseBoundary(request2, task, props);
                }
                return;
              }
            }
            if (typeof type === "object" && type !== null) {
              switch (type.$$typeof) {
                case REACT_FORWARD_REF_TYPE: {
                  renderForwardRef(request2, task, type, props, ref);
                  return;
                }
                case REACT_MEMO_TYPE: {
                  renderMemo(request2, task, type, props, ref);
                  return;
                }
                case REACT_PROVIDER_TYPE: {
                  renderContextProvider(request2, task, type, props);
                  return;
                }
                case REACT_CONTEXT_TYPE: {
                  renderContextConsumer(request2, task, type, props);
                  return;
                }
                case REACT_LAZY_TYPE: {
                  renderLazyComponent(request2, task, type, props);
                  return;
                }
              }
            }
            var info = "";
            {
              if (type === void 0 || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
              }
            }
            throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
          }
          function validateIterable(iterable, iteratorFn) {
            {
              if (typeof Symbol === "function" && iterable[Symbol.toStringTag] === "Generator") {
                if (!didWarnAboutGenerators) {
                  error3("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers.");
                }
                didWarnAboutGenerators = true;
              }
              if (iterable.entries === iteratorFn) {
                if (!didWarnAboutMaps) {
                  error3("Using Maps as children is not supported. Use an array of keyed ReactElements instead.");
                }
                didWarnAboutMaps = true;
              }
            }
          }
          function renderNodeDestructive(request2, task, node) {
            {
              try {
                return renderNodeDestructiveImpl(request2, task, node);
              } catch (x) {
                if (typeof x === "object" && x !== null && typeof x.then === "function")
                  ;
                else {
                  lastBoundaryErrorComponentStackDev = lastBoundaryErrorComponentStackDev !== null ? lastBoundaryErrorComponentStackDev : getCurrentStackInDEV();
                }
                throw x;
              }
            }
          }
          function renderNodeDestructiveImpl(request2, task, node) {
            task.node = node;
            if (typeof node === "object" && node !== null) {
              switch (node.$$typeof) {
                case REACT_ELEMENT_TYPE: {
                  var element = node;
                  var type = element.type;
                  var props = element.props;
                  var ref = element.ref;
                  renderElement(request2, task, type, props, ref);
                  return;
                }
                case REACT_PORTAL_TYPE:
                  throw new Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
                case REACT_LAZY_TYPE: {
                  var lazyNode = node;
                  var payload = lazyNode._payload;
                  var init3 = lazyNode._init;
                  var resolvedNode;
                  {
                    try {
                      resolvedNode = init3(payload);
                    } catch (x) {
                      if (typeof x === "object" && x !== null && typeof x.then === "function") {
                        pushBuiltInComponentStackInDEV(task, "Lazy");
                      }
                      throw x;
                    }
                  }
                  renderNodeDestructive(request2, task, resolvedNode);
                  return;
                }
              }
              if (isArray6(node)) {
                renderChildrenArray(request2, task, node);
                return;
              }
              var iteratorFn = getIteratorFn(node);
              if (iteratorFn) {
                {
                  validateIterable(node, iteratorFn);
                }
                var iterator2 = iteratorFn.call(node);
                if (iterator2) {
                  var step2 = iterator2.next();
                  if (!step2.done) {
                    var children = [];
                    do {
                      children.push(step2.value);
                      step2 = iterator2.next();
                    } while (!step2.done);
                    renderChildrenArray(request2, task, children);
                    return;
                  }
                  return;
                }
              }
              var childString = Object.prototype.toString.call(node);
              throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(node).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
            }
            if (typeof node === "string") {
              var segment = task.blockedSegment;
              segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, node, request2.responseState, segment.lastPushedText);
              return;
            }
            if (typeof node === "number") {
              var _segment = task.blockedSegment;
              _segment.lastPushedText = pushTextInstance(task.blockedSegment.chunks, "" + node, request2.responseState, _segment.lastPushedText);
              return;
            }
            {
              if (typeof node === "function") {
                error3("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
              }
            }
          }
          function renderChildrenArray(request2, task, children) {
            var totalChildren = children.length;
            for (var i = 0; i < totalChildren; i++) {
              var prevTreeContext = task.treeContext;
              task.treeContext = pushTreeContext(prevTreeContext, totalChildren, i);
              try {
                renderNode(request2, task, children[i]);
              } finally {
                task.treeContext = prevTreeContext;
              }
            }
          }
          function spawnNewSuspendedTask(request2, task, x) {
            var segment = task.blockedSegment;
            var insertionIndex = segment.chunks.length;
            var newSegment = createPendingSegment(
              request2,
              insertionIndex,
              null,
              segment.formatContext,
              segment.lastPushedText,
              true
            );
            segment.children.push(newSegment);
            segment.lastPushedText = false;
            var newTask = createTask(request2, task.node, task.blockedBoundary, newSegment, task.abortSet, task.legacyContext, task.context, task.treeContext);
            {
              if (task.componentStack !== null) {
                newTask.componentStack = task.componentStack.parent;
              }
            }
            var ping = newTask.ping;
            x.then(ping, ping);
          }
          function renderNode(request2, task, node) {
            var previousFormatContext = task.blockedSegment.formatContext;
            var previousLegacyContext = task.legacyContext;
            var previousContext = task.context;
            var previousComponentStack = null;
            {
              previousComponentStack = task.componentStack;
            }
            try {
              return renderNodeDestructive(request2, task, node);
            } catch (x) {
              resetHooksState();
              if (typeof x === "object" && x !== null && typeof x.then === "function") {
                spawnNewSuspendedTask(request2, task, x);
                task.blockedSegment.formatContext = previousFormatContext;
                task.legacyContext = previousLegacyContext;
                task.context = previousContext;
                switchContext(previousContext);
                {
                  task.componentStack = previousComponentStack;
                }
                return;
              } else {
                task.blockedSegment.formatContext = previousFormatContext;
                task.legacyContext = previousLegacyContext;
                task.context = previousContext;
                switchContext(previousContext);
                {
                  task.componentStack = previousComponentStack;
                }
                throw x;
              }
            }
          }
          function erroredTask(request2, boundary, segment, error4) {
            var errorDigest = logRecoverableError(request2, error4);
            if (boundary === null) {
              fatalError(request2, error4);
            } else {
              boundary.pendingTasks--;
              if (!boundary.forceClientRender) {
                boundary.forceClientRender = true;
                boundary.errorDigest = errorDigest;
                {
                  captureBoundaryErrorDetailsDev(boundary, error4);
                }
                if (boundary.parentFlushed) {
                  request2.clientRenderedBoundaries.push(boundary);
                }
              }
            }
            request2.allPendingTasks--;
            if (request2.allPendingTasks === 0) {
              var onAllReady = request2.onAllReady;
              onAllReady();
            }
          }
          function abortTaskSoft(task) {
            var request2 = this;
            var boundary = task.blockedBoundary;
            var segment = task.blockedSegment;
            segment.status = ABORTED;
            finishedTask(request2, boundary, segment);
          }
          function abortTask(task, request2, reason) {
            var boundary = task.blockedBoundary;
            var segment = task.blockedSegment;
            segment.status = ABORTED;
            if (boundary === null) {
              request2.allPendingTasks--;
              if (request2.status !== CLOSED) {
                request2.status = CLOSED;
                if (request2.destination !== null) {
                  close2(request2.destination);
                }
              }
            } else {
              boundary.pendingTasks--;
              if (!boundary.forceClientRender) {
                boundary.forceClientRender = true;
                var _error = reason === void 0 ? new Error("The render was aborted by the server without a reason.") : reason;
                boundary.errorDigest = request2.onError(_error);
                {
                  var errorPrefix = "The server did not finish this Suspense boundary: ";
                  if (_error && typeof _error.message === "string") {
                    _error = errorPrefix + _error.message;
                  } else {
                    _error = errorPrefix + String(_error);
                  }
                  var previousTaskInDev = currentTaskInDEV;
                  currentTaskInDEV = task;
                  try {
                    captureBoundaryErrorDetailsDev(boundary, _error);
                  } finally {
                    currentTaskInDEV = previousTaskInDev;
                  }
                }
                if (boundary.parentFlushed) {
                  request2.clientRenderedBoundaries.push(boundary);
                }
              }
              boundary.fallbackAbortableTasks.forEach(function(fallbackTask) {
                return abortTask(fallbackTask, request2, reason);
              });
              boundary.fallbackAbortableTasks.clear();
              request2.allPendingTasks--;
              if (request2.allPendingTasks === 0) {
                var onAllReady = request2.onAllReady;
                onAllReady();
              }
            }
          }
          function queueCompletedSegment(boundary, segment) {
            if (segment.chunks.length === 0 && segment.children.length === 1 && segment.children[0].boundary === null) {
              var childSegment = segment.children[0];
              childSegment.id = segment.id;
              childSegment.parentFlushed = true;
              if (childSegment.status === COMPLETED) {
                queueCompletedSegment(boundary, childSegment);
              }
            } else {
              var completedSegments = boundary.completedSegments;
              completedSegments.push(segment);
            }
          }
          function finishedTask(request2, boundary, segment) {
            if (boundary === null) {
              if (segment.parentFlushed) {
                if (request2.completedRootSegment !== null) {
                  throw new Error("There can only be one root segment. This is a bug in React.");
                }
                request2.completedRootSegment = segment;
              }
              request2.pendingRootTasks--;
              if (request2.pendingRootTasks === 0) {
                request2.onShellError = noop$1;
                var onShellReady = request2.onShellReady;
                onShellReady();
              }
            } else {
              boundary.pendingTasks--;
              if (boundary.forceClientRender)
                ;
              else if (boundary.pendingTasks === 0) {
                if (segment.parentFlushed) {
                  if (segment.status === COMPLETED) {
                    queueCompletedSegment(boundary, segment);
                  }
                }
                if (boundary.parentFlushed) {
                  request2.completedBoundaries.push(boundary);
                }
                boundary.fallbackAbortableTasks.forEach(abortTaskSoft, request2);
                boundary.fallbackAbortableTasks.clear();
              } else {
                if (segment.parentFlushed) {
                  if (segment.status === COMPLETED) {
                    queueCompletedSegment(boundary, segment);
                    var completedSegments = boundary.completedSegments;
                    if (completedSegments.length === 1) {
                      if (boundary.parentFlushed) {
                        request2.partialBoundaries.push(boundary);
                      }
                    }
                  }
                }
              }
            }
            request2.allPendingTasks--;
            if (request2.allPendingTasks === 0) {
              var onAllReady = request2.onAllReady;
              onAllReady();
            }
          }
          function retryTask(request2, task) {
            var segment = task.blockedSegment;
            if (segment.status !== PENDING) {
              return;
            }
            switchContext(task.context);
            var prevTaskInDEV = null;
            {
              prevTaskInDEV = currentTaskInDEV;
              currentTaskInDEV = task;
            }
            try {
              renderNodeDestructive(request2, task, task.node);
              pushSegmentFinale(segment.chunks, request2.responseState, segment.lastPushedText, segment.textEmbedded);
              task.abortSet.delete(task);
              segment.status = COMPLETED;
              finishedTask(request2, task.blockedBoundary, segment);
            } catch (x) {
              resetHooksState();
              if (typeof x === "object" && x !== null && typeof x.then === "function") {
                var ping = task.ping;
                x.then(ping, ping);
              } else {
                task.abortSet.delete(task);
                segment.status = ERRORED;
                erroredTask(request2, task.blockedBoundary, segment, x);
              }
            } finally {
              {
                currentTaskInDEV = prevTaskInDEV;
              }
            }
          }
          function performWork(request2) {
            if (request2.status === CLOSED) {
              return;
            }
            var prevContext = getActiveContext();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = Dispatcher;
            var prevGetCurrentStackImpl;
            {
              prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
              ReactDebugCurrentFrame$1.getCurrentStack = getCurrentStackInDEV;
            }
            var prevResponseState = currentResponseState;
            setCurrentResponseState(request2.responseState);
            try {
              var pingedTasks = request2.pingedTasks;
              var i;
              for (i = 0; i < pingedTasks.length; i++) {
                var task = pingedTasks[i];
                retryTask(request2, task);
              }
              pingedTasks.splice(0, i);
              if (request2.destination !== null) {
                flushCompletedQueues(request2, request2.destination);
              }
            } catch (error4) {
              logRecoverableError(request2, error4);
              fatalError(request2, error4);
            } finally {
              setCurrentResponseState(prevResponseState);
              ReactCurrentDispatcher$1.current = prevDispatcher;
              {
                ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
              }
              if (prevDispatcher === Dispatcher) {
                switchContext(prevContext);
              }
            }
          }
          function flushSubtree(request2, destination, segment) {
            segment.parentFlushed = true;
            switch (segment.status) {
              case PENDING: {
                var segmentID = segment.id = request2.nextSegmentId++;
                segment.lastPushedText = false;
                segment.textEmbedded = false;
                return writePlaceholder(destination, request2.responseState, segmentID);
              }
              case COMPLETED: {
                segment.status = FLUSHED;
                var r = true;
                var chunks = segment.chunks;
                var chunkIdx = 0;
                var children = segment.children;
                for (var childIdx = 0; childIdx < children.length; childIdx++) {
                  var nextChild = children[childIdx];
                  for (; chunkIdx < nextChild.index; chunkIdx++) {
                    writeChunk(destination, chunks[chunkIdx]);
                  }
                  r = flushSegment(request2, destination, nextChild);
                }
                for (; chunkIdx < chunks.length - 1; chunkIdx++) {
                  writeChunk(destination, chunks[chunkIdx]);
                }
                if (chunkIdx < chunks.length) {
                  r = writeChunkAndReturn(destination, chunks[chunkIdx]);
                }
                return r;
              }
              default: {
                throw new Error("Aborted, errored or already flushed boundaries should not be flushed again. This is a bug in React.");
              }
            }
          }
          function flushSegment(request2, destination, segment) {
            var boundary = segment.boundary;
            if (boundary === null) {
              return flushSubtree(request2, destination, segment);
            }
            boundary.parentFlushed = true;
            if (boundary.forceClientRender) {
              writeStartClientRenderedSuspenseBoundary(destination, request2.responseState, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
              flushSubtree(request2, destination, segment);
              return writeEndClientRenderedSuspenseBoundary(destination, request2.responseState);
            } else if (boundary.pendingTasks > 0) {
              boundary.rootSegmentID = request2.nextSegmentId++;
              if (boundary.completedSegments.length > 0) {
                request2.partialBoundaries.push(boundary);
              }
              var id2 = boundary.id = assignSuspenseBoundaryID(request2.responseState);
              writeStartPendingSuspenseBoundary(destination, request2.responseState, id2);
              flushSubtree(request2, destination, segment);
              return writeEndPendingSuspenseBoundary(destination, request2.responseState);
            } else if (boundary.byteSize > request2.progressiveChunkSize) {
              boundary.rootSegmentID = request2.nextSegmentId++;
              request2.completedBoundaries.push(boundary);
              writeStartPendingSuspenseBoundary(destination, request2.responseState, boundary.id);
              flushSubtree(request2, destination, segment);
              return writeEndPendingSuspenseBoundary(destination, request2.responseState);
            } else {
              writeStartCompletedSuspenseBoundary(destination, request2.responseState);
              var completedSegments = boundary.completedSegments;
              if (completedSegments.length !== 1) {
                throw new Error("A previously unvisited boundary must have exactly one root segment. This is a bug in React.");
              }
              var contentSegment = completedSegments[0];
              flushSegment(request2, destination, contentSegment);
              return writeEndCompletedSuspenseBoundary(destination, request2.responseState);
            }
          }
          function flushClientRenderedBoundary(request2, destination, boundary) {
            return writeClientRenderBoundaryInstruction(destination, request2.responseState, boundary.id, boundary.errorDigest, boundary.errorMessage, boundary.errorComponentStack);
          }
          function flushSegmentContainer(request2, destination, segment) {
            writeStartSegment(destination, request2.responseState, segment.formatContext, segment.id);
            flushSegment(request2, destination, segment);
            return writeEndSegment(destination, segment.formatContext);
          }
          function flushCompletedBoundary(request2, destination, boundary) {
            var completedSegments = boundary.completedSegments;
            var i = 0;
            for (; i < completedSegments.length; i++) {
              var segment = completedSegments[i];
              flushPartiallyCompletedSegment(request2, destination, boundary, segment);
            }
            completedSegments.length = 0;
            return writeCompletedBoundaryInstruction(destination, request2.responseState, boundary.id, boundary.rootSegmentID);
          }
          function flushPartialBoundary(request2, destination, boundary) {
            var completedSegments = boundary.completedSegments;
            var i = 0;
            for (; i < completedSegments.length; i++) {
              var segment = completedSegments[i];
              if (!flushPartiallyCompletedSegment(request2, destination, boundary, segment)) {
                i++;
                completedSegments.splice(0, i);
                return false;
              }
            }
            completedSegments.splice(0, i);
            return true;
          }
          function flushPartiallyCompletedSegment(request2, destination, boundary, segment) {
            if (segment.status === FLUSHED) {
              return true;
            }
            var segmentID = segment.id;
            if (segmentID === -1) {
              var rootSegmentID = segment.id = boundary.rootSegmentID;
              if (rootSegmentID === -1) {
                throw new Error("A root segment ID must have been assigned by now. This is a bug in React.");
              }
              return flushSegmentContainer(request2, destination, segment);
            } else {
              flushSegmentContainer(request2, destination, segment);
              return writeCompletedSegmentInstruction(destination, request2.responseState, segmentID);
            }
          }
          function flushCompletedQueues(request2, destination) {
            beginWriting();
            try {
              var completedRootSegment = request2.completedRootSegment;
              if (completedRootSegment !== null && request2.pendingRootTasks === 0) {
                flushSegment(request2, destination, completedRootSegment);
                request2.completedRootSegment = null;
                writeCompletedRoot(destination, request2.responseState);
              }
              var clientRenderedBoundaries = request2.clientRenderedBoundaries;
              var i;
              for (i = 0; i < clientRenderedBoundaries.length; i++) {
                var boundary = clientRenderedBoundaries[i];
                if (!flushClientRenderedBoundary(request2, destination, boundary)) {
                  request2.destination = null;
                  i++;
                  clientRenderedBoundaries.splice(0, i);
                  return;
                }
              }
              clientRenderedBoundaries.splice(0, i);
              var completedBoundaries = request2.completedBoundaries;
              for (i = 0; i < completedBoundaries.length; i++) {
                var _boundary = completedBoundaries[i];
                if (!flushCompletedBoundary(request2, destination, _boundary)) {
                  request2.destination = null;
                  i++;
                  completedBoundaries.splice(0, i);
                  return;
                }
              }
              completedBoundaries.splice(0, i);
              completeWriting(destination);
              beginWriting(destination);
              var partialBoundaries = request2.partialBoundaries;
              for (i = 0; i < partialBoundaries.length; i++) {
                var _boundary2 = partialBoundaries[i];
                if (!flushPartialBoundary(request2, destination, _boundary2)) {
                  request2.destination = null;
                  i++;
                  partialBoundaries.splice(0, i);
                  return;
                }
              }
              partialBoundaries.splice(0, i);
              var largeBoundaries = request2.completedBoundaries;
              for (i = 0; i < largeBoundaries.length; i++) {
                var _boundary3 = largeBoundaries[i];
                if (!flushCompletedBoundary(request2, destination, _boundary3)) {
                  request2.destination = null;
                  i++;
                  largeBoundaries.splice(0, i);
                  return;
                }
              }
              largeBoundaries.splice(0, i);
            } finally {
              completeWriting(destination);
              if (request2.allPendingTasks === 0 && request2.pingedTasks.length === 0 && request2.clientRenderedBoundaries.length === 0 && request2.completedBoundaries.length === 0) {
                {
                  if (request2.abortableTasks.size !== 0) {
                    error3("There was still abortable task at the root when we closed. This is a bug in React.");
                  }
                }
                close2(destination);
              }
            }
          }
          function startWork(request2) {
            scheduleWork(function() {
              return performWork(request2);
            });
          }
          function startFlowing(request2, destination) {
            if (request2.status === CLOSING) {
              request2.status = CLOSED;
              closeWithError(destination, request2.fatalError);
              return;
            }
            if (request2.status === CLOSED) {
              return;
            }
            if (request2.destination !== null) {
              return;
            }
            request2.destination = destination;
            try {
              flushCompletedQueues(request2, destination);
            } catch (error4) {
              logRecoverableError(request2, error4);
              fatalError(request2, error4);
            }
          }
          function abort(request2, reason) {
            try {
              var abortableTasks = request2.abortableTasks;
              abortableTasks.forEach(function(task) {
                return abortTask(task, request2, reason);
              });
              abortableTasks.clear();
              if (request2.destination !== null) {
                flushCompletedQueues(request2, request2.destination);
              }
            } catch (error4) {
              logRecoverableError(request2, error4);
              fatalError(request2, error4);
            }
          }
          function renderToReadableStream(children, options2) {
            return new Promise(function(resolve2, reject) {
              var onFatalError;
              var onAllReady;
              var allReady = new Promise(function(res, rej) {
                onAllReady = res;
                onFatalError = rej;
              });
              function onShellReady() {
                var stream = new ReadableStream(
                  {
                    type: "bytes",
                    pull: function(controller) {
                      startFlowing(request2, controller);
                    },
                    cancel: function(reason) {
                      abort(request2);
                    }
                  },
                  {
                    highWaterMark: 0
                  }
                );
                stream.allReady = allReady;
                resolve2(stream);
              }
              function onShellError(error4) {
                allReady.catch(function() {
                });
                reject(error4);
              }
              var request2 = createRequest(children, createResponseState(options2 ? options2.identifierPrefix : void 0, options2 ? options2.nonce : void 0, options2 ? options2.bootstrapScriptContent : void 0, options2 ? options2.bootstrapScripts : void 0, options2 ? options2.bootstrapModules : void 0), createRootFormatContext(options2 ? options2.namespaceURI : void 0), options2 ? options2.progressiveChunkSize : void 0, options2 ? options2.onError : void 0, onAllReady, onShellReady, onShellError, onFatalError);
              if (options2 && options2.signal) {
                var signal = options2.signal;
                var listener = function() {
                  abort(request2, signal.reason);
                  signal.removeEventListener("abort", listener);
                };
                signal.addEventListener("abort", listener);
              }
              startWork(request2);
            });
          }
          exports.renderToReadableStream = renderToReadableStream;
          exports.version = ReactVersion;
        })();
      }
    }
  });

  // node_modules/react-dom/server.browser.js
  var require_server_browser = __commonJS({
    "node_modules/react-dom/server.browser.js"(exports) {
      "use strict";
      var l;
      var s;
      if (false) {
        l = null;
        s = null;
      } else {
        l = require_react_dom_server_legacy_browser_development();
        s = require_react_dom_server_browser_development();
      }
      exports.version = l.version;
      exports.renderToString = l.renderToString;
      exports.renderToStaticMarkup = l.renderToStaticMarkup;
      exports.renderToNodeStream = l.renderToNodeStream;
      exports.renderToStaticNodeStream = l.renderToStaticNodeStream;
      exports.renderToReadableStream = s.renderToReadableStream;
    }
  });

  // output/Data.DateTime.Instant/foreign.js
  var createDateTime = function(y, m, d, h, mi, s, ms) {
    var dateTime3 = new Date(Date.UTC(y, m, d, h, mi, s, ms));
    if (y >= 0 && y < 100) {
      dateTime3.setUTCFullYear(y);
    }
    return dateTime3;
  };
  function fromDateTimeImpl(y, mo, d, h, mi, s, ms) {
    return createDateTime(y, mo - 1, d, h, mi, s, ms).getTime();
  }
  function toDateTimeImpl(ctor) {
    return function(instant2) {
      var dt = new Date(instant2);
      return ctor(dt.getUTCFullYear())(dt.getUTCMonth() + 1)(dt.getUTCDate())(dt.getUTCHours())(dt.getUTCMinutes())(dt.getUTCSeconds())(dt.getUTCMilliseconds());
    };
  }

  // output/Data.Boolean/index.js
  var otherwise = true;

  // output/Data.Bounded/foreign.js
  var topInt = 2147483647;
  var bottomInt = -2147483648;
  var topChar = String.fromCharCode(65535);
  var bottomChar = String.fromCharCode(0);
  var topNumber = Number.POSITIVE_INFINITY;
  var bottomNumber = Number.NEGATIVE_INFINITY;

  // output/Data.Ord/foreign.js
  var unsafeCompareImpl = function(lt) {
    return function(eq3) {
      return function(gt) {
        return function(x) {
          return function(y) {
            return x < y ? lt : x === y ? eq3 : gt;
          };
        };
      };
    };
  };
  var ordIntImpl = unsafeCompareImpl;
  var ordNumberImpl = unsafeCompareImpl;

  // output/Data.Eq/foreign.js
  var refEq = function(r1) {
    return function(r2) {
      return r1 === r2;
    };
  };
  var eqIntImpl = refEq;
  var eqNumberImpl = refEq;
  var eqStringImpl = refEq;

  // output/Data.Eq/index.js
  var eqString = {
    eq: eqStringImpl
  };
  var eqNumber = {
    eq: eqNumberImpl
  };
  var eqInt = {
    eq: eqIntImpl
  };
  var eq = function(dict) {
    return dict.eq;
  };

  // output/Data.Ordering/index.js
  var LT = /* @__PURE__ */ function() {
    function LT2() {
    }
    ;
    LT2.value = new LT2();
    return LT2;
  }();
  var GT = /* @__PURE__ */ function() {
    function GT2() {
    }
    ;
    GT2.value = new GT2();
    return GT2;
  }();
  var EQ = /* @__PURE__ */ function() {
    function EQ2() {
    }
    ;
    EQ2.value = new EQ2();
    return EQ2;
  }();
  var eqOrdering = {
    eq: function(v) {
      return function(v1) {
        if (v instanceof LT && v1 instanceof LT) {
          return true;
        }
        ;
        if (v instanceof GT && v1 instanceof GT) {
          return true;
        }
        ;
        if (v instanceof EQ && v1 instanceof EQ) {
          return true;
        }
        ;
        return false;
      };
    }
  };

  // output/Data.Unit/foreign.js
  var unit = void 0;

  // output/Data.Ord/index.js
  var ordNumber = /* @__PURE__ */ function() {
    return {
      compare: ordNumberImpl(LT.value)(EQ.value)(GT.value),
      Eq0: function() {
        return eqNumber;
      }
    };
  }();
  var ordInt = /* @__PURE__ */ function() {
    return {
      compare: ordIntImpl(LT.value)(EQ.value)(GT.value),
      Eq0: function() {
        return eqInt;
      }
    };
  }();
  var compare = function(dict) {
    return dict.compare;
  };

  // output/Data.Bounded/index.js
  var top = function(dict) {
    return dict.top;
  };
  var boundedInt = {
    top: topInt,
    bottom: bottomInt,
    Ord0: function() {
      return ordInt;
    }
  };
  var bottom = function(dict) {
    return dict.bottom;
  };

  // output/Data.Date/foreign.js
  var createDate = function(y, m, d) {
    var date2 = new Date(Date.UTC(y, m, d));
    if (y >= 0 && y < 100) {
      date2.setUTCFullYear(y);
    }
    return date2;
  };
  function canonicalDateImpl(ctor, y, m, d) {
    var date2 = createDate(y, m - 1, d);
    return ctor(date2.getUTCFullYear())(date2.getUTCMonth() + 1)(date2.getUTCDate());
  }

  // output/Control.Semigroupoid/index.js
  var semigroupoidFn = {
    compose: function(f) {
      return function(g) {
        return function(x) {
          return f(g(x));
        };
      };
    }
  };
  var compose = function(dict) {
    return dict.compose;
  };

  // output/Control.Category/index.js
  var identity = function(dict) {
    return dict.identity;
  };
  var categoryFn = {
    identity: function(x) {
      return x;
    },
    Semigroupoid0: function() {
      return semigroupoidFn;
    }
  };

  // output/Data.Function/index.js
  var on = function(f) {
    return function(g) {
      return function(x) {
        return function(y) {
          return f(g(x))(g(y));
        };
      };
    };
  };
  var flip = function(f) {
    return function(b) {
      return function(a) {
        return f(a)(b);
      };
    };
  };
  var $$const = function(a) {
    return function(v) {
      return a;
    };
  };
  var applyFlipped = function(x) {
    return function(f) {
      return f(x);
    };
  };

  // output/Data.Functor/foreign.js
  var arrayMap = function(f) {
    return function(arr) {
      var l = arr.length;
      var result = new Array(l);
      for (var i = 0; i < l; i++) {
        result[i] = f(arr[i]);
      }
      return result;
    };
  };

  // output/Data.Functor/index.js
  var map = function(dict) {
    return dict.map;
  };
  var mapFlipped = function(dictFunctor) {
    var map16 = map(dictFunctor);
    return function(fa) {
      return function(f) {
        return map16(f)(fa);
      };
    };
  };
  var $$void = function(dictFunctor) {
    return map(dictFunctor)($$const(unit));
  };
  var voidRight = function(dictFunctor) {
    var map16 = map(dictFunctor);
    return function(x) {
      return map16($$const(x));
    };
  };
  var functorFn = {
    map: /* @__PURE__ */ compose(semigroupoidFn)
  };
  var functorArray = {
    map: arrayMap
  };

  // output/Control.Apply/index.js
  var apply = function(dict) {
    return dict.apply;
  };
  var lift2 = function(dictApply) {
    var apply1 = apply(dictApply);
    var map16 = map(dictApply.Functor0());
    return function(f) {
      return function(a) {
        return function(b) {
          return apply1(map16(f)(a))(b);
        };
      };
    };
  };

  // output/Control.Applicative/index.js
  var pure = function(dict) {
    return dict.pure;
  };
  var liftA1 = function(dictApplicative) {
    var apply3 = apply(dictApplicative.Apply0());
    var pure17 = pure(dictApplicative);
    return function(f) {
      return function(a) {
        return apply3(pure17(f))(a);
      };
    };
  };

  // output/Control.Bind/index.js
  var discard = function(dict) {
    return dict.discard;
  };
  var bind = function(dict) {
    return dict.bind;
  };
  var bindFlipped = function(dictBind) {
    return flip(bind(dictBind));
  };
  var composeKleisliFlipped = function(dictBind) {
    var bindFlipped1 = bindFlipped(dictBind);
    return function(f) {
      return function(g) {
        return function(a) {
          return bindFlipped1(f)(g(a));
        };
      };
    };
  };
  var discardUnit = {
    discard: function(dictBind) {
      return bind(dictBind);
    }
  };

  // output/Data.Semigroup/foreign.js
  var concatArray = function(xs) {
    return function(ys) {
      if (xs.length === 0)
        return ys;
      if (ys.length === 0)
        return xs;
      return xs.concat(ys);
    };
  };

  // output/Data.Semigroup/index.js
  var semigroupUnit = {
    append: function(v) {
      return function(v1) {
        return unit;
      };
    }
  };
  var semigroupArray = {
    append: concatArray
  };
  var append = function(dict) {
    return dict.append;
  };

  // output/Control.Alt/index.js
  var alt = function(dict) {
    return dict.alt;
  };

  // output/Control.Plus/index.js
  var empty = function(dict) {
    return dict.empty;
  };

  // output/Data.Show/foreign.js
  var showIntImpl = function(n) {
    return n.toString();
  };
  var showStringImpl = function(s) {
    var l = s.length;
    return '"' + s.replace(
      /[\0-\x1F\x7F"\\]/g,
      function(c, i) {
        switch (c) {
          case '"':
          case "\\":
            return "\\" + c;
          case "\x07":
            return "\\a";
          case "\b":
            return "\\b";
          case "\f":
            return "\\f";
          case "\n":
            return "\\n";
          case "\r":
            return "\\r";
          case "	":
            return "\\t";
          case "\v":
            return "\\v";
        }
        var k = i + 1;
        var empty4 = k < l && s[k] >= "0" && s[k] <= "9" ? "\\&" : "";
        return "\\" + c.charCodeAt(0).toString(10) + empty4;
      }
    ) + '"';
  };

  // output/Data.Show/index.js
  var showString = {
    show: showStringImpl
  };
  var showInt = {
    show: showIntImpl
  };
  var show = function(dict) {
    return dict.show;
  };

  // output/Data.Maybe/index.js
  var identity2 = /* @__PURE__ */ identity(categoryFn);
  var Nothing = /* @__PURE__ */ function() {
    function Nothing2() {
    }
    ;
    Nothing2.value = new Nothing2();
    return Nothing2;
  }();
  var Just = /* @__PURE__ */ function() {
    function Just2(value0) {
      this.value0 = value0;
    }
    ;
    Just2.create = function(value0) {
      return new Just2(value0);
    };
    return Just2;
  }();
  var maybe = function(v) {
    return function(v1) {
      return function(v2) {
        if (v2 instanceof Nothing) {
          return v;
        }
        ;
        if (v2 instanceof Just) {
          return v1(v2.value0);
        }
        ;
        throw new Error("Failed pattern match at Data.Maybe (line 237, column 1 - line 237, column 51): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
      };
    };
  };
  var functorMaybe = {
    map: function(v) {
      return function(v1) {
        if (v1 instanceof Just) {
          return new Just(v(v1.value0));
        }
        ;
        return Nothing.value;
      };
    }
  };
  var map2 = /* @__PURE__ */ map(functorMaybe);
  var fromMaybe = function(a) {
    return maybe(a)(identity2);
  };
  var fromJust = function() {
    return function(v) {
      if (v instanceof Just) {
        return v.value0;
      }
      ;
      throw new Error("Failed pattern match at Data.Maybe (line 288, column 1 - line 288, column 46): " + [v.constructor.name]);
    };
  };
  var applyMaybe = {
    apply: function(v) {
      return function(v1) {
        if (v instanceof Just) {
          return map2(v.value0)(v1);
        }
        ;
        if (v instanceof Nothing) {
          return Nothing.value;
        }
        ;
        throw new Error("Failed pattern match at Data.Maybe (line 67, column 1 - line 69, column 30): " + [v.constructor.name, v1.constructor.name]);
      };
    },
    Functor0: function() {
      return functorMaybe;
    }
  };
  var bindMaybe = {
    bind: function(v) {
      return function(v1) {
        if (v instanceof Just) {
          return v1(v.value0);
        }
        ;
        if (v instanceof Nothing) {
          return Nothing.value;
        }
        ;
        throw new Error("Failed pattern match at Data.Maybe (line 125, column 1 - line 127, column 28): " + [v.constructor.name, v1.constructor.name]);
      };
    },
    Apply0: function() {
      return applyMaybe;
    }
  };
  var applicativeMaybe = /* @__PURE__ */ function() {
    return {
      pure: Just.create,
      Apply0: function() {
        return applyMaybe;
      }
    };
  }();

  // output/Data.Either/index.js
  var Left = /* @__PURE__ */ function() {
    function Left2(value0) {
      this.value0 = value0;
    }
    ;
    Left2.create = function(value0) {
      return new Left2(value0);
    };
    return Left2;
  }();
  var Right = /* @__PURE__ */ function() {
    function Right2(value0) {
      this.value0 = value0;
    }
    ;
    Right2.create = function(value0) {
      return new Right2(value0);
    };
    return Right2;
  }();
  var note = function(a) {
    return maybe(new Left(a))(Right.create);
  };
  var functorEither = {
    map: function(f) {
      return function(m) {
        if (m instanceof Left) {
          return new Left(m.value0);
        }
        ;
        if (m instanceof Right) {
          return new Right(f(m.value0));
        }
        ;
        throw new Error("Failed pattern match at Data.Either (line 0, column 0 - line 0, column 0): " + [m.constructor.name]);
      };
    }
  };
  var map3 = /* @__PURE__ */ map(functorEither);
  var either = function(v) {
    return function(v1) {
      return function(v2) {
        if (v2 instanceof Left) {
          return v(v2.value0);
        }
        ;
        if (v2 instanceof Right) {
          return v1(v2.value0);
        }
        ;
        throw new Error("Failed pattern match at Data.Either (line 208, column 1 - line 208, column 64): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
      };
    };
  };
  var applyEither = {
    apply: function(v) {
      return function(v1) {
        if (v instanceof Left) {
          return new Left(v.value0);
        }
        ;
        if (v instanceof Right) {
          return map3(v.value0)(v1);
        }
        ;
        throw new Error("Failed pattern match at Data.Either (line 70, column 1 - line 72, column 30): " + [v.constructor.name, v1.constructor.name]);
      };
    },
    Functor0: function() {
      return functorEither;
    }
  };
  var bindEither = {
    bind: /* @__PURE__ */ either(function(e) {
      return function(v) {
        return new Left(e);
      };
    })(function(a) {
      return function(f) {
        return f(a);
      };
    }),
    Apply0: function() {
      return applyEither;
    }
  };
  var applicativeEither = /* @__PURE__ */ function() {
    return {
      pure: Right.create,
      Apply0: function() {
        return applyEither;
      }
    };
  }();
  var monadEither = {
    Applicative0: function() {
      return applicativeEither;
    },
    Bind1: function() {
      return bindEither;
    }
  };

  // output/Data.HeytingAlgebra/foreign.js
  var boolConj = function(b1) {
    return function(b2) {
      return b1 && b2;
    };
  };
  var boolDisj = function(b1) {
    return function(b2) {
      return b1 || b2;
    };
  };
  var boolNot = function(b) {
    return !b;
  };

  // output/Data.HeytingAlgebra/index.js
  var not = function(dict) {
    return dict.not;
  };
  var ff = function(dict) {
    return dict.ff;
  };
  var disj = function(dict) {
    return dict.disj;
  };
  var heytingAlgebraBoolean = {
    ff: false,
    tt: true,
    implies: function(a) {
      return function(b) {
        return disj(heytingAlgebraBoolean)(not(heytingAlgebraBoolean)(a))(b);
      };
    },
    conj: boolConj,
    disj: boolDisj,
    not: boolNot
  };

  // output/Data.Monoid/index.js
  var monoidUnit = {
    mempty: unit,
    Semigroup0: function() {
      return semigroupUnit;
    }
  };
  var monoidArray = {
    mempty: [],
    Semigroup0: function() {
      return semigroupArray;
    }
  };
  var mempty = function(dict) {
    return dict.mempty;
  };

  // output/Data.Tuple/index.js
  var Tuple = /* @__PURE__ */ function() {
    function Tuple2(value0, value1) {
      this.value0 = value0;
      this.value1 = value1;
    }
    ;
    Tuple2.create = function(value0) {
      return function(value1) {
        return new Tuple2(value0, value1);
      };
    };
    return Tuple2;
  }();
  var uncurry = function(f) {
    return function(v) {
      return f(v.value0)(v.value1);
    };
  };

  // output/Data.Traversable/foreign.js
  var traverseArrayImpl = function() {
    function array12(a) {
      return [a];
    }
    function array2(a) {
      return function(b) {
        return [a, b];
      };
    }
    function array3(a) {
      return function(b) {
        return function(c) {
          return [a, b, c];
        };
      };
    }
    function concat2(xs) {
      return function(ys) {
        return xs.concat(ys);
      };
    }
    return function(apply3) {
      return function(map16) {
        return function(pure17) {
          return function(f) {
            return function(array4) {
              function go2(bot, top3) {
                switch (top3 - bot) {
                  case 0:
                    return pure17([]);
                  case 1:
                    return map16(array12)(f(array4[bot]));
                  case 2:
                    return apply3(map16(array2)(f(array4[bot])))(f(array4[bot + 1]));
                  case 3:
                    return apply3(apply3(map16(array3)(f(array4[bot])))(f(array4[bot + 1])))(f(array4[bot + 2]));
                  default:
                    var pivot = bot + Math.floor((top3 - bot) / 4) * 2;
                    return apply3(map16(concat2)(go2(bot, pivot)))(go2(pivot, top3));
                }
              }
              return go2(0, array4.length);
            };
          };
        };
      };
    };
  }();

  // output/Data.Foldable/foreign.js
  var foldrArray = function(f) {
    return function(init3) {
      return function(xs) {
        var acc = init3;
        var len = xs.length;
        for (var i = len - 1; i >= 0; i--) {
          acc = f(xs[i])(acc);
        }
        return acc;
      };
    };
  };
  var foldlArray = function(f) {
    return function(init3) {
      return function(xs) {
        var acc = init3;
        var len = xs.length;
        for (var i = 0; i < len; i++) {
          acc = f(acc)(xs[i]);
        }
        return acc;
      };
    };
  };

  // output/Data.Bifunctor/index.js
  var identity3 = /* @__PURE__ */ identity(categoryFn);
  var bimap = function(dict) {
    return dict.bimap;
  };
  var lmap = function(dictBifunctor) {
    var bimap1 = bimap(dictBifunctor);
    return function(f) {
      return bimap1(f)(identity3);
    };
  };
  var bifunctorEither = {
    bimap: function(v) {
      return function(v1) {
        return function(v2) {
          if (v2 instanceof Left) {
            return new Left(v(v2.value0));
          }
          ;
          if (v2 instanceof Right) {
            return new Right(v1(v2.value0));
          }
          ;
          throw new Error("Failed pattern match at Data.Bifunctor (line 32, column 1 - line 34, column 36): " + [v.constructor.name, v1.constructor.name, v2.constructor.name]);
        };
      };
    }
  };

  // output/Data.Monoid.Disj/index.js
  var Disj = function(x) {
    return x;
  };
  var semigroupDisj = function(dictHeytingAlgebra) {
    var disj2 = disj(dictHeytingAlgebra);
    return {
      append: function(v) {
        return function(v1) {
          return disj2(v)(v1);
        };
      }
    };
  };
  var monoidDisj = function(dictHeytingAlgebra) {
    var semigroupDisj1 = semigroupDisj(dictHeytingAlgebra);
    return {
      mempty: ff(dictHeytingAlgebra),
      Semigroup0: function() {
        return semigroupDisj1;
      }
    };
  };

  // output/Unsafe.Coerce/foreign.js
  var unsafeCoerce2 = function(x) {
    return x;
  };

  // output/Safe.Coerce/index.js
  var coerce = function() {
    return unsafeCoerce2;
  };

  // output/Data.Newtype/index.js
  var coerce2 = /* @__PURE__ */ coerce();
  var unwrap = function() {
    return coerce2;
  };
  var unwrap1 = /* @__PURE__ */ unwrap();
  var un = function() {
    return function(v) {
      return unwrap1;
    };
  };
  var alaF = function() {
    return function() {
      return function() {
        return function() {
          return function(v) {
            return coerce2;
          };
        };
      };
    };
  };

  // output/Data.Foldable/index.js
  var eq12 = /* @__PURE__ */ eq(eqOrdering);
  var alaF2 = /* @__PURE__ */ alaF()()()();
  var foldr = function(dict) {
    return dict.foldr;
  };
  var foldl = function(dict) {
    return dict.foldl;
  };
  var maximumBy = function(dictFoldable) {
    var foldl22 = foldl(dictFoldable);
    return function(cmp) {
      var max$prime = function(v) {
        return function(v1) {
          if (v instanceof Nothing) {
            return new Just(v1);
          }
          ;
          if (v instanceof Just) {
            return new Just(function() {
              var $303 = eq12(cmp(v.value0)(v1))(GT.value);
              if ($303) {
                return v.value0;
              }
              ;
              return v1;
            }());
          }
          ;
          throw new Error("Failed pattern match at Data.Foldable (line 441, column 3 - line 441, column 27): " + [v.constructor.name, v1.constructor.name]);
        };
      };
      return foldl22(max$prime)(Nothing.value);
    };
  };
  var maximum = function(dictOrd) {
    var compare2 = compare(dictOrd);
    return function(dictFoldable) {
      return maximumBy(dictFoldable)(compare2);
    };
  };
  var minimumBy = function(dictFoldable) {
    var foldl22 = foldl(dictFoldable);
    return function(cmp) {
      var min$prime = function(v) {
        return function(v1) {
          if (v instanceof Nothing) {
            return new Just(v1);
          }
          ;
          if (v instanceof Just) {
            return new Just(function() {
              var $307 = eq12(cmp(v.value0)(v1))(LT.value);
              if ($307) {
                return v.value0;
              }
              ;
              return v1;
            }());
          }
          ;
          throw new Error("Failed pattern match at Data.Foldable (line 454, column 3 - line 454, column 27): " + [v.constructor.name, v1.constructor.name]);
        };
      };
      return foldl22(min$prime)(Nothing.value);
    };
  };
  var minimum = function(dictOrd) {
    var compare2 = compare(dictOrd);
    return function(dictFoldable) {
      return minimumBy(dictFoldable)(compare2);
    };
  };
  var foldMapDefaultR = function(dictFoldable) {
    var foldr22 = foldr(dictFoldable);
    return function(dictMonoid) {
      var append3 = append(dictMonoid.Semigroup0());
      var mempty3 = mempty(dictMonoid);
      return function(f) {
        return foldr22(function(x) {
          return function(acc) {
            return append3(f(x))(acc);
          };
        })(mempty3);
      };
    };
  };
  var foldableArray = {
    foldr: foldrArray,
    foldl: foldlArray,
    foldMap: function(dictMonoid) {
      return foldMapDefaultR(foldableArray)(dictMonoid);
    }
  };
  var foldMap = function(dict) {
    return dict.foldMap;
  };
  var any = function(dictFoldable) {
    var foldMap22 = foldMap(dictFoldable);
    return function(dictHeytingAlgebra) {
      return alaF2(Disj)(foldMap22(monoidDisj(dictHeytingAlgebra)));
    };
  };

  // output/Data.Identity/index.js
  var Identity = function(x) {
    return x;
  };
  var functorIdentity = {
    map: function(f) {
      return function(m) {
        return f(m);
      };
    }
  };
  var applyIdentity = {
    apply: function(v) {
      return function(v1) {
        return v(v1);
      };
    },
    Functor0: function() {
      return functorIdentity;
    }
  };
  var bindIdentity = {
    bind: function(v) {
      return function(f) {
        return f(v);
      };
    },
    Apply0: function() {
      return applyIdentity;
    }
  };
  var applicativeIdentity = {
    pure: Identity,
    Apply0: function() {
      return applyIdentity;
    }
  };
  var monadIdentity = {
    Applicative0: function() {
      return applicativeIdentity;
    },
    Bind1: function() {
      return bindIdentity;
    }
  };

  // output/Data.Traversable/index.js
  var identity4 = /* @__PURE__ */ identity(categoryFn);
  var traverse = function(dict) {
    return dict.traverse;
  };
  var sequenceDefault = function(dictTraversable) {
    var traverse22 = traverse(dictTraversable);
    return function(dictApplicative) {
      return traverse22(dictApplicative)(identity4);
    };
  };
  var traversableArray = {
    traverse: function(dictApplicative) {
      var Apply0 = dictApplicative.Apply0();
      return traverseArrayImpl(apply(Apply0))(map(Apply0.Functor0()))(pure(dictApplicative));
    },
    sequence: function(dictApplicative) {
      return sequenceDefault(traversableArray)(dictApplicative);
    },
    Functor0: function() {
      return functorArray;
    },
    Foldable1: function() {
      return foldableArray;
    }
  };
  var sequence = function(dict) {
    return dict.sequence;
  };

  // output/Data.Enum/index.js
  var toEnum = function(dict) {
    return dict.toEnum;
  };
  var fromEnum = function(dict) {
    return dict.fromEnum;
  };

  // output/Data.Date.Component/index.js
  var $runtime_lazy = function(name16, moduleName, init3) {
    var state3 = 0;
    var val;
    return function(lineNumber) {
      if (state3 === 2)
        return val;
      if (state3 === 1)
        throw new ReferenceError(name16 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
      state3 = 1;
      val = init3();
      state3 = 2;
      return val;
    };
  };
  var January = /* @__PURE__ */ function() {
    function January2() {
    }
    ;
    January2.value = new January2();
    return January2;
  }();
  var February = /* @__PURE__ */ function() {
    function February2() {
    }
    ;
    February2.value = new February2();
    return February2;
  }();
  var March = /* @__PURE__ */ function() {
    function March2() {
    }
    ;
    March2.value = new March2();
    return March2;
  }();
  var April = /* @__PURE__ */ function() {
    function April2() {
    }
    ;
    April2.value = new April2();
    return April2;
  }();
  var May = /* @__PURE__ */ function() {
    function May2() {
    }
    ;
    May2.value = new May2();
    return May2;
  }();
  var June = /* @__PURE__ */ function() {
    function June2() {
    }
    ;
    June2.value = new June2();
    return June2;
  }();
  var July = /* @__PURE__ */ function() {
    function July2() {
    }
    ;
    July2.value = new July2();
    return July2;
  }();
  var August = /* @__PURE__ */ function() {
    function August2() {
    }
    ;
    August2.value = new August2();
    return August2;
  }();
  var September = /* @__PURE__ */ function() {
    function September2() {
    }
    ;
    September2.value = new September2();
    return September2;
  }();
  var October = /* @__PURE__ */ function() {
    function October2() {
    }
    ;
    October2.value = new October2();
    return October2;
  }();
  var November = /* @__PURE__ */ function() {
    function November2() {
    }
    ;
    November2.value = new November2();
    return November2;
  }();
  var December = /* @__PURE__ */ function() {
    function December2() {
    }
    ;
    December2.value = new December2();
    return December2;
  }();
  var eqMonth = {
    eq: function(x) {
      return function(y) {
        if (x instanceof January && y instanceof January) {
          return true;
        }
        ;
        if (x instanceof February && y instanceof February) {
          return true;
        }
        ;
        if (x instanceof March && y instanceof March) {
          return true;
        }
        ;
        if (x instanceof April && y instanceof April) {
          return true;
        }
        ;
        if (x instanceof May && y instanceof May) {
          return true;
        }
        ;
        if (x instanceof June && y instanceof June) {
          return true;
        }
        ;
        if (x instanceof July && y instanceof July) {
          return true;
        }
        ;
        if (x instanceof August && y instanceof August) {
          return true;
        }
        ;
        if (x instanceof September && y instanceof September) {
          return true;
        }
        ;
        if (x instanceof October && y instanceof October) {
          return true;
        }
        ;
        if (x instanceof November && y instanceof November) {
          return true;
        }
        ;
        if (x instanceof December && y instanceof December) {
          return true;
        }
        ;
        return false;
      };
    }
  };
  var ordMonth = {
    compare: function(x) {
      return function(y) {
        if (x instanceof January && y instanceof January) {
          return EQ.value;
        }
        ;
        if (x instanceof January) {
          return LT.value;
        }
        ;
        if (y instanceof January) {
          return GT.value;
        }
        ;
        if (x instanceof February && y instanceof February) {
          return EQ.value;
        }
        ;
        if (x instanceof February) {
          return LT.value;
        }
        ;
        if (y instanceof February) {
          return GT.value;
        }
        ;
        if (x instanceof March && y instanceof March) {
          return EQ.value;
        }
        ;
        if (x instanceof March) {
          return LT.value;
        }
        ;
        if (y instanceof March) {
          return GT.value;
        }
        ;
        if (x instanceof April && y instanceof April) {
          return EQ.value;
        }
        ;
        if (x instanceof April) {
          return LT.value;
        }
        ;
        if (y instanceof April) {
          return GT.value;
        }
        ;
        if (x instanceof May && y instanceof May) {
          return EQ.value;
        }
        ;
        if (x instanceof May) {
          return LT.value;
        }
        ;
        if (y instanceof May) {
          return GT.value;
        }
        ;
        if (x instanceof June && y instanceof June) {
          return EQ.value;
        }
        ;
        if (x instanceof June) {
          return LT.value;
        }
        ;
        if (y instanceof June) {
          return GT.value;
        }
        ;
        if (x instanceof July && y instanceof July) {
          return EQ.value;
        }
        ;
        if (x instanceof July) {
          return LT.value;
        }
        ;
        if (y instanceof July) {
          return GT.value;
        }
        ;
        if (x instanceof August && y instanceof August) {
          return EQ.value;
        }
        ;
        if (x instanceof August) {
          return LT.value;
        }
        ;
        if (y instanceof August) {
          return GT.value;
        }
        ;
        if (x instanceof September && y instanceof September) {
          return EQ.value;
        }
        ;
        if (x instanceof September) {
          return LT.value;
        }
        ;
        if (y instanceof September) {
          return GT.value;
        }
        ;
        if (x instanceof October && y instanceof October) {
          return EQ.value;
        }
        ;
        if (x instanceof October) {
          return LT.value;
        }
        ;
        if (y instanceof October) {
          return GT.value;
        }
        ;
        if (x instanceof November && y instanceof November) {
          return EQ.value;
        }
        ;
        if (x instanceof November) {
          return LT.value;
        }
        ;
        if (y instanceof November) {
          return GT.value;
        }
        ;
        if (x instanceof December && y instanceof December) {
          return EQ.value;
        }
        ;
        throw new Error("Failed pattern match at Data.Date.Component (line 0, column 0 - line 0, column 0): " + [x.constructor.name, y.constructor.name]);
      };
    },
    Eq0: function() {
      return eqMonth;
    }
  };
  var boundedMonth = /* @__PURE__ */ function() {
    return {
      bottom: January.value,
      top: December.value,
      Ord0: function() {
        return ordMonth;
      }
    };
  }();
  var boundedEnumMonth = {
    cardinality: 12,
    toEnum: function(v) {
      if (v === 1) {
        return new Just(January.value);
      }
      ;
      if (v === 2) {
        return new Just(February.value);
      }
      ;
      if (v === 3) {
        return new Just(March.value);
      }
      ;
      if (v === 4) {
        return new Just(April.value);
      }
      ;
      if (v === 5) {
        return new Just(May.value);
      }
      ;
      if (v === 6) {
        return new Just(June.value);
      }
      ;
      if (v === 7) {
        return new Just(July.value);
      }
      ;
      if (v === 8) {
        return new Just(August.value);
      }
      ;
      if (v === 9) {
        return new Just(September.value);
      }
      ;
      if (v === 10) {
        return new Just(October.value);
      }
      ;
      if (v === 11) {
        return new Just(November.value);
      }
      ;
      if (v === 12) {
        return new Just(December.value);
      }
      ;
      return Nothing.value;
    },
    fromEnum: function(v) {
      if (v instanceof January) {
        return 1;
      }
      ;
      if (v instanceof February) {
        return 2;
      }
      ;
      if (v instanceof March) {
        return 3;
      }
      ;
      if (v instanceof April) {
        return 4;
      }
      ;
      if (v instanceof May) {
        return 5;
      }
      ;
      if (v instanceof June) {
        return 6;
      }
      ;
      if (v instanceof July) {
        return 7;
      }
      ;
      if (v instanceof August) {
        return 8;
      }
      ;
      if (v instanceof September) {
        return 9;
      }
      ;
      if (v instanceof October) {
        return 10;
      }
      ;
      if (v instanceof November) {
        return 11;
      }
      ;
      if (v instanceof December) {
        return 12;
      }
      ;
      throw new Error("Failed pattern match at Data.Date.Component (line 87, column 14 - line 99, column 19): " + [v.constructor.name]);
    },
    Bounded0: function() {
      return boundedMonth;
    },
    Enum1: function() {
      return $lazy_enumMonth(0);
    }
  };
  var $lazy_enumMonth = /* @__PURE__ */ $runtime_lazy("enumMonth", "Data.Date.Component", function() {
    return {
      succ: function() {
        var $67 = toEnum(boundedEnumMonth);
        var $68 = fromEnum(boundedEnumMonth);
        return function($69) {
          return $67(function(v) {
            return v + 1 | 0;
          }($68($69)));
        };
      }(),
      pred: function() {
        var $70 = toEnum(boundedEnumMonth);
        var $71 = fromEnum(boundedEnumMonth);
        return function($72) {
          return $70(function(v) {
            return v - 1 | 0;
          }($71($72)));
        };
      }(),
      Ord0: function() {
        return ordMonth;
      }
    };
  });

  // output/Data.Int/foreign.js
  var fromNumberImpl = function(just) {
    return function(nothing) {
      return function(n) {
        return (n | 0) === n ? just(n) : nothing;
      };
    };
  };
  var toNumber = function(n) {
    return n;
  };

  // output/Data.Number/foreign.js
  var isFiniteImpl = isFinite;
  var floor = Math.floor;
  var pow = function(n) {
    return function(p) {
      return Math.pow(n, p);
    };
  };
  var remainder = function(n) {
    return function(m) {
      return n % m;
    };
  };

  // output/Data.Int/index.js
  var top2 = /* @__PURE__ */ top(boundedInt);
  var bottom2 = /* @__PURE__ */ bottom(boundedInt);
  var fromNumber = /* @__PURE__ */ function() {
    return fromNumberImpl(Just.create)(Nothing.value);
  }();
  var unsafeClamp = function(x) {
    if (!isFiniteImpl(x)) {
      return 0;
    }
    ;
    if (x >= toNumber(top2)) {
      return top2;
    }
    ;
    if (x <= toNumber(bottom2)) {
      return bottom2;
    }
    ;
    if (otherwise) {
      return fromMaybe(0)(fromNumber(x));
    }
    ;
    throw new Error("Failed pattern match at Data.Int (line 72, column 1 - line 72, column 29): " + [x.constructor.name]);
  };
  var floor2 = function($39) {
    return unsafeClamp(floor($39));
  };

  // output/Data.Time.Duration/index.js
  var Milliseconds = function(x) {
    return x;
  };

  // output/Data.Date/index.js
  var fromEnum2 = /* @__PURE__ */ fromEnum(boundedEnumMonth);
  var fromJust2 = /* @__PURE__ */ fromJust();
  var toEnum2 = /* @__PURE__ */ toEnum(boundedEnumMonth);
  var $$Date = /* @__PURE__ */ function() {
    function $$Date2(value0, value1, value22) {
      this.value0 = value0;
      this.value1 = value1;
      this.value2 = value22;
    }
    ;
    $$Date2.create = function(value0) {
      return function(value1) {
        return function(value22) {
          return new $$Date2(value0, value1, value22);
        };
      };
    };
    return $$Date2;
  }();
  var year = function(v) {
    return v.value0;
  };
  var month = function(v) {
    return v.value1;
  };
  var day = function(v) {
    return v.value2;
  };
  var canonicalDate = function(y) {
    return function(m) {
      return function(d) {
        var mkDate = function(y$prime) {
          return function(m$prime) {
            return function(d$prime) {
              return new $$Date(y$prime, fromJust2(toEnum2(m$prime)), d$prime);
            };
          };
        };
        return canonicalDateImpl(mkDate, y, fromEnum2(m), d);
      };
    };
  };

  // output/Data.Time/index.js
  var Time = /* @__PURE__ */ function() {
    function Time2(value0, value1, value22, value32) {
      this.value0 = value0;
      this.value1 = value1;
      this.value2 = value22;
      this.value3 = value32;
    }
    ;
    Time2.create = function(value0) {
      return function(value1) {
        return function(value22) {
          return function(value32) {
            return new Time2(value0, value1, value22, value32);
          };
        };
      };
    };
    return Time2;
  }();
  var second = function(v) {
    return v.value2;
  };
  var minute = function(v) {
    return v.value1;
  };
  var millisecond = function(v) {
    return v.value3;
  };
  var hour = function(v) {
    return v.value0;
  };

  // output/Data.DateTime/index.js
  var DateTime = /* @__PURE__ */ function() {
    function DateTime2(value0, value1) {
      this.value0 = value0;
      this.value1 = value1;
    }
    ;
    DateTime2.create = function(value0) {
      return function(value1) {
        return new DateTime2(value0, value1);
      };
    };
    return DateTime2;
  }();

  // output/Data.DateTime.Instant/index.js
  var fromJust3 = /* @__PURE__ */ fromJust();
  var toEnum3 = /* @__PURE__ */ toEnum(boundedEnumMonth);
  var fromEnum3 = /* @__PURE__ */ fromEnum(boundedEnumMonth);
  var unInstant = function(v) {
    return v;
  };
  var toDateTime = /* @__PURE__ */ function() {
    var mkDateTime = function(y) {
      return function(mo) {
        return function(d) {
          return function(h) {
            return function(mi) {
              return function(s) {
                return function(ms) {
                  return new DateTime(canonicalDate(y)(fromJust3(toEnum3(mo)))(d), new Time(h, mi, s, ms));
                };
              };
            };
          };
        };
      };
    };
    return toDateTimeImpl(mkDateTime);
  }();
  var instant = function(v) {
    if (v >= -86399778816e5 && v <= 8639977881599999) {
      return new Just(v);
    }
    ;
    if (otherwise) {
      return Nothing.value;
    }
    ;
    throw new Error("Failed pattern match at Data.DateTime.Instant (line 44, column 1 - line 44, column 41): " + [v.constructor.name]);
  };
  var fromDateTime = function(v) {
    return fromDateTimeImpl(year(v.value0), fromEnum3(month(v.value0)), day(v.value0), hour(v.value1), minute(v.value1), second(v.value1), millisecond(v.value1));
  };

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/assert.js
  function assert(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "loader assertion failed.");
    }
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/env-utils/globals.js
  var globals = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global,
    document: typeof document !== "undefined" && document
  };
  var self_ = globals.self || globals.window || globals.global || {};
  var window_ = globals.window || globals.self || globals.global || {};
  var global_ = globals.global || globals.self || globals.window || {};
  var document_ = globals.document || {};
  var isBrowser = Boolean(typeof process !== "object" || String(process) !== "[object process]" || process.browser);
  var matches = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
  var nodeVersion = matches && parseFloat(matches[1]) || 0;

  // node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/version.js
  var VERSION = true ? "3.4.14" : DEFAULT_VERSION;
  if (false) {
    console.error("loaders.gl: The __VERSION__ variable is not injected using babel plugin. Latest unstable workers would be fetched from the CDN.");
  }

  // node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/assert.js
  function assert2(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "loaders.gl assertion failed.");
    }
  }

  // node_modules/@loaders.gl/worker-utils/dist/esm/lib/env-utils/globals.js
  var globals2 = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global,
    document: typeof document !== "undefined" && document
  };
  var self_2 = globals2.self || globals2.window || globals2.global || {};
  var window_2 = globals2.window || globals2.self || globals2.global || {};
  var global_2 = globals2.global || globals2.self || globals2.window || {};
  var document_2 = globals2.document || {};
  var isBrowser2 = typeof process !== "object" || String(process) !== "[object process]" || process.browser;
  var isMobile = typeof window !== "undefined" && typeof window.orientation !== "undefined";
  var matches2 = typeof process !== "undefined" && process.version && /v([0-9]*)/.exec(process.version);
  var nodeVersion2 = matches2 && parseFloat(matches2[1]) || 0;

  // node_modules/@babel/runtime/helpers/esm/typeof.js
  function _typeof(o) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof(o);
  }

  // node_modules/@babel/runtime/helpers/esm/toPrimitive.js
  function toPrimitive(t, r) {
    if ("object" != _typeof(t) || !t)
      return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != _typeof(i))
        return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }

  // node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
  function toPropertyKey(t) {
    var i = toPrimitive(t, "string");
    return "symbol" == _typeof(i) ? i : String(i);
  }

  // node_modules/@babel/runtime/helpers/esm/defineProperty.js
  function _defineProperty(obj, key, value13) {
    key = toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value13,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value13;
    }
    return obj;
  }

  // node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-job.js
  var WorkerJob = class {
    constructor(jobName, workerThread) {
      _defineProperty(this, "name", void 0);
      _defineProperty(this, "workerThread", void 0);
      _defineProperty(this, "isRunning", true);
      _defineProperty(this, "result", void 0);
      _defineProperty(this, "_resolve", () => {
      });
      _defineProperty(this, "_reject", () => {
      });
      this.name = jobName;
      this.workerThread = workerThread;
      this.result = new Promise((resolve2, reject) => {
        this._resolve = resolve2;
        this._reject = reject;
      });
    }
    postMessage(type, payload) {
      this.workerThread.postMessage({
        source: "loaders.gl",
        type,
        payload
      });
    }
    done(value13) {
      assert2(this.isRunning);
      this.isRunning = false;
      this._resolve(value13);
    }
    error(error3) {
      assert2(this.isRunning);
      this.isRunning = false;
      this._reject(error3);
    }
  };

  // node_modules/@loaders.gl/worker-utils/dist/esm/lib/node/worker_threads-browser.js
  var Worker2 = class {
    terminate() {
    }
  };

  // node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-loadable-worker-url.js
  var workerURLCache = /* @__PURE__ */ new Map();
  function getLoadableWorkerURL(props) {
    assert2(props.source && !props.url || !props.source && props.url);
    let workerURL = workerURLCache.get(props.source || props.url);
    if (!workerURL) {
      if (props.url) {
        workerURL = getLoadableWorkerURLFromURL(props.url);
        workerURLCache.set(props.url, workerURL);
      }
      if (props.source) {
        workerURL = getLoadableWorkerURLFromSource(props.source);
        workerURLCache.set(props.source, workerURL);
      }
    }
    assert2(workerURL);
    return workerURL;
  }
  function getLoadableWorkerURLFromURL(url) {
    if (!url.startsWith("http")) {
      return url;
    }
    const workerSource = buildScriptSource(url);
    return getLoadableWorkerURLFromSource(workerSource);
  }
  function getLoadableWorkerURLFromSource(workerSource) {
    const blob = new Blob([workerSource], {
      type: "application/javascript"
    });
    return URL.createObjectURL(blob);
  }
  function buildScriptSource(workerUrl) {
    return "try {\n  importScripts('".concat(workerUrl, "');\n} catch (error) {\n  console.error(error);\n  throw error;\n}");
  }

  // node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-utils/get-transfer-list.js
  function getTransferList(object12) {
    let recursive = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    let transfers = arguments.length > 2 ? arguments[2] : void 0;
    const transfersSet = transfers || /* @__PURE__ */ new Set();
    if (!object12) {
    } else if (isTransferable(object12)) {
      transfersSet.add(object12);
    } else if (isTransferable(object12.buffer)) {
      transfersSet.add(object12.buffer);
    } else if (ArrayBuffer.isView(object12)) {
    } else if (recursive && typeof object12 === "object") {
      for (const key in object12) {
        getTransferList(object12[key], recursive, transfersSet);
      }
    }
    return transfers === void 0 ? Array.from(transfersSet) : [];
  }
  function isTransferable(object12) {
    if (!object12) {
      return false;
    }
    if (object12 instanceof ArrayBuffer) {
      return true;
    }
    if (typeof MessagePort !== "undefined" && object12 instanceof MessagePort) {
      return true;
    }
    if (typeof ImageBitmap !== "undefined" && object12 instanceof ImageBitmap) {
      return true;
    }
    if (typeof OffscreenCanvas !== "undefined" && object12 instanceof OffscreenCanvas) {
      return true;
    }
    return false;
  }

  // node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-thread.js
  var NOOP = () => {
  };
  var WorkerThread = class {
    static isSupported() {
      return typeof Worker !== "undefined" && isBrowser2 || typeof Worker2 !== "undefined" && !isBrowser2;
    }
    constructor(props) {
      _defineProperty(this, "name", void 0);
      _defineProperty(this, "source", void 0);
      _defineProperty(this, "url", void 0);
      _defineProperty(this, "terminated", false);
      _defineProperty(this, "worker", void 0);
      _defineProperty(this, "onMessage", void 0);
      _defineProperty(this, "onError", void 0);
      _defineProperty(this, "_loadableURL", "");
      const {
        name: name16,
        source,
        url
      } = props;
      assert2(source || url);
      this.name = name16;
      this.source = source;
      this.url = url;
      this.onMessage = NOOP;
      this.onError = (error3) => console.log(error3);
      this.worker = isBrowser2 ? this._createBrowserWorker() : this._createNodeWorker();
    }
    destroy() {
      this.onMessage = NOOP;
      this.onError = NOOP;
      this.worker.terminate();
      this.terminated = true;
    }
    get isRunning() {
      return Boolean(this.onMessage);
    }
    postMessage(data, transferList) {
      transferList = transferList || getTransferList(data);
      this.worker.postMessage(data, transferList);
    }
    _getErrorFromErrorEvent(event) {
      let message2 = "Failed to load ";
      message2 += "worker ".concat(this.name, " from ").concat(this.url, ". ");
      if (event.message) {
        message2 += "".concat(event.message, " in ");
      }
      if (event.lineno) {
        message2 += ":".concat(event.lineno, ":").concat(event.colno);
      }
      return new Error(message2);
    }
    _createBrowserWorker() {
      this._loadableURL = getLoadableWorkerURL({
        source: this.source,
        url: this.url
      });
      const worker = new Worker(this._loadableURL, {
        name: this.name
      });
      worker.onmessage = (event) => {
        if (!event.data) {
          this.onError(new Error("No data received"));
        } else {
          this.onMessage(event.data);
        }
      };
      worker.onerror = (error3) => {
        this.onError(this._getErrorFromErrorEvent(error3));
        this.terminated = true;
      };
      worker.onmessageerror = (event) => console.error(event);
      return worker;
    }
    _createNodeWorker() {
      let worker;
      if (this.url) {
        const absolute = this.url.includes(":/") || this.url.startsWith("/");
        const url = absolute ? this.url : "./".concat(this.url);
        worker = new Worker2(url, {
          eval: false
        });
      } else if (this.source) {
        worker = new Worker2(this.source, {
          eval: true
        });
      } else {
        throw new Error("no worker");
      }
      worker.on("message", (data) => {
        this.onMessage(data);
      });
      worker.on("error", (error3) => {
        this.onError(error3);
      });
      worker.on("exit", (code) => {
      });
      return worker;
    }
  };

  // node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-pool.js
  var WorkerPool = class {
    static isSupported() {
      return WorkerThread.isSupported();
    }
    constructor(props) {
      _defineProperty(this, "name", "unnamed");
      _defineProperty(this, "source", void 0);
      _defineProperty(this, "url", void 0);
      _defineProperty(this, "maxConcurrency", 1);
      _defineProperty(this, "maxMobileConcurrency", 1);
      _defineProperty(this, "onDebug", () => {
      });
      _defineProperty(this, "reuseWorkers", true);
      _defineProperty(this, "props", {});
      _defineProperty(this, "jobQueue", []);
      _defineProperty(this, "idleQueue", []);
      _defineProperty(this, "count", 0);
      _defineProperty(this, "isDestroyed", false);
      this.source = props.source;
      this.url = props.url;
      this.setProps(props);
    }
    destroy() {
      this.idleQueue.forEach((worker) => worker.destroy());
      this.isDestroyed = true;
    }
    setProps(props) {
      this.props = {
        ...this.props,
        ...props
      };
      if (props.name !== void 0) {
        this.name = props.name;
      }
      if (props.maxConcurrency !== void 0) {
        this.maxConcurrency = props.maxConcurrency;
      }
      if (props.maxMobileConcurrency !== void 0) {
        this.maxMobileConcurrency = props.maxMobileConcurrency;
      }
      if (props.reuseWorkers !== void 0) {
        this.reuseWorkers = props.reuseWorkers;
      }
      if (props.onDebug !== void 0) {
        this.onDebug = props.onDebug;
      }
    }
    async startJob(name16) {
      let onMessage2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : (job, type, data) => job.done(data);
      let onError = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : (job, error3) => job.error(error3);
      const startPromise = new Promise((onStart) => {
        this.jobQueue.push({
          name: name16,
          onMessage: onMessage2,
          onError,
          onStart
        });
        return this;
      });
      this._startQueuedJob();
      return await startPromise;
    }
    async _startQueuedJob() {
      if (!this.jobQueue.length) {
        return;
      }
      const workerThread = this._getAvailableWorker();
      if (!workerThread) {
        return;
      }
      const queuedJob = this.jobQueue.shift();
      if (queuedJob) {
        this.onDebug({
          message: "Starting job",
          name: queuedJob.name,
          workerThread,
          backlog: this.jobQueue.length
        });
        const job = new WorkerJob(queuedJob.name, workerThread);
        workerThread.onMessage = (data) => queuedJob.onMessage(job, data.type, data.payload);
        workerThread.onError = (error3) => queuedJob.onError(job, error3);
        queuedJob.onStart(job);
        try {
          await job.result;
        } finally {
          this.returnWorkerToQueue(workerThread);
        }
      }
    }
    returnWorkerToQueue(worker) {
      const shouldDestroyWorker = this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency();
      if (shouldDestroyWorker) {
        worker.destroy();
        this.count--;
      } else {
        this.idleQueue.push(worker);
      }
      if (!this.isDestroyed) {
        this._startQueuedJob();
      }
    }
    _getAvailableWorker() {
      if (this.idleQueue.length > 0) {
        return this.idleQueue.shift() || null;
      }
      if (this.count < this._getMaxConcurrency()) {
        this.count++;
        const name16 = "".concat(this.name.toLowerCase(), " (#").concat(this.count, " of ").concat(this.maxConcurrency, ")");
        return new WorkerThread({
          name: name16,
          source: this.source,
          url: this.url
        });
      }
      return null;
    }
    _getMaxConcurrency() {
      return isMobile ? this.maxMobileConcurrency : this.maxConcurrency;
    }
  };

  // node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-farm/worker-farm.js
  var DEFAULT_PROPS = {
    maxConcurrency: 3,
    maxMobileConcurrency: 1,
    reuseWorkers: true,
    onDebug: () => {
    }
  };
  var WorkerFarm = class {
    static isSupported() {
      return WorkerThread.isSupported();
    }
    static getWorkerFarm() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      WorkerFarm._workerFarm = WorkerFarm._workerFarm || new WorkerFarm({});
      WorkerFarm._workerFarm.setProps(props);
      return WorkerFarm._workerFarm;
    }
    constructor(props) {
      _defineProperty(this, "props", void 0);
      _defineProperty(this, "workerPools", /* @__PURE__ */ new Map());
      this.props = {
        ...DEFAULT_PROPS
      };
      this.setProps(props);
      this.workerPools = /* @__PURE__ */ new Map();
    }
    destroy() {
      for (const workerPool of this.workerPools.values()) {
        workerPool.destroy();
      }
      this.workerPools = /* @__PURE__ */ new Map();
    }
    setProps(props) {
      this.props = {
        ...this.props,
        ...props
      };
      for (const workerPool of this.workerPools.values()) {
        workerPool.setProps(this._getWorkerPoolProps());
      }
    }
    getWorkerPool(options2) {
      const {
        name: name16,
        source,
        url
      } = options2;
      let workerPool = this.workerPools.get(name16);
      if (!workerPool) {
        workerPool = new WorkerPool({
          name: name16,
          source,
          url
        });
        workerPool.setProps(this._getWorkerPoolProps());
        this.workerPools.set(name16, workerPool);
      }
      return workerPool;
    }
    _getWorkerPoolProps() {
      return {
        maxConcurrency: this.props.maxConcurrency,
        maxMobileConcurrency: this.props.maxMobileConcurrency,
        reuseWorkers: this.props.reuseWorkers,
        onDebug: this.props.onDebug
      };
    }
  };
  _defineProperty(WorkerFarm, "_workerFarm", void 0);

  // node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/get-worker-url.js
  var NPM_TAG = "latest";
  function getWorkerURL(worker) {
    let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const workerOptions = options2[worker.id] || {};
    const workerFile = "".concat(worker.id, "-worker.js");
    let url = workerOptions.workerUrl;
    if (!url && worker.id === "compression") {
      url = options2.workerUrl;
    }
    if (options2._workerType === "test") {
      url = "modules/".concat(worker.module, "/dist/").concat(workerFile);
    }
    if (!url) {
      let version = worker.version;
      if (version === "latest") {
        version = NPM_TAG;
      }
      const versionTag = version ? "@".concat(version) : "";
      url = "https://unpkg.com/@loaders.gl/".concat(worker.module).concat(versionTag, "/dist/").concat(workerFile);
    }
    assert2(url);
    return url;
  }

  // node_modules/@loaders.gl/worker-utils/dist/esm/lib/worker-api/validate-worker-version.js
  function validateWorkerVersion(worker) {
    let coreVersion = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : VERSION;
    assert2(worker, "no worker provided");
    const workerVersion = worker.version;
    if (!coreVersion || !workerVersion) {
      return false;
    }
    return true;
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/worker-loader-utils/parse-with-worker.js
  function canParseWithWorker(loader, options2) {
    if (!WorkerFarm.isSupported()) {
      return false;
    }
    if (!isBrowser2 && !(options2 !== null && options2 !== void 0 && options2._nodeWorkers)) {
      return false;
    }
    return loader.worker && (options2 === null || options2 === void 0 ? void 0 : options2.worker);
  }
  async function parseWithWorker(loader, data, options2, context, parseOnMainThread) {
    const name16 = loader.id;
    const url = getWorkerURL(loader, options2);
    const workerFarm = WorkerFarm.getWorkerFarm(options2);
    const workerPool = workerFarm.getWorkerPool({
      name: name16,
      url
    });
    options2 = JSON.parse(JSON.stringify(options2));
    context = JSON.parse(JSON.stringify(context || {}));
    const job = await workerPool.startJob("process-on-worker", onMessage.bind(null, parseOnMainThread));
    job.postMessage("process", {
      input: data,
      options: options2,
      context
    });
    const result = await job.result;
    return await result.result;
  }
  async function onMessage(parseOnMainThread, job, type, payload) {
    switch (type) {
      case "done":
        job.done(payload);
        break;
      case "error":
        job.error(new Error(payload.error));
        break;
      case "process":
        const {
          id: id2,
          input,
          options: options2
        } = payload;
        try {
          const result = await parseOnMainThread(input, options2);
          job.postMessage("done", {
            id: id2,
            result
          });
        } catch (error3) {
          const message2 = error3 instanceof Error ? error3.message : "unknown error";
          job.postMessage("error", {
            id: id2,
            error: message2
          });
        }
        break;
      default:
        console.warn("parse-with-worker unknown message ".concat(type));
    }
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/array-buffer-utils.js
  function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
    byteLength = byteLength || arrayBuffer1.byteLength;
    if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
      return false;
    }
    const array12 = new Uint8Array(arrayBuffer1);
    const array2 = new Uint8Array(arrayBuffer2);
    for (let i = 0; i < array12.length; ++i) {
      if (array12[i] !== array2[i]) {
        return false;
      }
    }
    return true;
  }
  function concatenateArrayBuffers() {
    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
      sources[_key] = arguments[_key];
    }
    const sourceArrays = sources.map((source2) => source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2);
    const byteLength = sourceArrays.reduce((length7, typedArray) => length7 + typedArray.byteLength, 0);
    const result = new Uint8Array(byteLength);
    let offset = 0;
    for (const sourceArray of sourceArrays) {
      result.set(sourceArray, offset);
      offset += sourceArray.byteLength;
    }
    return result.buffer;
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/iterators/async-iteration.js
  async function concatenateArrayBuffersAsync(asyncIterator) {
    const arrayBuffers = [];
    for await (const chunk of asyncIterator) {
      arrayBuffers.push(chunk);
    }
    return concatenateArrayBuffers(...arrayBuffers);
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/file-aliases.js
  var pathPrefix = "";
  var fileAliases = {};
  function resolvePath(filename2) {
    for (const alias in fileAliases) {
      if (filename2.startsWith(alias)) {
        const replacement = fileAliases[alias];
        filename2 = filename2.replace(alias, replacement);
      }
    }
    if (!filename2.startsWith("http://") && !filename2.startsWith("https://")) {
      filename2 = "".concat(pathPrefix).concat(filename2);
    }
    return filename2;
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/node/buffer.browser.js
  function toArrayBuffer(buffer) {
    return buffer;
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/binary-utils/memory-conversion-utils.js
  function isBuffer(value13) {
    return value13 && typeof value13 === "object" && value13.isBuffer;
  }
  function toArrayBuffer2(data) {
    if (isBuffer(data)) {
      return toArrayBuffer(data);
    }
    if (data instanceof ArrayBuffer) {
      return data;
    }
    if (ArrayBuffer.isView(data)) {
      if (data.byteOffset === 0 && data.byteLength === data.buffer.byteLength) {
        return data.buffer;
      }
      return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
    }
    if (typeof data === "string") {
      const text5 = data;
      const uint8Array = new TextEncoder().encode(text5);
      return uint8Array.buffer;
    }
    if (data && typeof data === "object" && data._toArrayBuffer) {
      return data._toArrayBuffer();
    }
    throw new Error("toArrayBuffer");
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js
  var path_exports = {};
  __export(path_exports, {
    dirname: () => dirname,
    filename: () => filename,
    join: () => join2,
    resolve: () => resolve
  });

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/get-cwd.js
  function getCWD() {
    var _window$location;
    if (typeof process !== "undefined" && typeof process.cwd !== "undefined") {
      return process.cwd();
    }
    const pathname2 = (_window$location = window.location) === null || _window$location === void 0 ? void 0 : _window$location.pathname;
    return (pathname2 === null || pathname2 === void 0 ? void 0 : pathname2.slice(0, pathname2.lastIndexOf("/") + 1)) || "";
  }

  // node_modules/@loaders.gl/loader-utils/dist/esm/lib/path-utils/path.js
  function filename(url) {
    const slashIndex = url ? url.lastIndexOf("/") : -1;
    return slashIndex >= 0 ? url.substr(slashIndex + 1) : "";
  }
  function dirname(url) {
    const slashIndex = url ? url.lastIndexOf("/") : -1;
    return slashIndex >= 0 ? url.substr(0, slashIndex) : "";
  }
  function join2() {
    for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
      parts[_key] = arguments[_key];
    }
    const separator = "/";
    parts = parts.map((part, index5) => {
      if (index5) {
        part = part.replace(new RegExp("^".concat(separator)), "");
      }
      if (index5 !== parts.length - 1) {
        part = part.replace(new RegExp("".concat(separator, "$")), "");
      }
      return part;
    });
    return parts.join(separator);
  }
  function resolve() {
    const paths = [];
    for (let _i = 0; _i < arguments.length; _i++) {
      paths[_i] = _i < 0 || arguments.length <= _i ? void 0 : arguments[_i];
    }
    let resolvedPath = "";
    let resolvedAbsolute = false;
    let cwd;
    for (let i = paths.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      let path;
      if (i >= 0) {
        path = paths[i];
      } else {
        if (cwd === void 0) {
          cwd = getCWD();
        }
        path = cwd;
      }
      if (path.length === 0) {
        continue;
      }
      resolvedPath = "".concat(path, "/").concat(resolvedPath);
      resolvedAbsolute = path.charCodeAt(0) === SLASH;
    }
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);
    if (resolvedAbsolute) {
      return "/".concat(resolvedPath);
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    }
    return ".";
  }
  var SLASH = 47;
  var DOT = 46;
  function normalizeStringPosix(path, allowAboveRoot) {
    let res = "";
    let lastSlash = -1;
    let dots = 0;
    let code;
    let isAboveRoot = false;
    for (let i = 0; i <= path.length; ++i) {
      if (i < path.length) {
        code = path.charCodeAt(i);
      } else if (code === SLASH) {
        break;
      } else {
        code = SLASH;
      }
      if (code === SLASH) {
        if (lastSlash === i - 1 || dots === 1) {
        } else if (lastSlash !== i - 1 && dots === 2) {
          if (res.length < 2 || !isAboveRoot || res.charCodeAt(res.length - 1) !== DOT || res.charCodeAt(res.length - 2) !== DOT) {
            if (res.length > 2) {
              const start2 = res.length - 1;
              let j = start2;
              for (; j >= 0; --j) {
                if (res.charCodeAt(j) === SLASH) {
                  break;
                }
              }
              if (j !== start2) {
                res = j === -1 ? "" : res.slice(0, j);
                lastSlash = i;
                dots = 0;
                isAboveRoot = false;
                continue;
              }
            } else if (res.length === 2 || res.length === 1) {
              res = "";
              lastSlash = i;
              dots = 0;
              isAboveRoot = false;
              continue;
            }
          }
          if (allowAboveRoot) {
            if (res.length > 0) {
              res += "/..";
            } else {
              res = "..";
            }
            isAboveRoot = true;
          }
        } else {
          const slice3 = path.slice(lastSlash + 1, i);
          if (res.length > 0) {
            res += "/".concat(slice3);
          } else {
            res = slice3;
          }
          isAboveRoot = false;
        }
        lastSlash = i;
        dots = 0;
      } else if (code === DOT && dots !== -1) {
        ++dots;
      } else {
        dots = -1;
      }
    }
    return res;
  }

  // node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js
  var isBoolean = (x) => typeof x === "boolean";
  var isFunction = (x) => typeof x === "function";
  var isObject = (x) => x !== null && typeof x === "object";
  var isPureObject = (x) => isObject(x) && x.constructor === {}.constructor;
  var isIterable = (x) => x && typeof x[Symbol.iterator] === "function";
  var isAsyncIterable = (x) => x && typeof x[Symbol.asyncIterator] === "function";
  var isResponse = (x) => typeof Response !== "undefined" && x instanceof Response || x && x.arrayBuffer && x.text && x.json;
  var isBlob = (x) => typeof Blob !== "undefined" && x instanceof Blob;
  var isBuffer2 = (x) => x && typeof x === "object" && x.isBuffer;
  var isReadableDOMStream = (x) => typeof ReadableStream !== "undefined" && x instanceof ReadableStream || isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.getReader);
  var isReadableNodeStream = (x) => isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);
  var isReadableStream = (x) => isReadableDOMStream(x) || isReadableNodeStream(x);

  // node_modules/@loaders.gl/core/dist/esm/lib/utils/mime-type-utils.js
  var DATA_URL_PATTERN = /^data:([-\w.]+\/[-\w.+]+)(;|,)/;
  var MIME_TYPE_PATTERN = /^([-\w.]+\/[-\w.+]+)/;
  function parseMIMEType(mimeString) {
    const matches3 = MIME_TYPE_PATTERN.exec(mimeString);
    if (matches3) {
      return matches3[1];
    }
    return mimeString;
  }
  function parseMIMETypeFromURL(url) {
    const matches3 = DATA_URL_PATTERN.exec(url);
    if (matches3) {
      return matches3[1];
    }
    return "";
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/utils/url-utils.js
  var QUERY_STRING_PATTERN = /\?.*/;
  function extractQueryString(url) {
    const matches3 = url.match(QUERY_STRING_PATTERN);
    return matches3 && matches3[0];
  }
  function stripQueryString(url) {
    return url.replace(QUERY_STRING_PATTERN, "");
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/utils/resource-utils.js
  function getResourceUrl(resource) {
    if (isResponse(resource)) {
      const response = resource;
      return response.url;
    }
    if (isBlob(resource)) {
      const blob = resource;
      return blob.name || "";
    }
    if (typeof resource === "string") {
      return resource;
    }
    return "";
  }
  function getResourceMIMEType(resource) {
    if (isResponse(resource)) {
      const response = resource;
      const contentTypeHeader = response.headers.get("content-type") || "";
      const noQueryUrl = stripQueryString(response.url);
      return parseMIMEType(contentTypeHeader) || parseMIMETypeFromURL(noQueryUrl);
    }
    if (isBlob(resource)) {
      const blob = resource;
      return blob.type || "";
    }
    if (typeof resource === "string") {
      return parseMIMETypeFromURL(resource);
    }
    return "";
  }
  function getResourceContentLength(resource) {
    if (isResponse(resource)) {
      const response = resource;
      return response.headers["content-length"] || -1;
    }
    if (isBlob(resource)) {
      const blob = resource;
      return blob.size;
    }
    if (typeof resource === "string") {
      return resource.length;
    }
    if (resource instanceof ArrayBuffer) {
      return resource.byteLength;
    }
    if (ArrayBuffer.isView(resource)) {
      return resource.byteLength;
    }
    return -1;
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/utils/response-utils.js
  async function makeResponse(resource) {
    if (isResponse(resource)) {
      return resource;
    }
    const headers = {};
    const contentLength = getResourceContentLength(resource);
    if (contentLength >= 0) {
      headers["content-length"] = String(contentLength);
    }
    const url = getResourceUrl(resource);
    const type = getResourceMIMEType(resource);
    if (type) {
      headers["content-type"] = type;
    }
    const initialDataUrl = await getInitialDataUrl(resource);
    if (initialDataUrl) {
      headers["x-first-bytes"] = initialDataUrl;
    }
    if (typeof resource === "string") {
      resource = new TextEncoder().encode(resource);
    }
    const response = new Response(resource, {
      headers
    });
    Object.defineProperty(response, "url", {
      value: url
    });
    return response;
  }
  async function checkResponse(response) {
    if (!response.ok) {
      const message2 = await getResponseError(response);
      throw new Error(message2);
    }
  }
  async function getResponseError(response) {
    let message2 = "Failed to fetch resource ".concat(response.url, " (").concat(response.status, "): ");
    try {
      const contentType = response.headers.get("Content-Type");
      let text5 = response.statusText;
      if (contentType.includes("application/json")) {
        text5 += " ".concat(await response.text());
      }
      message2 += text5;
      message2 = message2.length > 60 ? "".concat(message2.slice(0, 60), "...") : message2;
    } catch (error3) {
    }
    return message2;
  }
  async function getInitialDataUrl(resource) {
    const INITIAL_DATA_LENGTH = 5;
    if (typeof resource === "string") {
      return "data:,".concat(resource.slice(0, INITIAL_DATA_LENGTH));
    }
    if (resource instanceof Blob) {
      const blobSlice = resource.slice(0, 5);
      return await new Promise((resolve2) => {
        const reader = new FileReader();
        reader.onload = (event) => {
          var _event$target;
          return resolve2(event === null || event === void 0 ? void 0 : (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result);
        };
        reader.readAsDataURL(blobSlice);
      });
    }
    if (resource instanceof ArrayBuffer) {
      const slice3 = resource.slice(0, INITIAL_DATA_LENGTH);
      const base64 = arrayBufferToBase64(slice3);
      return "data:base64,".concat(base64);
    }
    return null;
  }
  function arrayBufferToBase64(buffer) {
    let binary = "";
    const bytes = new Uint8Array(buffer);
    for (let i = 0; i < bytes.byteLength; i++) {
      binary += String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js
  async function fetchFile(url, options2) {
    if (typeof url === "string") {
      url = resolvePath(url);
      let fetchOptions = options2;
      if (options2 !== null && options2 !== void 0 && options2.fetch && typeof (options2 === null || options2 === void 0 ? void 0 : options2.fetch) !== "function") {
        fetchOptions = options2.fetch;
      }
      return await fetch(url, fetchOptions);
    }
    return await makeResponse(url);
  }

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/is-electron.js
  function isElectron(mockUserAgent) {
    if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
      return true;
    }
    if (typeof process !== "undefined" && typeof process.versions === "object" && Boolean(process.versions["electron"])) {
      return true;
    }
    const realUserAgent = typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent;
    const userAgent3 = mockUserAgent || realUserAgent;
    if (userAgent3 && userAgent3.indexOf("Electron") >= 0) {
      return true;
    }
    return false;
  }

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/is-browser.js
  function isBrowser3() {
    const isNode = typeof process === "object" && String(process) === "[object process]" && !process.browser;
    return !isNode || isElectron();
  }

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/lib/globals.js
  var self_3 = globalThis.self || globalThis.window || globalThis.global;
  var window_3 = globalThis.window || globalThis.self || globalThis.global;
  var document_3 = globalThis.document || {};
  var process_ = globalThis.process || {};
  var console_ = globalThis.console;
  var navigator_ = globalThis.navigator || {};

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/env/dist/utils/globals.js
  var VERSION2 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "untranspiled source";
  var isBrowser4 = isBrowser3();

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/local-storage.js
  function getStorage(type) {
    try {
      const storage = window[type];
      const x = "__storage_test__";
      storage.setItem(x, x);
      storage.removeItem(x);
      return storage;
    } catch (e) {
      return null;
    }
  }
  var LocalStorage = class {
    constructor(id2, defaultConfig) {
      let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "sessionStorage";
      this.storage = void 0;
      this.id = void 0;
      this.config = void 0;
      this.storage = getStorage(type);
      this.id = id2;
      this.config = defaultConfig;
      this._loadConfiguration();
    }
    getConfiguration() {
      return this.config;
    }
    setConfiguration(configuration) {
      Object.assign(this.config, configuration);
      if (this.storage) {
        const serialized = JSON.stringify(this.config);
        this.storage.setItem(this.id, serialized);
      }
    }
    _loadConfiguration() {
      let configuration = {};
      if (this.storage) {
        const serializedConfiguration = this.storage.getItem(this.id);
        configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
      }
      Object.assign(this.config, configuration);
      return this;
    }
  };

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/formatters.js
  function formatTime(ms) {
    let formatted;
    if (ms < 10) {
      formatted = `${ms.toFixed(2)}ms`;
    } else if (ms < 100) {
      formatted = `${ms.toFixed(1)}ms`;
    } else if (ms < 1e3) {
      formatted = `${ms.toFixed(0)}ms`;
    } else {
      formatted = `${(ms / 1e3).toFixed(2)}s`;
    }
    return formatted;
  }
  function leftPad(string13) {
    let length7 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
    const padLength = Math.max(length7 - string13.length, 0);
    return `${" ".repeat(padLength)}${string13}`;
  }
  function formatImage(image, message2, scale4) {
    let maxWidth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;
    const imageUrl = image.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
    if (image.width > maxWidth) {
      scale4 = Math.min(scale4, maxWidth / image.width);
    }
    const width8 = image.width * scale4;
    const height8 = image.height * scale4;
    const style = ["font-size:1px;", `padding:${Math.floor(height8 / 2)}px ${Math.floor(width8 / 2)}px;`, `line-height:${height8}px;`, `background:url(${imageUrl});`, `background-size:${width8}px ${height8}px;`, "color:transparent;"].join("");
    return [`${message2} %c+`, style];
  }

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/color.js
  var COLOR;
  (function(COLOR3) {
    COLOR3[COLOR3["BLACK"] = 30] = "BLACK";
    COLOR3[COLOR3["RED"] = 31] = "RED";
    COLOR3[COLOR3["GREEN"] = 32] = "GREEN";
    COLOR3[COLOR3["YELLOW"] = 33] = "YELLOW";
    COLOR3[COLOR3["BLUE"] = 34] = "BLUE";
    COLOR3[COLOR3["MAGENTA"] = 35] = "MAGENTA";
    COLOR3[COLOR3["CYAN"] = 36] = "CYAN";
    COLOR3[COLOR3["WHITE"] = 37] = "WHITE";
    COLOR3[COLOR3["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
    COLOR3[COLOR3["BRIGHT_RED"] = 91] = "BRIGHT_RED";
    COLOR3[COLOR3["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
    COLOR3[COLOR3["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
    COLOR3[COLOR3["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
    COLOR3[COLOR3["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
    COLOR3[COLOR3["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
    COLOR3[COLOR3["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
  })(COLOR || (COLOR = {}));
  var BACKGROUND_INCREMENT = 10;
  function getColor(color) {
    if (typeof color !== "string") {
      return color;
    }
    color = color.toUpperCase();
    return COLOR[color] || COLOR.WHITE;
  }
  function addColor(string13, color, background) {
    if (!isBrowser3 && typeof string13 === "string") {
      if (color) {
        const colorCode = getColor(color);
        string13 = `\x1B[${colorCode}m${string13}\x1B[39m`;
      }
      if (background) {
        const colorCode = getColor(background);
        string13 = `\x1B[${colorCode + BACKGROUND_INCREMENT}m${string13}\x1B[49m`;
      }
    }
    return string13;
  }

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/autobind.js
  function autobind(obj) {
    let predefined = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["constructor"];
    const proto = Object.getPrototypeOf(obj);
    const propNames = Object.getOwnPropertyNames(proto);
    const object12 = obj;
    for (const key of propNames) {
      const value13 = object12[key];
      if (typeof value13 === "function") {
        if (!predefined.find((name16) => key === name16)) {
          object12[key] = value13.bind(obj);
        }
      }
    }
  }

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/assert.js
  function assert3(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "Assertion failed");
    }
  }

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/utils/hi-res-timestamp.js
  function getHiResTimestamp() {
    let timestamp;
    if (isBrowser3() && window_3.performance) {
      var _window$performance, _window$performance$n;
      timestamp = window_3 === null || window_3 === void 0 ? void 0 : (_window$performance = window_3.performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);
    } else if ("hrtime" in process_) {
      var _process$hrtime;
      const timeParts = process_ === null || process_ === void 0 ? void 0 : (_process$hrtime = process_.hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call(process_);
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/log.js
  var originalConsole = {
    debug: isBrowser3() ? console.debug || console.log : console.log,
    log: console.log,
    info: console.info,
    warn: console.warn,
    error: console.error
  };
  var DEFAULT_LOG_CONFIGURATION = {
    enabled: true,
    level: 0
  };
  function noop() {
  }
  var cache = {};
  var ONCE = {
    once: true
  };
  var Log = class {
    constructor() {
      let {
        id: id2
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        id: ""
      };
      this.id = void 0;
      this.VERSION = VERSION2;
      this._startTs = getHiResTimestamp();
      this._deltaTs = getHiResTimestamp();
      this._storage = void 0;
      this.userData = {};
      this.LOG_THROTTLE_TIMEOUT = 0;
      this.id = id2;
      this.userData = {};
      this._storage = new LocalStorage(`__probe-${this.id}__`, DEFAULT_LOG_CONFIGURATION);
      this.timeStamp(`${this.id} started`);
      autobind(this);
      Object.seal(this);
    }
    set level(newLevel) {
      this.setLevel(newLevel);
    }
    get level() {
      return this.getLevel();
    }
    isEnabled() {
      return this._storage.config.enabled;
    }
    getLevel() {
      return this._storage.config.level;
    }
    getTotal() {
      return Number((getHiResTimestamp() - this._startTs).toPrecision(10));
    }
    getDelta() {
      return Number((getHiResTimestamp() - this._deltaTs).toPrecision(10));
    }
    set priority(newPriority) {
      this.level = newPriority;
    }
    get priority() {
      return this.level;
    }
    getPriority() {
      return this.level;
    }
    enable() {
      let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this._storage.setConfiguration({
        enabled
      });
      return this;
    }
    setLevel(level) {
      this._storage.setConfiguration({
        level
      });
      return this;
    }
    get(setting) {
      return this._storage.config[setting];
    }
    set(setting, value13) {
      this._storage.setConfiguration({
        [setting]: value13
      });
    }
    settings() {
      if (console.table) {
        console.table(this._storage.config);
      } else {
        console.log(this._storage.config);
      }
    }
    assert(condition, message2) {
      assert3(condition, message2);
    }
    warn(message2) {
      return this._getLogFunction(0, message2, originalConsole.warn, arguments, ONCE);
    }
    error(message2) {
      return this._getLogFunction(0, message2, originalConsole.error, arguments);
    }
    deprecated(oldUsage, newUsage) {
      return this.warn(`\`${oldUsage}\` is deprecated and will be removed in a later version. Use \`${newUsage}\` instead`);
    }
    removed(oldUsage, newUsage) {
      return this.error(`\`${oldUsage}\` has been removed. Use \`${newUsage}\` instead`);
    }
    probe(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, originalConsole.log, arguments, {
        time: true,
        once: true
      });
    }
    log(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, originalConsole.debug, arguments);
    }
    info(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, console.info, arguments);
    }
    once(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, originalConsole.debug || originalConsole.info, arguments, ONCE);
    }
    table(logLevel, table, columns) {
      if (table) {
        return this._getLogFunction(logLevel, table, console.table || noop, columns && [columns], {
          tag: getTableHeader(table)
        });
      }
      return noop;
    }
    image(_ref) {
      let {
        logLevel,
        priority,
        image,
        message: message2 = "",
        scale: scale4 = 1
      } = _ref;
      if (!this._shouldLog(logLevel || priority)) {
        return noop;
      }
      return isBrowser3() ? logImageInBrowser({
        image,
        message: message2,
        scale: scale4
      }) : logImageInNode({
        image,
        message: message2,
        scale: scale4
      });
    }
    time(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, console.time ? console.time : console.info);
    }
    timeEnd(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, console.timeEnd ? console.timeEnd : console.info);
    }
    timeStamp(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, console.timeStamp || noop);
    }
    group(logLevel, message2) {
      let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        collapsed: false
      };
      const options2 = normalizeArguments({
        logLevel,
        message: message2,
        opts
      });
      const {
        collapsed
      } = opts;
      options2.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
      return this._getLogFunction(options2);
    }
    groupCollapsed(logLevel, message2) {
      let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.group(logLevel, message2, Object.assign({}, opts, {
        collapsed: true
      }));
    }
    groupEnd(logLevel) {
      return this._getLogFunction(logLevel, "", console.groupEnd || noop);
    }
    withGroup(logLevel, message2, func11) {
      this.group(logLevel, message2)();
      try {
        func11();
      } finally {
        this.groupEnd(logLevel)();
      }
    }
    trace() {
      if (console.trace) {
        console.trace();
      }
    }
    _shouldLog(logLevel) {
      return this.isEnabled() && this.getLevel() >= normalizeLogLevel(logLevel);
    }
    _getLogFunction(logLevel, message2, method2, args, opts) {
      if (this._shouldLog(logLevel)) {
        opts = normalizeArguments({
          logLevel,
          message: message2,
          args,
          opts
        });
        method2 = method2 || opts.method;
        assert3(method2);
        opts.total = this.getTotal();
        opts.delta = this.getDelta();
        this._deltaTs = getHiResTimestamp();
        const tag = opts.tag || opts.message;
        if (opts.once && tag) {
          if (!cache[tag]) {
            cache[tag] = getHiResTimestamp();
          } else {
            return noop;
          }
        }
        message2 = decorateMessage(this.id, opts.message, opts);
        return method2.bind(console, message2, ...opts.args);
      }
      return noop;
    }
  };
  Log.VERSION = VERSION2;
  function normalizeLogLevel(logLevel) {
    if (!logLevel) {
      return 0;
    }
    let resolvedLevel;
    switch (typeof logLevel) {
      case "number":
        resolvedLevel = logLevel;
        break;
      case "object":
        resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
        break;
      default:
        return 0;
    }
    assert3(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
    return resolvedLevel;
  }
  function normalizeArguments(opts) {
    const {
      logLevel,
      message: message2
    } = opts;
    opts.logLevel = normalizeLogLevel(logLevel);
    const args = opts.args ? Array.from(opts.args) : [];
    while (args.length && args.shift() !== message2) {
    }
    switch (typeof logLevel) {
      case "string":
      case "function":
        if (message2 !== void 0) {
          args.unshift(message2);
        }
        opts.message = logLevel;
        break;
      case "object":
        Object.assign(opts, logLevel);
        break;
      default:
    }
    if (typeof opts.message === "function") {
      opts.message = opts.message();
    }
    const messageType = typeof opts.message;
    assert3(messageType === "string" || messageType === "object");
    return Object.assign(opts, {
      args
    }, opts.opts);
  }
  function decorateMessage(id2, message2, opts) {
    if (typeof message2 === "string") {
      const time = opts.time ? leftPad(formatTime(opts.total)) : "";
      message2 = opts.time ? `${id2}: ${time}  ${message2}` : `${id2}: ${message2}`;
      message2 = addColor(message2, opts.color, opts.background);
    }
    return message2;
  }
  function logImageInNode(_ref2) {
    let {
      image,
      message: message2 = "",
      scale: scale4 = 1
    } = _ref2;
    console.warn("removed");
    return noop;
  }
  function logImageInBrowser(_ref3) {
    let {
      image,
      message: message2 = "",
      scale: scale4 = 1
    } = _ref3;
    if (typeof image === "string") {
      const img = new Image();
      img.onload = () => {
        const args = formatImage(img, message2, scale4);
        console.log(...args);
      };
      img.src = image;
      return noop;
    }
    const element = image.nodeName || "";
    if (element.toLowerCase() === "img") {
      console.log(...formatImage(image, message2, scale4));
      return noop;
    }
    if (element.toLowerCase() === "canvas") {
      const img = new Image();
      img.onload = () => console.log(...formatImage(img, message2, scale4));
      img.src = image.toDataURL();
      return noop;
    }
    return noop;
  }
  function getTableHeader(table) {
    for (const key in table) {
      for (const title2 in table[key]) {
        return title2 || "untitled";
      }
    }
    return "empty";
  }

  // node_modules/@loaders.gl/core/node_modules/@probe.gl/log/dist/index.js
  var dist_default = new Log({
    id: "@probe.gl/log"
  });

  // node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loggers.js
  var probeLog = new Log({
    id: "loaders.gl"
  });
  var NullLog = class {
    log() {
      return () => {
      };
    }
    info() {
      return () => {
      };
    }
    warn() {
      return () => {
      };
    }
    error() {
      return () => {
      };
    }
  };
  var ConsoleLog = class {
    constructor() {
      _defineProperty(this, "console", void 0);
      this.console = console;
    }
    log() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.console.log.bind(this.console, ...args);
    }
    info() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return this.console.info.bind(this.console, ...args);
    }
    warn() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.console.warn.bind(this.console, ...args);
    }
    error() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return this.console.error.bind(this.console, ...args);
    }
  };

  // node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-defaults.js
  var DEFAULT_LOADER_OPTIONS = {
    fetch: null,
    mimeType: void 0,
    nothrow: false,
    log: new ConsoleLog(),
    CDN: "https://unpkg.com/@loaders.gl",
    worker: true,
    maxConcurrency: 3,
    maxMobileConcurrency: 1,
    reuseWorkers: isBrowser,
    _nodeWorkers: false,
    _workerType: "",
    limit: 0,
    _limitMB: 0,
    batchSize: "auto",
    batchDebounceMs: 0,
    metadata: false,
    transforms: []
  };
  var REMOVED_LOADER_OPTIONS = {
    throws: "nothrow",
    dataType: "(no longer used)",
    uri: "baseUri",
    method: "fetch.method",
    headers: "fetch.headers",
    body: "fetch.body",
    mode: "fetch.mode",
    credentials: "fetch.credentials",
    cache: "fetch.cache",
    redirect: "fetch.redirect",
    referrer: "fetch.referrer",
    referrerPolicy: "fetch.referrerPolicy",
    integrity: "fetch.integrity",
    keepalive: "fetch.keepalive",
    signal: "fetch.signal"
  };

  // node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/option-utils.js
  function getGlobalLoaderState() {
    globalThis.loaders = globalThis.loaders || {};
    const {
      loaders
    } = globalThis;
    loaders._state = loaders._state || {};
    return loaders._state;
  }
  var getGlobalLoaderOptions = () => {
    const state3 = getGlobalLoaderState();
    state3.globalOptions = state3.globalOptions || {
      ...DEFAULT_LOADER_OPTIONS
    };
    return state3.globalOptions;
  };
  function normalizeOptions(options2, loader, loaders, url) {
    loaders = loaders || [];
    loaders = Array.isArray(loaders) ? loaders : [loaders];
    validateOptions(options2, loaders);
    return normalizeOptionsInternal(loader, options2, url);
  }
  function validateOptions(options2, loaders) {
    validateOptionsObject(options2, null, DEFAULT_LOADER_OPTIONS, REMOVED_LOADER_OPTIONS, loaders);
    for (const loader of loaders) {
      const idOptions = options2 && options2[loader.id] || {};
      const loaderOptions = loader.options && loader.options[loader.id] || {};
      const deprecatedOptions = loader.deprecatedOptions && loader.deprecatedOptions[loader.id] || {};
      validateOptionsObject(idOptions, loader.id, loaderOptions, deprecatedOptions, loaders);
    }
  }
  function validateOptionsObject(options2, id2, defaultOptions, deprecatedOptions, loaders) {
    const loaderName = id2 || "Top level";
    const prefix = id2 ? "".concat(id2, ".") : "";
    for (const key in options2) {
      const isSubOptions = !id2 && isObject(options2[key]);
      const isBaseUriOption = key === "baseUri" && !id2;
      const isWorkerUrlOption = key === "workerUrl" && id2;
      if (!(key in defaultOptions) && !isBaseUriOption && !isWorkerUrlOption) {
        if (key in deprecatedOptions) {
          probeLog.warn("".concat(loaderName, " loader option '").concat(prefix).concat(key, "' no longer supported, use '").concat(deprecatedOptions[key], "'"))();
        } else if (!isSubOptions) {
          const suggestion = findSimilarOption(key, loaders);
          probeLog.warn("".concat(loaderName, " loader option '").concat(prefix).concat(key, "' not recognized. ").concat(suggestion))();
        }
      }
    }
  }
  function findSimilarOption(optionKey, loaders) {
    const lowerCaseOptionKey = optionKey.toLowerCase();
    let bestSuggestion = "";
    for (const loader of loaders) {
      for (const key in loader.options) {
        if (optionKey === key) {
          return "Did you mean '".concat(loader.id, ".").concat(key, "'?");
        }
        const lowerCaseKey = key.toLowerCase();
        const isPartialMatch = lowerCaseOptionKey.startsWith(lowerCaseKey) || lowerCaseKey.startsWith(lowerCaseOptionKey);
        if (isPartialMatch) {
          bestSuggestion = bestSuggestion || "Did you mean '".concat(loader.id, ".").concat(key, "'?");
        }
      }
    }
    return bestSuggestion;
  }
  function normalizeOptionsInternal(loader, options2, url) {
    const loaderDefaultOptions = loader.options || {};
    const mergedOptions = {
      ...loaderDefaultOptions
    };
    addUrlOptions(mergedOptions, url);
    if (mergedOptions.log === null) {
      mergedOptions.log = new NullLog();
    }
    mergeNestedFields(mergedOptions, getGlobalLoaderOptions());
    mergeNestedFields(mergedOptions, options2);
    return mergedOptions;
  }
  function mergeNestedFields(mergedOptions, options2) {
    for (const key in options2) {
      if (key in options2) {
        const value13 = options2[key];
        if (isPureObject(value13) && isPureObject(mergedOptions[key])) {
          mergedOptions[key] = {
            ...mergedOptions[key],
            ...options2[key]
          };
        } else {
          mergedOptions[key] = options2[key];
        }
      }
    }
  }
  function addUrlOptions(options2, url) {
    if (url && !("baseUri" in options2)) {
      options2.baseUri = url;
    }
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js
  function isLoaderObject(loader) {
    var _loader;
    if (!loader) {
      return false;
    }
    if (Array.isArray(loader)) {
      loader = loader[0];
    }
    const hasExtensions = Array.isArray((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.extensions);
    return hasExtensions;
  }
  function normalizeLoader(loader) {
    var _loader2, _loader3;
    assert(loader, "null loader");
    assert(isLoaderObject(loader), "invalid loader");
    let options2;
    if (Array.isArray(loader)) {
      options2 = loader[1];
      loader = loader[0];
      loader = {
        ...loader,
        options: {
          ...loader.options,
          ...options2
        }
      };
    }
    if ((_loader2 = loader) !== null && _loader2 !== void 0 && _loader2.parseTextSync || (_loader3 = loader) !== null && _loader3 !== void 0 && _loader3.parseText) {
      loader.text = true;
    }
    if (!loader.text) {
      loader.binary = true;
    }
    return loader;
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/api/register-loaders.js
  var getGlobalLoaderRegistry = () => {
    const state3 = getGlobalLoaderState();
    state3.loaderRegistry = state3.loaderRegistry || [];
    return state3.loaderRegistry;
  };
  function registerLoaders(loaders) {
    const loaderRegistry = getGlobalLoaderRegistry();
    loaders = Array.isArray(loaders) ? loaders : [loaders];
    for (const loader of loaders) {
      const normalizedLoader = normalizeLoader(loader);
      if (!loaderRegistry.find((registeredLoader) => normalizedLoader === registeredLoader)) {
        loaderRegistry.unshift(normalizedLoader);
      }
    }
  }
  function getRegisteredLoaders() {
    return getGlobalLoaderRegistry();
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/utils/log.js
  var log2 = new Log({
    id: "loaders.gl"
  });

  // node_modules/@loaders.gl/core/dist/esm/lib/api/select-loader.js
  var EXT_PATTERN = /\.([^.]+)$/;
  async function selectLoader(data) {
    let loaders = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let options2 = arguments.length > 2 ? arguments[2] : void 0;
    let context = arguments.length > 3 ? arguments[3] : void 0;
    if (!validHTTPResponse(data)) {
      return null;
    }
    let loader = selectLoaderSync(data, loaders, {
      ...options2,
      nothrow: true
    }, context);
    if (loader) {
      return loader;
    }
    if (isBlob(data)) {
      data = await data.slice(0, 10).arrayBuffer();
      loader = selectLoaderSync(data, loaders, options2, context);
    }
    if (!loader && !(options2 !== null && options2 !== void 0 && options2.nothrow)) {
      throw new Error(getNoValidLoaderMessage(data));
    }
    return loader;
  }
  function selectLoaderSync(data) {
    let loaders = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    let options2 = arguments.length > 2 ? arguments[2] : void 0;
    let context = arguments.length > 3 ? arguments[3] : void 0;
    if (!validHTTPResponse(data)) {
      return null;
    }
    if (loaders && !Array.isArray(loaders)) {
      return normalizeLoader(loaders);
    }
    let candidateLoaders = [];
    if (loaders) {
      candidateLoaders = candidateLoaders.concat(loaders);
    }
    if (!(options2 !== null && options2 !== void 0 && options2.ignoreRegisteredLoaders)) {
      candidateLoaders.push(...getRegisteredLoaders());
    }
    normalizeLoaders(candidateLoaders);
    const loader = selectLoaderInternal(data, candidateLoaders, options2, context);
    if (!loader && !(options2 !== null && options2 !== void 0 && options2.nothrow)) {
      throw new Error(getNoValidLoaderMessage(data));
    }
    return loader;
  }
  function selectLoaderInternal(data, loaders, options2, context) {
    const url = getResourceUrl(data);
    const type = getResourceMIMEType(data);
    const testUrl = stripQueryString(url) || (context === null || context === void 0 ? void 0 : context.url);
    let loader = null;
    let reason = "";
    if (options2 !== null && options2 !== void 0 && options2.mimeType) {
      loader = findLoaderByMIMEType(loaders, options2 === null || options2 === void 0 ? void 0 : options2.mimeType);
      reason = "match forced by supplied MIME type ".concat(options2 === null || options2 === void 0 ? void 0 : options2.mimeType);
    }
    loader = loader || findLoaderByUrl(loaders, testUrl);
    reason = reason || (loader ? "matched url ".concat(testUrl) : "");
    loader = loader || findLoaderByMIMEType(loaders, type);
    reason = reason || (loader ? "matched MIME type ".concat(type) : "");
    loader = loader || findLoaderByInitialBytes(loaders, data);
    reason = reason || (loader ? "matched initial data ".concat(getFirstCharacters(data)) : "");
    loader = loader || findLoaderByMIMEType(loaders, options2 === null || options2 === void 0 ? void 0 : options2.fallbackMimeType);
    reason = reason || (loader ? "matched fallback MIME type ".concat(type) : "");
    if (reason) {
      var _loader;
      log2.log(1, "selectLoader selected ".concat((_loader = loader) === null || _loader === void 0 ? void 0 : _loader.name, ": ").concat(reason, "."));
    }
    return loader;
  }
  function validHTTPResponse(data) {
    if (data instanceof Response) {
      if (data.status === 204) {
        return false;
      }
    }
    return true;
  }
  function getNoValidLoaderMessage(data) {
    const url = getResourceUrl(data);
    const type = getResourceMIMEType(data);
    let message2 = "No valid loader found (";
    message2 += url ? "".concat(path_exports.filename(url), ", ") : "no url provided, ";
    message2 += "MIME type: ".concat(type ? '"'.concat(type, '"') : "not provided", ", ");
    const firstCharacters = data ? getFirstCharacters(data) : "";
    message2 += firstCharacters ? ' first bytes: "'.concat(firstCharacters, '"') : "first bytes: not available";
    message2 += ")";
    return message2;
  }
  function normalizeLoaders(loaders) {
    for (const loader of loaders) {
      normalizeLoader(loader);
    }
  }
  function findLoaderByUrl(loaders, url) {
    const match = url && EXT_PATTERN.exec(url);
    const extension = match && match[1];
    return extension ? findLoaderByExtension(loaders, extension) : null;
  }
  function findLoaderByExtension(loaders, extension) {
    extension = extension.toLowerCase();
    for (const loader of loaders) {
      for (const loaderExtension of loader.extensions) {
        if (loaderExtension.toLowerCase() === extension) {
          return loader;
        }
      }
    }
    return null;
  }
  function findLoaderByMIMEType(loaders, mimeType) {
    for (const loader of loaders) {
      if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {
        return loader;
      }
      if (mimeType === "application/x.".concat(loader.id)) {
        return loader;
      }
    }
    return null;
  }
  function findLoaderByInitialBytes(loaders, data) {
    if (!data) {
      return null;
    }
    for (const loader of loaders) {
      if (typeof data === "string") {
        if (testDataAgainstText(data, loader)) {
          return loader;
        }
      } else if (ArrayBuffer.isView(data)) {
        if (testDataAgainstBinary(data.buffer, data.byteOffset, loader)) {
          return loader;
        }
      } else if (data instanceof ArrayBuffer) {
        const byteOffset = 0;
        if (testDataAgainstBinary(data, byteOffset, loader)) {
          return loader;
        }
      }
    }
    return null;
  }
  function testDataAgainstText(data, loader) {
    if (loader.testText) {
      return loader.testText(data);
    }
    const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
    return tests.some((test) => data.startsWith(test));
  }
  function testDataAgainstBinary(data, byteOffset, loader) {
    const tests = Array.isArray(loader.tests) ? loader.tests : [loader.tests];
    return tests.some((test) => testBinary(data, byteOffset, loader, test));
  }
  function testBinary(data, byteOffset, loader, test) {
    if (test instanceof ArrayBuffer) {
      return compareArrayBuffers(test, data, test.byteLength);
    }
    switch (typeof test) {
      case "function":
        return test(data, loader);
      case "string":
        const magic = getMagicString(data, byteOffset, test.length);
        return test === magic;
      default:
        return false;
    }
  }
  function getFirstCharacters(data) {
    let length7 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
    if (typeof data === "string") {
      return data.slice(0, length7);
    } else if (ArrayBuffer.isView(data)) {
      return getMagicString(data.buffer, data.byteOffset, length7);
    } else if (data instanceof ArrayBuffer) {
      const byteOffset = 0;
      return getMagicString(data, byteOffset, length7);
    }
    return "";
  }
  function getMagicString(arrayBuffer2, byteOffset, length7) {
    if (arrayBuffer2.byteLength < byteOffset + length7) {
      return "";
    }
    const dataView = new DataView(arrayBuffer2);
    let magic = "";
    for (let i = 0; i < length7; i++) {
      magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
    }
    return magic;
  }

  // node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-string-iterator.js
  var DEFAULT_CHUNK_SIZE = 256 * 1024;
  function* makeStringIterator(string13, options2) {
    const chunkSize = (options2 === null || options2 === void 0 ? void 0 : options2.chunkSize) || DEFAULT_CHUNK_SIZE;
    let offset = 0;
    const textEncoder = new TextEncoder();
    while (offset < string13.length) {
      const chunkLength = Math.min(string13.length - offset, chunkSize);
      const chunk = string13.slice(offset, offset + chunkLength);
      offset += chunkLength;
      yield textEncoder.encode(chunk);
    }
  }

  // node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-array-buffer-iterator.js
  var DEFAULT_CHUNK_SIZE2 = 256 * 1024;
  function makeArrayBufferIterator(arrayBuffer2) {
    let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      const {
        chunkSize = DEFAULT_CHUNK_SIZE2
      } = options2;
      let byteOffset = 0;
      while (byteOffset < arrayBuffer2.byteLength) {
        const chunkByteLength = Math.min(arrayBuffer2.byteLength - byteOffset, chunkSize);
        const chunk = new ArrayBuffer(chunkByteLength);
        const sourceArray = new Uint8Array(arrayBuffer2, byteOffset, chunkByteLength);
        const chunkArray = new Uint8Array(chunk);
        chunkArray.set(sourceArray);
        byteOffset += chunkByteLength;
        yield chunk;
      }
    }();
  }

  // node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-blob-iterator.js
  var DEFAULT_CHUNK_SIZE3 = 1024 * 1024;
  async function* makeBlobIterator(blob, options2) {
    const chunkSize = (options2 === null || options2 === void 0 ? void 0 : options2.chunkSize) || DEFAULT_CHUNK_SIZE3;
    let offset = 0;
    while (offset < blob.size) {
      const end = offset + chunkSize;
      const chunk = await blob.slice(offset, end).arrayBuffer();
      offset = end;
      yield chunk;
    }
  }

  // node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-stream-iterator.js
  function makeStreamIterator(stream, options2) {
    return isBrowser ? makeBrowserStreamIterator(stream, options2) : makeNodeStreamIterator(stream, options2);
  }
  async function* makeBrowserStreamIterator(stream, options2) {
    const reader = stream.getReader();
    let nextBatchPromise;
    try {
      while (true) {
        const currentBatchPromise = nextBatchPromise || reader.read();
        if (options2 !== null && options2 !== void 0 && options2._streamReadAhead) {
          nextBatchPromise = reader.read();
        }
        const {
          done,
          value: value13
        } = await currentBatchPromise;
        if (done) {
          return;
        }
        yield toArrayBuffer2(value13);
      }
    } catch (error3) {
      reader.releaseLock();
    }
  }
  async function* makeNodeStreamIterator(stream, options2) {
    for await (const chunk of stream) {
      yield toArrayBuffer2(chunk);
    }
  }

  // node_modules/@loaders.gl/core/dist/esm/iterators/make-iterator/make-iterator.js
  function makeIterator(data, options2) {
    if (typeof data === "string") {
      return makeStringIterator(data, options2);
    }
    if (data instanceof ArrayBuffer) {
      return makeArrayBufferIterator(data, options2);
    }
    if (isBlob(data)) {
      return makeBlobIterator(data, options2);
    }
    if (isReadableStream(data)) {
      return makeStreamIterator(data, options2);
    }
    if (isResponse(data)) {
      const response = data;
      return makeStreamIterator(response.body, options2);
    }
    throw new Error("makeIterator");
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js
  var ERR_DATA = "Cannot convert supplied data type";
  function getArrayBufferOrStringFromDataSync(data, loader, options2) {
    if (loader.text && typeof data === "string") {
      return data;
    }
    if (isBuffer2(data)) {
      data = data.buffer;
    }
    if (data instanceof ArrayBuffer) {
      const arrayBuffer2 = data;
      if (loader.text && !loader.binary) {
        const textDecoder = new TextDecoder("utf8");
        return textDecoder.decode(arrayBuffer2);
      }
      return arrayBuffer2;
    }
    if (ArrayBuffer.isView(data)) {
      if (loader.text && !loader.binary) {
        const textDecoder = new TextDecoder("utf8");
        return textDecoder.decode(data);
      }
      let arrayBuffer2 = data.buffer;
      const byteLength = data.byteLength || data.length;
      if (data.byteOffset !== 0 || byteLength !== arrayBuffer2.byteLength) {
        arrayBuffer2 = arrayBuffer2.slice(data.byteOffset, data.byteOffset + byteLength);
      }
      return arrayBuffer2;
    }
    throw new Error(ERR_DATA);
  }
  async function getArrayBufferOrStringFromData(data, loader, options2) {
    const isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);
    if (typeof data === "string" || isArrayBuffer) {
      return getArrayBufferOrStringFromDataSync(data, loader, options2);
    }
    if (isBlob(data)) {
      data = await makeResponse(data);
    }
    if (isResponse(data)) {
      const response = data;
      await checkResponse(response);
      return loader.binary ? await response.arrayBuffer() : await response.text();
    }
    if (isReadableStream(data)) {
      data = makeIterator(data, options2);
    }
    if (isIterable(data) || isAsyncIterable(data)) {
      return concatenateArrayBuffersAsync(data);
    }
    throw new Error(ERR_DATA);
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-fetch-function.js
  function getFetchFunction(options2, context) {
    const globalOptions = getGlobalLoaderOptions();
    const fetchOptions = options2 || globalOptions;
    if (typeof fetchOptions.fetch === "function") {
      return fetchOptions.fetch;
    }
    if (isObject(fetchOptions.fetch)) {
      return (url) => fetchFile(url, fetchOptions);
    }
    if (context !== null && context !== void 0 && context.fetch) {
      return context === null || context === void 0 ? void 0 : context.fetch;
    }
    return fetchFile;
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/loader-context.js
  function getLoaderContext(context, options2, parentContext) {
    if (parentContext) {
      return parentContext;
    }
    const newContext = {
      fetch: getFetchFunction(options2, context),
      ...context
    };
    if (newContext.url) {
      const baseUrl = stripQueryString(newContext.url);
      newContext.baseUrl = baseUrl;
      newContext.queryString = extractQueryString(newContext.url);
      newContext.filename = path_exports.filename(baseUrl);
      newContext.baseUrl = path_exports.dirname(baseUrl);
    }
    if (!Array.isArray(newContext.loaders)) {
      newContext.loaders = null;
    }
    return newContext;
  }
  function getLoadersFromContext(loaders, context) {
    if (!context && loaders && !Array.isArray(loaders)) {
      return loaders;
    }
    let candidateLoaders;
    if (loaders) {
      candidateLoaders = Array.isArray(loaders) ? loaders : [loaders];
    }
    if (context && context.loaders) {
      const contextLoaders = Array.isArray(context.loaders) ? context.loaders : [context.loaders];
      candidateLoaders = candidateLoaders ? [...candidateLoaders, ...contextLoaders] : contextLoaders;
    }
    return candidateLoaders && candidateLoaders.length ? candidateLoaders : null;
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/api/parse.js
  async function parse(data, loaders, options2, context) {
    assert2(!context || typeof context === "object");
    if (loaders && !Array.isArray(loaders) && !isLoaderObject(loaders)) {
      context = void 0;
      options2 = loaders;
      loaders = void 0;
    }
    data = await data;
    options2 = options2 || {};
    const url = getResourceUrl(data);
    const typedLoaders = loaders;
    const candidateLoaders = getLoadersFromContext(typedLoaders, context);
    const loader = await selectLoader(data, candidateLoaders, options2);
    if (!loader) {
      return null;
    }
    options2 = normalizeOptions(options2, loader, candidateLoaders, url);
    context = getLoaderContext({
      url,
      parse,
      loaders: candidateLoaders
    }, options2, context || null);
    return await parseWithLoader(loader, data, options2, context);
  }
  async function parseWithLoader(loader, data, options2, context) {
    validateWorkerVersion(loader);
    if (isResponse(data)) {
      const response = data;
      const {
        ok,
        redirected,
        status,
        statusText,
        type,
        url
      } = response;
      const headers = Object.fromEntries(response.headers.entries());
      context.response = {
        headers,
        ok,
        redirected,
        status,
        statusText,
        type,
        url
      };
    }
    data = await getArrayBufferOrStringFromData(data, loader, options2);
    if (loader.parseTextSync && typeof data === "string") {
      options2.dataType = "text";
      return loader.parseTextSync(data, options2, context, loader);
    }
    if (canParseWithWorker(loader, options2)) {
      return await parseWithWorker(loader, data, options2, context, parse);
    }
    if (loader.parseText && typeof data === "string") {
      return await loader.parseText(data, options2, context, loader);
    }
    if (loader.parse) {
      return await loader.parse(data, options2, context, loader);
    }
    assert2(!loader.parseSync);
    throw new Error("".concat(loader.id, " loader - no parser found and worker is disabled"));
  }

  // node_modules/@loaders.gl/core/dist/esm/lib/api/load.js
  async function load(url, loaders, options2, context) {
    if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
      context = void 0;
      options2 = loaders;
      loaders = void 0;
    }
    const fetch2 = getFetchFunction(options2);
    let data = url;
    if (typeof url === "string") {
      data = await fetch2(url);
    }
    if (isBlob(url)) {
      data = await fetch2(url);
    }
    return await parse(data, loaders, options2);
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/utils/version.js
  var VERSION3 = true ? "3.4.14" : "latest";

  // node_modules/@loaders.gl/images/dist/esm/lib/category-api/image-type.js
  var {
    _parseImageNode
  } = globalThis;
  var IMAGE_SUPPORTED = typeof Image !== "undefined";
  var IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== "undefined";
  var NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);
  var DATA_SUPPORTED = isBrowser ? true : NODE_IMAGE_SUPPORTED;
  function isImageTypeSupported(type) {
    switch (type) {
      case "auto":
        return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;
      case "imagebitmap":
        return IMAGE_BITMAP_SUPPORTED;
      case "image":
        return IMAGE_SUPPORTED;
      case "data":
        return DATA_SUPPORTED;
      default:
        throw new Error("@loaders.gl/images: image ".concat(type, " not supported in this environment"));
    }
  }
  function getDefaultImageType() {
    if (IMAGE_BITMAP_SUPPORTED) {
      return "imagebitmap";
    }
    if (IMAGE_SUPPORTED) {
      return "image";
    }
    if (DATA_SUPPORTED) {
      return "data";
    }
    throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/category-api/parsed-image-api.js
  function getImageType(image) {
    const format = getImageTypeOrNull(image);
    if (!format) {
      throw new Error("Not an image");
    }
    return format;
  }
  function getImageData(image) {
    switch (getImageType(image)) {
      case "data":
        return image;
      case "image":
      case "imagebitmap":
        const canvas = document.createElement("canvas");
        const context = canvas.getContext("2d");
        if (!context) {
          throw new Error("getImageData");
        }
        canvas.width = image.width;
        canvas.height = image.height;
        context.drawImage(image, 0, 0);
        return context.getImageData(0, 0, image.width, image.height);
      default:
        throw new Error("getImageData");
    }
  }
  function getImageTypeOrNull(image) {
    if (typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      return "imagebitmap";
    }
    if (typeof Image !== "undefined" && image instanceof Image) {
      return "image";
    }
    if (image && typeof image === "object" && image.data && image.width && image.height) {
      return "data";
    }
    return null;
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/parsers/svg-utils.js
  var SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
  var SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;
  function isSVG(url) {
    return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
  }
  function getBlobOrSVGDataUrl(arrayBuffer2, url) {
    if (isSVG(url)) {
      const textDecoder = new TextDecoder();
      let xmlText = textDecoder.decode(arrayBuffer2);
      try {
        if (typeof unescape === "function" && typeof encodeURIComponent === "function") {
          xmlText = unescape(encodeURIComponent(xmlText));
        }
      } catch (error3) {
        throw new Error(error3.message);
      }
      const src9 = "data:image/svg+xml;base64,".concat(btoa(xmlText));
      return src9;
    }
    return getBlob(arrayBuffer2, url);
  }
  function getBlob(arrayBuffer2, url) {
    if (isSVG(url)) {
      throw new Error("SVG cannot be parsed directly to imagebitmap");
    }
    return new Blob([new Uint8Array(arrayBuffer2)]);
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image.js
  async function parseToImage(arrayBuffer2, options2, url) {
    const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer2, url);
    const URL2 = self.URL || self.webkitURL;
    const objectUrl = typeof blobOrDataUrl !== "string" && URL2.createObjectURL(blobOrDataUrl);
    try {
      return await loadToImage(objectUrl || blobOrDataUrl, options2);
    } finally {
      if (objectUrl) {
        URL2.revokeObjectURL(objectUrl);
      }
    }
  }
  async function loadToImage(url, options2) {
    const image = new Image();
    image.src = url;
    if (options2.image && options2.image.decode && image.decode) {
      await image.decode();
      return image;
    }
    return await new Promise((resolve2, reject) => {
      try {
        image.onload = () => resolve2(image);
        image.onerror = (err) => reject(new Error("Could not load image ".concat(url, ": ").concat(err)));
      } catch (error3) {
        reject(error3);
      }
    });
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-image-bitmap.js
  var EMPTY_OBJECT = {};
  var imagebitmapOptionsSupported = true;
  async function parseToImageBitmap(arrayBuffer2, options2, url) {
    let blob;
    if (isSVG(url)) {
      const image = await parseToImage(arrayBuffer2, options2, url);
      blob = image;
    } else {
      blob = getBlob(arrayBuffer2, url);
    }
    const imagebitmapOptions = options2 && options2.imagebitmap;
    return await safeCreateImageBitmap(blob, imagebitmapOptions);
  }
  async function safeCreateImageBitmap(blob) {
    let imagebitmapOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
      imagebitmapOptions = null;
    }
    if (imagebitmapOptions) {
      try {
        return await createImageBitmap(blob, imagebitmapOptions);
      } catch (error3) {
        console.warn(error3);
        imagebitmapOptionsSupported = false;
      }
    }
    return await createImageBitmap(blob);
  }
  function isEmptyObject(object12) {
    for (const key in object12 || EMPTY_OBJECT) {
      return false;
    }
    return true;
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/category-api/parse-isobmff-binary.js
  function getISOBMFFMediaType(buffer) {
    if (!checkString(buffer, "ftyp", 4)) {
      return null;
    }
    if ((buffer[8] & 96) === 0) {
      return null;
    }
    return decodeMajorBrand(buffer);
  }
  function decodeMajorBrand(buffer) {
    const brandMajor = getUTF8String(buffer, 8, 12).replace("\0", " ").trim();
    switch (brandMajor) {
      case "avif":
      case "avis":
        return {
          extension: "avif",
          mimeType: "image/avif"
        };
      default:
        return null;
    }
  }
  function getUTF8String(array2, start2, end) {
    return String.fromCharCode(...array2.slice(start2, end));
  }
  function stringToBytes(string13) {
    return [...string13].map((character) => character.charCodeAt(0));
  }
  function checkString(buffer, header) {
    let offset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    const headerBytes = stringToBytes(header);
    for (let i = 0; i < headerBytes.length; ++i) {
      if (headerBytes[i] !== buffer[i + offset]) {
        return false;
      }
    }
    return true;
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/category-api/binary-image-api.js
  var BIG_ENDIAN = false;
  var LITTLE_ENDIAN = true;
  function getBinaryImageMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    return getPngMetadata(dataView) || getJpegMetadata(dataView) || getGifMetadata(dataView) || getBmpMetadata(dataView) || getISOBMFFMetadata(dataView);
  }
  function getISOBMFFMetadata(binaryData) {
    const buffer = new Uint8Array(binaryData instanceof DataView ? binaryData.buffer : binaryData);
    const mediaType = getISOBMFFMediaType(buffer);
    if (!mediaType) {
      return null;
    }
    return {
      mimeType: mediaType.mimeType,
      width: 0,
      height: 0
    };
  }
  function getPngMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 2303741511;
    if (!isPng) {
      return null;
    }
    return {
      mimeType: "image/png",
      width: dataView.getUint32(16, BIG_ENDIAN),
      height: dataView.getUint32(20, BIG_ENDIAN)
    };
  }
  function getGifMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 1195984440;
    if (!isGif) {
      return null;
    }
    return {
      mimeType: "image/gif",
      width: dataView.getUint16(6, LITTLE_ENDIAN),
      height: dataView.getUint16(8, LITTLE_ENDIAN)
    };
  }
  function getBmpMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isBmp = dataView.byteLength >= 14 && dataView.getUint16(0, BIG_ENDIAN) === 16973 && dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;
    if (!isBmp) {
      return null;
    }
    return {
      mimeType: "image/bmp",
      width: dataView.getUint32(18, LITTLE_ENDIAN),
      height: dataView.getUint32(22, LITTLE_ENDIAN)
    };
  }
  function getJpegMetadata(binaryData) {
    const dataView = toDataView(binaryData);
    const isJpeg = dataView.byteLength >= 3 && dataView.getUint16(0, BIG_ENDIAN) === 65496 && dataView.getUint8(2) === 255;
    if (!isJpeg) {
      return null;
    }
    const {
      tableMarkers,
      sofMarkers
    } = getJpegMarkers();
    let i = 2;
    while (i + 9 < dataView.byteLength) {
      const marker = dataView.getUint16(i, BIG_ENDIAN);
      if (sofMarkers.has(marker)) {
        return {
          mimeType: "image/jpeg",
          height: dataView.getUint16(i + 5, BIG_ENDIAN),
          width: dataView.getUint16(i + 7, BIG_ENDIAN)
        };
      }
      if (!tableMarkers.has(marker)) {
        return null;
      }
      i += 2;
      i += dataView.getUint16(i, BIG_ENDIAN);
    }
    return null;
  }
  function getJpegMarkers() {
    const tableMarkers = /* @__PURE__ */ new Set([65499, 65476, 65484, 65501, 65534]);
    for (let i = 65504; i < 65520; ++i) {
      tableMarkers.add(i);
    }
    const sofMarkers = /* @__PURE__ */ new Set([65472, 65473, 65474, 65475, 65477, 65478, 65479, 65481, 65482, 65483, 65485, 65486, 65487, 65502]);
    return {
      tableMarkers,
      sofMarkers
    };
  }
  function toDataView(data) {
    if (data instanceof DataView) {
      return data;
    }
    if (ArrayBuffer.isView(data)) {
      return new DataView(data.buffer);
    }
    if (data instanceof ArrayBuffer) {
      return new DataView(data);
    }
    throw new Error("toDataView");
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-to-node-image.js
  async function parseToNodeImage(arrayBuffer2, options2) {
    const {
      mimeType
    } = getBinaryImageMetadata(arrayBuffer2) || {};
    const _parseImageNode2 = globalThis._parseImageNode;
    assert(_parseImageNode2);
    return await _parseImageNode2(arrayBuffer2, mimeType);
  }

  // node_modules/@loaders.gl/images/dist/esm/lib/parsers/parse-image.js
  async function parseImage(arrayBuffer2, options2, context) {
    options2 = options2 || {};
    const imageOptions = options2.image || {};
    const imageType = imageOptions.type || "auto";
    const {
      url
    } = context || {};
    const loadType = getLoadableImageType(imageType);
    let image;
    switch (loadType) {
      case "imagebitmap":
        image = await parseToImageBitmap(arrayBuffer2, options2, url);
        break;
      case "image":
        image = await parseToImage(arrayBuffer2, options2, url);
        break;
      case "data":
        image = await parseToNodeImage(arrayBuffer2, options2);
        break;
      default:
        assert(false);
    }
    if (imageType === "data") {
      image = getImageData(image);
    }
    return image;
  }
  function getLoadableImageType(type) {
    switch (type) {
      case "auto":
      case "data":
        return getDefaultImageType();
      default:
        isImageTypeSupported(type);
        return type;
    }
  }

  // node_modules/@loaders.gl/images/dist/esm/image-loader.js
  var EXTENSIONS = ["png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg", "avif"];
  var MIME_TYPES = ["image/png", "image/jpeg", "image/gif", "image/webp", "image/avif", "image/bmp", "image/vnd.microsoft.icon", "image/svg+xml"];
  var DEFAULT_IMAGE_LOADER_OPTIONS = {
    image: {
      type: "auto",
      decode: true
    }
  };
  var ImageLoader = {
    id: "image",
    module: "images",
    name: "Images",
    version: VERSION3,
    mimeTypes: MIME_TYPES,
    extensions: EXTENSIONS,
    parse: parseImage,
    tests: [(arrayBuffer2) => Boolean(getBinaryImageMetadata(new DataView(arrayBuffer2)))],
    options: DEFAULT_IMAGE_LOADER_OPTIONS
  };

  // node_modules/@probe.gl/env/dist/esm/lib/is-electron.js
  function isElectron2(mockUserAgent) {
    if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
      return true;
    }
    if (typeof process !== "undefined" && typeof process.versions === "object" && Boolean(process.versions["electron"])) {
      return true;
    }
    const realUserAgent = typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent;
    const userAgent3 = mockUserAgent || realUserAgent;
    if (userAgent3 && userAgent3.indexOf("Electron") >= 0) {
      return true;
    }
    return false;
  }

  // node_modules/@probe.gl/env/dist/esm/lib/is-browser.js
  function isBrowser5() {
    const isNode = typeof process === "object" && String(process) === "[object process]" && !process.browser;
    return !isNode || isElectron2();
  }

  // node_modules/@probe.gl/env/dist/esm/lib/globals.js
  var globals3 = {
    self: typeof self !== "undefined" && self,
    window: typeof window !== "undefined" && window,
    global: typeof global !== "undefined" && global,
    document: typeof document !== "undefined" && document,
    process: typeof process === "object" && process
  };
  var self_4 = globals3.self || globals3.window || globals3.global;
  var window_4 = globals3.window || globals3.self || globals3.global;
  var document_4 = globals3.document || {};
  var process_2 = globals3.process || {};

  // node_modules/@probe.gl/env/dist/esm/utils/globals.js
  var VERSION4 = typeof __VERSION__ !== "undefined" ? __VERSION__ : "untranspiled source";
  var isBrowser6 = isBrowser5();

  // node_modules/@probe.gl/env/dist/esm/lib/get-browser.js
  var window2 = globalThis;
  function getBrowser(mockUserAgent) {
    if (!mockUserAgent && !isBrowser5()) {
      return "Node";
    }
    if (isElectron2(mockUserAgent)) {
      return "Electron";
    }
    const navigator_2 = typeof navigator !== "undefined" ? navigator : {};
    const userAgent3 = mockUserAgent || navigator_2.userAgent || "";
    if (userAgent3.indexOf("Edge") > -1) {
      return "Edge";
    }
    const isMSIE = userAgent3.indexOf("MSIE ") !== -1;
    const isTrident = userAgent3.indexOf("Trident/") !== -1;
    if (isMSIE || isTrident) {
      return "IE";
    }
    if (window2.chrome) {
      return "Chrome";
    }
    if (window2.safari) {
      return "Safari";
    }
    if (window2.mozInnerScreenX) {
      return "Firefox";
    }
    return "Unknown";
  }

  // node_modules/@probe.gl/log/dist/esm/utils/local-storage.js
  function getStorage2(type) {
    try {
      const storage = window[type];
      const x = "__storage_test__";
      storage.setItem(x, x);
      storage.removeItem(x);
      return storage;
    } catch (e) {
      return null;
    }
  }
  var LocalStorage2 = class {
    constructor(id2, defaultConfig) {
      let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "sessionStorage";
      _defineProperty(this, "storage", void 0);
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "config", void 0);
      this.storage = getStorage2(type);
      this.id = id2;
      this.config = defaultConfig;
      this._loadConfiguration();
    }
    getConfiguration() {
      return this.config;
    }
    setConfiguration(configuration) {
      Object.assign(this.config, configuration);
      if (this.storage) {
        const serialized = JSON.stringify(this.config);
        this.storage.setItem(this.id, serialized);
      }
    }
    _loadConfiguration() {
      let configuration = {};
      if (this.storage) {
        const serializedConfiguration = this.storage.getItem(this.id);
        configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
      }
      Object.assign(this.config, configuration);
      return this;
    }
  };

  // node_modules/@probe.gl/log/dist/esm/utils/formatters.js
  function formatTime2(ms) {
    let formatted;
    if (ms < 10) {
      formatted = "".concat(ms.toFixed(2), "ms");
    } else if (ms < 100) {
      formatted = "".concat(ms.toFixed(1), "ms");
    } else if (ms < 1e3) {
      formatted = "".concat(ms.toFixed(0), "ms");
    } else {
      formatted = "".concat((ms / 1e3).toFixed(2), "s");
    }
    return formatted;
  }
  function leftPad2(string13) {
    let length7 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 8;
    const padLength = Math.max(length7 - string13.length, 0);
    return "".concat(" ".repeat(padLength)).concat(string13);
  }
  function formatImage2(image, message2, scale4) {
    let maxWidth = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 600;
    const imageUrl = image.src.replace(/\(/g, "%28").replace(/\)/g, "%29");
    if (image.width > maxWidth) {
      scale4 = Math.min(scale4, maxWidth / image.width);
    }
    const width8 = image.width * scale4;
    const height8 = image.height * scale4;
    const style = ["font-size:1px;", "padding:".concat(Math.floor(height8 / 2), "px ").concat(Math.floor(width8 / 2), "px;"), "line-height:".concat(height8, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width8, "px ").concat(height8, "px;"), "color:transparent;"].join("");
    return ["".concat(message2, " %c+"), style];
  }

  // node_modules/@probe.gl/log/dist/esm/utils/color.js
  var COLOR2;
  (function(COLOR3) {
    COLOR3[COLOR3["BLACK"] = 30] = "BLACK";
    COLOR3[COLOR3["RED"] = 31] = "RED";
    COLOR3[COLOR3["GREEN"] = 32] = "GREEN";
    COLOR3[COLOR3["YELLOW"] = 33] = "YELLOW";
    COLOR3[COLOR3["BLUE"] = 34] = "BLUE";
    COLOR3[COLOR3["MAGENTA"] = 35] = "MAGENTA";
    COLOR3[COLOR3["CYAN"] = 36] = "CYAN";
    COLOR3[COLOR3["WHITE"] = 37] = "WHITE";
    COLOR3[COLOR3["BRIGHT_BLACK"] = 90] = "BRIGHT_BLACK";
    COLOR3[COLOR3["BRIGHT_RED"] = 91] = "BRIGHT_RED";
    COLOR3[COLOR3["BRIGHT_GREEN"] = 92] = "BRIGHT_GREEN";
    COLOR3[COLOR3["BRIGHT_YELLOW"] = 93] = "BRIGHT_YELLOW";
    COLOR3[COLOR3["BRIGHT_BLUE"] = 94] = "BRIGHT_BLUE";
    COLOR3[COLOR3["BRIGHT_MAGENTA"] = 95] = "BRIGHT_MAGENTA";
    COLOR3[COLOR3["BRIGHT_CYAN"] = 96] = "BRIGHT_CYAN";
    COLOR3[COLOR3["BRIGHT_WHITE"] = 97] = "BRIGHT_WHITE";
  })(COLOR2 || (COLOR2 = {}));
  function getColor2(color) {
    return typeof color === "string" ? COLOR2[color.toUpperCase()] || COLOR2.WHITE : color;
  }
  function addColor2(string13, color, background) {
    if (!isBrowser5 && typeof string13 === "string") {
      if (color) {
        color = getColor2(color);
        string13 = "\x1B[".concat(color, "m").concat(string13, "\x1B[39m");
      }
      if (background) {
        color = getColor2(background);
        string13 = "\x1B[".concat(background + 10, "m").concat(string13, "\x1B[49m");
      }
    }
    return string13;
  }

  // node_modules/@probe.gl/log/dist/esm/utils/autobind.js
  function autobind2(obj) {
    let predefined = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["constructor"];
    const proto = Object.getPrototypeOf(obj);
    const propNames = Object.getOwnPropertyNames(proto);
    for (const key of propNames) {
      if (typeof obj[key] === "function") {
        if (!predefined.find((name16) => key === name16)) {
          obj[key] = obj[key].bind(obj);
        }
      }
    }
  }

  // node_modules/@probe.gl/log/dist/esm/utils/assert.js
  function assert4(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "Assertion failed");
    }
  }

  // node_modules/@probe.gl/log/dist/esm/utils/hi-res-timestamp.js
  function getHiResTimestamp2() {
    let timestamp;
    if (isBrowser5 && "performance" in window_4) {
      var _window$performance, _window$performance$n;
      timestamp = window_4 === null || window_4 === void 0 ? void 0 : (_window$performance = window_4.performance) === null || _window$performance === void 0 ? void 0 : (_window$performance$n = _window$performance.now) === null || _window$performance$n === void 0 ? void 0 : _window$performance$n.call(_window$performance);
    } else if ("hrtime" in process_2) {
      var _process$hrtime;
      const timeParts = process_2 === null || process_2 === void 0 ? void 0 : (_process$hrtime = process_2.hrtime) === null || _process$hrtime === void 0 ? void 0 : _process$hrtime.call(process_2);
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // node_modules/@probe.gl/log/dist/esm/log.js
  var originalConsole2 = {
    debug: isBrowser5 ? console.debug || console.log : console.log,
    log: console.log,
    info: console.info,
    warn: console.warn,
    error: console.error
  };
  var DEFAULT_SETTINGS = {
    enabled: true,
    level: 0
  };
  function noop2() {
  }
  var cache2 = {};
  var ONCE2 = {
    once: true
  };
  var Log2 = class {
    constructor() {
      let {
        id: id2
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {
        id: ""
      };
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "VERSION", VERSION4);
      _defineProperty(this, "_startTs", getHiResTimestamp2());
      _defineProperty(this, "_deltaTs", getHiResTimestamp2());
      _defineProperty(this, "_storage", void 0);
      _defineProperty(this, "userData", {});
      _defineProperty(this, "LOG_THROTTLE_TIMEOUT", 0);
      this.id = id2;
      this.userData = {};
      this._storage = new LocalStorage2("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS);
      this.timeStamp("".concat(this.id, " started"));
      autobind2(this);
      Object.seal(this);
    }
    set level(newLevel) {
      this.setLevel(newLevel);
    }
    get level() {
      return this.getLevel();
    }
    isEnabled() {
      return this._storage.config.enabled;
    }
    getLevel() {
      return this._storage.config.level;
    }
    getTotal() {
      return Number((getHiResTimestamp2() - this._startTs).toPrecision(10));
    }
    getDelta() {
      return Number((getHiResTimestamp2() - this._deltaTs).toPrecision(10));
    }
    set priority(newPriority) {
      this.level = newPriority;
    }
    get priority() {
      return this.level;
    }
    getPriority() {
      return this.level;
    }
    enable() {
      let enabled = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      this._storage.setConfiguration({
        enabled
      });
      return this;
    }
    setLevel(level) {
      this._storage.setConfiguration({
        level
      });
      return this;
    }
    get(setting) {
      return this._storage.config[setting];
    }
    set(setting, value13) {
      this._storage.setConfiguration({
        [setting]: value13
      });
    }
    settings() {
      if (console.table) {
        console.table(this._storage.config);
      } else {
        console.log(this._storage.config);
      }
    }
    assert(condition, message2) {
      assert4(condition, message2);
    }
    warn(message2) {
      return this._getLogFunction(0, message2, originalConsole2.warn, arguments, ONCE2);
    }
    error(message2) {
      return this._getLogFunction(0, message2, originalConsole2.error, arguments);
    }
    deprecated(oldUsage, newUsage) {
      return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
    }
    removed(oldUsage, newUsage) {
      return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
    }
    probe(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, originalConsole2.log, arguments, {
        time: true,
        once: true
      });
    }
    log(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, originalConsole2.debug, arguments);
    }
    info(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, console.info, arguments);
    }
    once(logLevel, message2) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      return this._getLogFunction(logLevel, message2, originalConsole2.debug || originalConsole2.info, arguments, ONCE2);
    }
    table(logLevel, table, columns) {
      if (table) {
        return this._getLogFunction(logLevel, table, console.table || noop2, columns && [columns], {
          tag: getTableHeader2(table)
        });
      }
      return noop2;
    }
    image(_ref) {
      let {
        logLevel,
        priority,
        image,
        message: message2 = "",
        scale: scale4 = 1
      } = _ref;
      if (!this._shouldLog(logLevel || priority)) {
        return noop2;
      }
      return isBrowser5 ? logImageInBrowser2({
        image,
        message: message2,
        scale: scale4
      }) : logImageInNode2({
        image,
        message: message2,
        scale: scale4
      });
    }
    time(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, console.time ? console.time : console.info);
    }
    timeEnd(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, console.timeEnd ? console.timeEnd : console.info);
    }
    timeStamp(logLevel, message2) {
      return this._getLogFunction(logLevel, message2, console.timeStamp || noop2);
    }
    group(logLevel, message2) {
      let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        collapsed: false
      };
      const options2 = normalizeArguments2({
        logLevel,
        message: message2,
        opts
      });
      const {
        collapsed
      } = opts;
      options2.method = (collapsed ? console.groupCollapsed : console.group) || console.info;
      return this._getLogFunction(options2);
    }
    groupCollapsed(logLevel, message2) {
      let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.group(logLevel, message2, Object.assign({}, opts, {
        collapsed: true
      }));
    }
    groupEnd(logLevel) {
      return this._getLogFunction(logLevel, "", console.groupEnd || noop2);
    }
    withGroup(logLevel, message2, func11) {
      this.group(logLevel, message2)();
      try {
        func11();
      } finally {
        this.groupEnd(logLevel)();
      }
    }
    trace() {
      if (console.trace) {
        console.trace();
      }
    }
    _shouldLog(logLevel) {
      return this.isEnabled() && this.getLevel() >= normalizeLogLevel2(logLevel);
    }
    _getLogFunction(logLevel, message2, method2, args, opts) {
      if (this._shouldLog(logLevel)) {
        opts = normalizeArguments2({
          logLevel,
          message: message2,
          args,
          opts
        });
        method2 = method2 || opts.method;
        assert4(method2);
        opts.total = this.getTotal();
        opts.delta = this.getDelta();
        this._deltaTs = getHiResTimestamp2();
        const tag = opts.tag || opts.message;
        if (opts.once) {
          if (!cache2[tag]) {
            cache2[tag] = getHiResTimestamp2();
          } else {
            return noop2;
          }
        }
        message2 = decorateMessage2(this.id, opts.message, opts);
        return method2.bind(console, message2, ...opts.args);
      }
      return noop2;
    }
  };
  _defineProperty(Log2, "VERSION", VERSION4);
  function normalizeLogLevel2(logLevel) {
    if (!logLevel) {
      return 0;
    }
    let resolvedLevel;
    switch (typeof logLevel) {
      case "number":
        resolvedLevel = logLevel;
        break;
      case "object":
        resolvedLevel = logLevel.logLevel || logLevel.priority || 0;
        break;
      default:
        return 0;
    }
    assert4(Number.isFinite(resolvedLevel) && resolvedLevel >= 0);
    return resolvedLevel;
  }
  function normalizeArguments2(opts) {
    const {
      logLevel,
      message: message2
    } = opts;
    opts.logLevel = normalizeLogLevel2(logLevel);
    const args = opts.args ? Array.from(opts.args) : [];
    while (args.length && args.shift() !== message2) {
    }
    switch (typeof logLevel) {
      case "string":
      case "function":
        if (message2 !== void 0) {
          args.unshift(message2);
        }
        opts.message = logLevel;
        break;
      case "object":
        Object.assign(opts, logLevel);
        break;
      default:
    }
    if (typeof opts.message === "function") {
      opts.message = opts.message();
    }
    const messageType = typeof opts.message;
    assert4(messageType === "string" || messageType === "object");
    return Object.assign(opts, {
      args
    }, opts.opts);
  }
  function decorateMessage2(id2, message2, opts) {
    if (typeof message2 === "string") {
      const time = opts.time ? leftPad2(formatTime2(opts.total)) : "";
      message2 = opts.time ? "".concat(id2, ": ").concat(time, "  ").concat(message2) : "".concat(id2, ": ").concat(message2);
      message2 = addColor2(message2, opts.color, opts.background);
    }
    return message2;
  }
  function logImageInNode2(_ref2) {
    let {
      image,
      message: message2 = "",
      scale: scale4 = 1
    } = _ref2;
    console.warn("removed");
    return noop2;
  }
  function logImageInBrowser2(_ref3) {
    let {
      image,
      message: message2 = "",
      scale: scale4 = 1
    } = _ref3;
    if (typeof image === "string") {
      const img = new Image();
      img.onload = () => {
        const args = formatImage2(img, message2, scale4);
        console.log(...args);
      };
      img.src = image;
      return noop2;
    }
    const element = image.nodeName || "";
    if (element.toLowerCase() === "img") {
      console.log(...formatImage2(image, message2, scale4));
      return noop2;
    }
    if (element.toLowerCase() === "canvas") {
      const img = new Image();
      img.onload = () => console.log(...formatImage2(img, message2, scale4));
      img.src = image.toDataURL();
      return noop2;
    }
    return noop2;
  }
  function getTableHeader2(table) {
    for (const key in table) {
      for (const title2 in table[key]) {
        return title2 || "untitled";
      }
    }
    return "empty";
  }

  // node_modules/@probe.gl/log/dist/esm/index.js
  var esm_default = new Log2({
    id: "@probe.gl/log"
  });

  // node_modules/@deck.gl/core/dist/esm/utils/log.js
  var log_default = new Log2({
    id: "deck"
  });

  // node_modules/@deck.gl/core/dist/esm/debug/loggers.js
  var logState = {
    attributeUpdateStart: -1,
    attributeManagerUpdateStart: -1,
    attributeUpdateMessages: []
  };
  var LOG_LEVEL_MAJOR_UPDATE = 1;
  var LOG_LEVEL_MINOR_UPDATE = 2;
  var LOG_LEVEL_UPDATE_DETAIL = 3;
  var LOG_LEVEL_INFO = 4;
  var LOG_LEVEL_DRAW = 2;
  var getLoggers = (log5) => ({
    "layer.changeFlag": (layer, key, flags) => {
      log5.log(LOG_LEVEL_UPDATE_DETAIL, "".concat(layer.id, " ").concat(key, ": "), flags[key])();
    },
    "layer.initialize": (layer) => {
      log5.log(LOG_LEVEL_MAJOR_UPDATE, "Initializing ".concat(layer))();
    },
    "layer.update": (layer, needsUpdate) => {
      if (needsUpdate) {
        const flags = layer.getChangeFlags();
        log5.log(LOG_LEVEL_MINOR_UPDATE, "Updating ".concat(layer, " because: ").concat(Object.keys(flags).filter((key) => flags[key]).join(", ")))();
      } else {
        log5.log(LOG_LEVEL_INFO, "".concat(layer, " does not need update"))();
      }
    },
    "layer.matched": (layer, changed) => {
      if (changed) {
        log5.log(LOG_LEVEL_INFO, "Matched ".concat(layer, ", state transfered"))();
      }
    },
    "layer.finalize": (layer) => {
      log5.log(LOG_LEVEL_MAJOR_UPDATE, "Finalizing ".concat(layer))();
    },
    "compositeLayer.renderLayers": (layer, updated, subLayers) => {
      if (updated) {
        log5.log(LOG_LEVEL_MINOR_UPDATE, "Composite layer rendered new subLayers ".concat(layer), subLayers)();
      } else {
        log5.log(LOG_LEVEL_INFO, "Composite layer reused subLayers ".concat(layer), subLayers)();
      }
    },
    "layerManager.setLayers": (layerManager, updated, layers) => {
      if (updated) {
        log5.log(LOG_LEVEL_MINOR_UPDATE, "Updating ".concat(layers.length, " deck layers"))();
      }
    },
    "layerManager.activateViewport": (layerManager, viewport) => {
      log5.log(LOG_LEVEL_UPDATE_DETAIL, "Viewport changed", viewport)();
    },
    "attributeManager.invalidate": (attributeManager, trigger, attributeNames) => {
      log5.log(LOG_LEVEL_MAJOR_UPDATE, attributeNames ? "invalidated attributes ".concat(attributeNames, " (").concat(trigger, ") for ").concat(attributeManager.id) : "invalidated all attributes for ".concat(attributeManager.id))();
    },
    "attributeManager.updateStart": (attributeManager) => {
      logState.attributeUpdateMessages.length = 0;
      logState.attributeManagerUpdateStart = Date.now();
    },
    "attributeManager.updateEnd": (attributeManager, numInstances) => {
      const timeMs = Math.round(Date.now() - logState.attributeManagerUpdateStart);
      log5.groupCollapsed(LOG_LEVEL_MINOR_UPDATE, "Updated attributes for ".concat(numInstances, " instances in ").concat(attributeManager.id, " in ").concat(timeMs, "ms"))();
      for (const updateMessage of logState.attributeUpdateMessages) {
        log5.log(LOG_LEVEL_UPDATE_DETAIL, updateMessage)();
      }
      log5.groupEnd(LOG_LEVEL_MINOR_UPDATE)();
    },
    "attribute.updateStart": (attribute) => {
      logState.attributeUpdateStart = Date.now();
    },
    "attribute.allocate": (attribute, numInstances) => {
      const message2 = "".concat(attribute.id, " allocated ").concat(numInstances);
      logState.attributeUpdateMessages.push(message2);
    },
    "attribute.updateEnd": (attribute, numInstances) => {
      const timeMs = Math.round(Date.now() - logState.attributeUpdateStart);
      const message2 = "".concat(attribute.id, " updated ").concat(numInstances, " in ").concat(timeMs, "ms");
      logState.attributeUpdateMessages.push(message2);
    },
    "deckRenderer.renderLayers": (deckRenderer, renderStats, opts) => {
      const {
        pass: pass2,
        redrawReason,
        stats
      } = opts;
      for (const status of renderStats) {
        const {
          totalCount,
          visibleCount,
          compositeCount,
          pickableCount
        } = status;
        const primitiveCount = totalCount - compositeCount;
        const hiddenCount = primitiveCount - visibleCount;
        log5.log(LOG_LEVEL_DRAW, "RENDER #".concat(deckRenderer.renderCount, "   ").concat(visibleCount, " (of ").concat(totalCount, " layers) to ").concat(pass2, " because ").concat(redrawReason, "   (").concat(hiddenCount, " hidden, ").concat(compositeCount, " composite ").concat(pickableCount, " pickable)"))();
        if (stats) {
          stats.get("Redraw Layers").add(visibleCount);
        }
      }
    }
  });

  // node_modules/@deck.gl/core/dist/esm/debug/index.js
  var loggers = {};
  if (true) {
    loggers = getLoggers(log_default);
  }
  function register(handlers) {
    loggers = handlers;
  }
  function debug(eventType, arg1, arg2, arg3) {
    if (log_default.level > 0 && loggers[eventType]) {
      loggers[eventType].call(null, arg1, arg2, arg3);
    }
  }

  // node_modules/@deck.gl/core/dist/esm/utils/json-loader.js
  function isJSON(text5) {
    const firstChar = text5[0];
    const lastChar = text5[text5.length - 1];
    return firstChar === "{" && lastChar === "}" || firstChar === "[" && lastChar === "]";
  }
  var json_loader_default = {
    id: "JSON",
    name: "JSON",
    module: "",
    version: "",
    options: {},
    extensions: ["json", "geojson"],
    mimeTypes: ["application/json", "application/geo+json"],
    testText: isJSON,
    parseTextSync: JSON.parse
  };

  // node_modules/@deck.gl/core/dist/esm/lib/init.js
  function checkVersion() {
    const version = true ? "8.9.34" : globalThis.DECK_VERSION || "untranspiled source";
    const existingVersion = globalThis.deck && globalThis.deck.VERSION;
    if (existingVersion && existingVersion !== version) {
      throw new Error("deck.gl - multiple versions detected: ".concat(existingVersion, " vs ").concat(version));
    }
    if (!existingVersion) {
      log_default.log(1, "deck.gl ".concat(version))();
      globalThis.deck = {
        ...globalThis.deck,
        VERSION: version,
        version,
        log: log_default,
        _registerLoggers: register
      };
      registerLoaders([json_loader_default, [ImageLoader, {
        imagebitmap: {
          premultiplyAlpha: "none"
        }
      }]]);
    }
    return version;
  }
  var VERSION5 = checkVersion();

  // node_modules/@deck.gl/core/dist/esm/lib/constants.js
  var COORDINATE_SYSTEM = {
    DEFAULT: -1,
    LNGLAT: 1,
    METER_OFFSETS: 2,
    LNGLAT_OFFSETS: 3,
    CARTESIAN: 0
  };
  Object.defineProperty(COORDINATE_SYSTEM, "IDENTITY", {
    get: () => {
      log_default.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")();
      return 0;
    }
  });
  var PROJECTION_MODE = {
    WEB_MERCATOR: 1,
    GLOBE: 2,
    WEB_MERCATOR_AUTO_OFFSET: 4,
    IDENTITY: 0
  };
  var UNIT = {
    common: 0,
    meters: 1,
    pixels: 2
  };
  var EVENTS = {
    click: {
      handler: "onClick"
    },
    panstart: {
      handler: "onDragStart"
    },
    panmove: {
      handler: "onDrag"
    },
    panend: {
      handler: "onDragEnd"
    }
  };

  // node_modules/@luma.gl/gltools/dist/esm/utils/log.js
  var log3 = new Log2({
    id: "luma.gl"
  });

  // node_modules/@luma.gl/gltools/dist/esm/utils/assert.js
  function assert5(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "luma.gl: assertion failed.");
    }
  }

  // node_modules/@luma.gl/gltools/dist/esm/utils/webgl-checks.js
  var ERR_CONTEXT = "Invalid WebGLRenderingContext";
  var ERR_WEBGL2 = "Requires WebGL2";
  function isWebGL(gl) {
    if (typeof WebGLRenderingContext !== "undefined" && gl instanceof WebGLRenderingContext) {
      return true;
    }
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && Number.isFinite(gl._version));
  }
  function isWebGL2(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && gl._version === 2);
  }
  function getWebGL2Context(gl) {
    return isWebGL2(gl) ? gl : null;
  }
  function assertWebGLContext(gl) {
    assert5(isWebGL(gl), ERR_CONTEXT);
    return gl;
  }
  function assertWebGL2Context(gl) {
    assert5(isWebGL2(gl), ERR_WEBGL2);
    return gl;
  }

  // node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-vertex-array-object.js
  var glErrorShadow = {};
  function error(msg) {
    if (globalThis.console && globalThis.console.error) {
      globalThis.console.error(msg);
    }
  }
  function log4(msg) {
    if (globalThis.console && globalThis.console.log) {
      globalThis.console.log(msg);
    }
  }
  function synthesizeGLError(err, opt_msg) {
    glErrorShadow[err] = true;
    if (opt_msg !== void 0) {
      error(opt_msg);
    }
  }
  function wrapGLError(gl) {
    const f = gl.getError;
    gl.getError = function getError() {
      let err;
      do {
        err = f.apply(gl);
        if (err !== 0) {
          glErrorShadow[err] = true;
        }
      } while (err !== 0);
      for (err in glErrorShadow) {
        if (glErrorShadow[err]) {
          delete glErrorShadow[err];
          return parseInt(err, 10);
        }
      }
      return 0;
    };
  }
  var WebGLVertexArrayObjectOES = function WebGLVertexArrayObjectOES2(ext) {
    const gl = ext.gl;
    this.ext = ext;
    this.isAlive = true;
    this.hasBeenBound = false;
    this.elementArrayBuffer = null;
    this.attribs = new Array(ext.maxVertexAttribs);
    for (let n = 0; n < this.attribs.length; n++) {
      const attrib = new WebGLVertexArrayObjectOES2.VertexAttrib(gl);
      this.attribs[n] = attrib;
    }
    this.maxAttrib = 0;
  };
  WebGLVertexArrayObjectOES.VertexAttrib = function VertexAttrib(gl) {
    this.enabled = false;
    this.buffer = null;
    this.size = 4;
    this.type = 5126;
    this.normalized = false;
    this.stride = 16;
    this.offset = 0;
    this.cached = "";
    this.recache();
  };
  WebGLVertexArrayObjectOES.VertexAttrib.prototype.recache = function recache() {
    this.cached = [this.size, this.type, this.normalized, this.stride, this.offset].join(":");
  };
  var OESVertexArrayObject = function OESVertexArrayObject2(gl) {
    const self2 = this;
    this.gl = gl;
    wrapGLError(gl);
    const original = this.original = {
      getParameter: gl.getParameter,
      enableVertexAttribArray: gl.enableVertexAttribArray,
      disableVertexAttribArray: gl.disableVertexAttribArray,
      bindBuffer: gl.bindBuffer,
      getVertexAttrib: gl.getVertexAttrib,
      vertexAttribPointer: gl.vertexAttribPointer
    };
    gl.getParameter = function getParameter(pname) {
      if (pname === self2.VERTEX_ARRAY_BINDING_OES) {
        if (self2.currentVertexArrayObject === self2.defaultVertexArrayObject) {
          return null;
        }
        return self2.currentVertexArrayObject;
      }
      return original.getParameter.apply(this, arguments);
    };
    gl.enableVertexAttribArray = function enableVertexAttribArray(index5) {
      const vao = self2.currentVertexArrayObject;
      vao.maxAttrib = Math.max(vao.maxAttrib, index5);
      const attrib = vao.attribs[index5];
      attrib.enabled = true;
      return original.enableVertexAttribArray.apply(this, arguments);
    };
    gl.disableVertexAttribArray = function disableVertexAttribArray(index5) {
      const vao = self2.currentVertexArrayObject;
      vao.maxAttrib = Math.max(vao.maxAttrib, index5);
      const attrib = vao.attribs[index5];
      attrib.enabled = false;
      return original.disableVertexAttribArray.apply(this, arguments);
    };
    gl.bindBuffer = function bindBuffer(target5, buffer) {
      switch (target5) {
        case 34962:
          self2.currentArrayBuffer = buffer;
          break;
        case 34963:
          self2.currentVertexArrayObject.elementArrayBuffer = buffer;
          break;
        default:
      }
      return original.bindBuffer.apply(this, arguments);
    };
    gl.getVertexAttrib = function getVertexAttrib(index5, pname) {
      const vao = self2.currentVertexArrayObject;
      const attrib = vao.attribs[index5];
      switch (pname) {
        case 34975:
          return attrib.buffer;
        case 34338:
          return attrib.enabled;
        case 34339:
          return attrib.size;
        case 34340:
          return attrib.stride;
        case 34341:
          return attrib.type;
        case 34922:
          return attrib.normalized;
        default:
          return original.getVertexAttrib.apply(this, arguments);
      }
    };
    gl.vertexAttribPointer = function vertexAttribPointer(indx, size5, type, normalized, stride, offset) {
      const vao = self2.currentVertexArrayObject;
      vao.maxAttrib = Math.max(vao.maxAttrib, indx);
      const attrib = vao.attribs[indx];
      attrib.buffer = self2.currentArrayBuffer;
      attrib.size = size5;
      attrib.type = type;
      attrib.normalized = normalized;
      attrib.stride = stride;
      attrib.offset = offset;
      attrib.recache();
      return original.vertexAttribPointer.apply(this, arguments);
    };
    if (gl.instrumentExtension) {
      gl.instrumentExtension(this, "OES_vertex_array_object");
    }
    if (gl.canvas) {
      gl.canvas.addEventListener("webglcontextrestored", () => {
        log4("OESVertexArrayObject emulation library context restored");
        self2.reset_();
      }, true);
    }
    this.reset_();
  };
  OESVertexArrayObject.prototype.VERTEX_ARRAY_BINDING_OES = 34229;
  OESVertexArrayObject.prototype.reset_ = function reset_() {
    const contextWasLost = this.vertexArrayObjects !== void 0;
    if (contextWasLost) {
      for (let ii = 0; ii < this.vertexArrayObjects.length; ++ii) {
        this.vertexArrayObjects.isAlive = false;
      }
    }
    const gl = this.gl;
    this.maxVertexAttribs = gl.getParameter(34921);
    this.defaultVertexArrayObject = new WebGLVertexArrayObjectOES(this);
    this.currentVertexArrayObject = null;
    this.currentArrayBuffer = null;
    this.vertexArrayObjects = [this.defaultVertexArrayObject];
    this.bindVertexArrayOES(null);
  };
  OESVertexArrayObject.prototype.createVertexArrayOES = function createVertexArrayOES() {
    const arrayObject = new WebGLVertexArrayObjectOES(this);
    this.vertexArrayObjects.push(arrayObject);
    return arrayObject;
  };
  OESVertexArrayObject.prototype.deleteVertexArrayOES = function deleteVertexArrayOES(arrayObject) {
    arrayObject.isAlive = false;
    this.vertexArrayObjects.splice(this.vertexArrayObjects.indexOf(arrayObject), 1);
    if (this.currentVertexArrayObject === arrayObject) {
      this.bindVertexArrayOES(null);
    }
  };
  OESVertexArrayObject.prototype.isVertexArrayOES = function isVertexArrayOES(arrayObject) {
    if (arrayObject && arrayObject instanceof WebGLVertexArrayObjectOES) {
      if (arrayObject.hasBeenBound && arrayObject.ext === this) {
        return true;
      }
    }
    return false;
  };
  OESVertexArrayObject.prototype.bindVertexArrayOES = function bindVertexArrayOES(arrayObject) {
    const gl = this.gl;
    if (arrayObject && !arrayObject.isAlive) {
      synthesizeGLError(1282, "bindVertexArrayOES: attempt to bind deleted arrayObject");
      return;
    }
    const original = this.original;
    const oldVAO = this.currentVertexArrayObject;
    this.currentVertexArrayObject = arrayObject || this.defaultVertexArrayObject;
    this.currentVertexArrayObject.hasBeenBound = true;
    const newVAO = this.currentVertexArrayObject;
    if (oldVAO === newVAO) {
      return;
    }
    if (!oldVAO || newVAO.elementArrayBuffer !== oldVAO.elementArrayBuffer) {
      original.bindBuffer.call(gl, 34963, newVAO.elementArrayBuffer);
    }
    let currentBinding = this.currentArrayBuffer;
    const maxAttrib = Math.max(oldVAO ? oldVAO.maxAttrib : 0, newVAO.maxAttrib);
    for (let n = 0; n <= maxAttrib; n++) {
      const attrib = newVAO.attribs[n];
      const oldAttrib = oldVAO ? oldVAO.attribs[n] : null;
      if (!oldVAO || attrib.enabled !== oldAttrib.enabled) {
        if (attrib.enabled) {
          original.enableVertexAttribArray.call(gl, n);
        } else {
          original.disableVertexAttribArray.call(gl, n);
        }
      }
      if (attrib.enabled) {
        let bufferChanged = false;
        if (!oldVAO || attrib.buffer !== oldAttrib.buffer) {
          if (currentBinding !== attrib.buffer) {
            original.bindBuffer.call(gl, 34962, attrib.buffer);
            currentBinding = attrib.buffer;
          }
          bufferChanged = true;
        }
        if (bufferChanged || attrib.cached !== oldAttrib.cached) {
          original.vertexAttribPointer.call(gl, n, attrib.size, attrib.type, attrib.normalized, attrib.stride, attrib.offset);
        }
      }
    }
    if (this.currentArrayBuffer !== currentBinding) {
      original.bindBuffer.call(gl, 34962, this.currentArrayBuffer);
    }
  };
  function polyfillVertexArrayObject(gl) {
    if (typeof gl.createVertexArray === "function") {
      return;
    }
    const original_getSupportedExtensions = gl.getSupportedExtensions;
    gl.getSupportedExtensions = function getSupportedExtensions() {
      const list = original_getSupportedExtensions.call(this) || [];
      if (list.indexOf("OES_vertex_array_object") < 0) {
        list.push("OES_vertex_array_object");
      }
      return list;
    };
    const original_getExtension = gl.getExtension;
    gl.getExtension = function getExtension(name16) {
      const ext = original_getExtension.call(this, name16);
      if (ext) {
        return ext;
      }
      if (name16 !== "OES_vertex_array_object") {
        return null;
      }
      if (!gl.__OESVertexArrayObject) {
        this.__OESVertexArrayObject = new OESVertexArrayObject(this);
      }
      return this.__OESVertexArrayObject;
    };
  }

  // node_modules/@luma.gl/gltools/dist/esm/polyfill/get-parameter-polyfill.js
  var OES_element_index = "OES_element_index";
  var WEBGL_draw_buffers = "WEBGL_draw_buffers";
  var EXT_disjoint_timer_query = "EXT_disjoint_timer_query";
  var EXT_disjoint_timer_query_webgl2 = "EXT_disjoint_timer_query_webgl2";
  var EXT_texture_filter_anisotropic = "EXT_texture_filter_anisotropic";
  var WEBGL_debug_renderer_info = "WEBGL_debug_renderer_info";
  var GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 35723;
  var GL_DONT_CARE = 4352;
  var GL_GPU_DISJOINT_EXT = 36795;
  var GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047;
  var GL_UNMASKED_VENDOR_WEBGL = 37445;
  var GL_UNMASKED_RENDERER_WEBGL = 37446;
  var getWebGL2ValueOrZero = (gl) => !isWebGL2(gl) ? 0 : void 0;
  var WEBGL_PARAMETERS = {
    [3074]: (gl) => !isWebGL2(gl) ? 36064 : void 0,
    [GL_FRAGMENT_SHADER_DERIVATIVE_HINT]: (gl) => !isWebGL2(gl) ? GL_DONT_CARE : void 0,
    [35977]: getWebGL2ValueOrZero,
    [32937]: getWebGL2ValueOrZero,
    [GL_GPU_DISJOINT_EXT]: (gl, getParameter) => {
      const ext = isWebGL2(gl) ? gl.getExtension(EXT_disjoint_timer_query_webgl2) : gl.getExtension(EXT_disjoint_timer_query);
      return ext && ext.GPU_DISJOINT_EXT ? getParameter(ext.GPU_DISJOINT_EXT) : 0;
    },
    [GL_UNMASKED_VENDOR_WEBGL]: (gl, getParameter) => {
      const ext = gl.getExtension(WEBGL_debug_renderer_info);
      return getParameter(ext && ext.UNMASKED_VENDOR_WEBGL || 7936);
    },
    [GL_UNMASKED_RENDERER_WEBGL]: (gl, getParameter) => {
      const ext = gl.getExtension(WEBGL_debug_renderer_info);
      return getParameter(ext && ext.UNMASKED_RENDERER_WEBGL || 7937);
    },
    [GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT]: (gl, getParameter) => {
      const ext = gl.luma.extensions[EXT_texture_filter_anisotropic];
      return ext ? getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;
    },
    [32883]: getWebGL2ValueOrZero,
    [35071]: getWebGL2ValueOrZero,
    [37447]: getWebGL2ValueOrZero,
    [36063]: (gl, getParameter) => {
      if (!isWebGL2(gl)) {
        const ext = gl.getExtension(WEBGL_draw_buffers);
        return ext ? getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
      }
      return void 0;
    },
    [35379]: getWebGL2ValueOrZero,
    [35374]: getWebGL2ValueOrZero,
    [35377]: getWebGL2ValueOrZero,
    [34852]: (gl) => {
      if (!isWebGL2(gl)) {
        const ext = gl.getExtension(WEBGL_draw_buffers);
        return ext ? ext.MAX_DRAW_BUFFERS_WEBGL : 0;
      }
      return void 0;
    },
    [36203]: (gl) => gl.getExtension(OES_element_index) ? 2147483647 : 65535,
    [33001]: (gl) => gl.getExtension(OES_element_index) ? 16777216 : 65535,
    [33e3]: (gl) => 16777216,
    [37157]: getWebGL2ValueOrZero,
    [35373]: getWebGL2ValueOrZero,
    [35657]: getWebGL2ValueOrZero,
    [36183]: getWebGL2ValueOrZero,
    [37137]: getWebGL2ValueOrZero,
    [34045]: getWebGL2ValueOrZero,
    [35978]: getWebGL2ValueOrZero,
    [35979]: getWebGL2ValueOrZero,
    [35968]: getWebGL2ValueOrZero,
    [35376]: getWebGL2ValueOrZero,
    [35375]: getWebGL2ValueOrZero,
    [35659]: getWebGL2ValueOrZero,
    [37154]: getWebGL2ValueOrZero,
    [35371]: getWebGL2ValueOrZero,
    [35658]: getWebGL2ValueOrZero,
    [35076]: getWebGL2ValueOrZero,
    [35077]: getWebGL2ValueOrZero,
    [35380]: getWebGL2ValueOrZero
  };
  function getParameterPolyfill(gl, originalGetParameter, pname) {
    const limit = WEBGL_PARAMETERS[pname];
    const value13 = typeof limit === "function" ? limit(gl, originalGetParameter, pname) : limit;
    const result = value13 !== void 0 ? value13 : originalGetParameter(pname);
    return result;
  }

  // node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-table.js
  var OES_vertex_array_object = "OES_vertex_array_object";
  var ANGLE_instanced_arrays = "ANGLE_instanced_arrays";
  var WEBGL_draw_buffers2 = "WEBGL_draw_buffers";
  var EXT_disjoint_timer_query2 = "EXT_disjoint_timer_query";
  var EXT_texture_filter_anisotropic2 = "EXT_texture_filter_anisotropic";
  var ERR_VAO_NOT_SUPPORTED = "VertexArray requires WebGL2 or OES_vertex_array_object extension";
  function getExtensionData(gl, extension) {
    return {
      webgl2: isWebGL2(gl),
      ext: gl.getExtension(extension)
    };
  }
  var WEBGL2_CONTEXT_POLYFILLS = {
    [OES_vertex_array_object]: {
      meta: {
        suffix: "OES"
      },
      createVertexArray: () => {
        assert5(false, ERR_VAO_NOT_SUPPORTED);
      },
      deleteVertexArray: () => {
      },
      bindVertexArray: () => {
      },
      isVertexArray: () => false
    },
    [ANGLE_instanced_arrays]: {
      meta: {
        suffix: "ANGLE"
      },
      vertexAttribDivisor(location2, divisor) {
        assert5(divisor === 0, "WebGL instanced rendering not supported");
      },
      drawElementsInstanced: () => {
      },
      drawArraysInstanced: () => {
      }
    },
    [WEBGL_draw_buffers2]: {
      meta: {
        suffix: "WEBGL"
      },
      drawBuffers: () => {
        assert5(false);
      }
    },
    [EXT_disjoint_timer_query2]: {
      meta: {
        suffix: "EXT"
      },
      createQuery: () => {
        assert5(false);
      },
      deleteQuery: () => {
        assert5(false);
      },
      beginQuery: () => {
        assert5(false);
      },
      endQuery: () => {
      },
      getQuery(handle, pname) {
        return this.getQueryObject(handle, pname);
      },
      getQueryParameter(handle, pname) {
        return this.getQueryObject(handle, pname);
      },
      getQueryObject: () => {
      }
    }
  };
  var WEBGL2_CONTEXT_OVERRIDES = {
    readBuffer: (gl, originalFunc, attachment) => {
      if (isWebGL2(gl)) {
        originalFunc(attachment);
      } else {
      }
    },
    getVertexAttrib: (gl, originalFunc, location2, pname) => {
      const {
        webgl2,
        ext
      } = getExtensionData(gl, ANGLE_instanced_arrays);
      let result;
      switch (pname) {
        case 35069:
          result = !webgl2 ? false : void 0;
          break;
        case 35070:
          result = !webgl2 && !ext ? 0 : void 0;
          break;
        default:
      }
      return result !== void 0 ? result : originalFunc(location2, pname);
    },
    getProgramParameter: (gl, originalFunc, program, pname) => {
      if (!isWebGL2(gl)) {
        switch (pname) {
          case 35967:
            return 35981;
          case 35971:
            return 0;
          case 35382:
            return 0;
          default:
        }
      }
      return originalFunc(program, pname);
    },
    getInternalformatParameter: (gl, originalFunc, target5, format, pname) => {
      if (!isWebGL2(gl)) {
        switch (pname) {
          case 32937:
            return new Int32Array([0]);
          default:
        }
      }
      return gl.getInternalformatParameter(target5, format, pname);
    },
    getTexParameter(gl, originalFunc, target5, pname) {
      switch (pname) {
        case 34046:
          const {
            extensions
          } = gl.luma;
          const ext = extensions[EXT_texture_filter_anisotropic2];
          pname = ext && ext.TEXTURE_MAX_ANISOTROPY_EXT || 34046;
          break;
        default:
      }
      return originalFunc(target5, pname);
    },
    getParameter: getParameterPolyfill,
    hint(gl, originalFunc, pname, value13) {
      return originalFunc(pname, value13);
    }
  };

  // node_modules/@luma.gl/gltools/dist/esm/polyfill/polyfill-context.js
  function polyfillContext(gl) {
    gl.luma = gl.luma || {};
    const {
      luma
    } = gl;
    if (!luma.polyfilled) {
      polyfillVertexArrayObject(gl);
      initializeExtensions(gl);
      installPolyfills(gl, WEBGL2_CONTEXT_POLYFILLS);
      installOverrides(gl, {
        target: luma,
        target2: gl
      });
      luma.polyfilled = true;
    }
    return gl;
  }
  globalThis.polyfillContext = polyfillContext;
  function initializeExtensions(gl) {
    gl.luma.extensions = {};
    const EXTENSIONS2 = gl.getSupportedExtensions() || [];
    for (const extension of EXTENSIONS2) {
      gl.luma[extension] = gl.getExtension(extension);
    }
  }
  function installOverrides(gl, _ref) {
    let {
      target: target5,
      target2: target22
    } = _ref;
    Object.keys(WEBGL2_CONTEXT_OVERRIDES).forEach((key) => {
      if (typeof WEBGL2_CONTEXT_OVERRIDES[key] === "function") {
        const originalFunc = gl[key] ? gl[key].bind(gl) : () => {
        };
        const polyfill = WEBGL2_CONTEXT_OVERRIDES[key].bind(null, gl, originalFunc);
        target5[key] = polyfill;
        target22[key] = polyfill;
      }
    });
  }
  function installPolyfills(gl, polyfills) {
    for (const extension of Object.getOwnPropertyNames(polyfills)) {
      if (extension !== "overrides") {
        polyfillExtension(gl, {
          extension,
          target: gl.luma,
          target2: gl
        });
      }
    }
  }
  function polyfillExtension(gl, _ref2) {
    let {
      extension,
      target: target5,
      target2: target22
    } = _ref2;
    const defaults = WEBGL2_CONTEXT_POLYFILLS[extension];
    assert5(defaults);
    const {
      meta = {}
    } = defaults;
    const {
      suffix = ""
    } = meta;
    const ext = gl.getExtension(extension);
    for (const key of Object.keys(defaults)) {
      const extKey = "".concat(key).concat(suffix);
      let polyfill = null;
      if (key === "meta") {
      } else if (typeof gl[key] === "function") {
      } else if (ext && typeof ext[extKey] === "function") {
        polyfill = function() {
          return ext[extKey](...arguments);
        };
      } else if (typeof defaults[key] === "function") {
        polyfill = defaults[key].bind(target5);
      }
      if (polyfill) {
        target5[key] = polyfill;
        target22[key] = polyfill;
      }
    }
  }

  // node_modules/@luma.gl/gltools/dist/esm/state-tracker/webgl-parameter-tables.js
  var GL_PARAMETER_DEFAULTS = {
    [3042]: false,
    [32773]: new Float32Array([0, 0, 0, 0]),
    [32777]: 32774,
    [34877]: 32774,
    [32969]: 1,
    [32968]: 0,
    [32971]: 1,
    [32970]: 0,
    [3106]: new Float32Array([0, 0, 0, 0]),
    [3107]: [true, true, true, true],
    [2884]: false,
    [2885]: 1029,
    [2929]: false,
    [2931]: 1,
    [2932]: 513,
    [2928]: new Float32Array([0, 1]),
    [2930]: true,
    [3024]: true,
    [36006]: null,
    [2886]: 2305,
    [33170]: 4352,
    [2849]: 1,
    [32823]: false,
    [32824]: 0,
    [10752]: 0,
    [32938]: 1,
    [32939]: false,
    [3089]: false,
    [3088]: new Int32Array([0, 0, 1024, 1024]),
    [2960]: false,
    [2961]: 0,
    [2968]: 4294967295,
    [36005]: 4294967295,
    [2962]: 519,
    [2967]: 0,
    [2963]: 4294967295,
    [34816]: 519,
    [36003]: 0,
    [36004]: 4294967295,
    [2964]: 7680,
    [2965]: 7680,
    [2966]: 7680,
    [34817]: 7680,
    [34818]: 7680,
    [34819]: 7680,
    [2978]: [0, 0, 1024, 1024],
    [3333]: 4,
    [3317]: 4,
    [37440]: false,
    [37441]: false,
    [37443]: 37444,
    [35723]: 4352,
    [36010]: null,
    [35977]: false,
    [3330]: 0,
    [3332]: 0,
    [3331]: 0,
    [3314]: 0,
    [32878]: 0,
    [3316]: 0,
    [3315]: 0,
    [32877]: 0
  };
  var enable = (gl, value13, key) => value13 ? gl.enable(key) : gl.disable(key);
  var hint = (gl, value13, key) => gl.hint(key, value13);
  var pixelStorei = (gl, value13, key) => gl.pixelStorei(key, value13);
  var drawFramebuffer = (gl, value13) => {
    const target5 = isWebGL2(gl) ? 36009 : 36160;
    return gl.bindFramebuffer(target5, value13);
  };
  var readFramebuffer = (gl, value13) => {
    return gl.bindFramebuffer(36008, value13);
  };
  function isArray(array2) {
    return Array.isArray(array2) || ArrayBuffer.isView(array2);
  }
  var GL_PARAMETER_SETTERS = {
    [3042]: enable,
    [32773]: (gl, value13) => gl.blendColor(...value13),
    [32777]: "blendEquation",
    [34877]: "blendEquation",
    [32969]: "blendFunc",
    [32968]: "blendFunc",
    [32971]: "blendFunc",
    [32970]: "blendFunc",
    [3106]: (gl, value13) => gl.clearColor(...value13),
    [3107]: (gl, value13) => gl.colorMask(...value13),
    [2884]: enable,
    [2885]: (gl, value13) => gl.cullFace(value13),
    [2929]: enable,
    [2931]: (gl, value13) => gl.clearDepth(value13),
    [2932]: (gl, value13) => gl.depthFunc(value13),
    [2928]: (gl, value13) => gl.depthRange(...value13),
    [2930]: (gl, value13) => gl.depthMask(value13),
    [3024]: enable,
    [35723]: hint,
    [36006]: drawFramebuffer,
    [2886]: (gl, value13) => gl.frontFace(value13),
    [33170]: hint,
    [2849]: (gl, value13) => gl.lineWidth(value13),
    [32823]: enable,
    [32824]: "polygonOffset",
    [10752]: "polygonOffset",
    [35977]: enable,
    [32938]: "sampleCoverage",
    [32939]: "sampleCoverage",
    [3089]: enable,
    [3088]: (gl, value13) => gl.scissor(...value13),
    [2960]: enable,
    [2961]: (gl, value13) => gl.clearStencil(value13),
    [2968]: (gl, value13) => gl.stencilMaskSeparate(1028, value13),
    [36005]: (gl, value13) => gl.stencilMaskSeparate(1029, value13),
    [2962]: "stencilFuncFront",
    [2967]: "stencilFuncFront",
    [2963]: "stencilFuncFront",
    [34816]: "stencilFuncBack",
    [36003]: "stencilFuncBack",
    [36004]: "stencilFuncBack",
    [2964]: "stencilOpFront",
    [2965]: "stencilOpFront",
    [2966]: "stencilOpFront",
    [34817]: "stencilOpBack",
    [34818]: "stencilOpBack",
    [34819]: "stencilOpBack",
    [2978]: (gl, value13) => gl.viewport(...value13),
    [3333]: pixelStorei,
    [3317]: pixelStorei,
    [37440]: pixelStorei,
    [37441]: pixelStorei,
    [37443]: pixelStorei,
    [3330]: pixelStorei,
    [3332]: pixelStorei,
    [3331]: pixelStorei,
    [36010]: readFramebuffer,
    [3314]: pixelStorei,
    [32878]: pixelStorei,
    [3316]: pixelStorei,
    [3315]: pixelStorei,
    [32877]: pixelStorei,
    framebuffer: (gl, framebuffer) => {
      const handle = framebuffer && "handle" in framebuffer ? framebuffer.handle : framebuffer;
      return gl.bindFramebuffer(36160, handle);
    },
    blend: (gl, value13) => value13 ? gl.enable(3042) : gl.disable(3042),
    blendColor: (gl, value13) => gl.blendColor(...value13),
    blendEquation: (gl, args) => {
      args = isArray(args) ? args : [args, args];
      gl.blendEquationSeparate(...args);
    },
    blendFunc: (gl, args) => {
      args = isArray(args) && args.length === 2 ? [...args, ...args] : args;
      gl.blendFuncSeparate(...args);
    },
    clearColor: (gl, value13) => gl.clearColor(...value13),
    clearDepth: (gl, value13) => gl.clearDepth(value13),
    clearStencil: (gl, value13) => gl.clearStencil(value13),
    colorMask: (gl, value13) => gl.colorMask(...value13),
    cull: (gl, value13) => value13 ? gl.enable(2884) : gl.disable(2884),
    cullFace: (gl, value13) => gl.cullFace(value13),
    depthTest: (gl, value13) => value13 ? gl.enable(2929) : gl.disable(2929),
    depthFunc: (gl, value13) => gl.depthFunc(value13),
    depthMask: (gl, value13) => gl.depthMask(value13),
    depthRange: (gl, value13) => gl.depthRange(...value13),
    dither: (gl, value13) => value13 ? gl.enable(3024) : gl.disable(3024),
    derivativeHint: (gl, value13) => {
      gl.hint(35723, value13);
    },
    frontFace: (gl, value13) => gl.frontFace(value13),
    mipmapHint: (gl, value13) => gl.hint(33170, value13),
    lineWidth: (gl, value13) => gl.lineWidth(value13),
    polygonOffsetFill: (gl, value13) => value13 ? gl.enable(32823) : gl.disable(32823),
    polygonOffset: (gl, value13) => gl.polygonOffset(...value13),
    sampleCoverage: (gl, value13) => gl.sampleCoverage(...value13),
    scissorTest: (gl, value13) => value13 ? gl.enable(3089) : gl.disable(3089),
    scissor: (gl, value13) => gl.scissor(...value13),
    stencilTest: (gl, value13) => value13 ? gl.enable(2960) : gl.disable(2960),
    stencilMask: (gl, value13) => {
      value13 = isArray(value13) ? value13 : [value13, value13];
      const [mask, backMask] = value13;
      gl.stencilMaskSeparate(1028, mask);
      gl.stencilMaskSeparate(1029, backMask);
    },
    stencilFunc: (gl, args) => {
      args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
      const [func11, ref, mask, backFunc, backRef, backMask] = args;
      gl.stencilFuncSeparate(1028, func11, ref, mask);
      gl.stencilFuncSeparate(1029, backFunc, backRef, backMask);
    },
    stencilOp: (gl, args) => {
      args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
      const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
      gl.stencilOpSeparate(1028, sfail, dpfail, dppass);
      gl.stencilOpSeparate(1029, backSfail, backDpfail, backDppass);
    },
    viewport: (gl, value13) => gl.viewport(...value13)
  };
  function getValue(glEnum, values2, cache3) {
    return values2[glEnum] !== void 0 ? values2[glEnum] : cache3[glEnum];
  }
  var GL_COMPOSITE_PARAMETER_SETTERS = {
    blendEquation: (gl, values2, cache3) => gl.blendEquationSeparate(getValue(32777, values2, cache3), getValue(34877, values2, cache3)),
    blendFunc: (gl, values2, cache3) => gl.blendFuncSeparate(getValue(32969, values2, cache3), getValue(32968, values2, cache3), getValue(32971, values2, cache3), getValue(32970, values2, cache3)),
    polygonOffset: (gl, values2, cache3) => gl.polygonOffset(getValue(32824, values2, cache3), getValue(10752, values2, cache3)),
    sampleCoverage: (gl, values2, cache3) => gl.sampleCoverage(getValue(32938, values2, cache3), getValue(32939, values2, cache3)),
    stencilFuncFront: (gl, values2, cache3) => gl.stencilFuncSeparate(1028, getValue(2962, values2, cache3), getValue(2967, values2, cache3), getValue(2963, values2, cache3)),
    stencilFuncBack: (gl, values2, cache3) => gl.stencilFuncSeparate(1029, getValue(34816, values2, cache3), getValue(36003, values2, cache3), getValue(36004, values2, cache3)),
    stencilOpFront: (gl, values2, cache3) => gl.stencilOpSeparate(1028, getValue(2964, values2, cache3), getValue(2965, values2, cache3), getValue(2966, values2, cache3)),
    stencilOpBack: (gl, values2, cache3) => gl.stencilOpSeparate(1029, getValue(34817, values2, cache3), getValue(34818, values2, cache3), getValue(34819, values2, cache3))
  };
  var GL_HOOKED_SETTERS = {
    enable: (update, capability) => update({
      [capability]: true
    }),
    disable: (update, capability) => update({
      [capability]: false
    }),
    pixelStorei: (update, pname, value13) => update({
      [pname]: value13
    }),
    hint: (update, pname, hint2) => update({
      [pname]: hint2
    }),
    bindFramebuffer: (update, target5, framebuffer) => {
      switch (target5) {
        case 36160:
          return update({
            [36006]: framebuffer,
            [36010]: framebuffer
          });
        case 36009:
          return update({
            [36006]: framebuffer
          });
        case 36008:
          return update({
            [36010]: framebuffer
          });
        default:
          return null;
      }
    },
    blendColor: (update, r, g, b, a) => update({
      [32773]: new Float32Array([r, g, b, a])
    }),
    blendEquation: (update, mode) => update({
      [32777]: mode,
      [34877]: mode
    }),
    blendEquationSeparate: (update, modeRGB, modeAlpha) => update({
      [32777]: modeRGB,
      [34877]: modeAlpha
    }),
    blendFunc: (update, src9, dst) => update({
      [32969]: src9,
      [32968]: dst,
      [32971]: src9,
      [32970]: dst
    }),
    blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) => update({
      [32969]: srcRGB,
      [32968]: dstRGB,
      [32971]: srcAlpha,
      [32970]: dstAlpha
    }),
    clearColor: (update, r, g, b, a) => update({
      [3106]: new Float32Array([r, g, b, a])
    }),
    clearDepth: (update, depth) => update({
      [2931]: depth
    }),
    clearStencil: (update, s) => update({
      [2961]: s
    }),
    colorMask: (update, r, g, b, a) => update({
      [3107]: [r, g, b, a]
    }),
    cullFace: (update, mode) => update({
      [2885]: mode
    }),
    depthFunc: (update, func11) => update({
      [2932]: func11
    }),
    depthRange: (update, zNear, zFar) => update({
      [2928]: new Float32Array([zNear, zFar])
    }),
    depthMask: (update, mask) => update({
      [2930]: mask
    }),
    frontFace: (update, face) => update({
      [2886]: face
    }),
    lineWidth: (update, width8) => update({
      [2849]: width8
    }),
    polygonOffset: (update, factor, units) => update({
      [32824]: factor,
      [10752]: units
    }),
    sampleCoverage: (update, value13, invert2) => update({
      [32938]: value13,
      [32939]: invert2
    }),
    scissor: (update, x, y, width8, height8) => update({
      [3088]: new Int32Array([x, y, width8, height8])
    }),
    stencilMask: (update, mask) => update({
      [2968]: mask,
      [36005]: mask
    }),
    stencilMaskSeparate: (update, face, mask) => update({
      [face === 1028 ? 2968 : 36005]: mask
    }),
    stencilFunc: (update, func11, ref, mask) => update({
      [2962]: func11,
      [2967]: ref,
      [2963]: mask,
      [34816]: func11,
      [36003]: ref,
      [36004]: mask
    }),
    stencilFuncSeparate: (update, face, func11, ref, mask) => update({
      [face === 1028 ? 2962 : 34816]: func11,
      [face === 1028 ? 2967 : 36003]: ref,
      [face === 1028 ? 2963 : 36004]: mask
    }),
    stencilOp: (update, fail3, zfail, zpass) => update({
      [2964]: fail3,
      [2965]: zfail,
      [2966]: zpass,
      [34817]: fail3,
      [34818]: zfail,
      [34819]: zpass
    }),
    stencilOpSeparate: (update, face, fail3, zfail, zpass) => update({
      [face === 1028 ? 2964 : 34817]: fail3,
      [face === 1028 ? 2965 : 34818]: zfail,
      [face === 1028 ? 2966 : 34819]: zpass
    }),
    viewport: (update, x, y, width8, height8) => update({
      [2978]: [x, y, width8, height8]
    })
  };
  var isEnabled = (gl, key) => gl.isEnabled(key);
  var GL_PARAMETER_GETTERS = {
    [3042]: isEnabled,
    [2884]: isEnabled,
    [2929]: isEnabled,
    [3024]: isEnabled,
    [32823]: isEnabled,
    [32926]: isEnabled,
    [32928]: isEnabled,
    [3089]: isEnabled,
    [2960]: isEnabled,
    [35977]: isEnabled
  };

  // node_modules/@luma.gl/gltools/dist/esm/utils/utils.js
  function isObjectEmpty(object12) {
    for (const key in object12) {
      return false;
    }
    return true;
  }
  function deepArrayEqual(x, y) {
    if (x === y) {
      return true;
    }
    const isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);
    const isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);
    if (isArrayX && isArrayY && x.length === y.length) {
      for (let i = 0; i < x.length; ++i) {
        if (x[i] !== y[i]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // node_modules/@luma.gl/gltools/dist/esm/state-tracker/track-context-state.js
  function installGetterOverride(gl, functionName) {
    const originalGetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function get3() {
      const pname = arguments.length <= 0 ? void 0 : arguments[0];
      if (!(pname in gl.state.cache)) {
        return originalGetterFunc(...arguments);
      }
      return gl.state.enable ? gl.state.cache[pname] : originalGetterFunc(...arguments);
    };
    Object.defineProperty(gl[functionName], "name", {
      value: "".concat(functionName, "-from-cache"),
      configurable: false
    });
  }
  function installSetterSpy(gl, functionName, setter) {
    const originalSetterFunc = gl[functionName].bind(gl);
    gl[functionName] = function set() {
      for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
        params[_key] = arguments[_key];
      }
      const {
        valueChanged,
        oldValue
      } = setter(gl.state._updateCache, ...params);
      if (valueChanged) {
        originalSetterFunc(...params);
      }
      return oldValue;
    };
    Object.defineProperty(gl[functionName], "name", {
      value: "".concat(functionName, "-to-cache"),
      configurable: false
    });
  }
  function installProgramSpy(gl) {
    const originalUseProgram = gl.useProgram.bind(gl);
    gl.useProgram = function useProgramLuma(handle) {
      if (gl.state.program !== handle) {
        originalUseProgram(handle);
        gl.state.program = handle;
      }
    };
  }
  var GLState = class {
    constructor(gl) {
      let {
        copyState = false,
        log: log5 = () => {
        }
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.gl = gl;
      this.program = null;
      this.stateStack = [];
      this.enable = true;
      this.cache = copyState ? getParameters(gl) : Object.assign({}, GL_PARAMETER_DEFAULTS);
      this.log = log5;
      this._updateCache = this._updateCache.bind(this);
      Object.seal(this);
    }
    push() {
      let values2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.stateStack.push({});
    }
    pop() {
      assert5(this.stateStack.length > 0);
      const oldValues = this.stateStack[this.stateStack.length - 1];
      setParameters(this.gl, oldValues);
      this.stateStack.pop();
    }
    _updateCache(values2) {
      let valueChanged = false;
      let oldValue;
      const oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];
      for (const key in values2) {
        assert5(key !== void 0);
        const value13 = values2[key];
        const cached = this.cache[key];
        if (!deepArrayEqual(value13, cached)) {
          valueChanged = true;
          oldValue = cached;
          if (oldValues && !(key in oldValues)) {
            oldValues[key] = cached;
          }
          this.cache[key] = value13;
        }
      }
      return {
        valueChanged,
        oldValue
      };
    }
  };
  function trackContextState(gl) {
    let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      enable: enable2 = true,
      copyState
    } = options2;
    assert5(copyState !== void 0);
    if (!gl.state) {
      const {
        polyfillContext: polyfillContext2
      } = globalThis;
      if (polyfillContext2) {
        polyfillContext2(gl);
      }
      gl.state = new GLState(gl, {
        copyState
      });
      installProgramSpy(gl);
      for (const key in GL_HOOKED_SETTERS) {
        const setter = GL_HOOKED_SETTERS[key];
        installSetterSpy(gl, key, setter);
      }
      installGetterOverride(gl, "getParameter");
      installGetterOverride(gl, "isEnabled");
    }
    gl.state.enable = enable2;
    return gl;
  }
  function pushContextState(gl) {
    if (!gl.state) {
      trackContextState(gl, {
        copyState: false
      });
    }
    gl.state.push();
  }
  function popContextState(gl) {
    assert5(gl.state);
    gl.state.pop();
  }

  // node_modules/@luma.gl/gltools/dist/esm/state-tracker/unified-parameter-api.js
  function setParameters(gl, values2) {
    assert5(isWebGL(gl), "setParameters requires a WebGL context");
    if (isObjectEmpty(values2)) {
      return;
    }
    const compositeSetters = {};
    for (const key in values2) {
      const glConstant = Number(key);
      const setter = GL_PARAMETER_SETTERS[key];
      if (setter) {
        if (typeof setter === "string") {
          compositeSetters[setter] = true;
        } else {
          setter(gl, values2[key], glConstant);
        }
      }
    }
    const cache3 = gl.state && gl.state.cache;
    if (cache3) {
      for (const key in compositeSetters) {
        const compositeSetter = GL_COMPOSITE_PARAMETER_SETTERS[key];
        compositeSetter(gl, values2, cache3);
      }
    }
  }
  function getParameters(gl, parameters) {
    parameters = parameters || GL_PARAMETER_DEFAULTS;
    if (typeof parameters === "number") {
      const key = parameters;
      const getter = GL_PARAMETER_GETTERS[key];
      return getter ? getter(gl, key) : gl.getParameter(key);
    }
    const parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);
    const state3 = {};
    for (const key of parameterKeys) {
      const getter = GL_PARAMETER_GETTERS[key];
      state3[key] = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
    }
    return state3;
  }
  function resetParameters(gl) {
    setParameters(gl, GL_PARAMETER_DEFAULTS);
  }
  function withParameters(gl, parameters, func11) {
    if (isObjectEmpty(parameters)) {
      return func11(gl);
    }
    const {
      nocatch = true
    } = parameters;
    pushContextState(gl);
    setParameters(gl, parameters);
    let value13;
    if (nocatch) {
      value13 = func11(gl);
      popContextState(gl);
    } else {
      try {
        value13 = func11(gl);
      } finally {
        popContextState(gl);
      }
    }
    return value13;
  }

  // node_modules/@luma.gl/gltools/dist/esm/utils/device-pixels.js
  function cssToDeviceRatio(gl) {
    const {
      luma
    } = gl;
    if (gl.canvas && luma) {
      const cachedSize = luma.canvasSizeInfo;
      const clientWidth = "clientWidth" in cachedSize ? cachedSize.clientWidth : gl.canvas.clientWidth;
      return clientWidth ? gl.drawingBufferWidth / clientWidth : 1;
    }
    return 1;
  }
  function cssToDevicePixels(gl, cssPixel) {
    let yInvert = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    const ratio = cssToDeviceRatio(gl);
    const width8 = gl.drawingBufferWidth;
    const height8 = gl.drawingBufferHeight;
    return scalePixels(cssPixel, ratio, width8, height8, yInvert);
  }
  function getDevicePixelRatio(useDevicePixels) {
    const windowRatio = typeof window === "undefined" ? 1 : window.devicePixelRatio || 1;
    if (Number.isFinite(useDevicePixels)) {
      return useDevicePixels <= 0 ? 1 : useDevicePixels;
    }
    return useDevicePixels ? windowRatio : 1;
  }
  function scalePixels(pixel, ratio, width8, height8, yInvert) {
    const x = scaleX(pixel[0], ratio, width8);
    let y = scaleY(pixel[1], ratio, height8, yInvert);
    let t = scaleX(pixel[0] + 1, ratio, width8);
    const xHigh = t === width8 - 1 ? t : t - 1;
    t = scaleY(pixel[1] + 1, ratio, height8, yInvert);
    let yHigh;
    if (yInvert) {
      t = t === 0 ? t : t + 1;
      yHigh = y;
      y = t;
    } else {
      yHigh = t === height8 - 1 ? t : t - 1;
    }
    return {
      x,
      y,
      width: Math.max(xHigh - x + 1, 1),
      height: Math.max(yHigh - y + 1, 1)
    };
  }
  function scaleX(x, ratio, width8) {
    const r = Math.min(Math.round(x * ratio), width8 - 1);
    return r;
  }
  function scaleY(y, ratio, height8, yInvert) {
    return yInvert ? Math.max(0, height8 - 1 - Math.round(y * ratio)) : Math.min(Math.round(y * ratio), height8 - 1);
  }

  // node_modules/@luma.gl/gltools/dist/esm/context/context.js
  var isBrowser7 = isBrowser5();
  var isPage = isBrowser7 && typeof document !== "undefined";
  var CONTEXT_DEFAULTS = {
    webgl2: true,
    webgl1: true,
    throwOnError: true,
    manageState: true,
    canvas: null,
    debug: false,
    width: 800,
    height: 600
  };
  function createGLContext() {
    let options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    assert5(isBrowser7, "createGLContext only available in the browser.\nCreate your own headless context or use 'createHeadlessContext' from @luma.gl/test-utils");
    options2 = Object.assign({}, CONTEXT_DEFAULTS, options2);
    const {
      width: width8,
      height: height8
    } = options2;
    function onError(message2) {
      if (options2.throwOnError) {
        throw new Error(message2);
      }
      console.error(message2);
      return null;
    }
    options2.onError = onError;
    let gl;
    const {
      canvas
    } = options2;
    const targetCanvas = getCanvas({
      canvas,
      width: width8,
      height: height8,
      onError
    });
    gl = createBrowserContext(targetCanvas, options2);
    if (!gl) {
      return null;
    }
    gl = instrumentGLContext(gl, options2);
    logInfo(gl);
    return gl;
  }
  function instrumentGLContext(gl) {
    let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!gl || gl._instrumented) {
      return gl;
    }
    gl._version = gl._version || getVersion(gl);
    gl.luma = gl.luma || {};
    gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
    options2 = Object.assign({}, CONTEXT_DEFAULTS, options2);
    const {
      manageState,
      debug: debug2
    } = options2;
    if (manageState) {
      trackContextState(gl, {
        copyState: false,
        log: function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return log3.log(1, ...args)();
        }
      });
    }
    if (isBrowser7 && debug2) {
      if (!globalThis.makeDebugContext) {
        log3.warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')();
      } else {
        gl = globalThis.makeDebugContext(gl, options2);
        log3.level = Math.max(log3.level, 1);
      }
    }
    gl._instrumented = true;
    return gl;
  }
  function getContextDebugInfo(gl) {
    const vendorMasked = gl.getParameter(7936);
    const rendererMasked = gl.getParameter(7937);
    const ext = gl.getExtension("WEBGL_debug_renderer_info");
    const vendorUnmasked = ext && gl.getParameter(ext.UNMASKED_VENDOR_WEBGL || 7936);
    const rendererUnmasked = ext && gl.getParameter(ext.UNMASKED_RENDERER_WEBGL || 7937);
    return {
      vendor: vendorUnmasked || vendorMasked,
      renderer: rendererUnmasked || rendererMasked,
      vendorMasked,
      rendererMasked,
      version: gl.getParameter(7938),
      shadingLanguageVersion: gl.getParameter(35724)
    };
  }
  function resizeGLContext(gl) {
    let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (gl.canvas) {
      const devicePixelRatio = getDevicePixelRatio(options2.useDevicePixels);
      setDevicePixelRatio(gl, devicePixelRatio, options2);
      return;
    }
    const ext = gl.getExtension("STACKGL_resize_drawingbuffer");
    if (ext && "width" in options2 && "height" in options2) {
      ext.resize(options2.width, options2.height);
    }
  }
  function createBrowserContext(canvas, options2) {
    const {
      onError
    } = options2;
    let errorMessage = null;
    const onCreateError = (error3) => errorMessage = error3.statusMessage || errorMessage;
    canvas.addEventListener("webglcontextcreationerror", onCreateError, false);
    const {
      webgl1 = true,
      webgl2 = true
    } = options2;
    let gl = null;
    if (webgl2) {
      gl = gl || canvas.getContext("webgl2", options2);
      gl = gl || canvas.getContext("experimental-webgl2", options2);
    }
    if (webgl1) {
      gl = gl || canvas.getContext("webgl", options2);
      gl = gl || canvas.getContext("experimental-webgl", options2);
    }
    canvas.removeEventListener("webglcontextcreationerror", onCreateError, false);
    if (!gl) {
      return onError("Failed to create ".concat(webgl2 && !webgl1 ? "WebGL2" : "WebGL", " context: ").concat(errorMessage || "Unknown error"));
    }
    if (options2.onContextLost) {
      canvas.addEventListener("webglcontextlost", options2.onContextLost, false);
    }
    if (options2.onContextRestored) {
      canvas.addEventListener("webglcontextrestored", options2.onContextRestored, false);
    }
    return gl;
  }
  function getCanvas(_ref) {
    let {
      canvas,
      width: width8 = 800,
      height: height8 = 600,
      onError
    } = _ref;
    let targetCanvas;
    if (typeof canvas === "string") {
      const isPageLoaded = isPage && document.readyState === "complete";
      if (!isPageLoaded) {
        onError("createGLContext called on canvas '".concat(canvas, "' before page was loaded"));
      }
      targetCanvas = document.getElementById(canvas);
    } else if (canvas) {
      targetCanvas = canvas;
    } else {
      targetCanvas = document.createElement("canvas");
      targetCanvas.id = "lumagl-canvas";
      targetCanvas.style.width = Number.isFinite(width8) ? "".concat(width8, "px") : "100%";
      targetCanvas.style.height = Number.isFinite(height8) ? "".concat(height8, "px") : "100%";
      document.body.insertBefore(targetCanvas, document.body.firstChild);
    }
    return targetCanvas;
  }
  function logInfo(gl) {
    const webGL = isWebGL2(gl) ? "WebGL2" : "WebGL1";
    const info = getContextDebugInfo(gl);
    const driver2 = info ? "(".concat(info.vendor, ",").concat(info.renderer, ")") : "";
    const debug2 = gl.debug ? " debug" : "";
    log3.info(1, "".concat(webGL).concat(debug2, " context ").concat(driver2))();
  }
  function getVersion(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return 2;
    }
    return 1;
  }
  function setDevicePixelRatio(gl, devicePixelRatio, options2) {
    let clientWidth = "width" in options2 ? options2.width : gl.canvas.clientWidth;
    let clientHeight = "height" in options2 ? options2.height : gl.canvas.clientHeight;
    if (!clientWidth || !clientHeight) {
      log3.log(1, "Canvas clientWidth/clientHeight is 0")();
      devicePixelRatio = 1;
      clientWidth = gl.canvas.width || 1;
      clientHeight = gl.canvas.height || 1;
    }
    gl.luma = gl.luma || {};
    gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
    const cachedSize = gl.luma.canvasSizeInfo;
    if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {
      let clampedPixelRatio = devicePixelRatio;
      const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);
      const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);
      gl.canvas.width = canvasWidth;
      gl.canvas.height = canvasHeight;
      if (gl.drawingBufferWidth !== canvasWidth || gl.drawingBufferHeight !== canvasHeight) {
        log3.warn("Device pixel ratio clamped")();
        clampedPixelRatio = Math.min(gl.drawingBufferWidth / clientWidth, gl.drawingBufferHeight / clientHeight);
        gl.canvas.width = Math.floor(clientWidth * clampedPixelRatio);
        gl.canvas.height = Math.floor(clientHeight * clampedPixelRatio);
      }
      Object.assign(gl.luma.canvasSizeInfo, {
        clientWidth,
        clientHeight,
        devicePixelRatio
      });
    }
  }

  // node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js
  function getHiResTimestamp3() {
    let timestamp;
    if (typeof window !== "undefined" && window.performance) {
      timestamp = window.performance.now();
    } else if (typeof process !== "undefined" && process.hrtime) {
      const timeParts = process.hrtime();
      timestamp = timeParts[0] * 1e3 + timeParts[1] / 1e6;
    } else {
      timestamp = Date.now();
    }
    return timestamp;
  }

  // node_modules/@probe.gl/stats/dist/esm/lib/stat.js
  var Stat = class {
    constructor(name16, type) {
      _defineProperty(this, "name", void 0);
      _defineProperty(this, "type", void 0);
      _defineProperty(this, "sampleSize", 1);
      _defineProperty(this, "time", void 0);
      _defineProperty(this, "count", void 0);
      _defineProperty(this, "samples", void 0);
      _defineProperty(this, "lastTiming", void 0);
      _defineProperty(this, "lastSampleTime", void 0);
      _defineProperty(this, "lastSampleCount", void 0);
      _defineProperty(this, "_count", 0);
      _defineProperty(this, "_time", 0);
      _defineProperty(this, "_samples", 0);
      _defineProperty(this, "_startTime", 0);
      _defineProperty(this, "_timerPending", false);
      this.name = name16;
      this.type = type;
      this.reset();
    }
    setSampleSize(samples) {
      this.sampleSize = samples;
      return this;
    }
    incrementCount() {
      this.addCount(1);
      return this;
    }
    decrementCount() {
      this.subtractCount(1);
      return this;
    }
    addCount(value13) {
      this._count += value13;
      this._samples++;
      this._checkSampling();
      return this;
    }
    subtractCount(value13) {
      this._count -= value13;
      this._samples++;
      this._checkSampling();
      return this;
    }
    addTime(time) {
      this._time += time;
      this.lastTiming = time;
      this._samples++;
      this._checkSampling();
      return this;
    }
    timeStart() {
      this._startTime = getHiResTimestamp3();
      this._timerPending = true;
      return this;
    }
    timeEnd() {
      if (!this._timerPending) {
        return this;
      }
      this.addTime(getHiResTimestamp3() - this._startTime);
      this._timerPending = false;
      this._checkSampling();
      return this;
    }
    getSampleAverageCount() {
      return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
    getSampleAverageTime() {
      return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
    getSampleHz() {
      return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
    }
    getAverageCount() {
      return this.samples > 0 ? this.count / this.samples : 0;
    }
    getAverageTime() {
      return this.samples > 0 ? this.time / this.samples : 0;
    }
    getHz() {
      return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
    }
    reset() {
      this.time = 0;
      this.count = 0;
      this.samples = 0;
      this.lastTiming = 0;
      this.lastSampleTime = 0;
      this.lastSampleCount = 0;
      this._count = 0;
      this._time = 0;
      this._samples = 0;
      this._startTime = 0;
      this._timerPending = false;
      return this;
    }
    _checkSampling() {
      if (this._samples === this.sampleSize) {
        this.lastSampleTime = this._time;
        this.lastSampleCount = this._count;
        this.count += this._count;
        this.time += this._time;
        this.samples += this._samples;
        this._time = 0;
        this._count = 0;
        this._samples = 0;
      }
    }
  };

  // node_modules/@probe.gl/stats/dist/esm/lib/stats.js
  var Stats = class {
    constructor(options2) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "stats", {});
      this.id = options2.id;
      this.stats = {};
      this._initializeStats(options2.stats);
      Object.seal(this);
    }
    get(name16) {
      let type = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "count";
      return this._getOrCreate({
        name: name16,
        type
      });
    }
    get size() {
      return Object.keys(this.stats).length;
    }
    reset() {
      for (const key in this.stats) {
        this.stats[key].reset();
      }
      return this;
    }
    forEach(fn) {
      for (const key in this.stats) {
        fn(this.stats[key]);
      }
    }
    getTable() {
      const table = {};
      this.forEach((stat) => {
        table[stat.name] = {
          time: stat.time || 0,
          count: stat.count || 0,
          average: stat.getAverageTime() || 0,
          hz: stat.getHz() || 0
        };
      });
      return table;
    }
    _initializeStats() {
      let stats = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      stats.forEach((stat) => this._getOrCreate(stat));
    }
    _getOrCreate(stat) {
      if (!stat || !stat.name) {
        return null;
      }
      const {
        name: name16,
        type
      } = stat;
      if (!this.stats[name16]) {
        if (stat instanceof Stat) {
          this.stats[name16] = stat;
        } else {
          this.stats[name16] = new Stat(name16, type);
        }
      }
      return this.stats[name16];
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/init.js
  var VERSION6 = true ? "8.5.21" : "untranspiled source";
  var STARTUP_MESSAGE = "set luma.log.level=1 (or higher) to trace rendering";
  var StatsManager = class {
    constructor() {
      this.stats = /* @__PURE__ */ new Map();
    }
    get(name16) {
      if (!this.stats.has(name16)) {
        this.stats.set(name16, new Stats({
          id: name16
        }));
      }
      return this.stats.get(name16);
    }
  };
  var lumaStats = new StatsManager();
  if (globalThis.luma && globalThis.luma.VERSION !== VERSION6) {
    throw new Error("luma.gl - multiple VERSIONs detected: ".concat(globalThis.luma.VERSION, " vs ").concat(VERSION6));
  }
  if (!globalThis.luma) {
    if (isBrowser5()) {
      log3.log(1, "luma.gl ".concat(VERSION6, " - ").concat(STARTUP_MESSAGE))();
    }
    globalThis.luma = globalThis.luma || {
      VERSION: VERSION6,
      version: VERSION6,
      log: log3,
      stats: lumaStats,
      globals: {
        modules: {},
        nodeIO: {}
      }
    };
  }
  var init_default = globalThis.luma;

  // node_modules/@luma.gl/webgl/dist/esm/webgl-utils/request-animation-frame.js
  function requestAnimationFrame2(callback) {
    return typeof window !== "undefined" && window.requestAnimationFrame ? window.requestAnimationFrame(callback) : setTimeout(callback, 1e3 / 60);
  }
  function cancelAnimationFrame2(timerId) {
    return typeof window !== "undefined" && window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : clearTimeout(timerId);
  }

  // node_modules/@luma.gl/webgl/dist/esm/utils/assert.js
  function assert6(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "luma.gl: assertion failed.");
    }
  }

  // node_modules/@luma.gl/webgl/dist/esm/webgl-utils/constants-to-keys.js
  function getKeyValue(gl, name16) {
    if (typeof name16 !== "string") {
      return name16;
    }
    const number8 = Number(name16);
    if (!isNaN(number8)) {
      return number8;
    }
    name16 = name16.replace(/^.*\./, "");
    const value13 = gl[name16];
    assert6(value13 !== void 0, "Accessing undefined constant GL.".concat(name16));
    return value13;
  }
  function getKey(gl, value13) {
    value13 = Number(value13);
    for (const key in gl) {
      if (gl[key] === value13) {
        return "GL.".concat(key);
      }
    }
    return String(value13);
  }

  // node_modules/@luma.gl/webgl/dist/esm/utils/utils.js
  var uidCounters = {};
  function uid() {
    let id2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "id";
    uidCounters[id2] = uidCounters[id2] || 1;
    const count2 = uidCounters[id2]++;
    return "".concat(id2, "-").concat(count2);
  }
  function isPowerOfTwo(n) {
    assert6(typeof n === "number", "Input must be a number");
    return n && (n & n - 1) === 0;
  }
  function isObjectEmpty2(obj) {
    let isEmpty2 = true;
    for (const key in obj) {
      isEmpty2 = false;
      break;
    }
    return isEmpty2;
  }

  // node_modules/@luma.gl/webgl/dist/esm/utils/stub-methods.js
  function stubRemovedMethods(instance, className, version, methodNames) {
    const upgradeMessage = "See luma.gl ".concat(version, " Upgrade Guide at https://luma.gl/docs/upgrade-guide");
    const prototype = Object.getPrototypeOf(instance);
    methodNames.forEach((methodName) => {
      if (prototype.methodName) {
        return;
      }
      prototype[methodName] = () => {
        log3.removed("Calling removed method ".concat(className, ".").concat(methodName, ": "), upgradeMessage)();
        throw new Error(methodName);
      };
    });
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/resource.js
  var ERR_RESOURCE_METHOD_UNDEFINED = "Resource subclass must define virtual methods";
  var Resource = class {
    get [Symbol.toStringTag]() {
      return "Resource";
    }
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assertWebGLContext(gl);
      const {
        id: id2,
        userData = {}
      } = opts;
      this.gl = gl;
      this.gl2 = gl;
      this.id = id2 || uid(this[Symbol.toStringTag]);
      this.userData = userData;
      this._bound = false;
      this._handle = opts.handle;
      if (this._handle === void 0) {
        this._handle = this._createHandle();
      }
      this.byteLength = 0;
      this._addStats();
    }
    toString() {
      return "".concat(this[Symbol.toStringTag] || this.constructor.name, "(").concat(this.id, ")");
    }
    get handle() {
      return this._handle;
    }
    delete() {
      let {
        deleteChildren = false
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const children = this._handle && this._deleteHandle(this._handle);
      if (this._handle) {
        this._removeStats();
      }
      this._handle = null;
      if (children && deleteChildren) {
        children.filter(Boolean).forEach((child) => child.delete());
      }
      return this;
    }
    bind() {
      let funcOrHandle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.handle;
      if (typeof funcOrHandle !== "function") {
        this._bindHandle(funcOrHandle);
        return this;
      }
      let value13;
      if (!this._bound) {
        this._bindHandle(this.handle);
        this._bound = true;
        value13 = funcOrHandle();
        this._bound = false;
        this._bindHandle(null);
      } else {
        value13 = funcOrHandle();
      }
      return value13;
    }
    unbind() {
      this.bind(null);
    }
    getParameter(pname) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      pname = getKeyValue(this.gl, pname);
      assert6(pname);
      const parameters = this.constructor.PARAMETERS || {};
      const parameter = parameters[pname];
      if (parameter) {
        const isWebgl2 = isWebGL2(this.gl);
        const parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
        if (!parameterAvailable) {
          const webgl1Default = parameter.webgl1;
          const webgl2Default = "webgl2" in parameter ? parameter.webgl2 : parameter.webgl1;
          const defaultValue4 = isWebgl2 ? webgl2Default : webgl1Default;
          return defaultValue4;
        }
      }
      return this._getParameter(pname, opts);
    }
    getParameters() {
      let options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        parameters,
        keys: keys3
      } = options2;
      const PARAMETERS = this.constructor.PARAMETERS || {};
      const isWebgl2 = isWebGL2(this.gl);
      const values2 = {};
      const parameterKeys = parameters || Object.keys(PARAMETERS);
      for (const pname of parameterKeys) {
        const parameter = PARAMETERS[pname];
        const parameterAvailable = parameter && (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
        if (parameterAvailable) {
          const key = keys3 ? getKey(this.gl, pname) : pname;
          values2[key] = this.getParameter(pname, options2);
          if (keys3 && parameter.type === "GLenum") {
            values2[key] = getKey(this.gl, values2[key]);
          }
        }
      }
      return values2;
    }
    setParameter(pname, value13) {
      pname = getKeyValue(this.gl, pname);
      assert6(pname);
      const parameters = this.constructor.PARAMETERS || {};
      const parameter = parameters[pname];
      if (parameter) {
        const isWebgl2 = isWebGL2(this.gl);
        const parameterAvailable = (!("webgl2" in parameter) || isWebgl2) && (!("extension" in parameter) || this.gl.getExtension(parameter.extension));
        if (!parameterAvailable) {
          throw new Error("Parameter not available on this platform");
        }
        if (parameter.type === "GLenum") {
          value13 = getKeyValue(value13);
        }
      }
      this._setParameter(pname, value13);
      return this;
    }
    setParameters(parameters) {
      for (const pname in parameters) {
        this.setParameter(pname, parameters[pname]);
      }
      return this;
    }
    stubRemovedMethods(className, version, methodNames) {
      return stubRemovedMethods(this, className, version, methodNames);
    }
    initialize(opts) {
    }
    _createHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _deleteHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _bindHandle(handle) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _getOptsFromHandle() {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _getParameter(pname, opts) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _setParameter(pname, value13) {
      throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
    }
    _context() {
      this.gl.luma = this.gl.luma || {};
      return this.gl.luma;
    }
    _addStats() {
      const name16 = this[Symbol.toStringTag];
      const stats = lumaStats.get("Resource Counts");
      stats.get("Resources Created").incrementCount();
      stats.get("".concat(name16, "s Created")).incrementCount();
      stats.get("".concat(name16, "s Active")).incrementCount();
    }
    _removeStats() {
      const name16 = this[Symbol.toStringTag];
      const stats = lumaStats.get("Resource Counts");
      stats.get("".concat(name16, "s Active")).decrementCount();
    }
    _trackAllocatedMemory(bytes) {
      let name16 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this[Symbol.toStringTag];
      this._trackAllocatedMemoryForContext(bytes, name16);
      this._trackAllocatedMemoryForContext(bytes, name16, this.gl.canvas && this.gl.canvas.id);
      this.byteLength = bytes;
    }
    _trackAllocatedMemoryForContext(bytes) {
      let name16 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this[Symbol.toStringTag];
      let id2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
      const stats = lumaStats.get("Memory Usage".concat(id2));
      stats.get("GPU Memory").addCount(bytes);
      stats.get("".concat(name16, " Memory")).addCount(bytes);
    }
    _trackDeallocatedMemory() {
      let name16 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this[Symbol.toStringTag];
      this._trackDeallocatedMemoryForContext(name16);
      this._trackDeallocatedMemoryForContext(name16, this.gl.canvas && this.gl.canvas.id);
      this.byteLength = 0;
    }
    _trackDeallocatedMemoryForContext() {
      let name16 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this[Symbol.toStringTag];
      let id2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      const stats = lumaStats.get("Memory Usage".concat(id2));
      stats.get("GPU Memory").subtractCount(this.byteLength);
      stats.get("".concat(name16, " Memory")).subtractCount(this.byteLength);
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/webgl-utils/typed-array-utils.js
  var ERR_TYPE_DEDUCTION = "Failed to deduce GL constant from typed array";
  function getGLTypeFromTypedArray(arrayOrType) {
    const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
    switch (type) {
      case Float32Array:
        return 5126;
      case Uint16Array:
        return 5123;
      case Uint32Array:
        return 5125;
      case Uint8Array:
        return 5121;
      case Uint8ClampedArray:
        return 5121;
      case Int8Array:
        return 5120;
      case Int16Array:
        return 5122;
      case Int32Array:
        return 5124;
      default:
        throw new Error(ERR_TYPE_DEDUCTION);
    }
  }
  function getTypedArrayFromGLType(glType) {
    let {
      clamped = true
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    switch (glType) {
      case 5126:
        return Float32Array;
      case 5123:
      case 33635:
      case 32819:
      case 32820:
        return Uint16Array;
      case 5125:
        return Uint32Array;
      case 5121:
        return clamped ? Uint8ClampedArray : Uint8Array;
      case 5120:
        return Int8Array;
      case 5122:
        return Int16Array;
      case 5124:
        return Int32Array;
      default:
        throw new Error("Failed to deduce typed array type from GL constant");
    }
  }
  function flipRows(_ref) {
    let {
      data,
      width: width8,
      height: height8,
      bytesPerPixel = 4,
      temp
    } = _ref;
    const bytesPerRow = width8 * bytesPerPixel;
    temp = temp || new Uint8Array(bytesPerRow);
    for (let y = 0; y < height8 / 2; ++y) {
      const topOffset = y * bytesPerRow;
      const bottomOffset = (height8 - y - 1) * bytesPerRow;
      temp.set(data.subarray(topOffset, topOffset + bytesPerRow));
      data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
      data.set(temp, bottomOffset);
    }
  }
  function scalePixels2(_ref2) {
    let {
      data,
      width: width8,
      height: height8
    } = _ref2;
    const newWidth = Math.round(width8 / 2);
    const newHeight = Math.round(height8 / 2);
    const newData = new Uint8Array(newWidth * newHeight * 4);
    for (let y = 0; y < newHeight; y++) {
      for (let x = 0; x < newWidth; x++) {
        for (let c = 0; c < 4; c++) {
          newData[(y * newWidth + x) * 4 + c] = data[(y * 2 * width8 + x * 2) * 4 + c];
        }
      }
    }
    return {
      data: newData,
      width: newWidth,
      height: newHeight
    };
  }

  // node_modules/@luma.gl/webgl/dist/esm/utils/check-props.js
  function checkProps(className, props, propChecks) {
    const {
      removedProps = {},
      deprecatedProps = {},
      replacedProps = {}
    } = propChecks;
    for (const propName in removedProps) {
      if (propName in props) {
        const replacementProp = removedProps[propName];
        const replacement = replacementProp ? "".concat(className, ".").concat(removedProps[propName]) : "N/A";
        log3.removed("".concat(className, ".").concat(propName), replacement)();
      }
    }
    for (const propName in deprecatedProps) {
      if (propName in props) {
        const replacementProp = deprecatedProps[propName];
        log3.deprecated("".concat(className, ".").concat(propName), "".concat(className, ".").concat(replacementProp))();
      }
    }
    let newProps = null;
    for (const propName in replacedProps) {
      if (propName in props) {
        const replacementProp = replacedProps[propName];
        log3.deprecated("".concat(className, ".").concat(propName), "".concat(className, ".").concat(replacementProp))();
        newProps = newProps || Object.assign({}, props);
        newProps[replacementProp] = props[propName];
        delete newProps[propName];
      }
    }
    return newProps || props;
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/accessor.js
  var DEFAULT_ACCESSOR_VALUES = {
    offset: 0,
    stride: 0,
    type: 5126,
    size: 1,
    divisor: 0,
    normalized: false,
    integer: false
  };
  var PROP_CHECKS = {
    deprecatedProps: {
      instanced: "divisor",
      isInstanced: "divisor"
    }
  };
  var Accessor = class {
    static getBytesPerElement(accessor) {
      const ArrayType = getTypedArrayFromGLType(accessor.type || 5126);
      return ArrayType.BYTES_PER_ELEMENT;
    }
    static getBytesPerVertex(accessor) {
      assert6(accessor.size);
      const ArrayType = getTypedArrayFromGLType(accessor.type || 5126);
      return ArrayType.BYTES_PER_ELEMENT * accessor.size;
    }
    static resolve() {
      for (var _len = arguments.length, accessors = new Array(_len), _key = 0; _key < _len; _key++) {
        accessors[_key] = arguments[_key];
      }
      return new Accessor(...[DEFAULT_ACCESSOR_VALUES, ...accessors]);
    }
    constructor() {
      for (var _len2 = arguments.length, accessors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        accessors[_key2] = arguments[_key2];
      }
      accessors.forEach((accessor) => this._assign(accessor));
      Object.freeze(this);
    }
    toString() {
      return JSON.stringify(this);
    }
    get BYTES_PER_ELEMENT() {
      return Accessor.getBytesPerElement(this);
    }
    get BYTES_PER_VERTEX() {
      return Accessor.getBytesPerVertex(this);
    }
    _assign() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      props = checkProps("Accessor", props, PROP_CHECKS);
      if (props.type !== void 0) {
        this.type = props.type;
        if (props.type === 5124 || props.type === 5125) {
          this.integer = true;
        }
      }
      if (props.size !== void 0) {
        this.size = props.size;
      }
      if (props.offset !== void 0) {
        this.offset = props.offset;
      }
      if (props.stride !== void 0) {
        this.stride = props.stride;
      }
      if (props.normalized !== void 0) {
        this.normalized = props.normalized;
      }
      if (props.integer !== void 0) {
        this.integer = props.integer;
      }
      if (props.divisor !== void 0) {
        this.divisor = props.divisor;
      }
      if (props.buffer !== void 0) {
        this.buffer = props.buffer;
      }
      if (props.index !== void 0) {
        if (typeof props.index === "boolean") {
          this.index = props.index ? 1 : 0;
        } else {
          this.index = props.index;
        }
      }
      if (props.instanced !== void 0) {
        this.divisor = props.instanced ? 1 : 0;
      }
      if (props.isInstanced !== void 0) {
        this.divisor = props.isInstanced ? 1 : 0;
      }
      return this;
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/classes/buffer.js
  var DEBUG_DATA_LENGTH = 10;
  var DEPRECATED_PROPS = {
    offset: "accessor.offset",
    stride: "accessor.stride",
    type: "accessor.type",
    size: "accessor.size",
    divisor: "accessor.divisor",
    normalized: "accessor.normalized",
    integer: "accessor.integer",
    instanced: "accessor.divisor",
    isInstanced: "accessor.divisor"
  };
  var PROP_CHECKS_INITIALIZE = {
    removedProps: {},
    replacedProps: {
      bytes: "byteLength"
    },
    deprecatedProps: DEPRECATED_PROPS
  };
  var PROP_CHECKS_SET_PROPS = {
    removedProps: DEPRECATED_PROPS
  };
  var Buffer2 = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Buffer";
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(gl, props);
      this.stubRemovedMethods("Buffer", "v6.0", ["layout", "setLayout", "getIndexedParameter"]);
      this.target = props.target || (this.gl.webgl2 ? 36662 : 34962);
      this.initialize(props);
      Object.seal(this);
    }
    getElementCount() {
      let accessor = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.accessor;
      return Math.round(this.byteLength / Accessor.getBytesPerElement(accessor));
    }
    getVertexCount() {
      let accessor = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.accessor;
      return Math.round(this.byteLength / Accessor.getBytesPerVertex(accessor));
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (ArrayBuffer.isView(props)) {
        props = {
          data: props
        };
      }
      if (Number.isFinite(props)) {
        props = {
          byteLength: props
        };
      }
      props = checkProps("Buffer", props, PROP_CHECKS_INITIALIZE);
      this.usage = props.usage || 35044;
      this.debugData = null;
      this.setAccessor(Object.assign({}, props, props.accessor));
      if (props.data) {
        this._setData(props.data, props.offset, props.byteLength);
      } else {
        this._setByteLength(props.byteLength || 0);
      }
      return this;
    }
    setProps(props) {
      props = checkProps("Buffer", props, PROP_CHECKS_SET_PROPS);
      if ("accessor" in props) {
        this.setAccessor(props.accessor);
      }
      return this;
    }
    setAccessor(accessor) {
      accessor = Object.assign({}, accessor);
      delete accessor.buffer;
      this.accessor = new Accessor(accessor);
      return this;
    }
    reallocate(byteLength) {
      if (byteLength > this.byteLength) {
        this._setByteLength(byteLength);
        return true;
      }
      this.bytesUsed = byteLength;
      return false;
    }
    setData(props) {
      return this.initialize(props);
    }
    subData(props) {
      if (ArrayBuffer.isView(props)) {
        props = {
          data: props
        };
      }
      const {
        data,
        offset = 0,
        srcOffset = 0
      } = props;
      const byteLength = props.byteLength || props.length;
      assert6(data);
      const target5 = this.gl.webgl2 ? 36663 : this.target;
      this.gl.bindBuffer(target5, this.handle);
      if (srcOffset !== 0 || byteLength !== void 0) {
        assertWebGL2Context(this.gl);
        this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);
      } else {
        this.gl.bufferSubData(target5, offset, data);
      }
      this.gl.bindBuffer(target5, null);
      this.debugData = null;
      this._inferType(data);
      return this;
    }
    copyData(_ref) {
      let {
        sourceBuffer,
        readOffset = 0,
        writeOffset = 0,
        size: size5
      } = _ref;
      const {
        gl
      } = this;
      assertWebGL2Context(gl);
      gl.bindBuffer(36662, sourceBuffer.handle);
      gl.bindBuffer(36663, this.handle);
      gl.copyBufferSubData(36662, 36663, readOffset, writeOffset, size5);
      gl.bindBuffer(36662, null);
      gl.bindBuffer(36663, null);
      this.debugData = null;
      return this;
    }
    getData() {
      let {
        dstData = null,
        srcByteOffset = 0,
        dstOffset = 0,
        length: length7 = 0
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      assertWebGL2Context(this.gl);
      const ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {
        clamped: false
      });
      const sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);
      const dstElementOffset = dstOffset;
      let dstAvailableElementCount;
      let dstElementCount;
      if (dstData) {
        dstElementCount = dstData.length;
        dstAvailableElementCount = dstElementCount - dstElementOffset;
      } else {
        dstAvailableElementCount = Math.min(sourceAvailableElementCount, length7 || sourceAvailableElementCount);
        dstElementCount = dstElementOffset + dstAvailableElementCount;
      }
      const copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);
      length7 = length7 || copyElementCount;
      assert6(length7 <= copyElementCount);
      dstData = dstData || new ArrayType(dstElementCount);
      this.gl.bindBuffer(36662, this.handle);
      this.gl.getBufferSubData(36662, srcByteOffset, dstData, dstOffset, length7);
      this.gl.bindBuffer(36662, null);
      return dstData;
    }
    bind() {
      let {
        target: target5 = this.target,
        index: index5 = this.accessor && this.accessor.index,
        offset = 0,
        size: size5
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (target5 === 35345 || target5 === 35982) {
        if (size5 !== void 0) {
          this.gl.bindBufferRange(target5, index5, this.handle, offset, size5);
        } else {
          assert6(offset === 0);
          this.gl.bindBufferBase(target5, index5, this.handle);
        }
      } else {
        this.gl.bindBuffer(target5, this.handle);
      }
      return this;
    }
    unbind() {
      let {
        target: target5 = this.target,
        index: index5 = this.accessor && this.accessor.index
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const isIndexedBuffer = target5 === 35345 || target5 === 35982;
      if (isIndexedBuffer) {
        this.gl.bindBufferBase(target5, index5, null);
      } else {
        this.gl.bindBuffer(target5, null);
      }
      return this;
    }
    getDebugData() {
      if (!this.debugData) {
        this.debugData = this.getData({
          length: Math.min(DEBUG_DATA_LENGTH, this.byteLength)
        });
        return {
          data: this.debugData,
          changed: true
        };
      }
      return {
        data: this.debugData,
        changed: false
      };
    }
    invalidateDebugData() {
      this.debugData = null;
    }
    _setData(data) {
      let offset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      let byteLength = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : data.byteLength + offset;
      assert6(ArrayBuffer.isView(data));
      this._trackDeallocatedMemory();
      const target5 = this._getTarget();
      this.gl.bindBuffer(target5, this.handle);
      this.gl.bufferData(target5, byteLength, this.usage);
      this.gl.bufferSubData(target5, offset, data);
      this.gl.bindBuffer(target5, null);
      this.debugData = data.slice(0, DEBUG_DATA_LENGTH);
      this.bytesUsed = byteLength;
      this._trackAllocatedMemory(byteLength);
      const type = getGLTypeFromTypedArray(data);
      assert6(type);
      this.setAccessor(new Accessor(this.accessor, {
        type
      }));
      return this;
    }
    _setByteLength(byteLength) {
      let usage = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.usage;
      assert6(byteLength >= 0);
      this._trackDeallocatedMemory();
      let data = byteLength;
      if (byteLength === 0) {
        data = new Float32Array(0);
      }
      const target5 = this._getTarget();
      this.gl.bindBuffer(target5, this.handle);
      this.gl.bufferData(target5, data, usage);
      this.gl.bindBuffer(target5, null);
      this.usage = usage;
      this.debugData = null;
      this.bytesUsed = byteLength;
      this._trackAllocatedMemory(byteLength);
      return this;
    }
    _getTarget() {
      return this.gl.webgl2 ? 36663 : this.target;
    }
    _getAvailableElementCount(srcByteOffset) {
      const ArrayType = getTypedArrayFromGLType(this.accessor.type || 5126, {
        clamped: false
      });
      const sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;
      return this.getElementCount() - sourceElementOffset;
    }
    _inferType(data) {
      if (!this.accessor.type) {
        this.setAccessor(new Accessor(this.accessor, {
          type: getGLTypeFromTypedArray(data)
        }));
      }
    }
    _createHandle() {
      return this.gl.createBuffer();
    }
    _deleteHandle() {
      this.gl.deleteBuffer(this.handle);
      this._trackDeallocatedMemory();
    }
    _getParameter(pname) {
      this.gl.bindBuffer(this.target, this.handle);
      const value13 = this.gl.getBufferParameter(this.target, pname);
      this.gl.bindBuffer(this.target, null);
      return value13;
    }
    get type() {
      log3.deprecated("Buffer.type", "Buffer.accessor.type")();
      return this.accessor.type;
    }
    get bytes() {
      log3.deprecated("Buffer.bytes", "Buffer.byteLength")();
      return this.byteLength;
    }
    setByteLength(byteLength) {
      log3.deprecated("setByteLength", "reallocate")();
      return this.reallocate(byteLength);
    }
    updateAccessor(opts) {
      log3.deprecated("updateAccessor(...)", "setAccessor(new Accessor(buffer.accessor, ...)")();
      this.accessor = new Accessor(this.accessor, opts);
      return this;
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/classes/texture-formats.js
  var TEXTURE_FORMATS = {
    [6407]: {
      dataFormat: 6407,
      types: [5121, 33635]
    },
    [6408]: {
      dataFormat: 6408,
      types: [5121, 32819, 32820]
    },
    [6406]: {
      dataFormat: 6406,
      types: [5121]
    },
    [6409]: {
      dataFormat: 6409,
      types: [5121]
    },
    [6410]: {
      dataFormat: 6410,
      types: [5121]
    },
    [33326]: {
      dataFormat: 6403,
      types: [5126],
      gl2: true
    },
    [33328]: {
      dataFormat: 33319,
      types: [5126],
      gl2: true
    },
    [34837]: {
      dataFormat: 6407,
      types: [5126],
      gl2: true
    },
    [34836]: {
      dataFormat: 6408,
      types: [5126],
      gl2: true
    }
  };
  var DATA_FORMAT_CHANNELS = {
    [6403]: 1,
    [36244]: 1,
    [33319]: 2,
    [33320]: 2,
    [6407]: 3,
    [36248]: 3,
    [6408]: 4,
    [36249]: 4,
    [6402]: 1,
    [34041]: 1,
    [6406]: 1,
    [6409]: 1,
    [6410]: 2
  };
  var TYPE_SIZES = {
    [5126]: 4,
    [5125]: 4,
    [5124]: 4,
    [5123]: 2,
    [5122]: 2,
    [5131]: 2,
    [5120]: 1,
    [5121]: 1
  };
  function isFormatSupported(gl, format) {
    const info = TEXTURE_FORMATS[format];
    if (!info) {
      return false;
    }
    if (info.gl1 === void 0 && info.gl2 === void 0) {
      return true;
    }
    const value13 = isWebGL2(gl) ? info.gl2 || info.gl1 : info.gl1;
    return typeof value13 === "string" ? gl.getExtension(value13) : value13;
  }
  function isLinearFilteringSupported(gl, format) {
    const info = TEXTURE_FORMATS[format];
    switch (info && info.types[0]) {
      case 5126:
        return gl.getExtension("OES_texture_float_linear");
      case 5131:
        return gl.getExtension("OES_texture_half_float_linear");
      default:
        return true;
    }
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/texture.js
  var NPOT_MIN_FILTERS = [9729, 9728];
  var WebGLBuffer = globalThis.WebGLBuffer || function WebGLBuffer2() {
  };
  var Texture = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Texture";
    }
    static isSupported(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const {
        format,
        linearFiltering
      } = opts;
      let supported2 = true;
      if (format) {
        supported2 = supported2 && isFormatSupported(gl, format);
        supported2 = supported2 && (!linearFiltering || isLinearFilteringSupported(gl, format));
      }
      return supported2;
    }
    constructor(gl, props) {
      const {
        id: id2 = uid("texture"),
        handle,
        target: target5
      } = props;
      super(gl, {
        id: id2,
        handle
      });
      this.target = target5;
      this.textureUnit = void 0;
      this.loaded = false;
      this.width = void 0;
      this.height = void 0;
      this.depth = void 0;
      this.format = void 0;
      this.type = void 0;
      this.dataFormat = void 0;
      this.border = void 0;
      this.textureUnit = void 0;
      this.mipmaps = void 0;
    }
    toString() {
      return "Texture(".concat(this.id, ",").concat(this.width, "x").concat(this.height, ")");
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let data = props.data;
      if (data instanceof Promise) {
        data.then((resolvedImageData) => this.initialize(Object.assign({}, props, {
          pixels: resolvedImageData,
          data: resolvedImageData
        })));
        return this;
      }
      const isVideo = typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement;
      if (isVideo && data.readyState < HTMLVideoElement.HAVE_METADATA) {
        this._video = null;
        data.addEventListener("loadeddata", () => this.initialize(props));
        return this;
      }
      const {
        pixels = null,
        format = 6408,
        border: border2 = 0,
        recreate = false,
        parameters = {},
        pixelStore = {},
        textureUnit = void 0
      } = props;
      if (!data) {
        data = pixels;
      }
      let {
        width: width8,
        height: height8,
        dataFormat,
        type,
        compressed = false,
        mipmaps = true
      } = props;
      const {
        depth = 0
      } = props;
      ({
        width: width8,
        height: height8,
        compressed,
        dataFormat,
        type
      } = this._deduceParameters({
        format,
        type,
        dataFormat,
        compressed,
        data,
        width: width8,
        height: height8
      }));
      this.width = width8;
      this.height = height8;
      this.depth = depth;
      this.format = format;
      this.type = type;
      this.dataFormat = dataFormat;
      this.border = border2;
      this.textureUnit = textureUnit;
      if (Number.isFinite(this.textureUnit)) {
        this.gl.activeTexture(33984 + this.textureUnit);
        this.gl.bindTexture(this.target, this.handle);
      }
      if (mipmaps && this._isNPOT()) {
        log3.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
        mipmaps = false;
        this._updateForNPOT(parameters);
      }
      this.mipmaps = mipmaps;
      this.setImageData({
        data,
        width: width8,
        height: height8,
        depth,
        format,
        type,
        dataFormat,
        border: border2,
        mipmaps,
        parameters: pixelStore,
        compressed
      });
      if (mipmaps) {
        this.generateMipmap();
      }
      this.setParameters(parameters);
      if (recreate) {
        this.data = data;
      }
      if (isVideo) {
        this._video = {
          video: data,
          parameters,
          lastTime: data.readyState >= HTMLVideoElement.HAVE_CURRENT_DATA ? data.currentTime : -1
        };
      }
      return this;
    }
    update() {
      if (this._video) {
        const {
          video,
          parameters,
          lastTime
        } = this._video;
        if (lastTime === video.currentTime || video.readyState < HTMLVideoElement.HAVE_CURRENT_DATA) {
          return;
        }
        this.setSubImageData({
          data: video,
          parameters
        });
        if (this.mipmaps) {
          this.generateMipmap();
        }
        this._video.lastTime = video.currentTime;
      }
    }
    resize(_ref) {
      let {
        height: height8,
        width: width8,
        mipmaps = false
      } = _ref;
      if (width8 !== this.width || height8 !== this.height) {
        return this.initialize({
          width: width8,
          height: height8,
          format: this.format,
          type: this.type,
          dataFormat: this.dataFormat,
          border: this.border,
          mipmaps
        });
      }
      return this;
    }
    generateMipmap() {
      let params = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (this._isNPOT()) {
        log3.warn("texture: ".concat(this, " is Non-Power-Of-Two, disabling mipmaping"))();
        return this;
      }
      this.mipmaps = true;
      this.gl.bindTexture(this.target, this.handle);
      withParameters(this.gl, params, () => {
        this.gl.generateMipmap(this.target);
      });
      this.gl.bindTexture(this.target, null);
      return this;
    }
    setImageData(options2) {
      this._trackDeallocatedMemory("Texture");
      const {
        target: target5 = this.target,
        pixels = null,
        level = 0,
        format = this.format,
        border: border2 = this.border,
        offset = 0,
        parameters = {}
      } = options2;
      let {
        data = null,
        type = this.type,
        width: width8 = this.width,
        height: height8 = this.height,
        dataFormat = this.dataFormat,
        compressed = false
      } = options2;
      if (!data) {
        data = pixels;
      }
      ({
        type,
        dataFormat,
        compressed,
        width: width8,
        height: height8
      } = this._deduceParameters({
        format,
        type,
        dataFormat,
        compressed,
        data,
        width: width8,
        height: height8
      }));
      const {
        gl
      } = this;
      gl.bindTexture(this.target, this.handle);
      let dataType = null;
      ({
        data,
        dataType
      } = this._getDataType({
        data,
        compressed
      }));
      let gl2;
      let compressedTextureSize = 0;
      withParameters(this.gl, parameters, () => {
        switch (dataType) {
          case "null":
            gl.texImage2D(target5, level, format, width8, height8, border2, dataFormat, type, data);
            break;
          case "typed-array":
            gl.texImage2D(target5, level, format, width8, height8, border2, dataFormat, type, data, offset);
            break;
          case "buffer":
            gl2 = assertWebGL2Context(gl);
            gl2.bindBuffer(35052, data.handle || data);
            gl2.texImage2D(target5, level, format, width8, height8, border2, dataFormat, type, offset);
            gl2.bindBuffer(35052, null);
            break;
          case "browser-object":
            if (isWebGL2(gl)) {
              gl.texImage2D(target5, level, format, width8, height8, border2, dataFormat, type, data);
            } else {
              gl.texImage2D(target5, level, format, dataFormat, type, data);
            }
            break;
          case "compressed":
            for (const [levelIndex, levelData] of data.entries()) {
              gl.compressedTexImage2D(target5, levelIndex, levelData.format, levelData.width, levelData.height, border2, levelData.data);
              compressedTextureSize += levelData.levelSize;
            }
            break;
          default:
            assert6(false, "Unknown image data type");
        }
      });
      if (dataType === "compressed") {
        this._trackAllocatedMemory(compressedTextureSize, "Texture");
      } else if (data && data.byteLength) {
        this._trackAllocatedMemory(data.byteLength, "Texture");
      } else {
        const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
        const channelSize = TYPE_SIZES[this.type] || 1;
        this._trackAllocatedMemory(this.width * this.height * channels * channelSize, "Texture");
      }
      this.loaded = true;
      return this;
    }
    setSubImageData(_ref2) {
      let {
        target: target5 = this.target,
        pixels = null,
        data = null,
        x = 0,
        y = 0,
        width: width8 = this.width,
        height: height8 = this.height,
        level = 0,
        format = this.format,
        type = this.type,
        dataFormat = this.dataFormat,
        compressed = false,
        offset = 0,
        border: border2 = this.border,
        parameters = {}
      } = _ref2;
      ({
        type,
        dataFormat,
        compressed,
        width: width8,
        height: height8
      } = this._deduceParameters({
        format,
        type,
        dataFormat,
        compressed,
        data,
        width: width8,
        height: height8
      }));
      assert6(this.depth === 0, "texSubImage not supported for 3D textures");
      if (!data) {
        data = pixels;
      }
      if (data && data.data) {
        const ndarray = data;
        data = ndarray.data;
        width8 = ndarray.shape[0];
        height8 = ndarray.shape[1];
      }
      if (data instanceof Buffer2) {
        data = data.handle;
      }
      this.gl.bindTexture(this.target, this.handle);
      withParameters(this.gl, parameters, () => {
        if (compressed) {
          this.gl.compressedTexSubImage2D(target5, level, x, y, width8, height8, format, data);
        } else if (data === null) {
          this.gl.texSubImage2D(target5, level, x, y, width8, height8, dataFormat, type, null);
        } else if (ArrayBuffer.isView(data)) {
          this.gl.texSubImage2D(target5, level, x, y, width8, height8, dataFormat, type, data, offset);
        } else if (data instanceof WebGLBuffer) {
          const gl2 = assertWebGL2Context(this.gl);
          gl2.bindBuffer(35052, data);
          gl2.texSubImage2D(target5, level, x, y, width8, height8, dataFormat, type, offset);
          gl2.bindBuffer(35052, null);
        } else if (isWebGL2(this.gl)) {
          const gl2 = assertWebGL2Context(this.gl);
          gl2.texSubImage2D(target5, level, x, y, width8, height8, dataFormat, type, data);
        } else {
          this.gl.texSubImage2D(target5, level, x, y, dataFormat, type, data);
        }
      });
      this.gl.bindTexture(this.target, null);
    }
    copyFramebuffer() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log3.error("Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})")();
      return null;
    }
    getActiveUnit() {
      return this.gl.getParameter(34016) - 33984;
    }
    bind() {
      let textureUnit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.textureUnit;
      const {
        gl
      } = this;
      if (textureUnit !== void 0) {
        this.textureUnit = textureUnit;
        gl.activeTexture(33984 + textureUnit);
      }
      gl.bindTexture(this.target, this.handle);
      return textureUnit;
    }
    unbind() {
      let textureUnit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.textureUnit;
      const {
        gl
      } = this;
      if (textureUnit !== void 0) {
        this.textureUnit = textureUnit;
        gl.activeTexture(33984 + textureUnit);
      }
      gl.bindTexture(this.target, null);
      return textureUnit;
    }
    _getDataType(_ref3) {
      let {
        data,
        compressed = false
      } = _ref3;
      if (compressed) {
        return {
          data,
          dataType: "compressed"
        };
      }
      if (data === null) {
        return {
          data,
          dataType: "null"
        };
      }
      if (ArrayBuffer.isView(data)) {
        return {
          data,
          dataType: "typed-array"
        };
      }
      if (data instanceof Buffer2) {
        return {
          data: data.handle,
          dataType: "buffer"
        };
      }
      if (data instanceof WebGLBuffer) {
        return {
          data,
          dataType: "buffer"
        };
      }
      return {
        data,
        dataType: "browser-object"
      };
    }
    _deduceParameters(opts) {
      const {
        format,
        data
      } = opts;
      let {
        width: width8,
        height: height8,
        dataFormat,
        type,
        compressed
      } = opts;
      const textureFormat = TEXTURE_FORMATS[format];
      dataFormat = dataFormat || textureFormat && textureFormat.dataFormat;
      type = type || textureFormat && textureFormat.types[0];
      compressed = compressed || textureFormat && textureFormat.compressed;
      ({
        width: width8,
        height: height8
      } = this._deduceImageSize(data, width8, height8));
      return {
        dataFormat,
        type,
        compressed,
        width: width8,
        height: height8,
        format,
        data
      };
    }
    _deduceImageSize(data, width8, height8) {
      let size5;
      if (typeof ImageData !== "undefined" && data instanceof ImageData) {
        size5 = {
          width: data.width,
          height: data.height
        };
      } else if (typeof HTMLImageElement !== "undefined" && data instanceof HTMLImageElement) {
        size5 = {
          width: data.naturalWidth,
          height: data.naturalHeight
        };
      } else if (typeof HTMLCanvasElement !== "undefined" && data instanceof HTMLCanvasElement) {
        size5 = {
          width: data.width,
          height: data.height
        };
      } else if (typeof ImageBitmap !== "undefined" && data instanceof ImageBitmap) {
        size5 = {
          width: data.width,
          height: data.height
        };
      } else if (typeof HTMLVideoElement !== "undefined" && data instanceof HTMLVideoElement) {
        size5 = {
          width: data.videoWidth,
          height: data.videoHeight
        };
      } else if (!data) {
        size5 = {
          width: width8 >= 0 ? width8 : 1,
          height: height8 >= 0 ? height8 : 1
        };
      } else {
        size5 = {
          width: width8,
          height: height8
        };
      }
      assert6(size5, "Could not deduced texture size");
      assert6(width8 === void 0 || size5.width === width8, "Deduced texture width does not match supplied width");
      assert6(height8 === void 0 || size5.height === height8, "Deduced texture height does not match supplied height");
      return size5;
    }
    _createHandle() {
      return this.gl.createTexture();
    }
    _deleteHandle() {
      this.gl.deleteTexture(this.handle);
      this._trackDeallocatedMemory("Texture");
    }
    _getParameter(pname) {
      switch (pname) {
        case 4096:
          return this.width;
        case 4097:
          return this.height;
        default:
          this.gl.bindTexture(this.target, this.handle);
          const value13 = this.gl.getTexParameter(this.target, pname);
          this.gl.bindTexture(this.target, null);
          return value13;
      }
    }
    _setParameter(pname, param) {
      this.gl.bindTexture(this.target, this.handle);
      param = this._getNPOTParam(pname, param);
      switch (pname) {
        case 33082:
        case 33083:
          this.gl.texParameterf(this.handle, pname, param);
          break;
        case 4096:
        case 4097:
          assert6(false);
          break;
        default:
          this.gl.texParameteri(this.target, pname, param);
          break;
      }
      this.gl.bindTexture(this.target, null);
      return this;
    }
    _isNPOT() {
      if (isWebGL2(this.gl)) {
        return false;
      }
      if (!this.width || !this.height) {
        return false;
      }
      return !isPowerOfTwo(this.width) || !isPowerOfTwo(this.height);
    }
    _updateForNPOT(parameters) {
      if (parameters[this.gl.TEXTURE_MIN_FILTER] === void 0) {
        parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;
      }
      if (parameters[this.gl.TEXTURE_WRAP_S] === void 0) {
        parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;
      }
      if (parameters[this.gl.TEXTURE_WRAP_T] === void 0) {
        parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;
      }
    }
    _getNPOTParam(pname, param) {
      if (this._isNPOT()) {
        switch (pname) {
          case 10241:
            if (NPOT_MIN_FILTERS.indexOf(param) === -1) {
              param = 9729;
            }
            break;
          case 10242:
          case 10243:
            if (param !== 33071) {
              param = 33071;
            }
            break;
          default:
            break;
        }
      }
      return param;
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/utils/load-file.js
  var pathPrefix2 = "";
  function loadImage(url, opts) {
    assert6(typeof url === "string");
    url = pathPrefix2 + url;
    return new Promise((resolve2, reject) => {
      try {
        const image = new Image();
        image.onload = () => resolve2(image);
        image.onerror = () => reject(new Error("Could not load image ".concat(url, ".")));
        image.crossOrigin = opts && opts.crossOrigin || "anonymous";
        image.src = url;
      } catch (error3) {
        reject(error3);
      }
    });
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/texture-2d.js
  var Texture2D = class extends Texture {
    get [Symbol.toStringTag]() {
      return "Texture2D";
    }
    static isSupported(gl, opts) {
      return Texture.isSupported(gl, opts);
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assertWebGLContext(gl);
      if (props instanceof Promise || typeof props === "string") {
        props = {
          data: props
        };
      }
      if (typeof props.data === "string") {
        props = Object.assign({}, props, {
          data: loadImage(props.data)
        });
      }
      super(gl, Object.assign({}, props, {
        target: 3553
      }));
      this.initialize(props);
      Object.seal(this);
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/classes/texture-cube.js
  var FACES = [34069, 34070, 34071, 34072, 34073, 34074];
  var TextureCube = class extends Texture {
    get [Symbol.toStringTag]() {
      return "TextureCube";
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assertWebGLContext(gl);
      super(gl, Object.assign({}, props, {
        target: 34067
      }));
      this.initialize(props);
      Object.seal(this);
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        mipmaps = true,
        parameters = {}
      } = props;
      this.opts = props;
      this.setCubeMapImageData(props).then(() => {
        this.loaded = true;
        if (mipmaps) {
          this.generateMipmap(props);
        }
        this.setParameters(parameters);
      });
      return this;
    }
    subImage(_ref) {
      let {
        face,
        data,
        x = 0,
        y = 0,
        mipmapLevel = 0
      } = _ref;
      return this._subImage({
        target: face,
        data,
        x,
        y,
        mipmapLevel
      });
    }
    async setCubeMapImageData(_ref2) {
      let {
        width: width8,
        height: height8,
        pixels,
        data,
        border: border2 = 0,
        format = 6408,
        type = 5121
      } = _ref2;
      const {
        gl
      } = this;
      const imageDataMap = pixels || data;
      const resolvedFaces = await Promise.all(FACES.map((face) => {
        const facePixels = imageDataMap[face];
        return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);
      }));
      this.bind();
      FACES.forEach((face, index5) => {
        if (resolvedFaces[index5].length > 1 && this.opts.mipmaps !== false) {
          log3.warn("".concat(this.id, " has mipmap and multiple LODs."))();
        }
        resolvedFaces[index5].forEach((image, lodLevel) => {
          if (width8 && height8) {
            gl.texImage2D(face, lodLevel, format, width8, height8, border2, format, type, image);
          } else {
            gl.texImage2D(face, lodLevel, format, format, type, image);
          }
        });
      });
      this.unbind();
    }
    setImageDataForFace(options2) {
      const {
        face,
        width: width8,
        height: height8,
        pixels,
        data,
        border: border2 = 0,
        format = 6408,
        type = 5121
      } = options2;
      const {
        gl
      } = this;
      const imageData = pixels || data;
      this.bind();
      if (imageData instanceof Promise) {
        imageData.then((resolvedImageData) => this.setImageDataForFace(Object.assign({}, options2, {
          face,
          data: resolvedImageData,
          pixels: resolvedImageData
        })));
      } else if (this.width || this.height) {
        gl.texImage2D(face, 0, format, width8, height8, border2, format, type, imageData);
      } else {
        gl.texImage2D(face, 0, format, format, type, imageData);
      }
      return this;
    }
  };
  TextureCube.FACES = FACES;

  // node_modules/@luma.gl/webgl/dist/esm/classes/texture-3d.js
  var Texture3D = class extends Texture {
    get [Symbol.toStringTag]() {
      return "Texture3D";
    }
    static isSupported(gl) {
      return isWebGL2(gl);
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assertWebGL2Context(gl);
      props = Object.assign({
        depth: 1
      }, props, {
        target: 32879,
        unpackFlipY: false
      });
      super(gl, props);
      this.initialize(props);
      Object.seal(this);
    }
    setImageData(_ref) {
      let {
        level = 0,
        dataFormat = 6408,
        width: width8,
        height: height8,
        depth = 1,
        border: border2 = 0,
        format,
        type = 5121,
        offset = 0,
        data,
        parameters = {}
      } = _ref;
      this._trackDeallocatedMemory("Texture");
      this.gl.bindTexture(this.target, this.handle);
      withParameters(this.gl, parameters, () => {
        if (ArrayBuffer.isView(data)) {
          this.gl.texImage3D(this.target, level, dataFormat, width8, height8, depth, border2, format, type, data);
        }
        if (data instanceof Buffer2) {
          this.gl.bindBuffer(35052, data.handle);
          this.gl.texImage3D(this.target, level, dataFormat, width8, height8, depth, border2, format, type, offset);
        }
      });
      if (data && data.byteLength) {
        this._trackAllocatedMemory(data.byteLength, "Texture");
      } else {
        const channels = DATA_FORMAT_CHANNELS[this.dataFormat] || 4;
        const channelSize = TYPE_SIZES[this.type] || 1;
        this._trackAllocatedMemory(this.width * this.height * this.depth * channels * channelSize, "Texture");
      }
      this.loaded = true;
      return this;
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer-formats.js
  var EXT_FLOAT_WEBGL2 = "EXT_color_buffer_float";
  var renderbuffer_formats_default = {
    [33189]: {
      bpp: 2
    },
    [33190]: {
      gl2: true,
      bpp: 3
    },
    [36012]: {
      gl2: true,
      bpp: 4
    },
    [36168]: {
      bpp: 1
    },
    [34041]: {
      bpp: 4
    },
    [35056]: {
      gl2: true,
      bpp: 4
    },
    [36013]: {
      gl2: true,
      bpp: 5
    },
    [32854]: {
      bpp: 2
    },
    [36194]: {
      bpp: 2
    },
    [32855]: {
      bpp: 2
    },
    [33321]: {
      gl2: true,
      bpp: 1
    },
    [33330]: {
      gl2: true,
      bpp: 1
    },
    [33329]: {
      gl2: true,
      bpp: 1
    },
    [33332]: {
      gl2: true,
      bpp: 2
    },
    [33331]: {
      gl2: true,
      bpp: 2
    },
    [33334]: {
      gl2: true,
      bpp: 4
    },
    [33333]: {
      gl2: true,
      bpp: 4
    },
    [33323]: {
      gl2: true,
      bpp: 2
    },
    [33336]: {
      gl2: true,
      bpp: 2
    },
    [33335]: {
      gl2: true,
      bpp: 2
    },
    [33338]: {
      gl2: true,
      bpp: 4
    },
    [33337]: {
      gl2: true,
      bpp: 4
    },
    [33340]: {
      gl2: true,
      bpp: 8
    },
    [33339]: {
      gl2: true,
      bpp: 8
    },
    [32849]: {
      gl2: true,
      bpp: 3
    },
    [32856]: {
      gl2: true,
      bpp: 4
    },
    [32857]: {
      gl2: true,
      bpp: 4
    },
    [36220]: {
      gl2: true,
      bpp: 4
    },
    [36238]: {
      gl2: true,
      bpp: 4
    },
    [36975]: {
      gl2: true,
      bpp: 4
    },
    [36214]: {
      gl2: true,
      bpp: 8
    },
    [36232]: {
      gl2: true,
      bpp: 8
    },
    [36226]: {
      gl2: true,
      bpp: 16
    },
    [36208]: {
      gl2: true,
      bpp: 16
    },
    [33325]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 2
    },
    [33327]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 4
    },
    [34842]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 8
    },
    [33326]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 4
    },
    [33328]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 8
    },
    [34836]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 16
    },
    [35898]: {
      gl2: EXT_FLOAT_WEBGL2,
      bpp: 4
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/classes/renderbuffer.js
  function isFormatSupported2(gl, format, formats) {
    const info = formats[format];
    if (!info) {
      return false;
    }
    const value13 = isWebGL2(gl) ? info.gl2 || info.gl1 : info.gl1;
    if (typeof value13 === "string") {
      return gl.getExtension(value13);
    }
    return value13;
  }
  var Renderbuffer = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Renderbuffer";
    }
    static isSupported(gl) {
      let {
        format
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        format: null
      };
      return !format || isFormatSupported2(gl, format, renderbuffer_formats_default);
    }
    static getSamplesForFormat(gl, _ref) {
      let {
        format
      } = _ref;
      return gl.getInternalformatParameter(36161, format, 32937);
    }
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(gl, opts);
      this.initialize(opts);
      Object.seal(this);
    }
    initialize(_ref2) {
      let {
        format,
        width: width8 = 1,
        height: height8 = 1,
        samples = 0
      } = _ref2;
      assert6(format, "Needs format");
      this._trackDeallocatedMemory();
      this.gl.bindRenderbuffer(36161, this.handle);
      if (samples !== 0 && isWebGL2(this.gl)) {
        this.gl.renderbufferStorageMultisample(36161, samples, format, width8, height8);
      } else {
        this.gl.renderbufferStorage(36161, format, width8, height8);
      }
      this.format = format;
      this.width = width8;
      this.height = height8;
      this.samples = samples;
      this._trackAllocatedMemory(this.width * this.height * (this.samples || 1) * renderbuffer_formats_default[this.format].bpp);
      return this;
    }
    resize(_ref3) {
      let {
        width: width8,
        height: height8
      } = _ref3;
      if (width8 !== this.width || height8 !== this.height) {
        return this.initialize({
          width: width8,
          height: height8,
          format: this.format,
          samples: this.samples
        });
      }
      return this;
    }
    _createHandle() {
      return this.gl.createRenderbuffer();
    }
    _deleteHandle() {
      this.gl.deleteRenderbuffer(this.handle);
      this._trackDeallocatedMemory();
    }
    _bindHandle(handle) {
      this.gl.bindRenderbuffer(36161, handle);
    }
    _syncHandle(handle) {
      this.format = this.getParameter(36164);
      this.width = this.getParameter(36162);
      this.height = this.getParameter(36163);
      this.samples = this.getParameter(36011);
    }
    _getParameter(pname) {
      this.gl.bindRenderbuffer(36161, this.handle);
      const value13 = this.gl.getRenderbufferParameter(36161, pname);
      return value13;
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/classes/clear.js
  var GL_DEPTH_BUFFER_BIT = 256;
  var GL_STENCIL_BUFFER_BIT = 1024;
  var GL_COLOR_BUFFER_BIT = 16384;
  var GL_COLOR = 6144;
  var GL_DEPTH = 6145;
  var GL_STENCIL = 6146;
  var GL_DEPTH_STENCIL = 34041;
  var ERR_ARGUMENTS = "clear: bad arguments";
  function clear(gl) {
    let {
      framebuffer = null,
      color = null,
      depth = null,
      stencil = null
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const parameters = {};
    if (framebuffer) {
      parameters.framebuffer = framebuffer;
    }
    let clearFlags = 0;
    if (color) {
      clearFlags |= GL_COLOR_BUFFER_BIT;
      if (color !== true) {
        parameters.clearColor = color;
      }
    }
    if (depth) {
      clearFlags |= GL_DEPTH_BUFFER_BIT;
      if (depth !== true) {
        parameters.clearDepth = depth;
      }
    }
    if (stencil) {
      clearFlags |= GL_STENCIL_BUFFER_BIT;
      if (depth !== true) {
        parameters.clearStencil = depth;
      }
    }
    assert6(clearFlags !== 0, ERR_ARGUMENTS);
    withParameters(gl, parameters, () => {
      gl.clear(clearFlags);
    });
  }
  function clearBuffer(gl) {
    let {
      framebuffer = null,
      buffer = GL_COLOR,
      drawBuffer = 0,
      value: value13 = [0, 0, 0, 0]
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    assertWebGL2Context(gl);
    withParameters(gl, {
      framebuffer
    }, () => {
      switch (buffer) {
        case GL_COLOR:
          switch (value13.constructor) {
            case Int32Array:
              gl.clearBufferiv(buffer, drawBuffer, value13);
              break;
            case Uint32Array:
              gl.clearBufferuiv(buffer, drawBuffer, value13);
              break;
            case Float32Array:
            default:
              gl.clearBufferfv(buffer, drawBuffer, value13);
          }
          break;
        case GL_DEPTH:
          gl.clearBufferfv(GL_DEPTH, 0, [value13]);
          break;
        case GL_STENCIL:
          gl.clearBufferiv(GL_STENCIL, 0, [value13]);
          break;
        case GL_DEPTH_STENCIL:
          const [depth, stencil] = value13;
          gl.clearBufferfi(GL_DEPTH_STENCIL, 0, depth, stencil);
          break;
        default:
          assert6(false, ERR_ARGUMENTS);
      }
    });
  }

  // node_modules/@luma.gl/webgl/dist/esm/webgl-utils/format-utils.js
  function glFormatToComponents(format) {
    switch (format) {
      case 6406:
      case 33326:
      case 6403:
        return 1;
      case 33328:
      case 33319:
        return 2;
      case 6407:
      case 34837:
        return 3;
      case 6408:
      case 34836:
        return 4;
      default:
        assert6(false);
        return 0;
    }
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/copy-and-blit.js
  function readPixelsToArray(source) {
    let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      sourceX = 0,
      sourceY = 0,
      sourceFormat = 6408
    } = options2;
    let {
      sourceAttachment = 36064,
      target: target5 = null,
      sourceWidth,
      sourceHeight,
      sourceType
    } = options2;
    const {
      framebuffer,
      deleteFramebuffer
    } = getFramebuffer(source);
    assert6(framebuffer);
    const {
      gl,
      handle,
      attachments
    } = framebuffer;
    sourceWidth = sourceWidth || framebuffer.width;
    sourceHeight = sourceHeight || framebuffer.height;
    if (sourceAttachment === 36064 && handle === null) {
      sourceAttachment = 1028;
    }
    assert6(attachments[sourceAttachment]);
    sourceType = sourceType || attachments[sourceAttachment].type;
    target5 = getPixelArray(target5, sourceType, sourceFormat, sourceWidth, sourceHeight);
    sourceType = sourceType || getGLTypeFromTypedArray(target5);
    const prevHandle = gl.bindFramebuffer(36160, handle);
    gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target5);
    gl.bindFramebuffer(36160, prevHandle || null);
    if (deleteFramebuffer) {
      framebuffer.delete();
    }
    return target5;
  }
  function copyToDataUrl(source) {
    let {
      sourceAttachment = 36064,
      targetMaxHeight = Number.MAX_SAFE_INTEGER
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let data = readPixelsToArray(source, {
      sourceAttachment
    });
    let {
      width: width8,
      height: height8
    } = source;
    while (height8 > targetMaxHeight) {
      ({
        data,
        width: width8,
        height: height8
      } = scalePixels2({
        data,
        width: width8,
        height: height8
      }));
    }
    flipRows({
      data,
      width: width8,
      height: height8
    });
    const canvas = document.createElement("canvas");
    canvas.width = width8;
    canvas.height = height8;
    const context = canvas.getContext("2d");
    const imageData = context.createImageData(width8, height8);
    imageData.data.set(data);
    context.putImageData(imageData, 0, 0);
    return canvas.toDataURL();
  }
  function getFramebuffer(source) {
    if (!(source instanceof Framebuffer)) {
      return {
        framebuffer: toFramebuffer(source),
        deleteFramebuffer: true
      };
    }
    return {
      framebuffer: source,
      deleteFramebuffer: false
    };
  }
  function getPixelArray(pixelArray, type, format, width8, height8) {
    if (pixelArray) {
      return pixelArray;
    }
    type = type || 5121;
    const ArrayType = getTypedArrayFromGLType(type, {
      clamped: false
    });
    const components = glFormatToComponents(format);
    return new ArrayType(width8 * height8 * components);
  }

  // node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js
  var FEATURES = {
    WEBGL2: "WEBGL2",
    VERTEX_ARRAY_OBJECT: "VERTEX_ARRAY_OBJECT",
    TIMER_QUERY: "TIMER_QUERY",
    INSTANCED_RENDERING: "INSTANCED_RENDERING",
    MULTIPLE_RENDER_TARGETS: "MULTIPLE_RENDER_TARGETS",
    ELEMENT_INDEX_UINT32: "ELEMENT_INDEX_UINT32",
    BLEND_EQUATION_MINMAX: "BLEND_EQUATION_MINMAX",
    FLOAT_BLEND: "FLOAT_BLEND",
    COLOR_ENCODING_SRGB: "COLOR_ENCODING_SRGB",
    TEXTURE_DEPTH: "TEXTURE_DEPTH",
    TEXTURE_FLOAT: "TEXTURE_FLOAT",
    TEXTURE_HALF_FLOAT: "TEXTURE_HALF_FLOAT",
    TEXTURE_FILTER_LINEAR_FLOAT: "TEXTURE_FILTER_LINEAR_FLOAT",
    TEXTURE_FILTER_LINEAR_HALF_FLOAT: "TEXTURE_FILTER_LINEAR_HALF_FLOAT",
    TEXTURE_FILTER_ANISOTROPIC: "TEXTURE_FILTER_ANISOTROPIC",
    COLOR_ATTACHMENT_RGBA32F: "COLOR_ATTACHMENT_RGBA32F",
    COLOR_ATTACHMENT_FLOAT: "COLOR_ATTACHMENT_FLOAT",
    COLOR_ATTACHMENT_HALF_FLOAT: "COLOR_ATTACHMENT_HALF_FLOAT",
    GLSL_FRAG_DATA: "GLSL_FRAG_DATA",
    GLSL_FRAG_DEPTH: "GLSL_FRAG_DEPTH",
    GLSL_DERIVATIVES: "GLSL_DERIVATIVES",
    GLSL_TEXTURE_LOD: "GLSL_TEXTURE_LOD"
  };
  function checkFloat32ColorAttachment(gl) {
    const testTexture = new Texture2D(gl, {
      format: 6408,
      type: 5126,
      dataFormat: 6408
    });
    const testFb = new Framebuffer(gl, {
      id: "test-framebuffer",
      check: false,
      attachments: {
        [36064]: testTexture
      }
    });
    const status = testFb.getStatus();
    testTexture.delete();
    testFb.delete();
    return status === 36053;
  }
  var webgl_features_table_default = {
    [FEATURES.WEBGL2]: [false, true],
    [FEATURES.VERTEX_ARRAY_OBJECT]: ["OES_vertex_array_object", true],
    [FEATURES.TIMER_QUERY]: ["EXT_disjoint_timer_query", "EXT_disjoint_timer_query_webgl2"],
    [FEATURES.INSTANCED_RENDERING]: ["ANGLE_instanced_arrays", true],
    [FEATURES.MULTIPLE_RENDER_TARGETS]: ["WEBGL_draw_buffers", true],
    [FEATURES.ELEMENT_INDEX_UINT32]: ["OES_element_index_uint", true],
    [FEATURES.BLEND_EQUATION_MINMAX]: ["EXT_blend_minmax", true],
    [FEATURES.FLOAT_BLEND]: ["EXT_float_blend"],
    [FEATURES.COLOR_ENCODING_SRGB]: ["EXT_sRGB", true],
    [FEATURES.TEXTURE_DEPTH]: ["WEBGL_depth_texture", true],
    [FEATURES.TEXTURE_FLOAT]: ["OES_texture_float", true],
    [FEATURES.TEXTURE_HALF_FLOAT]: ["OES_texture_half_float", true],
    [FEATURES.TEXTURE_FILTER_LINEAR_FLOAT]: ["OES_texture_float_linear"],
    [FEATURES.TEXTURE_FILTER_LINEAR_HALF_FLOAT]: ["OES_texture_half_float_linear"],
    [FEATURES.TEXTURE_FILTER_ANISOTROPIC]: ["EXT_texture_filter_anisotropic"],
    [FEATURES.COLOR_ATTACHMENT_RGBA32F]: [checkFloat32ColorAttachment, "EXT_color_buffer_float"],
    [FEATURES.COLOR_ATTACHMENT_FLOAT]: [false, "EXT_color_buffer_float"],
    [FEATURES.COLOR_ATTACHMENT_HALF_FLOAT]: ["EXT_color_buffer_half_float"],
    [FEATURES.GLSL_FRAG_DATA]: ["WEBGL_draw_buffers", true],
    [FEATURES.GLSL_FRAG_DEPTH]: ["EXT_frag_depth", true],
    [FEATURES.GLSL_DERIVATIVES]: ["OES_standard_derivatives", true],
    [FEATURES.GLSL_TEXTURE_LOD]: ["EXT_shader_texture_lod", true]
  };

  // node_modules/@luma.gl/webgl/dist/esm/features/features.js
  var LOG_UNSUPPORTED_FEATURE = 2;
  function hasFeature(gl, feature) {
    return hasFeatures(gl, feature);
  }
  function hasFeatures(gl, features) {
    features = Array.isArray(features) ? features : [features];
    return features.every((feature) => {
      return isFeatureSupported(gl, feature);
    });
  }
  function getFeatures(gl) {
    gl.luma = gl.luma || {};
    gl.luma.caps = gl.luma.caps || {};
    for (const cap in webgl_features_table_default) {
      if (gl.luma.caps[cap] === void 0) {
        gl.luma.caps[cap] = isFeatureSupported(gl, cap);
      }
    }
    return gl.luma.caps;
  }
  function isFeatureSupported(gl, cap) {
    gl.luma = gl.luma || {};
    gl.luma.caps = gl.luma.caps || {};
    if (gl.luma.caps[cap] === void 0) {
      gl.luma.caps[cap] = queryFeature(gl, cap);
    }
    if (!gl.luma.caps[cap]) {
      log3.log(LOG_UNSUPPORTED_FEATURE, "Feature: ".concat(cap, " not supported"))();
    }
    return gl.luma.caps[cap];
  }
  function queryFeature(gl, cap) {
    const feature = webgl_features_table_default[cap];
    assert6(feature, cap);
    let isSupported;
    const featureDefinition = isWebGL2(gl) ? feature[1] || feature[0] : feature[0];
    if (typeof featureDefinition === "function") {
      isSupported = featureDefinition(gl);
    } else if (Array.isArray(featureDefinition)) {
      isSupported = true;
      for (const extension of featureDefinition) {
        isSupported = isSupported && Boolean(gl.getExtension(extension));
      }
    } else if (typeof featureDefinition === "string") {
      isSupported = Boolean(gl.getExtension(featureDefinition));
    } else if (typeof featureDefinition === "boolean") {
      isSupported = featureDefinition;
    } else {
      assert6(false);
    }
    return isSupported;
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/framebuffer.js
  var ERR_MULTIPLE_RENDERTARGETS = "Multiple render targets not supported";
  var Framebuffer = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Framebuffer";
    }
    static isSupported(gl) {
      let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const {
        colorBufferFloat,
        colorBufferHalfFloat
      } = options2;
      let supported2 = true;
      if (colorBufferFloat) {
        supported2 = Boolean(gl.getExtension("EXT_color_buffer_float") || gl.getExtension("WEBGL_color_buffer_float") || gl.getExtension("OES_texture_float"));
      }
      if (colorBufferHalfFloat) {
        supported2 = supported2 && Boolean(gl.getExtension("EXT_color_buffer_float") || gl.getExtension("EXT_color_buffer_half_float"));
      }
      return supported2;
    }
    static getDefaultFramebuffer(gl) {
      gl.luma = gl.luma || {};
      gl.luma.defaultFramebuffer = gl.luma.defaultFramebuffer || new Framebuffer(gl, {
        id: "default-framebuffer",
        handle: null,
        attachments: {}
      });
      return gl.luma.defaultFramebuffer;
    }
    get MAX_COLOR_ATTACHMENTS() {
      const gl2 = assertWebGL2Context(this.gl);
      return gl2.getParameter(gl2.MAX_COLOR_ATTACHMENTS);
    }
    get MAX_DRAW_BUFFERS() {
      const gl2 = assertWebGL2Context(this.gl);
      return gl2.getParameter(gl2.MAX_DRAW_BUFFERS);
    }
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(gl, opts);
      this.width = null;
      this.height = null;
      this.attachments = {};
      this.readBuffer = 36064;
      this.drawBuffers = [36064];
      this.ownResources = [];
      this.initialize(opts);
      Object.seal(this);
    }
    get color() {
      return this.attachments[36064] || null;
    }
    get texture() {
      return this.attachments[36064] || null;
    }
    get depth() {
      return this.attachments[36096] || this.attachments[33306] || null;
    }
    get stencil() {
      return this.attachments[36128] || this.attachments[33306] || null;
    }
    initialize(_ref) {
      let {
        width: width8 = 1,
        height: height8 = 1,
        attachments = null,
        color = true,
        depth = true,
        stencil = false,
        check = true,
        readBuffer = void 0,
        drawBuffers = void 0
      } = _ref;
      assert6(width8 >= 0 && height8 >= 0, "Width and height need to be integers");
      this.width = width8;
      this.height = height8;
      if (attachments) {
        for (const attachment in attachments) {
          const target5 = attachments[attachment];
          const object12 = Array.isArray(target5) ? target5[0] : target5;
          object12.resize({
            width: width8,
            height: height8
          });
        }
      } else {
        attachments = this._createDefaultAttachments(color, depth, stencil, width8, height8);
      }
      this.update({
        clearAttachments: true,
        attachments,
        readBuffer,
        drawBuffers
      });
      if (attachments && check) {
        this.checkStatus();
      }
    }
    delete() {
      for (const resource of this.ownResources) {
        resource.delete();
      }
      super.delete();
      return this;
    }
    update(_ref2) {
      let {
        attachments = {},
        readBuffer,
        drawBuffers,
        clearAttachments = false,
        resizeAttachments = true
      } = _ref2;
      this.attach(attachments, {
        clearAttachments,
        resizeAttachments
      });
      const {
        gl
      } = this;
      const prevHandle = gl.bindFramebuffer(36160, this.handle);
      if (readBuffer) {
        this._setReadBuffer(readBuffer);
      }
      if (drawBuffers) {
        this._setDrawBuffers(drawBuffers);
      }
      gl.bindFramebuffer(36160, prevHandle || null);
      return this;
    }
    resize() {
      let options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      let {
        width: width8,
        height: height8
      } = options2;
      if (this.handle === null) {
        assert6(width8 === void 0 && height8 === void 0);
        this.width = this.gl.drawingBufferWidth;
        this.height = this.gl.drawingBufferHeight;
        return this;
      }
      if (width8 === void 0) {
        width8 = this.gl.drawingBufferWidth;
      }
      if (height8 === void 0) {
        height8 = this.gl.drawingBufferHeight;
      }
      if (width8 !== this.width && height8 !== this.height) {
        log3.log(2, "Resizing framebuffer ".concat(this.id, " to ").concat(width8, "x").concat(height8))();
      }
      for (const attachmentPoint in this.attachments) {
        this.attachments[attachmentPoint].resize({
          width: width8,
          height: height8
        });
      }
      this.width = width8;
      this.height = height8;
      return this;
    }
    attach(attachments) {
      let {
        clearAttachments = false,
        resizeAttachments = true
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const newAttachments = {};
      if (clearAttachments) {
        Object.keys(this.attachments).forEach((key) => {
          newAttachments[key] = null;
        });
      }
      Object.assign(newAttachments, attachments);
      const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
      for (const key in newAttachments) {
        assert6(key !== void 0, "Misspelled framebuffer binding point?");
        const attachment = Number(key);
        const descriptor = newAttachments[attachment];
        let object12 = descriptor;
        if (!object12) {
          this._unattach(attachment);
        } else if (object12 instanceof Renderbuffer) {
          this._attachRenderbuffer({
            attachment,
            renderbuffer: object12
          });
        } else if (Array.isArray(descriptor)) {
          const [texture, layer = 0, level = 0] = descriptor;
          object12 = texture;
          this._attachTexture({
            attachment,
            texture,
            layer,
            level
          });
        } else {
          this._attachTexture({
            attachment,
            texture: object12,
            layer: 0,
            level: 0
          });
        }
        if (resizeAttachments && object12) {
          object12.resize({
            width: this.width,
            height: this.height
          });
        }
      }
      this.gl.bindFramebuffer(36160, prevHandle || null);
      Object.assign(this.attachments, attachments);
      Object.keys(this.attachments).filter((key) => !this.attachments[key]).forEach((key) => {
        delete this.attachments[key];
      });
    }
    checkStatus() {
      const {
        gl
      } = this;
      const status = this.getStatus();
      if (status !== 36053) {
        throw new Error(_getFrameBufferStatus(status));
      }
      return this;
    }
    getStatus() {
      const {
        gl
      } = this;
      const prevHandle = gl.bindFramebuffer(36160, this.handle);
      const status = gl.checkFramebufferStatus(36160);
      gl.bindFramebuffer(36160, prevHandle || null);
      return status;
    }
    clear() {
      let options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        color,
        depth,
        stencil,
        drawBuffers = []
      } = options2;
      const prevHandle = this.gl.bindFramebuffer(36160, this.handle);
      if (color || depth || stencil) {
        clear(this.gl, {
          color,
          depth,
          stencil
        });
      }
      drawBuffers.forEach((value13, drawBuffer) => {
        clearBuffer(this.gl, {
          drawBuffer,
          value: value13
        });
      });
      this.gl.bindFramebuffer(36160, prevHandle || null);
      return this;
    }
    readPixels() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log3.error("Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)")();
      return null;
    }
    readPixelsToBuffer() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log3.error("Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)")();
      return null;
    }
    copyToDataUrl() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log3.error("Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)")();
      return null;
    }
    copyToImage() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log3.error("Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)")();
      return null;
    }
    copyToTexture() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log3.error("Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})")();
      return null;
    }
    blit() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log3.error("Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)")();
      return null;
    }
    invalidate(_ref3) {
      let {
        attachments = [],
        x = 0,
        y = 0,
        width: width8,
        height: height8
      } = _ref3;
      const gl2 = assertWebGL2Context(this.gl);
      const prevHandle = gl2.bindFramebuffer(36008, this.handle);
      const invalidateAll = x === 0 && y === 0 && width8 === void 0 && height8 === void 0;
      if (invalidateAll) {
        gl2.invalidateFramebuffer(36008, attachments);
      } else {
        gl2.invalidateFramebuffer(36008, attachments, x, y, width8, height8);
      }
      gl2.bindFramebuffer(36008, prevHandle);
      return this;
    }
    getAttachmentParameter(attachment, pname, keys3) {
      let value13 = this._getAttachmentParameterFallback(pname);
      if (value13 === null) {
        this.gl.bindFramebuffer(36160, this.handle);
        value13 = this.gl.getFramebufferAttachmentParameter(36160, attachment, pname);
        this.gl.bindFramebuffer(36160, null);
      }
      if (keys3 && value13 > 1e3) {
        value13 = getKey(this.gl, value13);
      }
      return value13;
    }
    getAttachmentParameters() {
      let attachment = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 36064;
      let keys3 = arguments.length > 1 ? arguments[1] : void 0;
      let parameters = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.constructor.ATTACHMENT_PARAMETERS || [];
      const values2 = {};
      for (const pname of parameters) {
        const key = keys3 ? getKey(this.gl, pname) : pname;
        values2[key] = this.getAttachmentParameter(attachment, pname, keys3);
      }
      return values2;
    }
    getParameters() {
      let keys3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      const attachments = Object.keys(this.attachments);
      const parameters = {};
      for (const attachmentName of attachments) {
        const attachment = Number(attachmentName);
        const key = keys3 ? getKey(this.gl, attachment) : attachment;
        parameters[key] = this.getAttachmentParameters(attachment, keys3);
      }
      return parameters;
    }
    show() {
      if (typeof window !== "undefined") {
        window.open(copyToDataUrl(this), "luma-debug-texture");
      }
      return this;
    }
    log() {
      let logLevel = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      let message2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      if (logLevel > log3.level || typeof window === "undefined") {
        return this;
      }
      message2 = message2 || "Framebuffer ".concat(this.id);
      const image = copyToDataUrl(this, {
        targetMaxHeight: 100
      });
      log3.image({
        logLevel,
        message: message2,
        image
      }, message2)();
      return this;
    }
    bind() {
      let {
        target: target5 = 36160
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.gl.bindFramebuffer(target5, this.handle);
      return this;
    }
    unbind() {
      let {
        target: target5 = 36160
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.gl.bindFramebuffer(target5, null);
      return this;
    }
    _createDefaultAttachments(color, depth, stencil, width8, height8) {
      let defaultAttachments = null;
      if (color) {
        defaultAttachments = defaultAttachments || {};
        defaultAttachments[36064] = new Texture2D(this.gl, {
          id: "".concat(this.id, "-color0"),
          pixels: null,
          format: 6408,
          type: 5121,
          width: width8,
          height: height8,
          mipmaps: false,
          parameters: {
            [10241]: 9729,
            [10240]: 9729,
            [10242]: 33071,
            [10243]: 33071
          }
        });
        this.ownResources.push(defaultAttachments[36064]);
      }
      if (depth && stencil) {
        defaultAttachments = defaultAttachments || {};
        defaultAttachments[33306] = new Renderbuffer(this.gl, {
          id: "".concat(this.id, "-depth-stencil"),
          format: 35056,
          width: width8,
          height: 111
        });
        this.ownResources.push(defaultAttachments[33306]);
      } else if (depth) {
        defaultAttachments = defaultAttachments || {};
        defaultAttachments[36096] = new Renderbuffer(this.gl, {
          id: "".concat(this.id, "-depth"),
          format: 33189,
          width: width8,
          height: height8
        });
        this.ownResources.push(defaultAttachments[36096]);
      } else if (stencil) {
        assert6(false);
      }
      return defaultAttachments;
    }
    _unattach(attachment) {
      const oldAttachment = this.attachments[attachment];
      if (!oldAttachment) {
        return;
      }
      if (oldAttachment instanceof Renderbuffer) {
        this.gl.framebufferRenderbuffer(36160, attachment, 36161, null);
      } else {
        this.gl.framebufferTexture2D(36160, attachment, 3553, null, 0);
      }
      delete this.attachments[attachment];
    }
    _attachRenderbuffer(_ref4) {
      let {
        attachment = 36064,
        renderbuffer
      } = _ref4;
      const {
        gl
      } = this;
      gl.framebufferRenderbuffer(36160, attachment, 36161, renderbuffer.handle);
      this.attachments[attachment] = renderbuffer;
    }
    _attachTexture(_ref5) {
      let {
        attachment = 36064,
        texture,
        layer,
        level
      } = _ref5;
      const {
        gl
      } = this;
      gl.bindTexture(texture.target, texture.handle);
      switch (texture.target) {
        case 35866:
        case 32879:
          const gl2 = assertWebGL2Context(gl);
          gl2.framebufferTextureLayer(36160, attachment, texture.target, level, layer);
          break;
        case 34067:
          const face = mapIndexToCubeMapFace(layer);
          gl.framebufferTexture2D(36160, attachment, face, texture.handle, level);
          break;
        case 3553:
          gl.framebufferTexture2D(36160, attachment, 3553, texture.handle, level);
          break;
        default:
          assert6(false, "Illegal texture type");
      }
      gl.bindTexture(texture.target, null);
      this.attachments[attachment] = texture;
    }
    _setReadBuffer(readBuffer) {
      const gl2 = getWebGL2Context(this.gl);
      if (gl2) {
        gl2.readBuffer(readBuffer);
      } else {
        assert6(readBuffer === 36064 || readBuffer === 1029, ERR_MULTIPLE_RENDERTARGETS);
      }
      this.readBuffer = readBuffer;
    }
    _setDrawBuffers(drawBuffers) {
      const {
        gl
      } = this;
      const gl2 = assertWebGL2Context(gl);
      if (gl2) {
        gl2.drawBuffers(drawBuffers);
      } else {
        const ext = gl.getExtension("WEBGL_draw_buffers");
        if (ext) {
          ext.drawBuffersWEBGL(drawBuffers);
        } else {
          assert6(drawBuffers.length === 1 && (drawBuffers[0] === 36064 || drawBuffers[0] === 1029), ERR_MULTIPLE_RENDERTARGETS);
        }
      }
      this.drawBuffers = drawBuffers;
    }
    _getAttachmentParameterFallback(pname) {
      const caps = getFeatures(this.gl);
      switch (pname) {
        case 36052:
          return !caps.WEBGL2 ? 0 : null;
        case 33298:
        case 33299:
        case 33300:
        case 33301:
        case 33302:
        case 33303:
          return !caps.WEBGL2 ? 8 : null;
        case 33297:
          return !caps.WEBGL2 ? 5125 : null;
        case 33296:
          return !caps.WEBGL2 && !caps.EXT_sRGB ? 9729 : null;
        default:
          return null;
      }
    }
    _createHandle() {
      return this.gl.createFramebuffer();
    }
    _deleteHandle() {
      this.gl.deleteFramebuffer(this.handle);
    }
    _bindHandle(handle) {
      return this.gl.bindFramebuffer(36160, handle);
    }
  };
  function mapIndexToCubeMapFace(layer) {
    return layer < 34069 ? layer + 34069 : layer;
  }
  function _getFrameBufferStatus(status) {
    const STATUS = Framebuffer.STATUS || {};
    return STATUS[status] || "Framebuffer error ".concat(status);
  }
  var FRAMEBUFFER_ATTACHMENT_PARAMETERS = [36049, 36048, 33296, 33298, 33299, 33300, 33301, 33302, 33303];
  Framebuffer.ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;

  // node_modules/@luma.gl/webgl/dist/esm/webgl-utils/texture-utils.js
  function cloneTextureFrom(refTexture, overrides) {
    assert6(refTexture instanceof Texture2D || refTexture instanceof TextureCube || refTexture instanceof Texture3D);
    const TextureType = refTexture.constructor;
    const {
      gl,
      width: width8,
      height: height8,
      format,
      type,
      dataFormat,
      border: border2,
      mipmaps
    } = refTexture;
    const textureOptions = Object.assign({
      width: width8,
      height: height8,
      format,
      type,
      dataFormat,
      border: border2,
      mipmaps
    }, overrides);
    return new TextureType(gl, textureOptions);
  }
  function toFramebuffer(texture, opts) {
    const {
      gl,
      width: width8,
      height: height8,
      id: id2
    } = texture;
    const framebuffer = new Framebuffer(gl, Object.assign({}, opts, {
      id: "framebuffer-for-".concat(id2),
      width: width8,
      height: height8,
      attachments: {
        [36064]: texture
      }
    }));
    return framebuffer;
  }

  // node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-name.js
  function getShaderName(shader) {
    let defaultName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "unnamed";
    const SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
    const match = shader.match(SHADER_NAME_REGEXP);
    return match ? match[1] : defaultName;
  }

  // node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-type-name.js
  var GL_FRAGMENT_SHADER = 35632;
  var GL_VERTEX_SHADER = 35633;
  function getShaderTypeName(type) {
    switch (type) {
      case GL_FRAGMENT_SHADER:
        return "fragment";
      case GL_VERTEX_SHADER:
        return "vertex";
      default:
        return "unknown type";
    }
  }

  // node_modules/@luma.gl/webgl/dist/esm/glsl-utils/format-glsl-error.js
  function parseGLSLCompilerError(errLog, src9, shaderType, shaderName) {
    const errorStrings = errLog.split(/\r?\n/);
    const errors = {};
    const warnings = {};
    const name16 = shaderName || getShaderName(src9) || "(unnamed)";
    const shaderDescription = "".concat(getShaderTypeName(shaderType), " shader ").concat(name16);
    for (let i = 0; i < errorStrings.length; i++) {
      const errorString = errorStrings[i];
      if (errorString.length <= 1) {
        continue;
      }
      const segments = errorString.split(":");
      const type = segments[0];
      const line = parseInt(segments[2], 10);
      if (isNaN(line)) {
        throw new Error("GLSL compilation error in ".concat(shaderDescription, ": ").concat(errLog));
      }
      if (type !== "WARNING") {
        errors[line] = errorString;
      } else {
        warnings[line] = errorString;
      }
    }
    const lines = addLineNumbers(src9);
    return {
      shaderName: shaderDescription,
      errors: formatErrors(errors, lines),
      warnings: formatErrors(warnings, lines)
    };
  }
  function formatErrors(errors, lines) {
    let message2 = "";
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1]) {
        continue;
      }
      message2 += "".concat(line, "\n");
      if (errors[i + 1]) {
        const error3 = errors[i + 1];
        const segments = error3.split(":", 3);
        const type = segments[0];
        const column = parseInt(segments[1], 10) || 0;
        const err = error3.substring(segments.join(":").length + 1).trim();
        message2 += padLeft("^^^ ".concat(type, ": ").concat(err, "\n\n"), column);
      }
    }
    return message2;
  }
  function addLineNumbers(string13) {
    let start2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    let delim = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ": ";
    const lines = string13.split(/\r?\n/);
    const maxDigits = String(lines.length + start2 - 1).length;
    return lines.map((line, i) => {
      const lineNumber = String(i + start2);
      const digits = lineNumber.length;
      const prefix = padLeft(lineNumber, maxDigits - digits);
      return prefix + delim + line;
    });
  }
  function padLeft(string13, digits) {
    let result = "";
    for (let i = 0; i < digits; ++i) {
      result += " ";
    }
    return "".concat(result).concat(string13);
  }

  // node_modules/@luma.gl/webgl/dist/esm/glsl-utils/get-shader-version.js
  function getShaderVersion(source) {
    let version = 100;
    const words = source.match(/[^\s]+/g);
    if (words.length >= 2 && words[0] === "#version") {
      const v = parseInt(words[1], 10);
      if (Number.isFinite(v)) {
        version = v;
      }
    }
    return version;
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/shader.js
  var ERR_SOURCE = "Shader: GLSL source code must be a JavaScript string";
  var Shader = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Shader";
    }
    static getTypeName(shaderType) {
      switch (shaderType) {
        case 35633:
          return "vertex-shader";
        case 35632:
          return "fragment-shader";
        default:
          assert6(false);
          return "unknown";
      }
    }
    constructor(gl, props) {
      assertWebGLContext(gl);
      assert6(typeof props.source === "string", ERR_SOURCE);
      const id2 = getShaderName(props.source, null) || props.id || uid("unnamed ".concat(Shader.getTypeName(props.shaderType)));
      super(gl, {
        id: id2
      });
      this.shaderType = props.shaderType;
      this.source = props.source;
      this.initialize(props);
    }
    initialize(_ref) {
      let {
        source
      } = _ref;
      const shaderName = getShaderName(source, null);
      if (shaderName) {
        this.id = uid(shaderName);
      }
      this._compile(source);
    }
    getParameter(pname) {
      return this.gl.getShaderParameter(this.handle, pname);
    }
    toString() {
      return "".concat(Shader.getTypeName(this.shaderType), ":").concat(this.id);
    }
    getName() {
      return getShaderName(this.source) || "unnamed-shader";
    }
    getSource() {
      return this.gl.getShaderSource(this.handle);
    }
    getTranslatedSource() {
      const extension = this.gl.getExtension("WEBGL_debug_shaders");
      return extension ? extension.getTranslatedShaderSource(this.handle) : "No translated source available. WEBGL_debug_shaders not implemented";
    }
    _compile() {
      let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.source;
      if (!source.startsWith("#version ")) {
        source = "#version 100\n".concat(source);
      }
      this.source = source;
      this.gl.shaderSource(this.handle, this.source);
      this.gl.compileShader(this.handle);
      const compileStatus = this.getParameter(35713);
      if (!compileStatus) {
        const infoLog = this.gl.getShaderInfoLog(this.handle);
        const {
          shaderName,
          errors,
          warnings
        } = parseGLSLCompilerError(infoLog, this.source, this.shaderType, this.id);
        log3.error("GLSL compilation errors in ".concat(shaderName, "\n").concat(errors))();
        log3.warn("GLSL compilation warnings in ".concat(shaderName, "\n").concat(warnings))();
        throw new Error("GLSL compilation errors in ".concat(shaderName));
      }
    }
    _deleteHandle() {
      this.gl.deleteShader(this.handle);
    }
    _getOptsFromHandle() {
      return {
        type: this.getParameter(35663),
        source: this.getSource()
      };
    }
  };
  var VertexShader = class extends Shader {
    get [Symbol.toStringTag]() {
      return "VertexShader";
    }
    constructor(gl, props) {
      if (typeof props === "string") {
        props = {
          source: props
        };
      }
      super(gl, Object.assign({}, props, {
        shaderType: 35633
      }));
    }
    _createHandle() {
      return this.gl.createShader(35633);
    }
  };
  var FragmentShader = class extends Shader {
    get [Symbol.toStringTag]() {
      return "FragmentShader";
    }
    constructor(gl, props) {
      if (typeof props === "string") {
        props = {
          source: props
        };
      }
      super(gl, Object.assign({}, props, {
        shaderType: 35632
      }));
    }
    _createHandle() {
      return this.gl.createShader(35632);
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/classes/uniforms.js
  var UNIFORM_SETTERS = {
    [5126]: getArraySetter.bind(null, "uniform1fv", toFloatArray, 1, setVectorUniform),
    [35664]: getArraySetter.bind(null, "uniform2fv", toFloatArray, 2, setVectorUniform),
    [35665]: getArraySetter.bind(null, "uniform3fv", toFloatArray, 3, setVectorUniform),
    [35666]: getArraySetter.bind(null, "uniform4fv", toFloatArray, 4, setVectorUniform),
    [5124]: getArraySetter.bind(null, "uniform1iv", toIntArray, 1, setVectorUniform),
    [35667]: getArraySetter.bind(null, "uniform2iv", toIntArray, 2, setVectorUniform),
    [35668]: getArraySetter.bind(null, "uniform3iv", toIntArray, 3, setVectorUniform),
    [35669]: getArraySetter.bind(null, "uniform4iv", toIntArray, 4, setVectorUniform),
    [35670]: getArraySetter.bind(null, "uniform1iv", toIntArray, 1, setVectorUniform),
    [35671]: getArraySetter.bind(null, "uniform2iv", toIntArray, 2, setVectorUniform),
    [35672]: getArraySetter.bind(null, "uniform3iv", toIntArray, 3, setVectorUniform),
    [35673]: getArraySetter.bind(null, "uniform4iv", toIntArray, 4, setVectorUniform),
    [35674]: getArraySetter.bind(null, "uniformMatrix2fv", toFloatArray, 4, setMatrixUniform),
    [35675]: getArraySetter.bind(null, "uniformMatrix3fv", toFloatArray, 9, setMatrixUniform),
    [35676]: getArraySetter.bind(null, "uniformMatrix4fv", toFloatArray, 16, setMatrixUniform),
    [35678]: getSamplerSetter,
    [35680]: getSamplerSetter,
    [5125]: getArraySetter.bind(null, "uniform1uiv", toUIntArray, 1, setVectorUniform),
    [36294]: getArraySetter.bind(null, "uniform2uiv", toUIntArray, 2, setVectorUniform),
    [36295]: getArraySetter.bind(null, "uniform3uiv", toUIntArray, 3, setVectorUniform),
    [36296]: getArraySetter.bind(null, "uniform4uiv", toUIntArray, 4, setVectorUniform),
    [35685]: getArraySetter.bind(null, "uniformMatrix2x3fv", toFloatArray, 6, setMatrixUniform),
    [35686]: getArraySetter.bind(null, "uniformMatrix2x4fv", toFloatArray, 8, setMatrixUniform),
    [35687]: getArraySetter.bind(null, "uniformMatrix3x2fv", toFloatArray, 6, setMatrixUniform),
    [35688]: getArraySetter.bind(null, "uniformMatrix3x4fv", toFloatArray, 12, setMatrixUniform),
    [35689]: getArraySetter.bind(null, "uniformMatrix4x2fv", toFloatArray, 8, setMatrixUniform),
    [35690]: getArraySetter.bind(null, "uniformMatrix4x3fv", toFloatArray, 12, setMatrixUniform),
    [35678]: getSamplerSetter,
    [35680]: getSamplerSetter,
    [35679]: getSamplerSetter,
    [35682]: getSamplerSetter,
    [36289]: getSamplerSetter,
    [36292]: getSamplerSetter,
    [36293]: getSamplerSetter,
    [36298]: getSamplerSetter,
    [36299]: getSamplerSetter,
    [36300]: getSamplerSetter,
    [36303]: getSamplerSetter,
    [36306]: getSamplerSetter,
    [36307]: getSamplerSetter,
    [36308]: getSamplerSetter,
    [36311]: getSamplerSetter
  };
  var FLOAT_ARRAY = {};
  var INT_ARRAY = {};
  var UINT_ARRAY = {};
  var array1 = [0];
  function toTypedArray(value13, uniformLength, Type, cache3) {
    if (uniformLength === 1 && typeof value13 === "boolean") {
      value13 = value13 ? 1 : 0;
    }
    if (Number.isFinite(value13)) {
      array1[0] = value13;
      value13 = array1;
    }
    const length7 = value13.length;
    if (length7 % uniformLength) {
      log3.warn("Uniform size should be multiples of ".concat(uniformLength), value13)();
    }
    if (value13 instanceof Type) {
      return value13;
    }
    let result = cache3[length7];
    if (!result) {
      result = new Type(length7);
      cache3[length7] = result;
    }
    for (let i = 0; i < length7; i++) {
      result[i] = value13[i];
    }
    return result;
  }
  function toFloatArray(value13, uniformLength) {
    return toTypedArray(value13, uniformLength, Float32Array, FLOAT_ARRAY);
  }
  function toIntArray(value13, uniformLength) {
    return toTypedArray(value13, uniformLength, Int32Array, INT_ARRAY);
  }
  function toUIntArray(value13, uniformLength) {
    return toTypedArray(value13, uniformLength, Uint32Array, UINT_ARRAY);
  }
  function getUniformSetter(gl, location2, info) {
    const setter = UNIFORM_SETTERS[info.type];
    if (!setter) {
      throw new Error("Unknown GLSL uniform type ".concat(info.type));
    }
    return setter().bind(null, gl, location2);
  }
  function parseUniformName(name16) {
    if (name16[name16.length - 1] !== "]") {
      return {
        name: name16,
        length: 1,
        isArray: false
      };
    }
    const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
    const matches3 = name16.match(UNIFORM_NAME_REGEXP);
    if (!matches3 || matches3.length < 2) {
      throw new Error("Failed to parse GLSL uniform name ".concat(name16));
    }
    return {
      name: matches3[1],
      length: matches3[2] || 1,
      isArray: Boolean(matches3[2])
    };
  }
  function checkUniformValues(uniforms, source, uniformMap) {
    for (const uniformName in uniforms) {
      const value13 = uniforms[uniformName];
      const shouldCheck = !uniformMap || Boolean(uniformMap[uniformName]);
      if (shouldCheck && !checkUniformValue(value13)) {
        source = source ? "".concat(source, " ") : "";
        console.error("".concat(source, " Bad uniform ").concat(uniformName), value13);
        throw new Error("".concat(source, " Bad uniform ").concat(uniformName));
      }
    }
    return true;
  }
  function checkUniformValue(value13) {
    if (Array.isArray(value13) || ArrayBuffer.isView(value13)) {
      return checkUniformArray(value13);
    }
    if (isFinite(value13)) {
      return true;
    } else if (value13 === true || value13 === false) {
      return true;
    } else if (value13 instanceof Texture) {
      return true;
    } else if (value13 instanceof Renderbuffer) {
      return true;
    } else if (value13 instanceof Framebuffer) {
      return Boolean(value13.texture);
    }
    return false;
  }
  function copyUniform(uniforms, key, value13) {
    if (Array.isArray(value13) || ArrayBuffer.isView(value13)) {
      if (uniforms[key]) {
        const dest = uniforms[key];
        for (let i = 0, len = value13.length; i < len; ++i) {
          dest[i] = value13[i];
        }
      } else {
        uniforms[key] = value13.slice();
      }
    } else {
      uniforms[key] = value13;
    }
  }
  function checkUniformArray(value13) {
    if (value13.length === 0) {
      return false;
    }
    const checkLength = Math.min(value13.length, 16);
    for (let i = 0; i < checkLength; ++i) {
      if (!Number.isFinite(value13[i])) {
        return false;
      }
    }
    return true;
  }
  function getSamplerSetter() {
    let cache3 = null;
    return (gl, location2, value13) => {
      const update = cache3 !== value13;
      if (update) {
        gl.uniform1i(location2, value13);
        cache3 = value13;
      }
      return update;
    };
  }
  function getArraySetter(functionName, toArray5, size5, uniformSetter) {
    let cache3 = null;
    let cacheLength = null;
    return (gl, location2, value13) => {
      const arrayValue = toArray5(value13, size5);
      const length7 = arrayValue.length;
      let update = false;
      if (cache3 === null) {
        cache3 = new Float32Array(length7);
        cacheLength = length7;
        update = true;
      } else {
        assert6(cacheLength === length7, "Uniform length cannot change.");
        for (let i = 0; i < length7; ++i) {
          if (arrayValue[i] !== cache3[i]) {
            update = true;
            break;
          }
        }
      }
      if (update) {
        uniformSetter(gl, functionName, location2, arrayValue);
        cache3.set(arrayValue);
      }
      return update;
    };
  }
  function setVectorUniform(gl, functionName, location2, value13) {
    gl[functionName](location2, value13);
  }
  function setMatrixUniform(gl, functionName, location2, value13) {
    gl[functionName](location2, false, value13);
  }

  // node_modules/@luma.gl/webgl/dist/esm/webgl-utils/attribute-utils.js
  var GL_BYTE = 5120;
  var GL_UNSIGNED_BYTE = 5121;
  var GL_SHORT = 5122;
  var GL_UNSIGNED_SHORT = 5123;
  var GL_POINTS = 0;
  var GL_LINES = 1;
  var GL_LINE_LOOP = 2;
  var GL_LINE_STRIP = 3;
  var GL_TRIANGLES = 4;
  var GL_TRIANGLE_STRIP = 5;
  var GL_TRIANGLE_FAN = 6;
  var GL_FLOAT = 5126;
  var GL_FLOAT_VEC2 = 35664;
  var GL_FLOAT_VEC3 = 35665;
  var GL_FLOAT_VEC4 = 35666;
  var GL_INT = 5124;
  var GL_INT_VEC2 = 35667;
  var GL_INT_VEC3 = 35668;
  var GL_INT_VEC4 = 35669;
  var GL_UNSIGNED_INT = 5125;
  var GL_UNSIGNED_INT_VEC2 = 36294;
  var GL_UNSIGNED_INT_VEC3 = 36295;
  var GL_UNSIGNED_INT_VEC4 = 36296;
  var GL_BOOL = 35670;
  var GL_BOOL_VEC2 = 35671;
  var GL_BOOL_VEC3 = 35672;
  var GL_BOOL_VEC4 = 35673;
  var GL_FLOAT_MAT2 = 35674;
  var GL_FLOAT_MAT3 = 35675;
  var GL_FLOAT_MAT4 = 35676;
  var GL_FLOAT_MAT2x3 = 35685;
  var GL_FLOAT_MAT2x4 = 35686;
  var GL_FLOAT_MAT3x2 = 35687;
  var GL_FLOAT_MAT3x4 = 35688;
  var GL_FLOAT_MAT4x2 = 35689;
  var GL_FLOAT_MAT4x3 = 35690;
  var COMPOSITE_GL_TYPES = {
    [GL_FLOAT]: [GL_FLOAT, 1, "float"],
    [GL_FLOAT_VEC2]: [GL_FLOAT, 2, "vec2"],
    [GL_FLOAT_VEC3]: [GL_FLOAT, 3, "vec3"],
    [GL_FLOAT_VEC4]: [GL_FLOAT, 4, "vec4"],
    [GL_INT]: [GL_INT, 1, "int"],
    [GL_INT_VEC2]: [GL_INT, 2, "ivec2"],
    [GL_INT_VEC3]: [GL_INT, 3, "ivec3"],
    [GL_INT_VEC4]: [GL_INT, 4, "ivec4"],
    [GL_UNSIGNED_INT]: [GL_UNSIGNED_INT, 1, "uint"],
    [GL_UNSIGNED_INT_VEC2]: [GL_UNSIGNED_INT, 2, "uvec2"],
    [GL_UNSIGNED_INT_VEC3]: [GL_UNSIGNED_INT, 3, "uvec3"],
    [GL_UNSIGNED_INT_VEC4]: [GL_UNSIGNED_INT, 4, "uvec4"],
    [GL_BOOL]: [GL_FLOAT, 1, "bool"],
    [GL_BOOL_VEC2]: [GL_FLOAT, 2, "bvec2"],
    [GL_BOOL_VEC3]: [GL_FLOAT, 3, "bvec3"],
    [GL_BOOL_VEC4]: [GL_FLOAT, 4, "bvec4"],
    [GL_FLOAT_MAT2]: [GL_FLOAT, 8, "mat2"],
    [GL_FLOAT_MAT2x3]: [GL_FLOAT, 8, "mat2x3"],
    [GL_FLOAT_MAT2x4]: [GL_FLOAT, 8, "mat2x4"],
    [GL_FLOAT_MAT3]: [GL_FLOAT, 12, "mat3"],
    [GL_FLOAT_MAT3x2]: [GL_FLOAT, 12, "mat3x2"],
    [GL_FLOAT_MAT3x4]: [GL_FLOAT, 12, "mat3x4"],
    [GL_FLOAT_MAT4]: [GL_FLOAT, 16, "mat4"],
    [GL_FLOAT_MAT4x2]: [GL_FLOAT, 16, "mat4x2"],
    [GL_FLOAT_MAT4x3]: [GL_FLOAT, 16, "mat4x3"]
  };
  function getPrimitiveDrawMode(drawMode) {
    switch (drawMode) {
      case GL_POINTS:
        return GL_POINTS;
      case GL_LINES:
        return GL_LINES;
      case GL_LINE_STRIP:
        return GL_LINES;
      case GL_LINE_LOOP:
        return GL_LINES;
      case GL_TRIANGLES:
        return GL_TRIANGLES;
      case GL_TRIANGLE_STRIP:
        return GL_TRIANGLES;
      case GL_TRIANGLE_FAN:
        return GL_TRIANGLES;
      default:
        assert6(false);
        return 0;
    }
  }
  function decomposeCompositeGLType(compositeGLType) {
    const typeAndSize = COMPOSITE_GL_TYPES[compositeGLType];
    if (!typeAndSize) {
      return null;
    }
    const [type, components] = typeAndSize;
    return {
      type,
      components
    };
  }
  function getCompositeGLType(type, components) {
    switch (type) {
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
        type = GL_FLOAT;
        break;
      default:
    }
    for (const glType in COMPOSITE_GL_TYPES) {
      const [compType, compComponents, name16] = COMPOSITE_GL_TYPES[glType];
      if (compType === type && compComponents === components) {
        return {
          glType,
          name: name16
        };
      }
    }
    return null;
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/program-configuration.js
  var ProgramConfiguration = class {
    constructor(program) {
      this.id = program.id;
      this.attributeInfos = [];
      this.attributeInfosByName = {};
      this.attributeInfosByLocation = [];
      this.varyingInfos = [];
      this.varyingInfosByName = {};
      Object.seal(this);
      this._readAttributesFromProgram(program);
      this._readVaryingsFromProgram(program);
    }
    getAttributeInfo(locationOrName) {
      const location2 = Number(locationOrName);
      if (Number.isFinite(location2)) {
        return this.attributeInfosByLocation[location2];
      }
      return this.attributeInfosByName[locationOrName] || null;
    }
    getAttributeLocation(locationOrName) {
      const attributeInfo = this.getAttributeInfo(locationOrName);
      return attributeInfo ? attributeInfo.location : -1;
    }
    getAttributeAccessor(locationOrName) {
      const attributeInfo = this.getAttributeInfo(locationOrName);
      return attributeInfo ? attributeInfo.accessor : null;
    }
    getVaryingInfo(locationOrName) {
      const location2 = Number(locationOrName);
      if (Number.isFinite(location2)) {
        return this.varyingInfos[location2];
      }
      return this.varyingInfosByName[locationOrName] || null;
    }
    getVaryingIndex(locationOrName) {
      const varying = this.getVaryingInfo();
      return varying ? varying.location : -1;
    }
    getVaryingAccessor(locationOrName) {
      const varying = this.getVaryingInfo();
      return varying ? varying.accessor : null;
    }
    _readAttributesFromProgram(program) {
      const {
        gl
      } = program;
      const count2 = gl.getProgramParameter(program.handle, 35721);
      for (let index5 = 0; index5 < count2; index5++) {
        const {
          name: name16,
          type,
          size: size5
        } = gl.getActiveAttrib(program.handle, index5);
        const location2 = gl.getAttribLocation(program.handle, name16);
        if (location2 >= 0) {
          this._addAttribute(location2, name16, type, size5);
        }
      }
      this.attributeInfos.sort((a, b) => a.location - b.location);
    }
    _readVaryingsFromProgram(program) {
      const {
        gl
      } = program;
      if (!isWebGL2(gl)) {
        return;
      }
      const count2 = gl.getProgramParameter(program.handle, 35971);
      for (let location2 = 0; location2 < count2; location2++) {
        const {
          name: name16,
          type,
          size: size5
        } = gl.getTransformFeedbackVarying(program.handle, location2);
        this._addVarying(location2, name16, type, size5);
      }
      this.varyingInfos.sort((a, b) => a.location - b.location);
    }
    _addAttribute(location2, name16, compositeType, size5) {
      const {
        type,
        components
      } = decomposeCompositeGLType(compositeType);
      const accessor = {
        type,
        size: size5 * components
      };
      this._inferProperties(location2, name16, accessor);
      const attributeInfo = {
        location: location2,
        name: name16,
        accessor: new Accessor(accessor)
      };
      this.attributeInfos.push(attributeInfo);
      this.attributeInfosByLocation[location2] = attributeInfo;
      this.attributeInfosByName[attributeInfo.name] = attributeInfo;
    }
    _inferProperties(location2, name16, accessor) {
      if (/instance/i.test(name16)) {
        accessor.divisor = 1;
      }
    }
    _addVarying(location2, name16, compositeType, size5) {
      const {
        type,
        components
      } = decomposeCompositeGLType(compositeType);
      const accessor = new Accessor({
        type,
        size: size5 * components
      });
      const varying = {
        location: location2,
        name: name16,
        accessor
      };
      this.varyingInfos.push(varying);
      this.varyingInfosByName[varying.name] = varying;
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/classes/program.js
  var LOG_PROGRAM_PERF_PRIORITY = 4;
  var GL_SEPARATE_ATTRIBS = 35981;
  var V6_DEPRECATED_METHODS = ["setVertexArray", "setAttributes", "setBuffers", "unsetBuffers", "use", "getUniformCount", "getUniformInfo", "getUniformLocation", "getUniformValue", "getVarying", "getFragDataLocation", "getAttachedShaders", "getAttributeCount", "getAttributeLocation", "getAttributeInfo"];
  var Program = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Program";
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(gl, props);
      this.stubRemovedMethods("Program", "v6.0", V6_DEPRECATED_METHODS);
      this._isCached = false;
      this.initialize(props);
      Object.seal(this);
      this._setId(props.id);
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        hash: hash2,
        vs: vs7,
        fs: fs4,
        varyings,
        bufferMode = GL_SEPARATE_ATTRIBS
      } = props;
      this.hash = hash2 || "";
      this.vs = typeof vs7 === "string" ? new VertexShader(this.gl, {
        id: "".concat(props.id, "-vs"),
        source: vs7
      }) : vs7;
      this.fs = typeof fs4 === "string" ? new FragmentShader(this.gl, {
        id: "".concat(props.id, "-fs"),
        source: fs4
      }) : fs4;
      assert6(this.vs instanceof VertexShader);
      assert6(this.fs instanceof FragmentShader);
      this.uniforms = {};
      this._textureUniforms = {};
      if (varyings && varyings.length > 0) {
        assertWebGL2Context(this.gl);
        this.varyings = varyings;
        this.gl2.transformFeedbackVaryings(this.handle, varyings, bufferMode);
      }
      this._compileAndLink();
      this._readUniformLocationsFromLinkedProgram();
      this.configuration = new ProgramConfiguration(this);
      return this.setProps(props);
    }
    delete() {
      let options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (this._isCached) {
        return this;
      }
      return super.delete(options2);
    }
    setProps(props) {
      if ("uniforms" in props) {
        this.setUniforms(props.uniforms);
      }
      return this;
    }
    draw(_ref) {
      let {
        logPriority,
        drawMode = 4,
        vertexCount,
        offset = 0,
        start: start2,
        end,
        isIndexed = false,
        indexType = 5123,
        instanceCount = 0,
        isInstanced = instanceCount > 0,
        vertexArray = null,
        transformFeedback,
        framebuffer,
        parameters = {},
        uniforms,
        samplers
      } = _ref;
      if (uniforms || samplers) {
        log3.deprecated("Program.draw({uniforms})", "Program.setUniforms(uniforms)")();
        this.setUniforms(uniforms || {});
      }
      if (log3.priority >= logPriority) {
        const fb = framebuffer ? framebuffer.id : "default";
        const message2 = "mode=".concat(getKey(this.gl, drawMode), " verts=").concat(vertexCount, " ") + "instances=".concat(instanceCount, " indexType=").concat(getKey(this.gl, indexType), " ") + "isInstanced=".concat(isInstanced, " isIndexed=").concat(isIndexed, " ") + "Framebuffer=".concat(fb);
        log3.log(logPriority, message2)();
      }
      assert6(vertexArray);
      this.gl.useProgram(this.handle);
      if (!this._areTexturesRenderable() || vertexCount === 0 || isInstanced && instanceCount === 0) {
        return false;
      }
      vertexArray.bindForDraw(vertexCount, instanceCount, () => {
        if (framebuffer !== void 0) {
          parameters = Object.assign({}, parameters, {
            framebuffer
          });
        }
        if (transformFeedback) {
          const primitiveMode = getPrimitiveDrawMode(drawMode);
          transformFeedback.begin(primitiveMode);
        }
        this._bindTextures();
        withParameters(this.gl, parameters, () => {
          if (isIndexed && isInstanced) {
            this.gl2.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);
          } else if (isIndexed && isWebGL2(this.gl) && !isNaN(start2) && !isNaN(end)) {
            this.gl2.drawRangeElements(drawMode, start2, end, vertexCount, indexType, offset);
          } else if (isIndexed) {
            this.gl.drawElements(drawMode, vertexCount, indexType, offset);
          } else if (isInstanced) {
            this.gl2.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);
          } else {
            this.gl.drawArrays(drawMode, offset, vertexCount);
          }
        });
        if (transformFeedback) {
          transformFeedback.end();
        }
      });
      return true;
    }
    setUniforms() {
      let uniforms = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (log3.priority >= 2) {
        checkUniformValues(uniforms, this.id, this._uniformSetters);
      }
      this.gl.useProgram(this.handle);
      for (const uniformName in uniforms) {
        const uniform = uniforms[uniformName];
        const uniformSetter = this._uniformSetters[uniformName];
        if (uniformSetter) {
          let value13 = uniform;
          let textureUpdate = false;
          if (value13 instanceof Framebuffer) {
            value13 = value13.texture;
          }
          if (value13 instanceof Texture) {
            textureUpdate = this.uniforms[uniformName] !== uniform;
            if (textureUpdate) {
              if (uniformSetter.textureIndex === void 0) {
                uniformSetter.textureIndex = this._textureIndexCounter++;
              }
              const texture = value13;
              const {
                textureIndex
              } = uniformSetter;
              texture.bind(textureIndex);
              value13 = textureIndex;
              this._textureUniforms[uniformName] = texture;
            } else {
              value13 = uniformSetter.textureIndex;
            }
          } else if (this._textureUniforms[uniformName]) {
            delete this._textureUniforms[uniformName];
          }
          if (uniformSetter(value13) || textureUpdate) {
            copyUniform(this.uniforms, uniformName, uniform);
          }
        }
      }
      return this;
    }
    _areTexturesRenderable() {
      let texturesRenderable = true;
      for (const uniformName in this._textureUniforms) {
        const texture = this._textureUniforms[uniformName];
        texture.update();
        texturesRenderable = texturesRenderable && texture.loaded;
      }
      return texturesRenderable;
    }
    _bindTextures() {
      for (const uniformName in this._textureUniforms) {
        const textureIndex = this._uniformSetters[uniformName].textureIndex;
        this._textureUniforms[uniformName].bind(textureIndex);
      }
    }
    _createHandle() {
      return this.gl.createProgram();
    }
    _deleteHandle() {
      this.gl.deleteProgram(this.handle);
    }
    _getOptionsFromHandle(handle) {
      const shaderHandles = this.gl.getAttachedShaders(handle);
      const opts = {};
      for (const shaderHandle of shaderHandles) {
        const type = this.gl.getShaderParameter(this.handle, 35663);
        switch (type) {
          case 35633:
            opts.vs = new VertexShader({
              handle: shaderHandle
            });
            break;
          case 35632:
            opts.fs = new FragmentShader({
              handle: shaderHandle
            });
            break;
          default:
        }
      }
      return opts;
    }
    _getParameter(pname) {
      return this.gl.getProgramParameter(this.handle, pname);
    }
    _setId(id2) {
      if (!id2) {
        const programName = this._getName();
        this.id = uid(programName);
      }
    }
    _getName() {
      let programName = this.vs.getName() || this.fs.getName();
      programName = programName.replace(/shader/i, "");
      programName = programName ? "".concat(programName, "-program") : "program";
      return programName;
    }
    _compileAndLink() {
      const {
        gl
      } = this;
      gl.attachShader(this.handle, this.vs.handle);
      gl.attachShader(this.handle, this.fs.handle);
      log3.time(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
      gl.linkProgram(this.handle);
      log3.timeEnd(LOG_PROGRAM_PERF_PRIORITY, "linkProgram for ".concat(this._getName()))();
      if (gl.debug || log3.level > 0) {
        const linked = gl.getProgramParameter(this.handle, 35714);
        if (!linked) {
          throw new Error("Error linking: ".concat(gl.getProgramInfoLog(this.handle)));
        }
        gl.validateProgram(this.handle);
        const validated = gl.getProgramParameter(this.handle, 35715);
        if (!validated) {
          throw new Error("Error validating: ".concat(gl.getProgramInfoLog(this.handle)));
        }
      }
    }
    _readUniformLocationsFromLinkedProgram() {
      const {
        gl
      } = this;
      this._uniformSetters = {};
      this._uniformCount = this._getParameter(35718);
      for (let i = 0; i < this._uniformCount; i++) {
        const info = this.gl.getActiveUniform(this.handle, i);
        const {
          name: name16
        } = parseUniformName(info.name);
        let location2 = gl.getUniformLocation(this.handle, name16);
        this._uniformSetters[name16] = getUniformSetter(gl, location2, info);
        if (info.size > 1) {
          for (let l = 0; l < info.size; l++) {
            location2 = gl.getUniformLocation(this.handle, "".concat(name16, "[").concat(l, "]"));
            this._uniformSetters["".concat(name16, "[").concat(l, "]")] = getUniformSetter(gl, location2, info);
          }
        }
      }
      this._textureIndexCounter = 0;
    }
    getActiveUniforms(uniformIndices, pname) {
      return this.gl2.getActiveUniforms(this.handle, uniformIndices, pname);
    }
    getUniformBlockIndex(blockName) {
      return this.gl2.getUniformBlockIndex(this.handle, blockName);
    }
    getActiveUniformBlockParameter(blockIndex, pname) {
      return this.gl2.getActiveUniformBlockParameter(this.handle, blockIndex, pname);
    }
    uniformBlockBinding(blockIndex, blockBinding) {
      this.gl2.uniformBlockBinding(this.handle, blockIndex, blockBinding);
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/classes/query.js
  var GL_QUERY_RESULT = 34918;
  var GL_QUERY_RESULT_AVAILABLE = 34919;
  var GL_TIME_ELAPSED_EXT = 35007;
  var GL_GPU_DISJOINT_EXT2 = 36795;
  var GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976;
  var GL_ANY_SAMPLES_PASSED = 35887;
  var GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 36202;
  var Query = class extends Resource {
    get [Symbol.toStringTag]() {
      return "Query";
    }
    static isSupported(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      const webgl2 = isWebGL2(gl);
      const hasTimerQuery = hasFeatures(gl, FEATURES.TIMER_QUERY);
      let supported2 = webgl2 || hasTimerQuery;
      for (const key of opts) {
        switch (key) {
          case "queries":
            supported2 = supported2 && webgl2;
            break;
          case "timers":
            supported2 = supported2 && hasTimerQuery;
            break;
          default:
            assert6(false);
        }
      }
      return supported2;
    }
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      super(gl, opts);
      this.target = null;
      this._queryPending = false;
      this._pollingPromise = null;
      Object.seal(this);
    }
    beginTimeElapsedQuery() {
      return this.begin(GL_TIME_ELAPSED_EXT);
    }
    beginOcclusionQuery() {
      let {
        conservative = false
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return this.begin(conservative ? GL_ANY_SAMPLES_PASSED_CONSERVATIVE : GL_ANY_SAMPLES_PASSED);
    }
    beginTransformFeedbackQuery() {
      return this.begin(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);
    }
    begin(target5) {
      if (this._queryPending) {
        return this;
      }
      this.target = target5;
      this.gl2.beginQuery(this.target, this.handle);
      return this;
    }
    end() {
      if (this._queryPending) {
        return this;
      }
      if (this.target) {
        this.gl2.endQuery(this.target);
        this.target = null;
        this._queryPending = true;
      }
      return this;
    }
    isResultAvailable() {
      if (!this._queryPending) {
        return false;
      }
      const resultAvailable = this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT_AVAILABLE);
      if (resultAvailable) {
        this._queryPending = false;
      }
      return resultAvailable;
    }
    isTimerDisjoint() {
      return this.gl2.getParameter(GL_GPU_DISJOINT_EXT2);
    }
    getResult() {
      return this.gl2.getQueryParameter(this.handle, GL_QUERY_RESULT);
    }
    getTimerMilliseconds() {
      return this.getResult() / 1e6;
    }
    createPoll() {
      let limit = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.POSITIVE_INFINITY;
      if (this._pollingPromise) {
        return this._pollingPromise;
      }
      let counter2 = 0;
      this._pollingPromise = new Promise((resolve2, reject) => {
        const poll = () => {
          if (this.isResultAvailable()) {
            resolve2(this.getResult());
            this._pollingPromise = null;
          } else if (counter2++ > limit) {
            reject("Timed out");
            this._pollingPromise = null;
          } else {
            requestAnimationFrame(poll);
          }
        };
        requestAnimationFrame(poll);
      });
      return this._pollingPromise;
    }
    _createHandle() {
      return Query.isSupported(this.gl) ? this.gl2.createQuery() : null;
    }
    _deleteHandle() {
      this.gl2.deleteQuery(this.handle);
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/classes/transform-feedback.js
  var TransformFeedback = class extends Resource {
    get [Symbol.toStringTag]() {
      return "TransformFeedback";
    }
    static isSupported(gl) {
      return isWebGL2(gl);
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assertWebGL2Context(gl);
      super(gl, props);
      this.initialize(props);
      this.stubRemovedMethods("TransformFeedback", "v6.0", ["pause", "resume"]);
      Object.seal(this);
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.buffers = {};
      this.unused = {};
      this.configuration = null;
      this.bindOnUse = true;
      if (!isObjectEmpty2(this.buffers)) {
        this.bind(() => this._unbindBuffers());
      }
      this.setProps(props);
      return this;
    }
    setProps(props) {
      if ("program" in props) {
        this.configuration = props.program && props.program.configuration;
      }
      if ("configuration" in props) {
        this.configuration = props.configuration;
      }
      if ("bindOnUse" in props) {
        props = props.bindOnUse;
      }
      if ("buffers" in props) {
        this.setBuffers(props.buffers);
      }
    }
    setBuffers() {
      let buffers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.bind(() => {
        for (const bufferName in buffers) {
          this.setBuffer(bufferName, buffers[bufferName]);
        }
      });
      return this;
    }
    setBuffer(locationOrName, bufferOrParams) {
      const location2 = this._getVaryingIndex(locationOrName);
      const {
        buffer,
        byteSize,
        byteOffset
      } = this._getBufferParams(bufferOrParams);
      if (location2 < 0) {
        this.unused[locationOrName] = buffer;
        log3.warn("".concat(this.id, " unused varying buffer ").concat(locationOrName))();
        return this;
      }
      this.buffers[location2] = bufferOrParams;
      if (!this.bindOnUse) {
        this._bindBuffer(location2, buffer, byteOffset, byteSize);
      }
      return this;
    }
    begin() {
      let primitiveMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      this.gl.bindTransformFeedback(36386, this.handle);
      this._bindBuffers();
      this.gl.beginTransformFeedback(primitiveMode);
      return this;
    }
    end() {
      this.gl.endTransformFeedback();
      this._unbindBuffers();
      this.gl.bindTransformFeedback(36386, null);
      return this;
    }
    _getBufferParams(bufferOrParams) {
      let byteOffset;
      let byteSize;
      let buffer;
      if (bufferOrParams instanceof Buffer2 === false) {
        buffer = bufferOrParams.buffer;
        byteSize = bufferOrParams.byteSize;
        byteOffset = bufferOrParams.byteOffset;
      } else {
        buffer = bufferOrParams;
      }
      if (byteOffset !== void 0 || byteSize !== void 0) {
        byteOffset = byteOffset || 0;
        byteSize = byteSize || buffer.byteLength - byteOffset;
      }
      return {
        buffer,
        byteOffset,
        byteSize
      };
    }
    _getVaryingInfo(locationOrName) {
      return this.configuration && this.configuration.getVaryingInfo(locationOrName);
    }
    _getVaryingIndex(locationOrName) {
      if (this.configuration) {
        return this.configuration.getVaryingInfo(locationOrName).location;
      }
      const location2 = Number(locationOrName);
      return Number.isFinite(location2) ? location2 : -1;
    }
    _bindBuffers() {
      if (this.bindOnUse) {
        for (const bufferIndex in this.buffers) {
          const {
            buffer,
            byteSize,
            byteOffset
          } = this._getBufferParams(this.buffers[bufferIndex]);
          this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);
        }
      }
    }
    _unbindBuffers() {
      if (this.bindOnUse) {
        for (const bufferIndex in this.buffers) {
          this._bindBuffer(bufferIndex, null);
        }
      }
    }
    _bindBuffer(index5, buffer) {
      let byteOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      let byteSize = arguments.length > 3 ? arguments[3] : void 0;
      const handle = buffer && buffer.handle;
      if (!handle || byteSize === void 0) {
        this.gl.bindBufferBase(35982, index5, handle);
      } else {
        this.gl.bindBufferRange(35982, index5, handle, byteOffset, byteSize);
      }
      return this;
    }
    _createHandle() {
      return this.gl.createTransformFeedback();
    }
    _deleteHandle() {
      this.gl.deleteTransformFeedback(this.handle);
    }
    _bindHandle(handle) {
      this.gl.bindTransformFeedback(36386, this.handle);
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/utils/array-utils-flat.js
  var arrayBuffer = null;
  function getScratchArrayBuffer(byteLength) {
    if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {
      arrayBuffer = new ArrayBuffer(byteLength);
    }
    return arrayBuffer;
  }
  function getScratchArray(Type, length7) {
    const scratchArrayBuffer = getScratchArrayBuffer(Type.BYTES_PER_ELEMENT * length7);
    return new Type(scratchArrayBuffer, 0, length7);
  }
  function fillArray(_ref) {
    let {
      target: target5,
      source,
      start: start2 = 0,
      count: count2 = 1
    } = _ref;
    const length7 = source.length;
    const total = count2 * length7;
    let copied = 0;
    for (let i = start2; copied < length7; copied++) {
      target5[i++] = source[copied];
    }
    while (copied < total) {
      if (copied < total - copied) {
        target5.copyWithin(start2 + copied, start2, start2 + copied);
        copied *= 2;
      } else {
        target5.copyWithin(start2 + copied, start2, start2 + total - copied);
        copied = total;
      }
    }
    return target5;
  }

  // node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array-object.js
  var ERR_ELEMENTS = "elements must be GL.ELEMENT_ARRAY_BUFFER";
  var VertexArrayObject = class extends Resource {
    get [Symbol.toStringTag]() {
      return "VertexArrayObject";
    }
    static isSupported(gl) {
      let options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (options2.constantAttributeZero) {
        return isWebGL2(gl) || getBrowser() === "Chrome";
      }
      return true;
    }
    static getDefaultArray(gl) {
      gl.luma = gl.luma || {};
      if (!gl.luma.defaultVertexArray) {
        gl.luma.defaultVertexArray = new VertexArrayObject(gl, {
          handle: null,
          isDefaultArray: true
        });
      }
      return gl.luma.defaultVertexArray;
    }
    static getMaxAttributes(gl) {
      VertexArrayObject.MAX_ATTRIBUTES = VertexArrayObject.MAX_ATTRIBUTES || gl.getParameter(34921);
      return VertexArrayObject.MAX_ATTRIBUTES;
    }
    static setConstant(gl, location2, array2) {
      switch (array2.constructor) {
        case Float32Array:
          VertexArrayObject._setConstantFloatArray(gl, location2, array2);
          break;
        case Int32Array:
          VertexArrayObject._setConstantIntArray(gl, location2, array2);
          break;
        case Uint32Array:
          VertexArrayObject._setConstantUintArray(gl, location2, array2);
          break;
        default:
          assert6(false);
      }
    }
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const id2 = opts.id || opts.program && opts.program.id;
      super(gl, Object.assign({}, opts, {
        id: id2
      }));
      this.buffer = null;
      this.bufferValue = null;
      this.isDefaultArray = opts.isDefaultArray || false;
      this.gl2 = gl;
      this.initialize(opts);
      Object.seal(this);
    }
    delete() {
      super.delete();
      if (this.buffer) {
        this.buffer.delete();
      }
      return this;
    }
    get MAX_ATTRIBUTES() {
      return VertexArrayObject.getMaxAttributes(this.gl);
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      return this.setProps(props);
    }
    setProps(props) {
      return this;
    }
    setElementBuffer() {
      let elementBuffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      assert6(!elementBuffer || elementBuffer.target === 34963, ERR_ELEMENTS);
      this.bind(() => {
        this.gl.bindBuffer(34963, elementBuffer ? elementBuffer.handle : null);
      });
      return this;
    }
    setBuffer(location2, buffer, accessor) {
      if (buffer.target === 34963) {
        return this.setElementBuffer(buffer, accessor);
      }
      const {
        size: size5,
        type,
        stride,
        offset,
        normalized,
        integer,
        divisor
      } = accessor;
      const {
        gl,
        gl2
      } = this;
      location2 = Number(location2);
      this.bind(() => {
        gl.bindBuffer(34962, buffer.handle);
        if (integer) {
          assert6(isWebGL2(gl));
          gl2.vertexAttribIPointer(location2, size5, type, stride, offset);
        } else {
          gl.vertexAttribPointer(location2, size5, type, normalized, stride, offset);
        }
        gl.enableVertexAttribArray(location2);
        gl2.vertexAttribDivisor(location2, divisor || 0);
      });
      return this;
    }
    enable(location2) {
      let enable2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
      const disablingAttributeZero = !enable2 && location2 === 0 && !VertexArrayObject.isSupported(this.gl, {
        constantAttributeZero: true
      });
      if (!disablingAttributeZero) {
        location2 = Number(location2);
        this.bind(() => enable2 ? this.gl.enableVertexAttribArray(location2) : this.gl.disableVertexAttribArray(location2));
      }
      return this;
    }
    getConstantBuffer(elementCount, value13) {
      const constantValue = this._normalizeConstantArrayValue(value13);
      const byteLength = constantValue.byteLength * elementCount;
      const length7 = constantValue.length * elementCount;
      let updateNeeded = !this.buffer;
      this.buffer = this.buffer || new Buffer2(this.gl, byteLength);
      updateNeeded = updateNeeded || this.buffer.reallocate(byteLength);
      updateNeeded = updateNeeded || !this._compareConstantArrayValues(constantValue, this.bufferValue);
      if (updateNeeded) {
        const typedArray = getScratchArray(value13.constructor, length7);
        fillArray({
          target: typedArray,
          source: constantValue,
          start: 0,
          count: length7
        });
        this.buffer.subData(typedArray);
        this.bufferValue = value13;
      }
      return this.buffer;
    }
    _normalizeConstantArrayValue(arrayValue) {
      if (Array.isArray(arrayValue)) {
        return new Float32Array(arrayValue);
      }
      return arrayValue;
    }
    _compareConstantArrayValues(v1, v2) {
      if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
        return false;
      }
      for (let i = 0; i < v1.length; ++i) {
        if (v1[i] !== v2[i]) {
          return false;
        }
      }
      return true;
    }
    static _setConstantFloatArray(gl, location2, array2) {
      switch (array2.length) {
        case 1:
          gl.vertexAttrib1fv(location2, array2);
          break;
        case 2:
          gl.vertexAttrib2fv(location2, array2);
          break;
        case 3:
          gl.vertexAttrib3fv(location2, array2);
          break;
        case 4:
          gl.vertexAttrib4fv(location2, array2);
          break;
        default:
          assert6(false);
      }
    }
    static _setConstantIntArray(gl, location2, array2) {
      assert6(isWebGL2(gl));
      switch (array2.length) {
        case 1:
          gl.vertexAttribI1iv(location2, array2);
          break;
        case 2:
          gl.vertexAttribI2iv(location2, array2);
          break;
        case 3:
          gl.vertexAttribI3iv(location2, array2);
          break;
        case 4:
          gl.vertexAttribI4iv(location2, array2);
          break;
        default:
          assert6(false);
      }
    }
    static _setConstantUintArray(gl, location2, array2) {
      assert6(isWebGL2(gl));
      switch (array2.length) {
        case 1:
          gl.vertexAttribI1uiv(location2, array2);
          break;
        case 2:
          gl.vertexAttribI2uiv(location2, array2);
          break;
        case 3:
          gl.vertexAttribI3uiv(location2, array2);
          break;
        case 4:
          gl.vertexAttribI4uiv(location2, array2);
          break;
        default:
          assert6(false);
      }
    }
    _createHandle() {
      const gl2 = this.gl;
      return gl2.createVertexArray();
    }
    _deleteHandle(handle) {
      this.gl2.deleteVertexArray(handle);
      return [this.elements];
    }
    _bindHandle(handle) {
      this.gl2.bindVertexArray(handle);
    }
    _getParameter(pname, _ref) {
      let {
        location: location2
      } = _ref;
      assert6(Number.isFinite(location2));
      return this.bind(() => {
        switch (pname) {
          case 34373:
            return this.gl.getVertexAttribOffset(location2, pname);
          default:
            return this.gl.getVertexAttrib(location2, pname);
        }
      });
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/classes/vertex-array.js
  var ERR_ATTRIBUTE_TYPE = "VertexArray: attributes must be Buffers or constants (i.e. typed array)";
  var MULTI_LOCATION_ATTRIBUTE_REGEXP = /^(.+)__LOCATION_([0-9]+)$/;
  var DEPRECATIONS_V6 = ["setBuffers", "setGeneric", "clearBindings", "setLocations", "setGenericValues", "setDivisor", "enable", "disable"];
  var VertexArray = class {
    constructor(gl) {
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const id2 = opts.id || opts.program && opts.program.id;
      this.id = id2;
      this.gl = gl;
      this.configuration = null;
      this.elements = null;
      this.elementsAccessor = null;
      this.values = null;
      this.accessors = null;
      this.unused = null;
      this.drawParams = null;
      this.buffer = null;
      this.attributes = {};
      this.vertexArrayObject = new VertexArrayObject(gl);
      stubRemovedMethods(this, "VertexArray", "v6.0", DEPRECATIONS_V6);
      this.initialize(opts);
      Object.seal(this);
    }
    delete() {
      if (this.buffer) {
        this.buffer.delete();
      }
      this.vertexArrayObject.delete();
    }
    initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.reset();
      this.configuration = null;
      this.bindOnUse = false;
      return this.setProps(props);
    }
    reset() {
      this.elements = null;
      this.elementsAccessor = null;
      const {
        MAX_ATTRIBUTES
      } = this.vertexArrayObject;
      this.values = new Array(MAX_ATTRIBUTES).fill(null);
      this.accessors = new Array(MAX_ATTRIBUTES).fill(null);
      this.unused = {};
      this.drawParams = null;
      return this;
    }
    setProps(props) {
      if ("program" in props) {
        this.configuration = props.program && props.program.configuration;
      }
      if ("configuration" in props) {
        this.configuration = props.configuration;
      }
      if ("attributes" in props) {
        this.setAttributes(props.attributes);
      }
      if ("elements" in props) {
        this.setElementBuffer(props.elements);
      }
      if ("bindOnUse" in props) {
        props = props.bindOnUse;
      }
      return this;
    }
    clearDrawParams() {
      this.drawParams = null;
    }
    getDrawParams() {
      this.drawParams = this.drawParams || this._updateDrawParams();
      return this.drawParams;
    }
    setAttributes(attributes) {
      Object.assign(this.attributes, attributes);
      this.vertexArrayObject.bind(() => {
        for (const locationOrName in attributes) {
          const value13 = attributes[locationOrName];
          this._setAttribute(locationOrName, value13);
        }
        this.gl.bindBuffer(34962, null);
      });
      return this;
    }
    setElementBuffer() {
      let elementBuffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      let accessor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.elements = elementBuffer;
      this.elementsAccessor = accessor;
      this.clearDrawParams();
      this.vertexArrayObject.setElementBuffer(elementBuffer, accessor);
      return this;
    }
    setBuffer(locationOrName, buffer) {
      let appAccessor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      if (buffer.target === 34963) {
        return this.setElementBuffer(buffer, appAccessor);
      }
      const {
        location: location2,
        accessor
      } = this._resolveLocationAndAccessor(locationOrName, buffer, buffer.accessor, appAccessor);
      if (location2 >= 0) {
        this.values[location2] = buffer;
        this.accessors[location2] = accessor;
        this.clearDrawParams();
        this.vertexArrayObject.setBuffer(location2, buffer, accessor);
      }
      return this;
    }
    setConstant(locationOrName, arrayValue) {
      let appAccessor = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      const {
        location: location2,
        accessor
      } = this._resolveLocationAndAccessor(locationOrName, arrayValue, Object.assign({
        size: arrayValue.length
      }, appAccessor));
      if (location2 >= 0) {
        arrayValue = this.vertexArrayObject._normalizeConstantArrayValue(arrayValue);
        this.values[location2] = arrayValue;
        this.accessors[location2] = accessor;
        this.clearDrawParams();
        this.vertexArrayObject.enable(location2, false);
      }
      return this;
    }
    unbindBuffers() {
      this.vertexArrayObject.bind(() => {
        if (this.elements) {
          this.vertexArrayObject.setElementBuffer(null);
        }
        this.buffer = this.buffer || new Buffer2(this.gl, {
          accessor: {
            size: 4
          }
        });
        for (let location2 = 0; location2 < this.vertexArrayObject.MAX_ATTRIBUTES; location2++) {
          if (this.values[location2] instanceof Buffer2) {
            this.gl.disableVertexAttribArray(location2);
            this.gl.bindBuffer(34962, this.buffer.handle);
            this.gl.vertexAttribPointer(location2, 1, 5126, false, 0, 0);
          }
        }
      });
      return this;
    }
    bindBuffers() {
      this.vertexArrayObject.bind(() => {
        if (this.elements) {
          this.setElementBuffer(this.elements);
        }
        for (let location2 = 0; location2 < this.vertexArrayObject.MAX_ATTRIBUTES; location2++) {
          const buffer = this.values[location2];
          if (buffer instanceof Buffer2) {
            this.setBuffer(location2, buffer);
          }
        }
      });
      return this;
    }
    bindForDraw(vertexCount, instanceCount, func11) {
      let value13;
      this.vertexArrayObject.bind(() => {
        this._setConstantAttributes(vertexCount, instanceCount);
        value13 = func11();
      });
      return value13;
    }
    _resolveLocationAndAccessor(locationOrName, value13, valueAccessor, appAccessor) {
      const INVALID_RESULT = {
        location: -1,
        accessor: null
      };
      const {
        location: location2,
        name: name16
      } = this._getAttributeIndex(locationOrName);
      if (!Number.isFinite(location2) || location2 < 0) {
        this.unused[locationOrName] = value13;
        log3.once(3, () => "unused value ".concat(locationOrName, " in ").concat(this.id))();
        return INVALID_RESULT;
      }
      const accessInfo = this._getAttributeInfo(name16 || location2);
      if (!accessInfo) {
        return INVALID_RESULT;
      }
      const currentAccessor = this.accessors[location2] || {};
      const accessor = Accessor.resolve(accessInfo.accessor, currentAccessor, valueAccessor, appAccessor);
      const {
        size: size5,
        type
      } = accessor;
      assert6(Number.isFinite(size5) && Number.isFinite(type));
      return {
        location: location2,
        accessor
      };
    }
    _getAttributeInfo(attributeName) {
      return this.configuration && this.configuration.getAttributeInfo(attributeName);
    }
    _getAttributeIndex(locationOrName) {
      const location2 = Number(locationOrName);
      if (Number.isFinite(location2)) {
        return {
          location: location2
        };
      }
      const multiLocation = MULTI_LOCATION_ATTRIBUTE_REGEXP.exec(locationOrName);
      const name16 = multiLocation ? multiLocation[1] : locationOrName;
      const locationOffset = multiLocation ? Number(multiLocation[2]) : 0;
      if (this.configuration) {
        return {
          location: this.configuration.getAttributeLocation(name16) + locationOffset,
          name: name16
        };
      }
      return {
        location: -1
      };
    }
    _setAttribute(locationOrName, value13) {
      if (value13 instanceof Buffer2) {
        this.setBuffer(locationOrName, value13);
      } else if (Array.isArray(value13) && value13.length && value13[0] instanceof Buffer2) {
        const buffer = value13[0];
        const accessor = value13[1];
        this.setBuffer(locationOrName, buffer, accessor);
      } else if (ArrayBuffer.isView(value13) || Array.isArray(value13)) {
        const constant = value13;
        this.setConstant(locationOrName, constant);
      } else if (value13.buffer instanceof Buffer2) {
        const accessor = value13;
        this.setBuffer(locationOrName, accessor.buffer, accessor);
      } else {
        throw new Error(ERR_ATTRIBUTE_TYPE);
      }
    }
    _setConstantAttributes(vertexCount, instanceCount) {
      const elementCount = Math.max(vertexCount | 0, instanceCount | 0);
      let constant = this.values[0];
      if (ArrayBuffer.isView(constant)) {
        this._setConstantAttributeZero(constant, elementCount);
      }
      for (let location2 = 1; location2 < this.vertexArrayObject.MAX_ATTRIBUTES; location2++) {
        constant = this.values[location2];
        if (ArrayBuffer.isView(constant)) {
          this._setConstantAttribute(location2, constant);
        }
      }
    }
    _setConstantAttributeZero(constant, elementCount) {
      if (VertexArrayObject.isSupported(this.gl, {
        constantAttributeZero: true
      })) {
        this._setConstantAttribute(0, constant);
        return;
      }
      const buffer = this.vertexArrayObject.getConstantBuffer(elementCount, constant);
      this.vertexArrayObject.setBuffer(0, buffer, this.accessors[0]);
    }
    _setConstantAttribute(location2, constant) {
      VertexArrayObject.setConstant(this.gl, location2, constant);
    }
    _updateDrawParams() {
      const drawParams = {
        isIndexed: false,
        isInstanced: false,
        indexCount: Infinity,
        vertexCount: Infinity,
        instanceCount: Infinity
      };
      for (let location2 = 0; location2 < this.vertexArrayObject.MAX_ATTRIBUTES; location2++) {
        this._updateDrawParamsForLocation(drawParams, location2);
      }
      if (this.elements) {
        drawParams.elementCount = this.elements.getElementCount(this.elements.accessor);
        drawParams.isIndexed = true;
        drawParams.indexType = this.elementsAccessor.type || this.elements.accessor.type;
        drawParams.indexOffset = this.elementsAccessor.offset || 0;
      }
      if (drawParams.indexCount === Infinity) {
        drawParams.indexCount = 0;
      }
      if (drawParams.vertexCount === Infinity) {
        drawParams.vertexCount = 0;
      }
      if (drawParams.instanceCount === Infinity) {
        drawParams.instanceCount = 0;
      }
      return drawParams;
    }
    _updateDrawParamsForLocation(drawParams, location2) {
      const value13 = this.values[location2];
      const accessor = this.accessors[location2];
      if (!value13) {
        return;
      }
      const {
        divisor
      } = accessor;
      const isInstanced = divisor > 0;
      drawParams.isInstanced = drawParams.isInstanced || isInstanced;
      if (value13 instanceof Buffer2) {
        const buffer = value13;
        if (isInstanced) {
          const instanceCount = buffer.getVertexCount(accessor);
          drawParams.instanceCount = Math.min(drawParams.instanceCount, instanceCount);
        } else {
          const vertexCount = buffer.getVertexCount(accessor);
          drawParams.vertexCount = Math.min(drawParams.vertexCount, vertexCount);
        }
      }
    }
    setElements() {
      let elementBuffer = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      let accessor = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      log3.deprecated("setElements", "setElementBuffer")();
      return this.setElementBuffer(elementBuffer, accessor);
    }
  };

  // node_modules/@luma.gl/webgl/dist/esm/utils/format-value.js
  function formatArrayValue(v, opts) {
    const {
      maxElts = 16,
      size: size5 = 1
    } = opts;
    let string13 = "[";
    for (let i = 0; i < v.length && i < maxElts; ++i) {
      if (i > 0) {
        string13 += ",".concat(i % size5 === 0 ? " " : "");
      }
      string13 += formatValue(v[i], opts);
    }
    const terminator = v.length > maxElts ? "..." : "]";
    return "".concat(string13).concat(terminator);
  }
  function formatValue(v) {
    let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const EPSILON5 = 1e-16;
    const {
      isInteger = false
    } = opts;
    if (Array.isArray(v) || ArrayBuffer.isView(v)) {
      return formatArrayValue(v, opts);
    }
    if (!Number.isFinite(v)) {
      return String(v);
    }
    if (Math.abs(v) < EPSILON5) {
      return isInteger ? "0" : "0.";
    }
    if (isInteger) {
      return v.toFixed(0);
    }
    if (Math.abs(v) > 100 && Math.abs(v) < 1e4) {
      return v.toFixed(0);
    }
    const string13 = v.toPrecision(2);
    const decimal = string13.indexOf(".0");
    return decimal === string13.length - 2 ? string13.slice(0, -1) : string13;
  }

  // node_modules/@luma.gl/webgl/dist/esm/debug/debug-uniforms.js
  function getDebugTableForUniforms(_ref) {
    let {
      header = "Uniforms",
      program,
      uniforms,
      undefinedOnly = false
    } = _ref;
    assert6(program);
    const SHADER_MODULE_UNIFORM_REGEXP = ".*_.*";
    const PROJECT_MODULE_UNIFORM_REGEXP = ".*Matrix";
    const uniformLocations = program._uniformSetters;
    const table = {};
    const uniformNames = Object.keys(uniformLocations).sort();
    let count2 = 0;
    for (const uniformName of uniformNames) {
      if (!uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) && !uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
        if (addUniformToTable({
          table,
          header,
          uniforms,
          uniformName,
          undefinedOnly
        })) {
          count2++;
        }
      }
    }
    for (const uniformName of uniformNames) {
      if (uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
        if (addUniformToTable({
          table,
          header,
          uniforms,
          uniformName,
          undefinedOnly
        })) {
          count2++;
        }
      }
    }
    for (const uniformName of uniformNames) {
      if (!table[uniformName]) {
        if (addUniformToTable({
          table,
          header,
          uniforms,
          uniformName,
          undefinedOnly
        })) {
          count2++;
        }
      }
    }
    let unusedCount = 0;
    const unusedTable = {};
    if (!undefinedOnly) {
      for (const uniformName in uniforms) {
        const uniform = uniforms[uniformName];
        if (!table[uniformName]) {
          unusedCount++;
          unusedTable[uniformName] = {
            Type: "NOT USED: ".concat(uniform),
            [header]: formatValue(uniform)
          };
        }
      }
    }
    return {
      table,
      count: count2,
      unusedTable,
      unusedCount
    };
  }
  function addUniformToTable(_ref2) {
    let {
      table,
      header,
      uniforms,
      uniformName,
      undefinedOnly
    } = _ref2;
    const value13 = uniforms[uniformName];
    const isDefined = isUniformDefined(value13);
    if (!undefinedOnly || !isDefined) {
      table[uniformName] = {
        [header]: isDefined ? formatValue(value13) : "N/A",
        "Uniform Type": isDefined ? value13 : "NOT PROVIDED"
      };
      return true;
    }
    return false;
  }
  function isUniformDefined(value13) {
    return value13 !== void 0 && value13 !== null;
  }

  // node_modules/@luma.gl/webgl/dist/esm/debug/debug-vertex-array.js
  function getDebugTableForVertexArray(_ref) {
    let {
      vertexArray,
      header = "Attributes"
    } = _ref;
    if (!vertexArray.configuration) {
      return {};
    }
    const table = {};
    if (vertexArray.elements) {
      table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);
    }
    const attributes = vertexArray.values;
    for (const attributeLocation in attributes) {
      const info = vertexArray._getAttributeInfo(attributeLocation);
      if (info) {
        let rowHeader = "".concat(attributeLocation, ": ").concat(info.name);
        const accessor = vertexArray.accessors[info.location];
        if (accessor) {
          rowHeader = "".concat(attributeLocation, ": ").concat(getGLSLDeclaration(info.name, accessor));
        }
        table[rowHeader] = getDebugTableRow(vertexArray, attributes[attributeLocation], accessor, header);
      }
    }
    return table;
  }
  function getDebugTableRow(vertexArray, attribute, accessor, header) {
    const {
      gl
    } = vertexArray;
    if (!attribute) {
      return {
        [header]: "null",
        "Format ": "N/A"
      };
    }
    let type = "NOT PROVIDED";
    let size5 = 1;
    let verts = 0;
    let bytes = 0;
    let isInteger;
    let marker;
    let value13;
    if (accessor) {
      type = accessor.type;
      size5 = accessor.size;
      type = String(type).replace("Array", "");
      isInteger = type.indexOf("nt") !== -1;
    }
    if (attribute instanceof Buffer2) {
      const buffer = attribute;
      const {
        data,
        changed
      } = buffer.getDebugData();
      marker = changed ? "*" : "";
      value13 = data;
      bytes = buffer.byteLength;
      verts = bytes / data.BYTES_PER_ELEMENT / size5;
      let format;
      if (accessor) {
        const instanced = accessor.divisor > 0;
        format = "".concat(instanced ? "I " : "P ", " ").concat(verts, " (x").concat(size5, "=").concat(bytes, " bytes ").concat(getKey(gl, type), ")");
      } else {
        isInteger = true;
        format = "".concat(bytes, " bytes");
      }
      return {
        [header]: "".concat(marker).concat(formatValue(value13, {
          size: size5,
          isInteger
        })),
        "Format ": format
      };
    }
    value13 = attribute;
    size5 = attribute.length;
    type = String(attribute.constructor.name).replace("Array", "");
    isInteger = type.indexOf("nt") !== -1;
    return {
      [header]: "".concat(formatValue(value13, {
        size: size5,
        isInteger
      }), " (constant)"),
      "Format ": "".concat(size5, "x").concat(type, " (constant)")
    };
  }
  function getGLSLDeclaration(name16, accessor) {
    const {
      type,
      size: size5
    } = accessor;
    const typeAndName = getCompositeGLType(type, size5);
    return typeAndName ? "".concat(name16, " (").concat(typeAndName.name, ")") : name16;
  }

  // node_modules/@luma.gl/webgl/dist/esm/debug/debug-program-configuration.js
  function getDebugTableForProgramConfiguration(config2) {
    const table = {};
    const header = "Accessors for ".concat(config2.id);
    for (const attributeInfo of config2.attributeInfos) {
      if (attributeInfo) {
        const glslDeclaration = getGLSLDeclaration2(attributeInfo);
        table["in ".concat(glslDeclaration)] = {
          [header]: JSON.stringify(attributeInfo.accessor)
        };
      }
    }
    for (const varyingInfo of config2.varyingInfos) {
      if (varyingInfo) {
        const glslDeclaration = getGLSLDeclaration2(varyingInfo);
        table["out ".concat(glslDeclaration)] = {
          [header]: JSON.stringify(varyingInfo.accessor)
        };
      }
    }
    return table;
  }
  function getGLSLDeclaration2(attributeInfo) {
    const {
      type,
      size: size5
    } = attributeInfo.accessor;
    const typeAndName = getCompositeGLType(type, size5);
    if (typeAndName) {
      return "".concat(typeAndName.name, " ").concat(attributeInfo.name);
    }
    return attributeInfo.name;
  }

  // node_modules/@luma.gl/engine/dist/esm/lib/animation-loop.js
  var isPage2 = isBrowser5() && typeof document !== "undefined";
  var statIdCounter = 0;
  var AnimationLoop = class {
    constructor() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        onCreateContext = (opts) => createGLContext(opts),
        onAddHTML = null,
        onInitialize = () => {
        },
        onRender = () => {
        },
        onFinalize = () => {
        },
        onError,
        gl = null,
        glOptions = {},
        debug: debug2 = false,
        createFramebuffer = false,
        autoResizeViewport = true,
        autoResizeDrawingBuffer = true,
        stats = lumaStats.get("animation-loop-".concat(statIdCounter++))
      } = props;
      let {
        useDevicePixels = true
      } = props;
      if ("useDevicePixelRatio" in props) {
        log3.deprecated("useDevicePixelRatio", "useDevicePixels")();
        useDevicePixels = props.useDevicePixelRatio;
      }
      this.props = {
        onCreateContext,
        onAddHTML,
        onInitialize,
        onRender,
        onFinalize,
        onError,
        gl,
        glOptions,
        debug: debug2,
        createFramebuffer
      };
      this.gl = gl;
      this.needsRedraw = null;
      this.timeline = null;
      this.stats = stats;
      this.cpuTime = this.stats.get("CPU Time");
      this.gpuTime = this.stats.get("GPU Time");
      this.frameRate = this.stats.get("Frame Rate");
      this._initialized = false;
      this._running = false;
      this._animationFrameId = null;
      this._nextFramePromise = null;
      this._resolveNextFrame = null;
      this._cpuStartTime = 0;
      this.setProps({
        autoResizeViewport,
        autoResizeDrawingBuffer,
        useDevicePixels
      });
      this.start = this.start.bind(this);
      this.stop = this.stop.bind(this);
      this._pageLoadPromise = null;
      this._onMousemove = this._onMousemove.bind(this);
      this._onMouseleave = this._onMouseleave.bind(this);
    }
    delete() {
      this.stop();
      this._setDisplay(null);
    }
    setNeedsRedraw(reason) {
      assert6(typeof reason === "string");
      this.needsRedraw = this.needsRedraw || reason;
      return this;
    }
    setProps(props) {
      if ("autoResizeViewport" in props) {
        this.autoResizeViewport = props.autoResizeViewport;
      }
      if ("autoResizeDrawingBuffer" in props) {
        this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
      }
      if ("useDevicePixels" in props) {
        this.useDevicePixels = props.useDevicePixels;
      }
      return this;
    }
    start() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (this._running) {
        return this;
      }
      this._running = true;
      const startPromise = this._getPageLoadPromise().then(() => {
        if (!this._running || this._initialized) {
          return null;
        }
        this._createWebGLContext(opts);
        this._createFramebuffer();
        this._startEventHandling();
        this._initializeCallbackData();
        this._updateCallbackData();
        this._resizeCanvasDrawingBuffer();
        this._resizeViewport();
        this._gpuTimeQuery = Query.isSupported(this.gl, ["timers"]) ? new Query(this.gl) : null;
        this._initialized = true;
        return this.onInitialize(this.animationProps);
      }).then((appContext) => {
        if (this._running) {
          this._addCallbackData(appContext || {});
          if (appContext !== false) {
            this._startLoop();
          }
        }
      });
      if (this.props.onError) {
        startPromise.catch(this.props.onError);
      }
      return this;
    }
    redraw() {
      if (this.isContextLost()) {
        return this;
      }
      this._beginTimers();
      this._setupFrame();
      this._updateCallbackData();
      this._renderFrame(this.animationProps);
      this._clearNeedsRedraw();
      if (this.offScreen && this.gl.commit) {
        this.gl.commit();
      }
      if (this._resolveNextFrame) {
        this._resolveNextFrame(this);
        this._nextFramePromise = null;
        this._resolveNextFrame = null;
      }
      this._endTimers();
      return this;
    }
    stop() {
      if (this._running) {
        this._finalizeCallbackData();
        this._cancelAnimationFrame(this._animationFrameId);
        this._nextFramePromise = null;
        this._resolveNextFrame = null;
        this._animationFrameId = null;
        this._running = false;
      }
      return this;
    }
    attachTimeline(timeline) {
      this.timeline = timeline;
      return this.timeline;
    }
    detachTimeline() {
      this.timeline = null;
    }
    waitForRender() {
      this.setNeedsRedraw("waitForRender");
      if (!this._nextFramePromise) {
        this._nextFramePromise = new Promise((resolve2) => {
          this._resolveNextFrame = resolve2;
        });
      }
      return this._nextFramePromise;
    }
    async toDataURL() {
      this.setNeedsRedraw("toDataURL");
      await this.waitForRender();
      return this.gl.canvas.toDataURL();
    }
    isContextLost() {
      return this.gl.isContextLost();
    }
    onCreateContext() {
      return this.props.onCreateContext(...arguments);
    }
    onInitialize() {
      return this.props.onInitialize(...arguments);
    }
    onRender() {
      return this.props.onRender(...arguments);
    }
    onFinalize() {
      return this.props.onFinalize(...arguments);
    }
    getHTMLControlValue(id2) {
      let defaultValue4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      const element = document.getElementById(id2);
      return element ? Number(element.value) : defaultValue4;
    }
    setViewParameters() {
      log3.removed("AnimationLoop.setViewParameters", "AnimationLoop.setProps")();
      return this;
    }
    _startLoop() {
      const renderFrame = () => {
        if (!this._running) {
          return;
        }
        this.redraw();
        this._animationFrameId = this._requestAnimationFrame(renderFrame);
      };
      this._cancelAnimationFrame(this._animationFrameId);
      this._animationFrameId = this._requestAnimationFrame(renderFrame);
    }
    _getPageLoadPromise() {
      if (!this._pageLoadPromise) {
        this._pageLoadPromise = isPage2 ? new Promise((resolve2, reject) => {
          if (isPage2 && document.readyState === "complete") {
            resolve2(document);
            return;
          }
          window.addEventListener("load", () => {
            resolve2(document);
          });
        }) : Promise.resolve({});
      }
      return this._pageLoadPromise;
    }
    _setDisplay(display) {
      if (this.display) {
        this.display.delete();
        this.display.animationLoop = null;
      }
      if (display) {
        display.animationLoop = this;
      }
      this.display = display;
    }
    _cancelAnimationFrame(animationFrameId) {
      if (this.display && this.display.cancelAnimationFrame) {
        return this.display.cancelAnimationFrame(animationFrameId);
      }
      return cancelAnimationFrame2(animationFrameId);
    }
    _requestAnimationFrame(renderFrameCallback) {
      if (this._running) {
        if (this.display && this.display.requestAnimationFrame) {
          return this.display.requestAnimationFrame(renderFrameCallback);
        }
        return requestAnimationFrame2(renderFrameCallback);
      }
      return void 0;
    }
    _renderFrame() {
      if (this.display) {
        this.display._renderFrame(...arguments);
        return;
      }
      this.onRender(...arguments);
    }
    _clearNeedsRedraw() {
      this.needsRedraw = null;
    }
    _setupFrame() {
      this._resizeCanvasDrawingBuffer();
      this._resizeViewport();
      this._resizeFramebuffer();
    }
    _initializeCallbackData() {
      this.animationProps = {
        gl: this.gl,
        stop: this.stop,
        canvas: this.gl.canvas,
        framebuffer: this.framebuffer,
        useDevicePixels: this.useDevicePixels,
        needsRedraw: null,
        startTime: Date.now(),
        engineTime: 0,
        tick: 0,
        tock: 0,
        time: 0,
        _timeline: this.timeline,
        _loop: this,
        _animationLoop: this,
        _mousePosition: null
      };
    }
    _updateCallbackData() {
      const {
        width: width8,
        height: height8,
        aspect
      } = this._getSizeAndAspect();
      if (width8 !== this.animationProps.width || height8 !== this.animationProps.height) {
        this.setNeedsRedraw("drawing buffer resized");
      }
      if (aspect !== this.animationProps.aspect) {
        this.setNeedsRedraw("drawing buffer aspect changed");
      }
      this.animationProps.width = width8;
      this.animationProps.height = height8;
      this.animationProps.aspect = aspect;
      this.animationProps.needsRedraw = this.needsRedraw;
      this.animationProps.engineTime = Date.now() - this.animationProps.startTime;
      if (this.timeline) {
        this.timeline.update(this.animationProps.engineTime);
      }
      this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60);
      this.animationProps.tock++;
      this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
      this.animationProps._offScreen = this.offScreen;
    }
    _finalizeCallbackData() {
      this.onFinalize(this.animationProps);
    }
    _addCallbackData(appContext) {
      if (typeof appContext === "object" && appContext !== null) {
        this.animationProps = Object.assign({}, this.animationProps, appContext);
      }
    }
    _createWebGLContext(opts) {
      this.offScreen = opts.canvas && typeof OffscreenCanvas !== "undefined" && opts.canvas instanceof OffscreenCanvas;
      opts = Object.assign({}, opts, this.props.glOptions);
      this.gl = this.props.gl ? instrumentGLContext(this.props.gl, opts) : this.onCreateContext(opts);
      if (!isWebGL(this.gl)) {
        throw new Error("AnimationLoop.onCreateContext - illegal context returned");
      }
      resetParameters(this.gl);
      this._createInfoDiv();
    }
    _createInfoDiv() {
      if (this.gl.canvas && this.props.onAddHTML) {
        const wrapperDiv = document.createElement("div");
        document.body.appendChild(wrapperDiv);
        wrapperDiv.style.position = "relative";
        const div2 = document.createElement("div");
        div2.style.position = "absolute";
        div2.style.left = "10px";
        div2.style.bottom = "10px";
        div2.style.width = "300px";
        div2.style.background = "white";
        wrapperDiv.appendChild(this.gl.canvas);
        wrapperDiv.appendChild(div2);
        const html = this.props.onAddHTML(div2);
        if (html) {
          div2.innerHTML = html;
        }
      }
    }
    _getSizeAndAspect() {
      const width8 = this.gl.drawingBufferWidth;
      const height8 = this.gl.drawingBufferHeight;
      let aspect = 1;
      const {
        canvas
      } = this.gl;
      if (canvas && canvas.clientHeight) {
        aspect = canvas.clientWidth / canvas.clientHeight;
      } else if (width8 > 0 && height8 > 0) {
        aspect = width8 / height8;
      }
      return {
        width: width8,
        height: height8,
        aspect
      };
    }
    _resizeViewport() {
      if (this.autoResizeViewport) {
        this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
      }
    }
    _resizeCanvasDrawingBuffer() {
      if (this.autoResizeDrawingBuffer) {
        resizeGLContext(this.gl, {
          useDevicePixels: this.useDevicePixels
        });
      }
    }
    _createFramebuffer() {
      if (this.props.createFramebuffer) {
        this.framebuffer = new Framebuffer(this.gl);
      }
    }
    _resizeFramebuffer() {
      if (this.framebuffer) {
        this.framebuffer.resize({
          width: this.gl.drawingBufferWidth,
          height: this.gl.drawingBufferHeight
        });
      }
    }
    _beginTimers() {
      this.frameRate.timeEnd();
      this.frameRate.timeStart();
      if (this._gpuTimeQuery && this._gpuTimeQuery.isResultAvailable() && !this._gpuTimeQuery.isTimerDisjoint()) {
        this.stats.get("GPU Time").addTime(this._gpuTimeQuery.getTimerMilliseconds());
      }
      if (this._gpuTimeQuery) {
        this._gpuTimeQuery.beginTimeElapsedQuery();
      }
      this.cpuTime.timeStart();
    }
    _endTimers() {
      this.cpuTime.timeEnd();
      if (this._gpuTimeQuery) {
        this._gpuTimeQuery.end();
      }
    }
    _startEventHandling() {
      const {
        canvas
      } = this.gl;
      if (canvas) {
        canvas.addEventListener("mousemove", this._onMousemove);
        canvas.addEventListener("mouseleave", this._onMouseleave);
      }
    }
    _onMousemove(e) {
      this.animationProps._mousePosition = [e.offsetX, e.offsetY];
    }
    _onMouseleave(e) {
      this.animationProps._mousePosition = null;
    }
  };

  // node_modules/@luma.gl/shadertools/dist/esm/lib/constants.js
  var VERTEX_SHADER = "vs";
  var FRAGMENT_SHADER = "fs";

  // node_modules/@luma.gl/shadertools/dist/esm/utils/assert.js
  function assert7(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "shadertools: assertion failed.");
    }
  }

  // node_modules/@luma.gl/shadertools/dist/esm/lib/filters/prop-types.js
  var TYPE_DEFINITIONS = {
    number: {
      validate(value13, propType) {
        return Number.isFinite(value13) && (!("max" in propType) || value13 <= propType.max) && (!("min" in propType) || value13 >= propType.min);
      }
    },
    array: {
      validate(value13, propType) {
        return Array.isArray(value13) || ArrayBuffer.isView(value13);
      }
    }
  };
  function parsePropTypes(propDefs) {
    const propTypes16 = {};
    for (const propName in propDefs) {
      const propDef = propDefs[propName];
      const propType = parsePropType(propDef);
      propTypes16[propName] = propType;
    }
    return propTypes16;
  }
  function parsePropType(propDef) {
    let type = getTypeOf(propDef);
    if (type === "object") {
      if (!propDef) {
        return {
          type: "object",
          value: null
        };
      }
      if ("type" in propDef) {
        return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);
      }
      if (!("value" in propDef)) {
        return {
          type: "object",
          value: propDef
        };
      }
      type = getTypeOf(propDef.value);
      return Object.assign({
        type
      }, propDef, TYPE_DEFINITIONS[type]);
    }
    return Object.assign({
      type,
      value: propDef
    }, TYPE_DEFINITIONS[type]);
  }
  function getTypeOf(value13) {
    if (Array.isArray(value13) || ArrayBuffer.isView(value13)) {
      return "array";
    }
    return typeof value13;
  }

  // node_modules/@luma.gl/shadertools/dist/esm/lib/shader-module.js
  var VERTEX_SHADER2 = "vs";
  var FRAGMENT_SHADER2 = "fs";
  var ShaderModule = class {
    constructor(_ref) {
      let {
        name: name16,
        vs: vs7,
        fs: fs4,
        dependencies = [],
        uniforms,
        getUniforms: getUniforms3,
        deprecations = [],
        defines: defines2 = {},
        inject = {},
        vertexShader,
        fragmentShader
      } = _ref;
      assert7(typeof name16 === "string");
      this.name = name16;
      this.vs = vs7 || vertexShader;
      this.fs = fs4 || fragmentShader;
      this.getModuleUniforms = getUniforms3;
      this.dependencies = dependencies;
      this.deprecations = this._parseDeprecationDefinitions(deprecations);
      this.defines = defines2;
      this.injections = normalizeInjections(inject);
      if (uniforms) {
        this.uniforms = parsePropTypes(uniforms);
      }
    }
    getModuleSource(type) {
      let moduleSource;
      switch (type) {
        case VERTEX_SHADER2:
          moduleSource = this.vs || "";
          break;
        case FRAGMENT_SHADER2:
          moduleSource = this.fs || "";
          break;
        default:
          assert7(false);
      }
      return "#define MODULE_".concat(this.name.toUpperCase().replace(/[^0-9a-z]/gi, "_"), "\n").concat(moduleSource, "// END MODULE_").concat(this.name, "\n\n");
    }
    getUniforms(opts, uniforms) {
      if (this.getModuleUniforms) {
        return this.getModuleUniforms(opts, uniforms);
      }
      if (this.uniforms) {
        return this._defaultGetUniforms(opts);
      }
      return {};
    }
    getDefines() {
      return this.defines;
    }
    checkDeprecations(shaderSource, log5) {
      this.deprecations.forEach((def) => {
        if (def.regex.test(shaderSource)) {
          if (def.deprecated) {
            log5.deprecated(def.old, def.new)();
          } else {
            log5.removed(def.old, def.new)();
          }
        }
      });
    }
    _parseDeprecationDefinitions(deprecations) {
      deprecations.forEach((def) => {
        switch (def.type) {
          case "function":
            def.regex = new RegExp("\\b".concat(def.old, "\\("));
            break;
          default:
            def.regex = new RegExp("".concat(def.type, " ").concat(def.old, ";"));
        }
      });
      return deprecations;
    }
    _defaultGetUniforms() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const uniforms = {};
      const propTypes16 = this.uniforms;
      for (const key in propTypes16) {
        const propDef = propTypes16[key];
        if (key in opts && !propDef.private) {
          if (propDef.validate) {
            assert7(propDef.validate(opts[key], propDef), "".concat(this.name, ": invalid ").concat(key));
          }
          uniforms[key] = opts[key];
        } else {
          uniforms[key] = propDef.value;
        }
      }
      return uniforms;
    }
  };
  function normalizeInjections(injections) {
    const result = {
      vs: {},
      fs: {}
    };
    for (const hook in injections) {
      let injection = injections[hook];
      const stage = hook.slice(0, 2);
      if (typeof injection === "string") {
        injection = {
          order: 0,
          injection
        };
      }
      result[stage][hook] = injection;
    }
    return result;
  }

  // node_modules/@luma.gl/shadertools/dist/esm/lib/resolve-modules.js
  function resolveModules(modules) {
    return getShaderDependencies(instantiateModules(modules));
  }
  function getShaderDependencies(modules) {
    const moduleMap = {};
    const moduleDepth = {};
    getDependencyGraph({
      modules,
      level: 0,
      moduleMap,
      moduleDepth
    });
    return Object.keys(moduleDepth).sort((a, b) => moduleDepth[b] - moduleDepth[a]).map((name16) => moduleMap[name16]);
  }
  function getDependencyGraph(_ref) {
    let {
      modules,
      level,
      moduleMap,
      moduleDepth
    } = _ref;
    if (level >= 5) {
      throw new Error("Possible loop in shader dependency graph");
    }
    for (const module of modules) {
      moduleMap[module.name] = module;
      if (moduleDepth[module.name] === void 0 || moduleDepth[module.name] < level) {
        moduleDepth[module.name] = level;
      }
    }
    for (const module of modules) {
      if (module.dependencies) {
        getDependencyGraph({
          modules: module.dependencies,
          level: level + 1,
          moduleMap,
          moduleDepth
        });
      }
    }
  }
  function instantiateModules(modules, seen) {
    return modules.map((module) => {
      if (module instanceof ShaderModule) {
        return module;
      }
      assert7(typeof module !== "string", "Shader module use by name is deprecated. Import shader module '".concat(module, "' and use it directly."));
      assert7(module.name, "shader module has no name");
      module = new ShaderModule(module);
      module.dependencies = instantiateModules(module.dependencies);
      return module;
    });
  }

  // node_modules/@luma.gl/shadertools/dist/esm/utils/is-old-ie.js
  function isOldIE() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const navigator3 = typeof window !== "undefined" ? window.navigator || {} : {};
    const userAgent3 = opts.userAgent || navigator3.userAgent || "";
    const isMSIE = userAgent3.indexOf("MSIE ") !== -1;
    const isTrident = userAgent3.indexOf("Trident/") !== -1;
    return isMSIE || isTrident;
  }

  // node_modules/@luma.gl/shadertools/dist/esm/utils/webgl-info.js
  var GL_VENDOR = 7936;
  var GL_RENDERER = 7937;
  var GL_VERSION = 7938;
  var GL_SHADING_LANGUAGE_VERSION = 35724;
  var WEBGL_FEATURES = {
    GLSL_FRAG_DATA: ["WEBGL_draw_buffers", true],
    GLSL_FRAG_DEPTH: ["EXT_frag_depth", true],
    GLSL_DERIVATIVES: ["OES_standard_derivatives", true],
    GLSL_TEXTURE_LOD: ["EXT_shader_texture_lod", true]
  };
  var FEATURES2 = {};
  Object.keys(WEBGL_FEATURES).forEach((key) => {
    FEATURES2[key] = key;
  });
  function isWebGL22(gl) {
    if (typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext) {
      return true;
    }
    return Boolean(gl && gl._version === 2);
  }
  function getContextInfo(gl) {
    const info = gl.getExtension("WEBGL_debug_renderer_info");
    const vendor = gl.getParameter(info && info.UNMASKED_VENDOR_WEBGL || GL_VENDOR);
    const renderer = gl.getParameter(info && info.UNMASKED_RENDERER_WEBGL || GL_RENDERER);
    const gpuVendor = identifyGPUVendor(vendor, renderer);
    const gpuInfo = {
      gpuVendor,
      vendor,
      renderer,
      version: gl.getParameter(GL_VERSION),
      shadingLanguageVersion: gl.getParameter(GL_SHADING_LANGUAGE_VERSION)
    };
    return gpuInfo;
  }
  function identifyGPUVendor(vendor, renderer) {
    if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) {
      return "NVIDIA";
    }
    if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) {
      return "INTEL";
    }
    if (vendor.match(/AMD/i) || renderer.match(/AMD/i) || vendor.match(/ATI/i) || renderer.match(/ATI/i)) {
      return "AMD";
    }
    return "UNKNOWN GPU";
  }
  var compiledGlslExtensions = {};
  function canCompileGLGSExtension(gl, cap) {
    let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const feature = WEBGL_FEATURES[cap];
    assert7(feature, cap);
    if (!isOldIE(opts)) {
      return true;
    }
    if (cap in compiledGlslExtensions) {
      return compiledGlslExtensions[cap];
    }
    const extensionName = feature[0];
    const behavior = opts.behavior || "enable";
    const source = "#extension GL_".concat(extensionName, " : ").concat(behavior, "\nvoid main(void) {}");
    const shader = gl.createShader(35633);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    const canCompile = gl.getShaderParameter(shader, 35713);
    gl.deleteShader(shader);
    compiledGlslExtensions[cap] = canCompile;
    return canCompile;
  }
  function getFeature(gl, cap) {
    const feature = WEBGL_FEATURES[cap];
    assert7(feature, cap);
    const extensionName = isWebGL22(gl) ? feature[1] || feature[0] : feature[0];
    const value13 = typeof extensionName === "string" ? Boolean(gl.getExtension(extensionName)) : extensionName;
    assert7(value13 === false || value13 === true);
    return value13;
  }
  function hasFeatures2(gl, features) {
    features = Array.isArray(features) ? features : [features];
    return features.every((feature) => getFeature(gl, feature));
  }

  // node_modules/@luma.gl/shadertools/dist/esm/lib/platform-defines.js
  function getPlatformShaderDefines(gl) {
    const debugInfo = getContextInfo(gl);
    switch (debugInfo.gpuVendor.toLowerCase()) {
      case "nvidia":
        return "#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n";
      case "intel":
        return "#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
      case "amd":
        return "#define AMD_GPU\n";
      default:
        return "#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n";
    }
  }
  function getVersionDefines(gl, glslVersion, isFragment) {
    let versionDefines = "#if (__VERSION__ > 120)\n\n# define FEATURE_GLSL_DERIVATIVES\n# define FEATURE_GLSL_DRAW_BUFFERS\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FEATURE_GLSL_TEXTURE_LOD\n\n// DEPRECATED FLAGS, remove in v9\n# define FRAG_DEPTH\n# define DERIVATIVES\n# define DRAW_BUFFERS\n# define TEXTURE_LOD\n\n#endif // __VERSION\n";
    if (hasFeatures2(gl, FEATURES2.GLSL_FRAG_DEPTH)) {
      versionDefines += "\n// FRAG_DEPTH => gl_FragDepth is available\n#ifdef GL_EXT_frag_depth\n#extension GL_EXT_frag_depth : enable\n# define FEATURE_GLSL_FRAG_DEPTH\n# define FRAG_DEPTH\n# define gl_FragDepth gl_FragDepthEXT\n#endif\n";
    }
    if (hasFeatures2(gl, FEATURES2.GLSL_DERIVATIVES) && canCompileGLGSExtension(gl, FEATURES2.GLSL_DERIVATIVES)) {
      versionDefines += "\n// DERIVATIVES => dxdF, dxdY and fwidth are available\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n# define FEATURE_GLSL_DERIVATIVES\n# define DERIVATIVES\n#endif\n";
    }
    if (hasFeatures2(gl, FEATURES2.GLSL_FRAG_DATA) && canCompileGLGSExtension(gl, FEATURES2.GLSL_FRAG_DATA, {
      behavior: "require"
    })) {
      versionDefines += "\n// DRAW_BUFFERS => gl_FragData[] is available\n#ifdef GL_EXT_draw_buffers\n#extension GL_EXT_draw_buffers : require\n#define FEATURE_GLSL_DRAW_BUFFERS\n#define DRAW_BUFFERS\n#endif\n";
    }
    if (hasFeatures2(gl, FEATURES2.GLSL_TEXTURE_LOD)) {
      versionDefines += "// TEXTURE_LOD => texture2DLod etc are available\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod : enable\n\n# define FEATURE_GLSL_TEXTURE_LOD\n# define TEXTURE_LOD\n\n#endif\n";
    }
    return versionDefines;
  }

  // node_modules/@luma.gl/shadertools/dist/esm/modules/module-injectors.js
  var MODULE_INJECTORS_VS = "#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n";
  var MODULE_INJECTORS_FS = "#ifdef MODULE_MATERIAL\n  gl_FragColor = material_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  gl_FragColor = lighting_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_FOG\n  gl_FragColor = fog_filterColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n";

  // node_modules/@luma.gl/shadertools/dist/esm/lib/inject-shader.js
  var MODULE_INJECTORS = {
    [VERTEX_SHADER]: MODULE_INJECTORS_VS,
    [FRAGMENT_SHADER]: MODULE_INJECTORS_FS
  };
  var DECLARATION_INJECT_MARKER = "__LUMA_INJECT_DECLARATIONS__";
  var REGEX_START_OF_MAIN = /void\s+main\s*\([^)]*\)\s*\{\n?/;
  var REGEX_END_OF_MAIN = /}\n?[^{}]*$/;
  var fragments = [];
  function injectShader(source, type, inject) {
    let injectStandardStubs = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    const isVertex = type === VERTEX_SHADER;
    for (const key in inject) {
      const fragmentData = inject[key];
      fragmentData.sort((a, b) => a.order - b.order);
      fragments.length = fragmentData.length;
      for (let i = 0, len = fragmentData.length; i < len; ++i) {
        fragments[i] = fragmentData[i].injection;
      }
      const fragmentString = "".concat(fragments.join("\n"), "\n");
      switch (key) {
        case "vs:#decl":
          if (isVertex) {
            source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
          }
          break;
        case "vs:#main-start":
          if (isVertex) {
            source = source.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
          }
          break;
        case "vs:#main-end":
          if (isVertex) {
            source = source.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
          }
          break;
        case "fs:#decl":
          if (!isVertex) {
            source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
          }
          break;
        case "fs:#main-start":
          if (!isVertex) {
            source = source.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);
          }
          break;
        case "fs:#main-end":
          if (!isVertex) {
            source = source.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);
          }
          break;
        default:
          source = source.replace(key, (match) => match + fragmentString);
      }
    }
    source = source.replace(DECLARATION_INJECT_MARKER, "");
    if (injectStandardStubs) {
      source = source.replace(/\}\s*$/, (match) => match + MODULE_INJECTORS[type]);
    }
    return source;
  }
  function combineInjects(injects) {
    const result = {};
    assert7(Array.isArray(injects) && injects.length > 1);
    injects.forEach((inject) => {
      for (const key in inject) {
        result[key] = result[key] ? "".concat(result[key], "\n").concat(inject[key]) : inject[key];
      }
    });
    return result;
  }

  // node_modules/@luma.gl/shadertools/dist/esm/lib/transpile-shader.js
  function testVariable(qualifier) {
    return new RegExp("\\b".concat(qualifier, "[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)"), "g");
  }
  var ES300_REPLACEMENTS = [[/^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/, "#version 300 es\n"], [/\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g, "textureLod("], [/\btexture(2D|2DProj|Cube)(EXT)?\(/g, "texture("]];
  var ES300_VERTEX_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable("attribute"), "in $1"], [testVariable("varying"), "out $1"]];
  var ES300_FRAGMENT_REPLACEMENTS = [...ES300_REPLACEMENTS, [testVariable("varying"), "in $1"]];
  var ES100_REPLACEMENTS = [[/^#version[ \t]+300[ \t]+es/, "#version 100"], [/\btexture(2D|2DProj|Cube)Lod\(/g, "texture$1LodEXT("], [/\btexture\(/g, "texture2D("], [/\btextureLod\(/g, "texture2DLodEXT("]];
  var ES100_VERTEX_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable("in"), "attribute $1"], [testVariable("out"), "varying $1"]];
  var ES100_FRAGMENT_REPLACEMENTS = [...ES100_REPLACEMENTS, [testVariable("in"), "varying $1"]];
  var ES100_FRAGMENT_OUTPUT_NAME = "gl_FragColor";
  var ES300_FRAGMENT_OUTPUT_REGEX = /\bout[ \t]+vec4[ \t]+(\w+)[ \t]*;\n?/;
  var REGEX_START_OF_MAIN2 = /void\s+main\s*\([^)]*\)\s*\{\n?/;
  function transpileShader(source, targetGLSLVersion, isVertex) {
    switch (targetGLSLVersion) {
      case 300:
        return isVertex ? convertShader(source, ES300_VERTEX_REPLACEMENTS) : convertFragmentShaderTo300(source);
      case 100:
        return isVertex ? convertShader(source, ES100_VERTEX_REPLACEMENTS) : convertFragmentShaderTo100(source);
      default:
        throw new Error("unknown GLSL version ".concat(targetGLSLVersion));
    }
  }
  function convertShader(source, replacements) {
    for (const [pattern2, replacement] of replacements) {
      source = source.replace(pattern2, replacement);
    }
    return source;
  }
  function convertFragmentShaderTo300(source) {
    source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);
    const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);
    if (outputMatch) {
      const outputName = outputMatch[1];
      source = source.replace(new RegExp("\\b".concat(ES100_FRAGMENT_OUTPUT_NAME, "\\b"), "g"), outputName);
    } else {
      const outputName = "fragmentColor";
      source = source.replace(REGEX_START_OF_MAIN2, (match) => "out vec4 ".concat(outputName, ";\n").concat(match)).replace(new RegExp("\\b".concat(ES100_FRAGMENT_OUTPUT_NAME, "\\b"), "g"), outputName);
    }
    return source;
  }
  function convertFragmentShaderTo100(source) {
    source = convertShader(source, ES100_FRAGMENT_REPLACEMENTS);
    const outputMatch = source.match(ES300_FRAGMENT_OUTPUT_REGEX);
    if (outputMatch) {
      const outputName = outputMatch[1];
      source = source.replace(ES300_FRAGMENT_OUTPUT_REGEX, "").replace(new RegExp("\\b".concat(outputName, "\\b"), "g"), ES100_FRAGMENT_OUTPUT_NAME);
    }
    return source;
  }

  // node_modules/@luma.gl/shadertools/dist/esm/lib/assemble-shaders.js
  var INJECT_SHADER_DECLARATIONS = "\n\n".concat(DECLARATION_INJECT_MARKER, "\n\n");
  var SHADER_TYPE = {
    [VERTEX_SHADER]: "vertex",
    [FRAGMENT_SHADER]: "fragment"
  };
  var FRAGMENT_SHADER_PROLOGUE = "precision highp float;\n\n";
  function assembleShaders(gl, opts) {
    const {
      vs: vs7,
      fs: fs4
    } = opts;
    const modules = resolveModules(opts.modules || []);
    return {
      gl,
      vs: assembleShader(gl, Object.assign({}, opts, {
        source: vs7,
        type: VERTEX_SHADER,
        modules
      })),
      fs: assembleShader(gl, Object.assign({}, opts, {
        source: fs4,
        type: FRAGMENT_SHADER,
        modules
      })),
      getUniforms: assembleGetUniforms(modules)
    };
  }
  function assembleShader(gl, _ref) {
    let {
      id: id2,
      source,
      type,
      modules,
      defines: defines2 = {},
      hookFunctions = [],
      inject = {},
      transpileToGLSL100 = false,
      prologue = true,
      log: log5
    } = _ref;
    assert7(typeof source === "string", "shader source must be a string");
    const isVertex = type === VERTEX_SHADER;
    const sourceLines = source.split("\n");
    let glslVersion = 100;
    let versionLine = "";
    let coreSource = source;
    if (sourceLines[0].indexOf("#version ") === 0) {
      glslVersion = 300;
      versionLine = sourceLines[0];
      coreSource = sourceLines.slice(1).join("\n");
    } else {
      versionLine = "#version ".concat(glslVersion);
    }
    const allDefines = {};
    modules.forEach((module) => {
      Object.assign(allDefines, module.getDefines());
    });
    Object.assign(allDefines, defines2);
    let assembledSource = prologue ? "".concat(versionLine, "\n").concat(getShaderName2({
      id: id2,
      source,
      type
    }), "\n").concat(getShaderType({
      type
    }), "\n").concat(getPlatformShaderDefines(gl), "\n").concat(getVersionDefines(gl, glslVersion, !isVertex), "\n").concat(getApplicationDefines(allDefines), "\n").concat(isVertex ? "" : FRAGMENT_SHADER_PROLOGUE, "\n") : "".concat(versionLine, "\n");
    const hookFunctionMap = normalizeHookFunctions(hookFunctions);
    const hookInjections = {};
    const declInjections = {};
    const mainInjections = {};
    for (const key in inject) {
      const injection = typeof inject[key] === "string" ? {
        injection: inject[key],
        order: 0
      } : inject[key];
      const match = key.match(/^(v|f)s:(#)?([\w-]+)$/);
      if (match) {
        const hash2 = match[2];
        const name16 = match[3];
        if (hash2) {
          if (name16 === "decl") {
            declInjections[key] = [injection];
          } else {
            mainInjections[key] = [injection];
          }
        } else {
          hookInjections[key] = [injection];
        }
      } else {
        mainInjections[key] = [injection];
      }
    }
    for (const module of modules) {
      if (log5) {
        module.checkDeprecations(coreSource, log5);
      }
      const moduleSource = module.getModuleSource(type, glslVersion);
      assembledSource += moduleSource;
      const injections = module.injections[type];
      for (const key in injections) {
        const match = key.match(/^(v|f)s:#([\w-]+)$/);
        if (match) {
          const name16 = match[2];
          const injectionType = name16 === "decl" ? declInjections : mainInjections;
          injectionType[key] = injectionType[key] || [];
          injectionType[key].push(injections[key]);
        } else {
          hookInjections[key] = hookInjections[key] || [];
          hookInjections[key].push(injections[key]);
        }
      }
    }
    assembledSource += INJECT_SHADER_DECLARATIONS;
    assembledSource = injectShader(assembledSource, type, declInjections);
    assembledSource += getHookFunctions(hookFunctionMap[type], hookInjections);
    assembledSource += coreSource;
    assembledSource = injectShader(assembledSource, type, mainInjections);
    assembledSource = transpileShader(assembledSource, transpileToGLSL100 ? 100 : glslVersion, isVertex);
    return assembledSource;
  }
  function assembleGetUniforms(modules) {
    return function getUniforms3(opts) {
      const uniforms = {};
      for (const module of modules) {
        const moduleUniforms = module.getUniforms(opts, uniforms);
        Object.assign(uniforms, moduleUniforms);
      }
      return uniforms;
    };
  }
  function getShaderType(_ref2) {
    let {
      type
    } = _ref2;
    return "\n#define SHADER_TYPE_".concat(SHADER_TYPE[type].toUpperCase(), "\n");
  }
  function getShaderName2(_ref3) {
    let {
      id: id2,
      source,
      type
    } = _ref3;
    const injectShaderName = id2 && typeof id2 === "string" && source.indexOf("SHADER_NAME") === -1;
    return injectShaderName ? "\n#define SHADER_NAME ".concat(id2, "_").concat(SHADER_TYPE[type], "\n\n") : "";
  }
  function getApplicationDefines() {
    let defines2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let count2 = 0;
    let sourceText = "";
    for (const define2 in defines2) {
      if (count2 === 0) {
        sourceText += "\n// APPLICATION DEFINES\n";
      }
      count2++;
      const value13 = defines2[define2];
      if (value13 || Number.isFinite(value13)) {
        sourceText += "#define ".concat(define2.toUpperCase(), " ").concat(defines2[define2], "\n");
      }
    }
    if (count2 === 0) {
      sourceText += "\n";
    }
    return sourceText;
  }
  function getHookFunctions(hookFunctions, hookInjections) {
    let result = "";
    for (const hookName in hookFunctions) {
      const hookFunction = hookFunctions[hookName];
      result += "void ".concat(hookFunction.signature, " {\n");
      if (hookFunction.header) {
        result += "  ".concat(hookFunction.header);
      }
      if (hookInjections[hookName]) {
        const injections = hookInjections[hookName];
        injections.sort((a, b) => a.order - b.order);
        for (const injection of injections) {
          result += "  ".concat(injection.injection, "\n");
        }
      }
      if (hookFunction.footer) {
        result += "  ".concat(hookFunction.footer);
      }
      result += "}\n";
    }
    return result;
  }
  function normalizeHookFunctions(hookFunctions) {
    const result = {
      vs: {},
      fs: {}
    };
    hookFunctions.forEach((hook) => {
      let opts;
      if (typeof hook !== "string") {
        opts = hook;
        hook = opts.hook;
      } else {
        opts = {};
      }
      hook = hook.trim();
      const [stage, signature] = hook.split(":");
      const name16 = hook.replace(/\(.+/, "");
      result[stage][name16] = Object.assign(opts, {
        signature
      });
    });
    return result;
  }

  // node_modules/@luma.gl/shadertools/dist/esm/utils/shader-utils.js
  var FS100 = "void main() {gl_FragColor = vec4(0);}";
  var FS_GLES = "out vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}";
  var FS300 = "#version 300 es\n".concat(FS_GLES);
  function getQualifierDetails(line, qualifiers) {
    qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];
    const words = line.replace(/^\s+/, "").split(/\s+/);
    const [qualifier, type, definition] = words;
    if (!qualifiers.includes(qualifier) || !type || !definition) {
      return null;
    }
    const name16 = definition.split(";")[0];
    return {
      qualifier,
      type,
      name: name16
    };
  }
  function getPassthroughFS() {
    let options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const {
      version = 100,
      input,
      inputType,
      output
    } = options2;
    if (!input) {
      if (version === 300) {
        return FS300;
      } else if (version > 300) {
        return "#version ".concat(version, "\n").concat(FS_GLES);
      }
      return FS100;
    }
    const outputValue = convertToVec4(input, inputType);
    if (version >= 300) {
      return "#version ".concat(version, " ").concat(version === 300 ? "es" : "", "\nin ").concat(inputType, " ").concat(input, ";\nout vec4 ").concat(output, ";\nvoid main() {\n  ").concat(output, " = ").concat(outputValue, ";\n}");
    }
    return "varying ".concat(inputType, " ").concat(input, ";\nvoid main() {\n  gl_FragColor = ").concat(outputValue, ";\n}");
  }
  function typeToChannelSuffix(type) {
    switch (type) {
      case "float":
        return "x";
      case "vec2":
        return "xy";
      case "vec3":
        return "xyz";
      case "vec4":
        return "xyzw";
      default:
        assert7(false);
        return null;
    }
  }
  function typeToChannelCount(type) {
    switch (type) {
      case "float":
        return 1;
      case "vec2":
        return 2;
      case "vec3":
        return 3;
      case "vec4":
        return 4;
      default:
        assert7(false);
        return null;
    }
  }
  function convertToVec4(variable, type) {
    switch (type) {
      case "float":
        return "vec4(".concat(variable, ", 0.0, 0.0, 1.0)");
      case "vec2":
        return "vec4(".concat(variable, ", 0.0, 1.0)");
      case "vec3":
        return "vec4(".concat(variable, ", 1.0)");
      case "vec4":
        return variable;
      default:
        assert7(false);
        return null;
    }
  }

  // node_modules/@luma.gl/shadertools/dist/esm/modules/fp32/fp32.js
  var fp32shader = "#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01;\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03;\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04;\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06;\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 1.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 1.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n";
  var fp32 = {
    name: "fp32",
    vs: fp32shader,
    fs: null
  };

  // node_modules/@math.gl/core/dist/esm/lib/assert.js
  function assert8(condition, message2) {
    if (!condition) {
      throw new Error("math.gl assertion ".concat(message2));
    }
  }

  // node_modules/@math.gl/core/dist/esm/lib/common.js
  var RADIANS_TO_DEGREES = 1 / Math.PI * 180;
  var DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
  var config = {
    EPSILON: 1e-12,
    debug: false,
    precision: 4,
    printTypes: false,
    printDegrees: false,
    printRowMajor: true
  };
  function formatValue2(value13, {
    precision = config.precision
  } = {}) {
    value13 = round2(value13);
    return "".concat(parseFloat(value13.toPrecision(precision)));
  }
  function isArray2(value13) {
    return Array.isArray(value13) || ArrayBuffer.isView(value13) && !(value13 instanceof DataView);
  }
  function clamp(value13, min5, max6) {
    return map4(value13, (value14) => Math.max(min5, Math.min(max6, value14)));
  }
  function lerp(a, b, t) {
    if (isArray2(a)) {
      return a.map((ai, i) => lerp(ai, b[i], t));
    }
    return t * b + (1 - t) * a;
  }
  function equals(a, b, epsilon) {
    const oldEpsilon = config.EPSILON;
    if (epsilon) {
      config.EPSILON = epsilon;
    }
    try {
      if (a === b) {
        return true;
      }
      if (isArray2(a) && isArray2(b)) {
        if (a.length !== b.length) {
          return false;
        }
        for (let i = 0; i < a.length; ++i) {
          if (!equals(a[i], b[i])) {
            return false;
          }
        }
        return true;
      }
      if (a && a.equals) {
        return a.equals(b);
      }
      if (b && b.equals) {
        return b.equals(a);
      }
      if (typeof a === "number" && typeof b === "number") {
        return Math.abs(a - b) <= config.EPSILON * Math.max(1, Math.abs(a), Math.abs(b));
      }
      return false;
    } finally {
      config.EPSILON = oldEpsilon;
    }
  }
  function round2(value13) {
    return Math.round(value13 / config.EPSILON) * config.EPSILON;
  }
  function duplicateArray(array2) {
    return array2.clone ? array2.clone() : new Array(array2.length);
  }
  function map4(value13, func11, result) {
    if (isArray2(value13)) {
      const array2 = value13;
      result = result || duplicateArray(array2);
      for (let i = 0; i < result.length && i < array2.length; ++i) {
        result[i] = func11(value13[i], i, result);
      }
      return result;
    }
    return func11(value13);
  }

  // node_modules/@math.gl/core/dist/esm/classes/base/math-array.js
  function _extendableBuiltin(cls) {
    function ExtendableBuiltin() {
      var instance = Reflect.construct(cls, Array.from(arguments));
      Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
      return instance;
    }
    ExtendableBuiltin.prototype = Object.create(cls.prototype, {
      constructor: {
        value: cls,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(ExtendableBuiltin, cls);
    } else {
      ExtendableBuiltin.__proto__ = cls;
    }
    return ExtendableBuiltin;
  }
  var MathArray = class extends _extendableBuiltin(Array) {
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(array2, offset = 0) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = array2[i + offset];
      }
      return this.check();
    }
    toArray(targetArray = [], offset = 0) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        targetArray[offset + i] = this[i];
      }
      return targetArray;
    }
    from(arrayOrObject) {
      return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);
    }
    to(arrayOrObject) {
      if (arrayOrObject === this) {
        return this;
      }
      return isArray2(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
    }
    toTarget(target5) {
      return target5 ? this.to(target5) : this;
    }
    toFloat32Array() {
      return new Float32Array(this);
    }
    toString() {
      return this.formatString(config);
    }
    formatString(opts) {
      let string13 = "";
      for (let i = 0; i < this.ELEMENTS; ++i) {
        string13 += (i > 0 ? ", " : "") + formatValue2(this[i], opts);
      }
      return "".concat(opts.printTypes ? this.constructor.name : "", "[").concat(string13, "]");
    }
    equals(array2) {
      if (!array2 || this.length !== array2.length) {
        return false;
      }
      for (let i = 0; i < this.ELEMENTS; ++i) {
        if (!equals(this[i], array2[i])) {
          return false;
        }
      }
      return true;
    }
    exactEquals(array2) {
      if (!array2 || this.length !== array2.length) {
        return false;
      }
      for (let i = 0; i < this.ELEMENTS; ++i) {
        if (this[i] !== array2[i]) {
          return false;
        }
      }
      return true;
    }
    negate() {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = -this[i];
      }
      return this.check();
    }
    lerp(a, b, t) {
      if (t === void 0) {
        return this.lerp(this, a, b);
      }
      for (let i = 0; i < this.ELEMENTS; ++i) {
        const ai = a[i];
        this[i] = ai + t * (b[i] - ai);
      }
      return this.check();
    }
    min(vector) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.min(vector[i], this[i]);
      }
      return this.check();
    }
    max(vector) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.max(vector[i], this[i]);
      }
      return this.check();
    }
    clamp(minVector, maxVector) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);
      }
      return this.check();
    }
    add(...vectors) {
      for (const vector of vectors) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] += vector[i];
        }
      }
      return this.check();
    }
    subtract(...vectors) {
      for (const vector of vectors) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] -= vector[i];
        }
      }
      return this.check();
    }
    scale(scale4) {
      if (typeof scale4 === "number") {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] *= scale4;
        }
      } else {
        for (let i = 0; i < this.ELEMENTS && i < scale4.length; ++i) {
          this[i] *= scale4[i];
        }
      }
      return this.check();
    }
    multiplyByScalar(scalar) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= scalar;
      }
      return this.check();
    }
    check() {
      if (config.debug && !this.validate()) {
        throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
      }
      return this;
    }
    validate() {
      let valid = this.length === this.ELEMENTS;
      for (let i = 0; i < this.ELEMENTS; ++i) {
        valid = valid && Number.isFinite(this[i]);
      }
      return valid;
    }
    sub(a) {
      return this.subtract(a);
    }
    setScalar(a) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = a;
      }
      return this.check();
    }
    addScalar(a) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] += a;
      }
      return this.check();
    }
    subScalar(a) {
      return this.addScalar(-a);
    }
    multiplyScalar(scalar) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= scalar;
      }
      return this.check();
    }
    divideScalar(a) {
      return this.multiplyByScalar(1 / a);
    }
    clampScalar(min5, max6) {
      for (let i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.min(Math.max(this[i], min5), max6);
      }
      return this.check();
    }
    get elements() {
      return this;
    }
  };

  // node_modules/@math.gl/core/dist/esm/lib/validators.js
  function validateVector(v, length7) {
    if (v.length !== length7) {
      return false;
    }
    for (let i = 0; i < v.length; ++i) {
      if (!Number.isFinite(v[i])) {
        return false;
      }
    }
    return true;
  }
  function checkNumber(value13) {
    if (!Number.isFinite(value13)) {
      throw new Error("Invalid number ".concat(value13));
    }
    return value13;
  }
  function checkVector(v, length7, callerName = "") {
    if (config.debug && !validateVector(v, length7)) {
      throw new Error("math.gl: ".concat(callerName, " some fields set to invalid numbers'"));
    }
    return v;
  }

  // node_modules/@math.gl/core/dist/esm/classes/base/vector.js
  var Vector = class extends MathArray {
    get x() {
      return this[0];
    }
    set x(value13) {
      this[0] = checkNumber(value13);
    }
    get y() {
      return this[1];
    }
    set y(value13) {
      this[1] = checkNumber(value13);
    }
    len() {
      return Math.sqrt(this.lengthSquared());
    }
    magnitude() {
      return this.len();
    }
    lengthSquared() {
      let length7 = 0;
      for (let i = 0; i < this.ELEMENTS; ++i) {
        length7 += this[i] * this[i];
      }
      return length7;
    }
    magnitudeSquared() {
      return this.lengthSquared();
    }
    distance(mathArray) {
      return Math.sqrt(this.distanceSquared(mathArray));
    }
    distanceSquared(mathArray) {
      let length7 = 0;
      for (let i = 0; i < this.ELEMENTS; ++i) {
        const dist = this[i] - mathArray[i];
        length7 += dist * dist;
      }
      return checkNumber(length7);
    }
    dot(mathArray) {
      let product2 = 0;
      for (let i = 0; i < this.ELEMENTS; ++i) {
        product2 += this[i] * mathArray[i];
      }
      return checkNumber(product2);
    }
    normalize() {
      const length7 = this.magnitude();
      if (length7 !== 0) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] /= length7;
        }
      }
      return this.check();
    }
    multiply(...vectors) {
      for (const vector of vectors) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] *= vector[i];
        }
      }
      return this.check();
    }
    divide(...vectors) {
      for (const vector of vectors) {
        for (let i = 0; i < this.ELEMENTS; ++i) {
          this[i] /= vector[i];
        }
      }
      return this.check();
    }
    lengthSq() {
      return this.lengthSquared();
    }
    distanceTo(vector) {
      return this.distance(vector);
    }
    distanceToSquared(vector) {
      return this.distanceSquared(vector);
    }
    getComponent(i) {
      assert8(i >= 0 && i < this.ELEMENTS, "index is out of range");
      return checkNumber(this[i]);
    }
    setComponent(i, value13) {
      assert8(i >= 0 && i < this.ELEMENTS, "index is out of range");
      this[i] = value13;
      return this.check();
    }
    addVectors(a, b) {
      return this.copy(a).add(b);
    }
    subVectors(a, b) {
      return this.copy(a).subtract(b);
    }
    multiplyVectors(a, b) {
      return this.copy(a).multiply(b);
    }
    addScaledVector(a, b) {
      return this.add(new this.constructor(a).multiplyScalar(b));
    }
  };

  // node_modules/gl-matrix/esm/common.js
  var EPSILON = 1e-6;
  var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var degree = Math.PI / 180;
  if (!Math.hypot)
    Math.hypot = function() {
      var y = 0, i = arguments.length;
      while (i--) {
        y += arguments[i] * arguments[i];
      }
      return Math.sqrt(y);
    };

  // node_modules/gl-matrix/esm/vec2.js
  function create() {
    var out = new ARRAY_TYPE(2);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }
    return out;
  }
  function add2(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
  }
  function subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
  }
  function scale(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
  }
  function length(a) {
    var x = a[0], y = a[1];
    return Math.hypot(x, y);
  }
  function negate2(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
  }
  function lerp2(out, a, b, t) {
    var ax = a[0], ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
  }
  function transformMat4(out, a, m) {
    var x = a[0];
    var y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
  }
  var sub2 = subtract;
  var forEach2 = function() {
    var vec = create();
    return function(a, stride, offset, count2, fn, arg) {
      var i, l;
      if (!stride) {
        stride = 2;
      }
      if (!offset) {
        offset = 0;
      }
      if (count2) {
        l = Math.min(count2 * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
      }
      return a;
    };
  }();

  // node_modules/@math.gl/core/dist/esm/lib/gl-matrix-extras.js
  function vec2_transformMat4AsVector(out, a, m) {
    const x = a[0];
    const y = a[1];
    const w = m[3] * x + m[7] * y || 1;
    out[0] = (m[0] * x + m[4] * y) / w;
    out[1] = (m[1] * x + m[5] * y) / w;
    return out;
  }
  function vec3_transformMat4AsVector(out, a, m) {
    const x = a[0];
    const y = a[1];
    const z = a[2];
    const w = m[3] * x + m[7] * y + m[11] * z || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;
    return out;
  }
  function vec3_transformMat2(out, a, m) {
    const x = a[0];
    const y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    out[2] = a[2];
    return out;
  }

  // node_modules/gl-matrix/esm/vec3.js
  function create2() {
    var out = new ARRAY_TYPE(3);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function add3(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
  }
  function subtract2(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
  }
  function multiply(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
  }
  function negate3(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
  }
  function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function cross(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2];
    var bx = b[0], by = b[1], bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  function transformMat42(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    var w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
  }
  function transformMat3(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
  }
  function transformQuat(out, a, q) {
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var x = a[0], y = a[1], z = a[2];
    var uvx = qy * z - qz * y, uvy = qz * x - qx * z, uvz = qx * y - qy * x;
    var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    out[0] = x + uvx + uuvx;
    out[1] = y + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
  }
  function rotateX(out, a, b, rad) {
    var p = [], r = [];
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    r[0] = p[0];
    r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);
    r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad);
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function rotateY(out, a, b, rad) {
    var p = [], r = [];
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);
    r[1] = p[1];
    r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad);
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function rotateZ(out, a, b, rad) {
    var p = [], r = [];
    p[0] = a[0] - b[0];
    p[1] = a[1] - b[1];
    p[2] = a[2] - b[2];
    r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);
    r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);
    r[2] = p[2];
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function angle(a, b) {
    var ax = a[0], ay = a[1], az = a[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a, b) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  var sub3 = subtract2;
  var mul2 = multiply;
  var forEach3 = function() {
    var vec = create2();
    return function(a, stride, offset, count2, fn, arg) {
      var i, l;
      if (!stride) {
        stride = 3;
      }
      if (!offset) {
        offset = 0;
      }
      if (count2) {
        l = Math.min(count2 * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
      }
      return a;
    };
  }();

  // node_modules/@math.gl/core/dist/esm/classes/vector3.js
  var ORIGIN = [0, 0, 0];
  var ZERO;
  var Vector3 = class extends Vector {
    static get ZERO() {
      if (!ZERO) {
        ZERO = new Vector3(0, 0, 0);
        Object.freeze(ZERO);
      }
      return ZERO;
    }
    constructor(x = 0, y = 0, z = 0) {
      super(-0, -0, -0);
      if (arguments.length === 1 && isArray2(x)) {
        this.copy(x);
      } else {
        if (config.debug) {
          checkNumber(x);
          checkNumber(y);
          checkNumber(z);
        }
        this[0] = x;
        this[1] = y;
        this[2] = z;
      }
    }
    set(x, y, z) {
      this[0] = x;
      this[1] = y;
      this[2] = z;
      return this.check();
    }
    copy(array2) {
      this[0] = array2[0];
      this[1] = array2[1];
      this[2] = array2[2];
      return this.check();
    }
    fromObject(object12) {
      if (config.debug) {
        checkNumber(object12.x);
        checkNumber(object12.y);
        checkNumber(object12.z);
      }
      this[0] = object12.x;
      this[1] = object12.y;
      this[2] = object12.z;
      return this.check();
    }
    toObject(object12) {
      object12.x = this[0];
      object12.y = this[1];
      object12.z = this[2];
      return object12;
    }
    get ELEMENTS() {
      return 3;
    }
    get z() {
      return this[2];
    }
    set z(value13) {
      this[2] = checkNumber(value13);
    }
    angle(vector) {
      return angle(this, vector);
    }
    cross(vector) {
      cross(this, this, vector);
      return this.check();
    }
    rotateX({
      radians: radians2,
      origin: origin2 = ORIGIN
    }) {
      rotateX(this, this, origin2, radians2);
      return this.check();
    }
    rotateY({
      radians: radians2,
      origin: origin2 = ORIGIN
    }) {
      rotateY(this, this, origin2, radians2);
      return this.check();
    }
    rotateZ({
      radians: radians2,
      origin: origin2 = ORIGIN
    }) {
      rotateZ(this, this, origin2, radians2);
      return this.check();
    }
    transform(matrix4) {
      return this.transformAsPoint(matrix4);
    }
    transformAsPoint(matrix4) {
      transformMat42(this, this, matrix4);
      return this.check();
    }
    transformAsVector(matrix4) {
      vec3_transformMat4AsVector(this, this, matrix4);
      return this.check();
    }
    transformByMatrix3(matrix3) {
      transformMat3(this, this, matrix3);
      return this.check();
    }
    transformByMatrix2(matrix2) {
      vec3_transformMat2(this, this, matrix2);
      return this.check();
    }
    transformByQuaternion(quaternion) {
      transformQuat(this, this, quaternion);
      return this.check();
    }
  };

  // node_modules/@math.gl/core/dist/esm/classes/base/matrix.js
  var Matrix = class extends MathArray {
    toString() {
      let string13 = "[";
      if (config.printRowMajor) {
        string13 += "row-major:";
        for (let row = 0; row < this.RANK; ++row) {
          for (let col = 0; col < this.RANK; ++col) {
            string13 += " ".concat(this[col * this.RANK + row]);
          }
        }
      } else {
        string13 += "column-major:";
        for (let i = 0; i < this.ELEMENTS; ++i) {
          string13 += " ".concat(this[i]);
        }
      }
      string13 += "]";
      return string13;
    }
    getElementIndex(row, col) {
      return col * this.RANK + row;
    }
    getElement(row, col) {
      return this[col * this.RANK + row];
    }
    setElement(row, col, value13) {
      this[col * this.RANK + row] = checkNumber(value13);
      return this;
    }
    getColumn(columnIndex, result = new Array(this.RANK).fill(-0)) {
      const firstIndex = columnIndex * this.RANK;
      for (let i = 0; i < this.RANK; ++i) {
        result[i] = this[firstIndex + i];
      }
      return result;
    }
    setColumn(columnIndex, columnVector) {
      const firstIndex = columnIndex * this.RANK;
      for (let i = 0; i < this.RANK; ++i) {
        this[firstIndex + i] = columnVector[i];
      }
      return this;
    }
  };

  // node_modules/gl-matrix/esm/mat4.js
  function identity5(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function transpose(out, a) {
    if (out === a) {
      var a01 = a[1], a02 = a[2], a03 = a[3];
      var a12 = a[6], a13 = a[7];
      var a23 = a[11];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a01;
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a[0];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a[1];
      out[5] = a[5];
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a[2];
      out[9] = a[6];
      out[10] = a[10];
      out[11] = a[14];
      out[12] = a[3];
      out[13] = a[7];
      out[14] = a[11];
      out[15] = a[15];
    }
    return out;
  }
  function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  }
  function multiply2(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  function translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    if (a === out) {
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
      a00 = a[0];
      a01 = a[1];
      a02 = a[2];
      a03 = a[3];
      a10 = a[4];
      a11 = a[5];
      a12 = a[6];
      a13 = a[7];
      a20 = a[8];
      a21 = a[9];
      a22 = a[10];
      a23 = a[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x + a10 * y + a20 * z + a[12];
      out[13] = a01 * x + a11 * y + a21 * z + a[13];
      out[14] = a02 * x + a12 * y + a22 * z + a[14];
      out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }
    return out;
  }
  function scale2(out, a, v) {
    var x = v[0], y = v[1], z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  function rotate(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2];
    var len = Math.hypot(x, y, z);
    var s, c, t;
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    var b00, b01, b02;
    var b10, b11, b12;
    var b20, b21, b22;
    if (len < EPSILON) {
      return null;
    }
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    b00 = x * x * t + c;
    b01 = y * x * t + z * s;
    b02 = z * x * t - y * s;
    b10 = x * y * t - z * s;
    b11 = y * y * t + c;
    b12 = z * y * t + x * s;
    b20 = x * z * t + y * s;
    b21 = y * z * t - x * s;
    b22 = z * z * t + c;
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a !== out) {
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    return out;
  }
  function rotateX2(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
  }
  function rotateY2(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a20 = a[8];
    var a21 = a[9];
    var a22 = a[10];
    var a23 = a[11];
    if (a !== out) {
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
  }
  function rotateZ2(out, a, rad) {
    var s = Math.sin(rad);
    var c = Math.cos(rad);
    var a00 = a[0];
    var a01 = a[1];
    var a02 = a[2];
    var a03 = a[3];
    var a10 = a[4];
    var a11 = a[5];
    var a12 = a[6];
    var a13 = a[7];
    if (a !== out) {
      out[8] = a[8];
      out[9] = a[9];
      out[10] = a[10];
      out[11] = a[11];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
  }
  function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3];
    var x2 = x + x;
    var y2 = y + y;
    var z2 = z + z;
    var xx = x * x2;
    var yx = y * x2;
    var yy = y * y2;
    var zx = z * x2;
    var zy = z * y2;
    var zz = z * z2;
    var wx = w * x2;
    var wy = w * y2;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function frustum(out, left3, right, bottom3, top3, near, far) {
    var rl = 1 / (right - left3);
    var tb = 1 / (top3 - bottom3);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left3) * rl;
    out[9] = (top3 + bottom3) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  function perspectiveNO(out, fovy, aspect, near, far) {
    var f = 1 / Math.tan(fovy / 2), nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  var perspective = perspectiveNO;
  function orthoNO(out, left3, right, bottom3, top3, near, far) {
    var lr = 1 / (left3 - right);
    var bt = 1 / (bottom3 - top3);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left3 + right) * lr;
    out[13] = (top3 + bottom3) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  var ortho = orthoNO;
  function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center[0];
    var centery = center[1];
    var centerz = center[2];
    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return identity5(out);
    }
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len = 1 / Math.hypot(z0, z1, z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.hypot(x0, x1, x2);
    if (!len) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len = 1 / len;
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }
    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;
    len = Math.hypot(y0, y1, y2);
    if (!len) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len = 1 / len;
      y0 *= len;
      y1 *= len;
      y2 *= len;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }
  function equals2(a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7];
    var a8 = a[8], a9 = a[9], a10 = a[10], a11 = a[11];
    var a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
    var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
    var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
  }

  // node_modules/gl-matrix/esm/vec4.js
  function create3() {
    var out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }
    return out;
  }
  function scale3(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
  }
  function transformMat43(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
  }
  var forEach4 = function() {
    var vec = create3();
    return function(a, stride, offset, count2, fn, arg) {
      var i, l;
      if (!stride) {
        stride = 4;
      }
      if (!offset) {
        offset = 0;
      }
      if (count2) {
        l = Math.min(count2 * stride + offset, a.length);
      } else {
        l = a.length;
      }
      for (i = offset; i < l; i += stride) {
        vec[0] = a[i];
        vec[1] = a[i + 1];
        vec[2] = a[i + 2];
        vec[3] = a[i + 3];
        fn(vec, vec, arg);
        a[i] = vec[0];
        a[i + 1] = vec[1];
        a[i + 2] = vec[2];
        a[i + 3] = vec[3];
      }
      return a;
    };
  }();

  // node_modules/@math.gl/core/dist/esm/classes/matrix4.js
  var INDICES;
  (function(INDICES2) {
    INDICES2[INDICES2["COL0ROW0"] = 0] = "COL0ROW0";
    INDICES2[INDICES2["COL0ROW1"] = 1] = "COL0ROW1";
    INDICES2[INDICES2["COL0ROW2"] = 2] = "COL0ROW2";
    INDICES2[INDICES2["COL0ROW3"] = 3] = "COL0ROW3";
    INDICES2[INDICES2["COL1ROW0"] = 4] = "COL1ROW0";
    INDICES2[INDICES2["COL1ROW1"] = 5] = "COL1ROW1";
    INDICES2[INDICES2["COL1ROW2"] = 6] = "COL1ROW2";
    INDICES2[INDICES2["COL1ROW3"] = 7] = "COL1ROW3";
    INDICES2[INDICES2["COL2ROW0"] = 8] = "COL2ROW0";
    INDICES2[INDICES2["COL2ROW1"] = 9] = "COL2ROW1";
    INDICES2[INDICES2["COL2ROW2"] = 10] = "COL2ROW2";
    INDICES2[INDICES2["COL2ROW3"] = 11] = "COL2ROW3";
    INDICES2[INDICES2["COL3ROW0"] = 12] = "COL3ROW0";
    INDICES2[INDICES2["COL3ROW1"] = 13] = "COL3ROW1";
    INDICES2[INDICES2["COL3ROW2"] = 14] = "COL3ROW2";
    INDICES2[INDICES2["COL3ROW3"] = 15] = "COL3ROW3";
  })(INDICES || (INDICES = {}));
  var DEFAULT_FOVY = 45 * Math.PI / 180;
  var DEFAULT_ASPECT = 1;
  var DEFAULT_NEAR = 0.1;
  var DEFAULT_FAR = 500;
  var IDENTITY_MATRIX = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  var Matrix4 = class extends Matrix {
    static get IDENTITY() {
      return getIdentityMatrix();
    }
    static get ZERO() {
      return getZeroMatrix();
    }
    get ELEMENTS() {
      return 16;
    }
    get RANK() {
      return 4;
    }
    get INDICES() {
      return INDICES;
    }
    constructor(array2) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0);
      if (arguments.length === 1 && Array.isArray(array2)) {
        this.copy(array2);
      } else {
        this.identity();
      }
    }
    copy(array2) {
      this[0] = array2[0];
      this[1] = array2[1];
      this[2] = array2[2];
      this[3] = array2[3];
      this[4] = array2[4];
      this[5] = array2[5];
      this[6] = array2[6];
      this[7] = array2[7];
      this[8] = array2[8];
      this[9] = array2[9];
      this[10] = array2[10];
      this[11] = array2[11];
      this[12] = array2[12];
      this[13] = array2[13];
      this[14] = array2[14];
      this[15] = array2[15];
      return this.check();
    }
    set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
    toRowMajor(result) {
      result[0] = this[0];
      result[1] = this[4];
      result[2] = this[8];
      result[3] = this[12];
      result[4] = this[1];
      result[5] = this[5];
      result[6] = this[9];
      result[7] = this[13];
      result[8] = this[2];
      result[9] = this[6];
      result[10] = this[10];
      result[11] = this[14];
      result[12] = this[3];
      result[13] = this[7];
      result[14] = this[11];
      result[15] = this[15];
      return result;
    }
    identity() {
      return this.copy(IDENTITY_MATRIX);
    }
    fromObject(object12) {
      return this.check();
    }
    fromQuaternion(quaternion) {
      fromQuat(this, quaternion);
      return this.check();
    }
    frustum(view) {
      const {
        left: left3,
        right,
        bottom: bottom3,
        top: top3,
        near = DEFAULT_NEAR,
        far = DEFAULT_FAR
      } = view;
      if (far === Infinity) {
        computeInfinitePerspectiveOffCenter(this, left3, right, bottom3, top3, near);
      } else {
        frustum(this, left3, right, bottom3, top3, near, far);
      }
      return this.check();
    }
    lookAt(view) {
      const {
        eye,
        center = [0, 0, 0],
        up = [0, 1, 0]
      } = view;
      lookAt(this, eye, center, up);
      return this.check();
    }
    ortho(view) {
      const {
        left: left3,
        right,
        bottom: bottom3,
        top: top3,
        near = DEFAULT_NEAR,
        far = DEFAULT_FAR
      } = view;
      ortho(this, left3, right, bottom3, top3, near, far);
      return this.check();
    }
    orthographic(view) {
      const {
        fovy = DEFAULT_FOVY,
        aspect = DEFAULT_ASPECT,
        focalDistance = 1,
        near = DEFAULT_NEAR,
        far = DEFAULT_FAR
      } = view;
      checkRadians(fovy);
      const halfY = fovy / 2;
      const top3 = focalDistance * Math.tan(halfY);
      const right = top3 * aspect;
      return this.ortho({
        left: -right,
        right,
        bottom: -top3,
        top: top3,
        near,
        far
      });
    }
    perspective(view) {
      const {
        fovy = 45 * Math.PI / 180,
        aspect = 1,
        near = 0.1,
        far = 500
      } = view;
      checkRadians(fovy);
      perspective(this, fovy, aspect, near, far);
      return this.check();
    }
    determinant() {
      return determinant(this);
    }
    getScale(result = [-0, -0, -0]) {
      result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
      result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
      result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
      return result;
    }
    getTranslation(result = [-0, -0, -0]) {
      result[0] = this[12];
      result[1] = this[13];
      result[2] = this[14];
      return result;
    }
    getRotation(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale4 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale4[0];
      const inverseScale1 = 1 / scale4[1];
      const inverseScale2 = 1 / scale4[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = 0;
      result[4] = this[4] * inverseScale0;
      result[5] = this[5] * inverseScale1;
      result[6] = this[6] * inverseScale2;
      result[7] = 0;
      result[8] = this[8] * inverseScale0;
      result[9] = this[9] * inverseScale1;
      result[10] = this[10] * inverseScale2;
      result[11] = 0;
      result[12] = 0;
      result[13] = 0;
      result[14] = 0;
      result[15] = 1;
      return result;
    }
    getRotationMatrix3(result, scaleResult) {
      result = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0];
      scaleResult = scaleResult || [-0, -0, -0];
      const scale4 = this.getScale(scaleResult);
      const inverseScale0 = 1 / scale4[0];
      const inverseScale1 = 1 / scale4[1];
      const inverseScale2 = 1 / scale4[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = this[4] * inverseScale0;
      result[4] = this[5] * inverseScale1;
      result[5] = this[6] * inverseScale2;
      result[6] = this[8] * inverseScale0;
      result[7] = this[9] * inverseScale1;
      result[8] = this[10] * inverseScale2;
      return result;
    }
    transpose() {
      transpose(this, this);
      return this.check();
    }
    invert() {
      invert(this, this);
      return this.check();
    }
    multiplyLeft(a) {
      multiply2(this, a, this);
      return this.check();
    }
    multiplyRight(a) {
      multiply2(this, this, a);
      return this.check();
    }
    rotateX(radians2) {
      rotateX2(this, this, radians2);
      return this.check();
    }
    rotateY(radians2) {
      rotateY2(this, this, radians2);
      return this.check();
    }
    rotateZ(radians2) {
      rotateZ2(this, this, radians2);
      return this.check();
    }
    rotateXYZ(angleXYZ) {
      return this.rotateX(angleXYZ[0]).rotateY(angleXYZ[1]).rotateZ(angleXYZ[2]);
    }
    rotateAxis(radians2, axis) {
      rotate(this, this, radians2, axis);
      return this.check();
    }
    scale(factor) {
      scale2(this, this, Array.isArray(factor) ? factor : [factor, factor, factor]);
      return this.check();
    }
    translate(vector) {
      translate(this, this, vector);
      return this.check();
    }
    transform(vector, result) {
      if (vector.length === 4) {
        result = transformMat43(result || [-0, -0, -0, -0], vector, this);
        checkVector(result, 4);
        return result;
      }
      return this.transformAsPoint(vector, result);
    }
    transformAsPoint(vector, result) {
      const {
        length: length7
      } = vector;
      let out;
      switch (length7) {
        case 2:
          out = transformMat4(result || [-0, -0], vector, this);
          break;
        case 3:
          out = transformMat42(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    transformAsVector(vector, result) {
      let out;
      switch (vector.length) {
        case 2:
          out = vec2_transformMat4AsVector(result || [-0, -0], vector, this);
          break;
        case 3:
          out = vec3_transformMat4AsVector(result || [-0, -0, -0], vector, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      checkVector(out, vector.length);
      return out;
    }
    transformPoint(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    transformVector(vector, result) {
      return this.transformAsPoint(vector, result);
    }
    transformDirection(vector, result) {
      return this.transformAsVector(vector, result);
    }
    makeRotationX(radians2) {
      return this.identity().rotateX(radians2);
    }
    makeTranslation(x, y, z) {
      return this.identity().translate([x, y, z]);
    }
  };
  var ZERO2;
  var IDENTITY;
  function getZeroMatrix() {
    if (!ZERO2) {
      ZERO2 = new Matrix4([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
      Object.freeze(ZERO2);
    }
    return ZERO2;
  }
  function getIdentityMatrix() {
    if (!IDENTITY) {
      IDENTITY = new Matrix4();
      Object.freeze(IDENTITY);
    }
    return IDENTITY;
  }
  function checkRadians(possiblyDegrees) {
    if (possiblyDegrees > Math.PI * 2) {
      throw Error("expected radians");
    }
  }
  function computeInfinitePerspectiveOffCenter(result, left3, right, bottom3, top3, near) {
    const column0Row0 = 2 * near / (right - left3);
    const column1Row1 = 2 * near / (top3 - bottom3);
    const column2Row0 = (right + left3) / (right - left3);
    const column2Row1 = (top3 + bottom3) / (top3 - bottom3);
    const column2Row2 = -1;
    const column2Row3 = -1;
    const column3Row2 = -2 * near;
    result[0] = column0Row0;
    result[1] = 0;
    result[2] = 0;
    result[3] = 0;
    result[4] = 0;
    result[5] = column1Row1;
    result[6] = 0;
    result[7] = 0;
    result[8] = column2Row0;
    result[9] = column2Row1;
    result[10] = column2Row2;
    result[11] = column2Row3;
    result[12] = 0;
    result[13] = 0;
    result[14] = column3Row2;
    result[15] = 0;
    return result;
  }

  // node_modules/@luma.gl/shadertools/dist/esm/modules/picking/picking.js
  var DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 255, 255, 255]);
  var DEFAULT_MODULE_OPTIONS = {
    pickingSelectedColor: null,
    pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR,
    pickingActive: false,
    pickingAttribute: false
  };
  function getUniforms() {
    let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : DEFAULT_MODULE_OPTIONS;
    const uniforms = {};
    if (opts.pickingSelectedColor !== void 0) {
      if (!opts.pickingSelectedColor) {
        uniforms.picking_uSelectedColorValid = 0;
      } else {
        const selectedColor = opts.pickingSelectedColor.slice(0, 3);
        uniforms.picking_uSelectedColorValid = 1;
        uniforms.picking_uSelectedColor = selectedColor;
      }
    }
    if (opts.pickingHighlightColor) {
      const color = Array.from(opts.pickingHighlightColor, (x) => x / 255);
      if (!Number.isFinite(color[3])) {
        color[3] = 1;
      }
      uniforms.picking_uHighlightColor = color;
    }
    if (opts.pickingActive !== void 0) {
      uniforms.picking_uActive = Boolean(opts.pickingActive);
      uniforms.picking_uAttribute = Boolean(opts.pickingAttribute);
    }
    return uniforms;
  }
  var vs = "uniform bool picking_uActive;\nuniform bool picking_uAttribute;\nuniform vec3 picking_uSelectedColor;\nuniform bool picking_uSelectedColorValid;\n\nout vec4 picking_vRGBcolor_Avalid;\n\nconst float COLOR_SCALE = 1. / 255.;\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.001;\n}\n\nbool isVertexPicked(vec3 vertexColor) {\n  return\n    picking_uSelectedColorValid &&\n    !picking_isColorValid(abs(vertexColor - picking_uSelectedColor));\n}\n\nvoid picking_setPickingColor(vec3 pickingColor) {\n  if (picking_uActive) {\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!picking_uAttribute) {\n      picking_vRGBcolor_Avalid.rgb = pickingColor * COLOR_SCALE;\n    }\n  } else {\n    picking_vRGBcolor_Avalid.a = float(isVertexPicked(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\nvoid picking_setPickingAttribute(vec2 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\nvoid picking_setPickingAttribute(vec3 value) {\n  if (picking_uAttribute) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n";
  var fs = "uniform bool picking_uActive;\nuniform vec3 picking_uSelectedColor;\nuniform vec4 picking_uHighlightColor;\n\nin vec4 picking_vRGBcolor_Avalid;\nvec4 picking_filterHighlightColor(vec4 color) {\n  if (picking_uActive) {\n    return color;\n  }\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    float highLightAlpha = picking_uHighlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking_uHighlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\nvec4 picking_filterPickingColor(vec4 color) {\n  if (picking_uActive) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\nvec4 picking_filterColor(vec4 color) {\n  vec4 highightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highightColor);\n}\n\n";
  var picking = {
    name: "picking",
    vs,
    fs,
    getUniforms
  };

  // node_modules/@luma.gl/shadertools/dist/esm/modules/transform/transform.js
  var vs2 = "attribute float transform_elementID;\nvec2 transform_getPixelSizeHalf(vec2 size) {\n  return vec2(1.) / (2. * size);\n}\n\nvec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {\n  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);\n  float xIndex = transform_elementID - (yIndex * texSize[0]);\n  return vec2(xIndex, yIndex);\n}\nvec2 transform_getTexCoord(vec2 size) {\n  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);\n  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);\n  vec2 coord = indices / size + pixelSizeHalf;\n  return coord;\n}\nvec2 transform_getPos(vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);\n  return pos;\n}\nvec4 transform_getInput(sampler2D texSampler, vec2 size) {\n  vec2 texCoord = transform_getTexCoord(size);\n  vec4 textureColor = texture2D(texSampler, texCoord);\n  return textureColor;\n}\n";
  var transform = {
    name: "transform",
    vs: vs2,
    fs: null
  };

  // node_modules/@luma.gl/engine/dist/esm/lib/program-manager.js
  var ProgramManager = class {
    static getDefaultProgramManager(gl) {
      gl.luma = gl.luma || {};
      gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new ProgramManager(gl);
      return gl.luma.defaultProgramManager;
    }
    constructor(gl) {
      this.gl = gl;
      this._programCache = {};
      this._getUniforms = {};
      this._registeredModules = {};
      this._hookFunctions = [];
      this._defaultModules = [];
      this._hashes = {};
      this._hashCounter = 0;
      this.stateHash = 0;
      this._useCounts = {};
    }
    addDefaultModule(module) {
      if (!this._defaultModules.find((m) => m.name === module.name)) {
        this._defaultModules.push(module);
      }
      this.stateHash++;
    }
    removeDefaultModule(module) {
      const moduleName = typeof module === "string" ? module : module.name;
      this._defaultModules = this._defaultModules.filter((m) => m.name !== moduleName);
      this.stateHash++;
    }
    addShaderHook(hook, opts) {
      if (opts) {
        hook = Object.assign(opts, {
          hook
        });
      }
      this._hookFunctions.push(hook);
      this.stateHash++;
    }
    get() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        vs: vs7 = "",
        fs: fs4 = "",
        defines: defines2 = {},
        inject = {},
        varyings = [],
        bufferMode = 35981,
        transpileToGLSL100 = false
      } = props;
      const modules = this._getModuleList(props.modules);
      const vsHash = this._getHash(vs7);
      const fsHash = this._getHash(fs4);
      const moduleHashes = modules.map((m) => this._getHash(m.name)).sort();
      const varyingHashes = varyings.map((v) => this._getHash(v));
      const defineKeys = Object.keys(defines2).sort();
      const injectKeys = Object.keys(inject).sort();
      const defineHashes = [];
      const injectHashes = [];
      for (const key of defineKeys) {
        defineHashes.push(this._getHash(key));
        defineHashes.push(this._getHash(defines2[key]));
      }
      for (const key of injectKeys) {
        injectHashes.push(this._getHash(key));
        injectHashes.push(this._getHash(inject[key]));
      }
      const hash2 = "".concat(vsHash, "/").concat(fsHash, "D").concat(defineHashes.join("/"), "M").concat(moduleHashes.join("/"), "I").concat(injectHashes.join("/"), "V").concat(varyingHashes.join("/"), "H").concat(this.stateHash, "B").concat(bufferMode).concat(transpileToGLSL100 ? "T" : "");
      if (!this._programCache[hash2]) {
        const assembled = assembleShaders(this.gl, {
          vs: vs7,
          fs: fs4,
          modules,
          inject,
          defines: defines2,
          hookFunctions: this._hookFunctions,
          transpileToGLSL100
        });
        this._programCache[hash2] = new Program(this.gl, {
          hash: hash2,
          vs: assembled.vs,
          fs: assembled.fs,
          varyings,
          bufferMode
        });
        this._getUniforms[hash2] = assembled.getUniforms || ((x) => {
        });
        this._useCounts[hash2] = 0;
      }
      this._useCounts[hash2]++;
      return this._programCache[hash2];
    }
    getUniforms(program) {
      return this._getUniforms[program.hash] || null;
    }
    release(program) {
      const hash2 = program.hash;
      this._useCounts[hash2]--;
      if (this._useCounts[hash2] === 0) {
        this._programCache[hash2].delete();
        delete this._programCache[hash2];
        delete this._getUniforms[hash2];
        delete this._useCounts[hash2];
      }
    }
    _getHash(key) {
      if (this._hashes[key] === void 0) {
        this._hashes[key] = this._hashCounter++;
      }
      return this._hashes[key];
    }
    _getModuleList() {
      let appModules = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      const modules = new Array(this._defaultModules.length + appModules.length);
      const seen = {};
      let count2 = 0;
      for (let i = 0, len = this._defaultModules.length; i < len; ++i) {
        const module = this._defaultModules[i];
        const name16 = module.name;
        modules[count2++] = module;
        seen[name16] = true;
      }
      for (let i = 0, len = appModules.length; i < len; ++i) {
        const module = appModules[i];
        const name16 = module.name;
        if (!seen[name16]) {
          modules[count2++] = module;
          seen[name16] = true;
        }
      }
      modules.length = count2;
      return modules;
    }
  };

  // node_modules/@luma.gl/engine/dist/esm/lib/model-utils.js
  var GLTF_TO_LUMA_ATTRIBUTE_MAP = {
    POSITION: "positions",
    NORMAL: "normals",
    COLOR_0: "colors",
    TEXCOORD_0: "texCoords",
    TEXCOORD_1: "texCoords1",
    TEXCOORD_2: "texCoords2"
  };
  function getBuffersFromGeometry(gl, geometry, options2) {
    const buffers = {};
    let indices = geometry.indices;
    for (const name16 in geometry.attributes) {
      const attribute = geometry.attributes[name16];
      const remappedName = mapAttributeName(name16, options2);
      if (name16 === "indices") {
        indices = attribute;
      } else if (attribute.constant) {
        buffers[remappedName] = attribute.value;
      } else {
        const typedArray = attribute.value;
        const accessor = {
          ...attribute
        };
        delete accessor.value;
        buffers[remappedName] = [new Buffer2(gl, typedArray), accessor];
        inferAttributeAccessor(name16, accessor);
      }
    }
    if (indices) {
      const data = indices.value || indices;
      assert6(data instanceof Uint16Array || data instanceof Uint32Array, 'attribute array for "indices" must be of integer type');
      const accessor = {
        size: 1,
        isIndexed: indices.isIndexed === void 0 ? true : indices.isIndexed
      };
      buffers.indices = [new Buffer2(gl, {
        data,
        target: 34963
      }), accessor];
    }
    return buffers;
  }
  function mapAttributeName(name16, options2) {
    const {
      attributeMap = GLTF_TO_LUMA_ATTRIBUTE_MAP
    } = options2 || {};
    return attributeMap && attributeMap[name16] || name16;
  }
  function inferAttributeAccessor(attributeName, attribute) {
    let category;
    switch (attributeName) {
      case "texCoords":
      case "texCoord1":
      case "texCoord2":
      case "texCoord3":
        category = "uvs";
        break;
      case "vertices":
      case "positions":
      case "normals":
      case "pickingColors":
        category = "vectors";
        break;
      default:
    }
    switch (category) {
      case "vectors":
        attribute.size = attribute.size || 3;
        break;
      case "uvs":
        attribute.size = attribute.size || 2;
        break;
      default:
    }
    assert6(Number.isFinite(attribute.size), "attribute ".concat(attributeName, " needs size"));
  }

  // node_modules/@luma.gl/engine/dist/esm/lib/model.js
  var LOG_DRAW_PRIORITY = 2;
  var LOG_DRAW_TIMEOUT = 1e4;
  var ERR_MODEL_PARAMS = "Model needs drawMode and vertexCount";
  var NOOP2 = () => {
  };
  var DRAW_PARAMS = {};
  var Model = class {
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      const {
        id: id2 = uid("model")
      } = props;
      assert6(isWebGL(gl));
      this.id = id2;
      this.gl = gl;
      this.id = props.id || uid("Model");
      this.lastLogTime = 0;
      this.animated = false;
      this.initialize(props);
    }
    initialize(props) {
      this.props = {};
      this.programManager = props.programManager || ProgramManager.getDefaultProgramManager(this.gl);
      this._programManagerState = -1;
      this._managedProgram = false;
      const {
        program = null,
        vs: vs7,
        fs: fs4,
        modules,
        defines: defines2,
        inject,
        varyings,
        bufferMode,
        transpileToGLSL100
      } = props;
      this.programProps = {
        program,
        vs: vs7,
        fs: fs4,
        modules,
        defines: defines2,
        inject,
        varyings,
        bufferMode,
        transpileToGLSL100
      };
      this.program = null;
      this.vertexArray = null;
      this._programDirty = true;
      this.userData = {};
      this.needsRedraw = true;
      this._attributes = {};
      this.attributes = {};
      this.uniforms = {};
      this.pickable = true;
      this._checkProgram();
      this.setUniforms(Object.assign({}, this.getModuleUniforms(props.moduleSettings)));
      this.drawMode = props.drawMode !== void 0 ? props.drawMode : 4;
      this.vertexCount = props.vertexCount || 0;
      this.geometryBuffers = {};
      this.isInstanced = props.isInstanced || props.instanced || props.instanceCount > 0;
      this._setModelProps(props);
      this.geometry = {};
      assert6(this.drawMode !== void 0 && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);
    }
    setProps(props) {
      this._setModelProps(props);
    }
    delete() {
      for (const key in this._attributes) {
        if (this._attributes[key] !== this.attributes[key]) {
          this._attributes[key].delete();
        }
      }
      if (this._managedProgram) {
        this.programManager.release(this.program);
        this._managedProgram = false;
      }
      this.vertexArray.delete();
      this._deleteGeometryBuffers();
    }
    getDrawMode() {
      return this.drawMode;
    }
    getVertexCount() {
      return this.vertexCount;
    }
    getInstanceCount() {
      return this.instanceCount;
    }
    getAttributes() {
      return this.attributes;
    }
    getProgram() {
      return this.program;
    }
    setProgram(props) {
      const {
        program,
        vs: vs7,
        fs: fs4,
        modules,
        defines: defines2,
        inject,
        varyings,
        bufferMode,
        transpileToGLSL100
      } = props;
      this.programProps = {
        program,
        vs: vs7,
        fs: fs4,
        modules,
        defines: defines2,
        inject,
        varyings,
        bufferMode,
        transpileToGLSL100
      };
      this._programDirty = true;
    }
    getUniforms() {
      return this.uniforms;
    }
    setDrawMode(drawMode) {
      this.drawMode = drawMode;
      return this;
    }
    setVertexCount(vertexCount) {
      assert6(Number.isFinite(vertexCount));
      this.vertexCount = vertexCount;
      return this;
    }
    setInstanceCount(instanceCount) {
      assert6(Number.isFinite(instanceCount));
      this.instanceCount = instanceCount;
      return this;
    }
    setGeometry(geometry) {
      this.drawMode = geometry.drawMode;
      this.vertexCount = geometry.getVertexCount();
      this._deleteGeometryBuffers();
      this.geometryBuffers = getBuffersFromGeometry(this.gl, geometry);
      this.vertexArray.setAttributes(this.geometryBuffers);
      return this;
    }
    setAttributes() {
      let attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (isObjectEmpty2(attributes)) {
        return this;
      }
      const normalizedAttributes = {};
      for (const name16 in attributes) {
        const attribute = attributes[name16];
        normalizedAttributes[name16] = attribute.getValue ? attribute.getValue() : attribute;
      }
      this.vertexArray.setAttributes(normalizedAttributes);
      return this;
    }
    setUniforms() {
      let uniforms = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      Object.assign(this.uniforms, uniforms);
      return this;
    }
    getModuleUniforms(opts) {
      this._checkProgram();
      const getUniforms3 = this.programManager.getUniforms(this.program);
      if (getUniforms3) {
        return getUniforms3(opts);
      }
      return {};
    }
    updateModuleSettings(opts) {
      const uniforms = this.getModuleUniforms(opts || {});
      return this.setUniforms(uniforms);
    }
    clear(opts) {
      clear(this.program.gl, opts);
      return this;
    }
    draw() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this._checkProgram();
      const {
        moduleSettings = null,
        framebuffer,
        uniforms = {},
        attributes = {},
        transformFeedback = this.transformFeedback,
        parameters = {},
        vertexArray = this.vertexArray
      } = opts;
      this.setAttributes(attributes);
      this.updateModuleSettings(moduleSettings);
      this.setUniforms(uniforms);
      let logPriority;
      if (log3.priority >= LOG_DRAW_PRIORITY) {
        logPriority = this._logDrawCallStart(LOG_DRAW_PRIORITY);
      }
      const drawParams = this.vertexArray.getDrawParams();
      const {
        isIndexed = drawParams.isIndexed,
        indexType = drawParams.indexType,
        indexOffset = drawParams.indexOffset,
        vertexArrayInstanced = drawParams.isInstanced
      } = this.props;
      if (vertexArrayInstanced && !this.isInstanced) {
        log3.warn("Found instanced attributes on non-instanced model", this.id)();
      }
      const {
        isInstanced,
        instanceCount
      } = this;
      const {
        onBeforeRender = NOOP2,
        onAfterRender = NOOP2
      } = this.props;
      onBeforeRender();
      this.program.setUniforms(this.uniforms);
      const didDraw = this.program.draw(Object.assign(DRAW_PARAMS, opts, {
        logPriority,
        uniforms: null,
        framebuffer,
        parameters,
        drawMode: this.getDrawMode(),
        vertexCount: this.getVertexCount(),
        vertexArray,
        transformFeedback,
        isIndexed,
        indexType,
        isInstanced,
        instanceCount,
        offset: isIndexed ? indexOffset : 0
      }));
      onAfterRender();
      if (log3.priority >= LOG_DRAW_PRIORITY) {
        this._logDrawCallEnd(logPriority, vertexArray, framebuffer);
      }
      return didDraw;
    }
    transform() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        discard: discard3 = true,
        feedbackBuffers,
        unbindModels = []
      } = opts;
      let {
        parameters
      } = opts;
      if (feedbackBuffers) {
        this._setFeedbackBuffers(feedbackBuffers);
      }
      if (discard3) {
        parameters = Object.assign({}, parameters, {
          [35977]: discard3
        });
      }
      unbindModels.forEach((model) => model.vertexArray.unbindBuffers());
      try {
        this.draw(Object.assign({}, opts, {
          parameters
        }));
      } finally {
        unbindModels.forEach((model) => model.vertexArray.bindBuffers());
      }
      return this;
    }
    render() {
      let uniforms = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      log3.warn("Model.render() is deprecated. Use Model.setUniforms() and Model.draw()")();
      return this.setUniforms(uniforms).draw();
    }
    _setModelProps(props) {
      Object.assign(this.props, props);
      if ("uniforms" in props) {
        this.setUniforms(props.uniforms);
      }
      if ("pickable" in props) {
        this.pickable = props.pickable;
      }
      if ("instanceCount" in props) {
        this.instanceCount = props.instanceCount;
      }
      if ("geometry" in props) {
        this.setGeometry(props.geometry);
      }
      if ("attributes" in props) {
        this.setAttributes(props.attributes);
      }
      if ("_feedbackBuffers" in props) {
        this._setFeedbackBuffers(props._feedbackBuffers);
      }
    }
    _checkProgram() {
      const needsUpdate = this._programDirty || this.programManager.stateHash !== this._programManagerState;
      if (!needsUpdate) {
        return;
      }
      let {
        program
      } = this.programProps;
      if (program) {
        this._managedProgram = false;
      } else {
        const {
          vs: vs7,
          fs: fs4,
          modules,
          inject,
          defines: defines2,
          varyings,
          bufferMode,
          transpileToGLSL100
        } = this.programProps;
        program = this.programManager.get({
          vs: vs7,
          fs: fs4,
          modules,
          inject,
          defines: defines2,
          varyings,
          bufferMode,
          transpileToGLSL100
        });
        if (this.program && this._managedProgram) {
          this.programManager.release(this.program);
        }
        this._programManagerState = this.programManager.stateHash;
        this._managedProgram = true;
      }
      assert6(program instanceof Program, "Model needs a program");
      this._programDirty = false;
      if (program === this.program) {
        return;
      }
      this.program = program;
      if (this.vertexArray) {
        this.vertexArray.setProps({
          program: this.program,
          attributes: this.vertexArray.attributes
        });
      } else {
        this.vertexArray = new VertexArray(this.gl, {
          program: this.program
        });
      }
      this.setUniforms(Object.assign({}, this.getModuleUniforms()));
    }
    _deleteGeometryBuffers() {
      for (const name16 in this.geometryBuffers) {
        const buffer = this.geometryBuffers[name16][0] || this.geometryBuffers[name16];
        if (buffer instanceof Buffer2) {
          buffer.delete();
        }
      }
    }
    _setAnimationProps(animationProps) {
      if (this.animated) {
        assert6(animationProps, "Model.draw(): animated uniforms but no animationProps");
      }
    }
    _setFeedbackBuffers() {
      let feedbackBuffers = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (isObjectEmpty2(feedbackBuffers)) {
        return this;
      }
      const {
        gl
      } = this.program;
      this.transformFeedback = this.transformFeedback || new TransformFeedback(gl, {
        program: this.program
      });
      this.transformFeedback.setBuffers(feedbackBuffers);
      return this;
    }
    _logDrawCallStart(logLevel) {
      const logDrawTimeout = logLevel > 3 ? 0 : LOG_DRAW_TIMEOUT;
      if (Date.now() - this.lastLogTime < logDrawTimeout) {
        return void 0;
      }
      this.lastLogTime = Date.now();
      log3.group(LOG_DRAW_PRIORITY, ">>> DRAWING MODEL ".concat(this.id), {
        collapsed: log3.level <= 2
      })();
      return logLevel;
    }
    _logDrawCallEnd(logLevel, vertexArray, uniforms, framebuffer) {
      if (logLevel === void 0) {
        return;
      }
      const attributeTable = getDebugTableForVertexArray({
        vertexArray,
        header: "".concat(this.id, " attributes"),
        attributes: this._attributes
      });
      const {
        table: uniformTable,
        unusedTable,
        unusedCount
      } = getDebugTableForUniforms({
        header: "".concat(this.id, " uniforms"),
        program: this.program,
        uniforms: Object.assign({}, this.program.uniforms, uniforms)
      });
      const {
        table: missingTable,
        count: missingCount
      } = getDebugTableForUniforms({
        header: "".concat(this.id, " uniforms"),
        program: this.program,
        uniforms: Object.assign({}, this.program.uniforms, uniforms),
        undefinedOnly: true
      });
      if (missingCount > 0) {
        log3.log("MISSING UNIFORMS", Object.keys(missingTable))();
      }
      if (unusedCount > 0) {
        log3.log("UNUSED UNIFORMS", Object.keys(unusedTable))();
      }
      const configTable = getDebugTableForProgramConfiguration(this.vertexArray.configuration);
      log3.table(logLevel, attributeTable)();
      log3.table(logLevel, uniformTable)();
      log3.table(logLevel + 1, configTable)();
      if (framebuffer) {
        framebuffer.log({
          logLevel: LOG_DRAW_PRIORITY,
          message: "Rendered to ".concat(framebuffer.id)
        });
      }
      log3.groupEnd(LOG_DRAW_PRIORITY)();
    }
  };

  // node_modules/@luma.gl/engine/dist/esm/transform/buffer-transform.js
  var BufferTransform = class {
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.gl = gl;
      this.currentIndex = 0;
      this.feedbackMap = {};
      this.varyings = null;
      this.bindings = [];
      this.resources = {};
      this._initialize(props);
      Object.seal(this);
    }
    setupResources(opts) {
      for (const binding of this.bindings) {
        this._setupTransformFeedback(binding, opts);
      }
    }
    updateModelProps() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        varyings
      } = this;
      if (varyings.length > 0) {
        props = Object.assign({}, props, {
          varyings
        });
      }
      return props;
    }
    getDrawOptions() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const binding = this.bindings[this.currentIndex];
      const {
        sourceBuffers,
        transformFeedback
      } = binding;
      const attributes = Object.assign({}, sourceBuffers, opts.attributes);
      return {
        attributes,
        transformFeedback
      };
    }
    swap() {
      if (this.feedbackMap) {
        this.currentIndex = this._getNextIndex();
        return true;
      }
      return false;
    }
    update() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this._setupBuffers(opts);
    }
    getBuffer(varyingName) {
      const {
        feedbackBuffers
      } = this.bindings[this.currentIndex];
      const bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;
      if (!bufferOrParams) {
        return null;
      }
      return bufferOrParams instanceof Buffer2 ? bufferOrParams : bufferOrParams.buffer;
    }
    getData() {
      let options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        varyingName
      } = options2;
      const buffer = this.getBuffer(varyingName);
      if (buffer) {
        return buffer.getData();
      }
      return null;
    }
    delete() {
      for (const name16 in this.resources) {
        this.resources[name16].delete();
      }
    }
    _initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this._setupBuffers(props);
      this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);
      if (this.varyings.length > 0) {
        assert6(isWebGL2(this.gl));
      }
    }
    _getFeedbackBuffers(props) {
      const {
        sourceBuffers = {}
      } = props;
      const feedbackBuffers = {};
      if (this.bindings[this.currentIndex]) {
        Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);
      }
      if (this.feedbackMap) {
        for (const sourceName in this.feedbackMap) {
          const feedbackName = this.feedbackMap[sourceName];
          if (sourceName in sourceBuffers) {
            feedbackBuffers[feedbackName] = sourceName;
          }
        }
      }
      Object.assign(feedbackBuffers, props.feedbackBuffers);
      for (const bufferName in feedbackBuffers) {
        const bufferOrRef = feedbackBuffers[bufferName];
        if (typeof bufferOrRef === "string") {
          const sourceBuffer = sourceBuffers[bufferOrRef];
          const {
            byteLength,
            usage,
            accessor
          } = sourceBuffer;
          feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {
            byteLength,
            usage,
            accessor
          });
        }
      }
      return feedbackBuffers;
    }
    _setupBuffers() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        sourceBuffers = null
      } = props;
      Object.assign(this.feedbackMap, props.feedbackMap);
      const feedbackBuffers = this._getFeedbackBuffers(props);
      this._updateBindings({
        sourceBuffers,
        feedbackBuffers
      });
    }
    _setupTransformFeedback(binding, _ref) {
      let {
        model
      } = _ref;
      const {
        program
      } = model;
      binding.transformFeedback = new TransformFeedback(this.gl, {
        program,
        buffers: binding.feedbackBuffers
      });
    }
    _updateBindings(opts) {
      this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);
      if (this.feedbackMap) {
        const {
          sourceBuffers,
          feedbackBuffers
        } = this._swapBuffers(this.bindings[this.currentIndex]);
        const nextIndex = this._getNextIndex();
        this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
          sourceBuffers,
          feedbackBuffers
        });
      }
    }
    _updateBinding(binding, opts) {
      if (!binding) {
        return {
          sourceBuffers: Object.assign({}, opts.sourceBuffers),
          feedbackBuffers: Object.assign({}, opts.feedbackBuffers)
        };
      }
      Object.assign(binding.sourceBuffers, opts.sourceBuffers);
      Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);
      if (binding.transformFeedback) {
        binding.transformFeedback.setBuffers(binding.feedbackBuffers);
      }
      return binding;
    }
    _swapBuffers(opts) {
      if (!this.feedbackMap) {
        return null;
      }
      const sourceBuffers = Object.assign({}, opts.sourceBuffers);
      const feedbackBuffers = Object.assign({}, opts.feedbackBuffers);
      for (const srcName in this.feedbackMap) {
        const dstName = this.feedbackMap[srcName];
        sourceBuffers[srcName] = opts.feedbackBuffers[dstName];
        feedbackBuffers[dstName] = opts.sourceBuffers[srcName];
        assert6(feedbackBuffers[dstName] instanceof Buffer2);
      }
      return {
        sourceBuffers,
        feedbackBuffers
      };
    }
    _createNewBuffer(name16, opts) {
      const buffer = new Buffer2(this.gl, opts);
      if (this.resources[name16]) {
        this.resources[name16].delete();
      }
      this.resources[name16] = buffer;
      return buffer;
    }
    _getNextIndex() {
      return (this.currentIndex + 1) % 2;
    }
  };

  // node_modules/@luma.gl/engine/dist/esm/transform/transform-shader-utils.js
  var SAMPLER_UNIFORM_PREFIX = "transform_uSampler_";
  var SIZE_UNIFORM_PREFIX = "transform_uSize_";
  var VS_POS_VARIABLE = "transform_position";
  function updateForTextures(_ref) {
    let {
      vs: vs7,
      sourceTextureMap,
      targetTextureVarying,
      targetTexture
    } = _ref;
    const texAttributeNames = Object.keys(sourceTextureMap);
    let sourceCount = texAttributeNames.length;
    let targetTextureType = null;
    const samplerTextureMap = {};
    let updatedVs = vs7;
    let finalInject = {};
    if (sourceCount > 0 || targetTextureVarying) {
      const vsLines = updatedVs.split("\n");
      const updateVsLines = vsLines.slice();
      vsLines.forEach((line, index5, lines) => {
        if (sourceCount > 0) {
          const updated = processAttributeDefinition(line, sourceTextureMap);
          if (updated) {
            const {
              updatedLine,
              inject
            } = updated;
            updateVsLines[index5] = updatedLine;
            finalInject = combineInjects([finalInject, inject]);
            Object.assign(samplerTextureMap, updated.samplerTextureMap);
            sourceCount--;
          }
        }
        if (targetTextureVarying && !targetTextureType) {
          targetTextureType = getVaryingType(line, targetTextureVarying);
        }
      });
      if (targetTextureVarying) {
        assert6(targetTexture);
        const sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying);
        const uniformDeclaration = "uniform vec2 ".concat(sizeName, ";\n");
        const posInstructions = "     vec2 ".concat(VS_POS_VARIABLE, " = transform_getPos(").concat(sizeName, ");\n     gl_Position = vec4(").concat(VS_POS_VARIABLE, ", 0, 1.);\n");
        const inject = {
          "vs:#decl": uniformDeclaration,
          "vs:#main-start": posInstructions
        };
        finalInject = combineInjects([finalInject, inject]);
      }
      updatedVs = updateVsLines.join("\n");
    }
    return {
      vs: updatedVs,
      targetTextureType,
      inject: finalInject,
      samplerTextureMap
    };
  }
  function getSizeUniforms(_ref2) {
    let {
      sourceTextureMap,
      targetTextureVarying,
      targetTexture
    } = _ref2;
    const uniforms = {};
    let width8;
    let height8;
    if (targetTextureVarying) {
      ({
        width: width8,
        height: height8
      } = targetTexture);
      uniforms["".concat(SIZE_UNIFORM_PREFIX).concat(targetTextureVarying)] = [width8, height8];
    }
    for (const textureName in sourceTextureMap) {
      ({
        width: width8,
        height: height8
      } = sourceTextureMap[textureName]);
      uniforms["".concat(SIZE_UNIFORM_PREFIX).concat(textureName)] = [width8, height8];
    }
    return uniforms;
  }
  function getAttributeDefinition(line) {
    return getQualifierDetails(line, ["attribute", "in"]);
  }
  function getSamplerDeclerations(textureName) {
    const samplerName = "".concat(SAMPLER_UNIFORM_PREFIX).concat(textureName);
    const sizeName = "".concat(SIZE_UNIFORM_PREFIX).concat(textureName);
    const uniformDeclerations = "  uniform sampler2D ".concat(samplerName, ";\n  uniform vec2 ").concat(sizeName, ";");
    return {
      samplerName,
      sizeName,
      uniformDeclerations
    };
  }
  function getVaryingType(line, varying) {
    const qualaiferDetails = getQualifierDetails(line, ["varying", "out"]);
    if (!qualaiferDetails) {
      return null;
    }
    return qualaiferDetails.name === varying ? qualaiferDetails.type : null;
  }
  function processAttributeDefinition(line, textureMap) {
    const samplerTextureMap = {};
    const attributeData = getAttributeDefinition(line);
    if (!attributeData) {
      return null;
    }
    const {
      type,
      name: name16
    } = attributeData;
    if (name16 && textureMap[name16]) {
      const updatedLine = "// ".concat(line, " => Replaced by Transform with a sampler");
      const {
        samplerName,
        sizeName,
        uniformDeclerations
      } = getSamplerDeclerations(name16);
      const channels = typeToChannelSuffix(type);
      const sampleInstruction = "  ".concat(type, " ").concat(name16, " = transform_getInput(").concat(samplerName, ", ").concat(sizeName, ").").concat(channels, ";\n");
      samplerTextureMap[samplerName] = name16;
      const inject = {
        "vs:#decl": uniformDeclerations,
        "vs:#main-start": sampleInstruction
      };
      return {
        updatedLine,
        inject,
        samplerTextureMap
      };
    }
    return null;
  }

  // node_modules/@luma.gl/engine/dist/esm/transform/texture-transform.js
  var SRC_TEX_PARAMETER_OVERRIDES = {
    [10241]: 9728,
    [10240]: 9728,
    [10242]: 33071,
    [10243]: 33071
  };
  var FS_OUTPUT_VARIABLE = "transform_output";
  var TextureTransform = class {
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.gl = gl;
      this.id = this.currentIndex = 0;
      this._swapTexture = null;
      this.targetTextureVarying = null;
      this.targetTextureType = null;
      this.samplerTextureMap = null;
      this.bindings = [];
      this.resources = {};
      this._initialize(props);
      Object.seal(this);
    }
    updateModelProps() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const updatedModelProps = this._processVertexShader(props);
      return Object.assign({}, props, updatedModelProps);
    }
    getDrawOptions() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        sourceBuffers,
        sourceTextures,
        framebuffer,
        targetTexture
      } = this.bindings[this.currentIndex];
      const attributes = Object.assign({}, sourceBuffers, opts.attributes);
      const uniforms = Object.assign({}, opts.uniforms);
      const parameters = Object.assign({}, opts.parameters);
      let discard3 = opts.discard;
      if (this.hasSourceTextures || this.hasTargetTexture) {
        attributes.transform_elementID = this.elementIDBuffer;
        for (const sampler in this.samplerTextureMap) {
          const textureName = this.samplerTextureMap[sampler];
          uniforms[sampler] = sourceTextures[textureName];
        }
        this._setSourceTextureParameters();
        const sizeUniforms = getSizeUniforms({
          sourceTextureMap: sourceTextures,
          targetTextureVarying: this.targetTextureVarying,
          targetTexture
        });
        Object.assign(uniforms, sizeUniforms);
      }
      if (this.hasTargetTexture) {
        discard3 = false;
        parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];
      }
      return {
        attributes,
        framebuffer,
        uniforms,
        discard: discard3,
        parameters
      };
    }
    swap() {
      if (this._swapTexture) {
        this.currentIndex = this._getNextIndex();
        return true;
      }
      return false;
    }
    update() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this._setupTextures(opts);
    }
    getTargetTexture() {
      const {
        targetTexture
      } = this.bindings[this.currentIndex];
      return targetTexture;
    }
    getData() {
      let {
        packed = false
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        framebuffer
      } = this.bindings[this.currentIndex];
      const pixels = readPixelsToArray(framebuffer);
      if (!packed) {
        return pixels;
      }
      const ArrayType = pixels.constructor;
      const channelCount = typeToChannelCount(this.targetTextureType);
      const packedPixels = new ArrayType(pixels.length * channelCount / 4);
      let packCount = 0;
      for (let i = 0; i < pixels.length; i += 4) {
        for (let j = 0; j < channelCount; j++) {
          packedPixels[packCount++] = pixels[i + j];
        }
      }
      return packedPixels;
    }
    getFramebuffer() {
      const currentResources = this.bindings[this.currentIndex];
      return currentResources.framebuffer;
    }
    delete() {
      if (this.ownTexture) {
        this.ownTexture.delete();
      }
      if (this.elementIDBuffer) {
        this.elementIDBuffer.delete();
      }
    }
    _initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        _targetTextureVarying,
        _swapTexture
      } = props;
      this._swapTexture = _swapTexture;
      this.targetTextureVarying = _targetTextureVarying;
      this.hasTargetTexture = _targetTextureVarying;
      this._setupTextures(props);
    }
    _createTargetTexture(props) {
      const {
        sourceTextures,
        textureOrReference
      } = props;
      if (textureOrReference instanceof Texture2D) {
        return textureOrReference;
      }
      const refTexture = sourceTextures[textureOrReference];
      if (!refTexture) {
        return null;
      }
      this._targetRefTexName = textureOrReference;
      return this._createNewTexture(refTexture);
    }
    _setupTextures() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        sourceBuffers,
        _sourceTextures = {},
        _targetTexture
      } = props;
      const targetTexture = this._createTargetTexture({
        sourceTextures: _sourceTextures,
        textureOrReference: _targetTexture
      });
      this.hasSourceTextures = this.hasSourceTextures || _sourceTextures && Object.keys(_sourceTextures).length > 0;
      this._updateBindings({
        sourceBuffers,
        sourceTextures: _sourceTextures,
        targetTexture
      });
      if ("elementCount" in props) {
        this._updateElementIDBuffer(props.elementCount);
      }
    }
    _updateElementIDBuffer(elementCount) {
      if (typeof elementCount !== "number" || this.elementCount >= elementCount) {
        return;
      }
      const elementIds = new Float32Array(elementCount);
      elementIds.forEach((_, index5, array2) => {
        array2[index5] = index5;
      });
      if (!this.elementIDBuffer) {
        this.elementIDBuffer = new Buffer2(this.gl, {
          data: elementIds,
          accessor: {
            size: 1
          }
        });
      } else {
        this.elementIDBuffer.setData({
          data: elementIds
        });
      }
      this.elementCount = elementCount;
    }
    _updateBindings(opts) {
      this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);
      if (this._swapTexture) {
        const {
          sourceTextures,
          targetTexture
        } = this._swapTextures(this.bindings[this.currentIndex]);
        const nextIndex = this._getNextIndex();
        this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
          sourceTextures,
          targetTexture
        });
      }
    }
    _updateBinding(binding, opts) {
      const {
        sourceBuffers,
        sourceTextures,
        targetTexture
      } = opts;
      if (!binding) {
        binding = {
          sourceBuffers: {},
          sourceTextures: {},
          targetTexture: null
        };
      }
      Object.assign(binding.sourceTextures, sourceTextures);
      Object.assign(binding.sourceBuffers, sourceBuffers);
      if (targetTexture) {
        binding.targetTexture = targetTexture;
        const {
          width: width8,
          height: height8
        } = targetTexture;
        const {
          framebuffer
        } = binding;
        if (framebuffer) {
          framebuffer.update({
            attachments: {
              [36064]: targetTexture
            },
            resizeAttachments: false
          });
          framebuffer.resize({
            width: width8,
            height: height8
          });
        } else {
          binding.framebuffer = new Framebuffer(this.gl, {
            id: "transform-framebuffer",
            width: width8,
            height: height8,
            attachments: {
              [36064]: targetTexture
            }
          });
        }
      }
      return binding;
    }
    _setSourceTextureParameters() {
      const index5 = this.currentIndex;
      const {
        sourceTextures
      } = this.bindings[index5];
      for (const name16 in sourceTextures) {
        sourceTextures[name16].setParameters(SRC_TEX_PARAMETER_OVERRIDES);
      }
    }
    _swapTextures(opts) {
      if (!this._swapTexture) {
        return null;
      }
      const sourceTextures = Object.assign({}, opts.sourceTextures);
      sourceTextures[this._swapTexture] = opts.targetTexture;
      const targetTexture = opts.sourceTextures[this._swapTexture];
      return {
        sourceTextures,
        targetTexture
      };
    }
    _createNewTexture(refTexture) {
      const texture = cloneTextureFrom(refTexture, {
        parameters: {
          [10241]: 9728,
          [10240]: 9728,
          [10242]: 33071,
          [10243]: 33071
        },
        pixelStore: {
          [37440]: false
        }
      });
      if (this.ownTexture) {
        this.ownTexture.delete();
      }
      this.ownTexture = texture;
      return texture;
    }
    _getNextIndex() {
      return (this.currentIndex + 1) % 2;
    }
    _processVertexShader() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        sourceTextures,
        targetTexture
      } = this.bindings[this.currentIndex];
      const {
        vs: vs7,
        uniforms,
        targetTextureType,
        inject,
        samplerTextureMap
      } = updateForTextures({
        vs: props.vs,
        sourceTextureMap: sourceTextures,
        targetTextureVarying: this.targetTextureVarying,
        targetTexture
      });
      const combinedInject = combineInjects([props.inject || {}, inject]);
      this.targetTextureType = targetTextureType;
      this.samplerTextureMap = samplerTextureMap;
      const fs4 = props._fs || getPassthroughFS({
        version: getShaderVersion(vs7),
        input: this.targetTextureVarying,
        inputType: targetTextureType,
        output: FS_OUTPUT_VARIABLE
      });
      const modules = this.hasSourceTextures || this.targetTextureVarying ? [transform].concat(props.modules || []) : props.modules;
      return {
        vs: vs7,
        fs: fs4,
        modules,
        uniforms,
        inject: combinedInject
      };
    }
  };

  // node_modules/@luma.gl/engine/dist/esm/transform/transform.js
  var Transform = class {
    static isSupported(gl) {
      return isWebGL2(gl);
    }
    constructor(gl) {
      let props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.gl = gl;
      this.model = null;
      this.elementCount = 0;
      this.bufferTransform = null;
      this.textureTransform = null;
      this.elementIDBuffer = null;
      this._initialize(props);
      Object.seal(this);
    }
    delete() {
      const {
        model,
        bufferTransform,
        textureTransform
      } = this;
      if (model) {
        model.delete();
      }
      if (bufferTransform) {
        bufferTransform.delete();
      }
      if (textureTransform) {
        textureTransform.delete();
      }
    }
    run() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        clearRenderTarget = true
      } = opts;
      const updatedOpts = this._updateDrawOptions(opts);
      if (clearRenderTarget && updatedOpts.framebuffer) {
        updatedOpts.framebuffer.clear({
          color: true
        });
      }
      this.model.transform(updatedOpts);
    }
    swap() {
      let swapped = false;
      const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
      for (const resourceTransform of resourceTransforms) {
        swapped = swapped || resourceTransform.swap();
      }
      assert6(swapped, "Nothing to swap");
    }
    getBuffer() {
      let varyingName = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);
    }
    getData() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
      for (const resourceTransform of resourceTransforms) {
        const data = resourceTransform.getData(opts);
        if (data) {
          return data;
        }
      }
      return null;
    }
    getFramebuffer() {
      return this.textureTransform && this.textureTransform.getFramebuffer();
    }
    update() {
      let opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if ("elementCount" in opts) {
        this.model.setVertexCount(opts.elementCount);
      }
      const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
      for (const resourceTransform of resourceTransforms) {
        resourceTransform.update(opts);
      }
    }
    _initialize() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        gl
      } = this;
      this._buildResourceTransforms(gl, props);
      props = this._updateModelProps(props);
      this.model = new Model(gl, Object.assign({}, props, {
        fs: props.fs || getPassthroughFS({
          version: getShaderVersion(props.vs)
        }),
        id: props.id || "transform-model",
        drawMode: props.drawMode || 0,
        vertexCount: props.elementCount
      }));
      this.bufferTransform && this.bufferTransform.setupResources({
        model: this.model
      });
    }
    _updateModelProps(props) {
      let updatedProps = Object.assign({}, props);
      const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
      for (const resourceTransform of resourceTransforms) {
        updatedProps = resourceTransform.updateModelProps(updatedProps);
      }
      return updatedProps;
    }
    _buildResourceTransforms(gl, props) {
      if (canCreateBufferTransform(props)) {
        this.bufferTransform = new BufferTransform(gl, props);
      }
      if (canCreateTextureTransform(props)) {
        this.textureTransform = new TextureTransform(gl, props);
      }
      assert6(this.bufferTransform || this.textureTransform, "must provide source/feedback buffers or source/target textures");
    }
    _updateDrawOptions(opts) {
      let updatedOpts = Object.assign({}, opts);
      const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
      for (const resourceTransform of resourceTransforms) {
        updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));
      }
      return updatedOpts;
    }
  };
  function canCreateBufferTransform(props) {
    if (!isObjectEmpty2(props.feedbackBuffers) || !isObjectEmpty2(props.feedbackMap) || props.varyings && props.varyings.length > 0) {
      return true;
    }
    return false;
  }
  function canCreateTextureTransform(props) {
    if (!isObjectEmpty2(props._sourceTextures) || props._targetTexture || props._targetTextureVarying) {
      return true;
    }
    return false;
  }

  // node_modules/@luma.gl/engine/dist/esm/geometry/geometry.js
  var DRAW_MODE = {
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6
  };
  var Geometry = class {
    static get DRAW_MODE() {
      return DRAW_MODE;
    }
    constructor() {
      let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      const {
        id: id2 = uid("geometry"),
        drawMode = DRAW_MODE.TRIANGLES,
        attributes = {},
        indices = null,
        vertexCount = null
      } = props;
      this.id = id2;
      this.drawMode = drawMode | 0;
      this.attributes = {};
      this.userData = {};
      this._setAttributes(attributes, indices);
      this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);
    }
    get mode() {
      return this.drawMode;
    }
    getVertexCount() {
      return this.vertexCount;
    }
    getAttributes() {
      return this.indices ? {
        indices: this.indices,
        ...this.attributes
      } : this.attributes;
    }
    _print(attributeName) {
      return "Geometry ".concat(this.id, " attribute ").concat(attributeName);
    }
    _setAttributes(attributes, indices) {
      if (indices) {
        this.indices = ArrayBuffer.isView(indices) ? {
          value: indices,
          size: 1
        } : indices;
      }
      for (const attributeName in attributes) {
        let attribute = attributes[attributeName];
        attribute = ArrayBuffer.isView(attribute) ? {
          value: attribute
        } : attribute;
        assert6(ArrayBuffer.isView(attribute.value), "".concat(this._print(attributeName), ": must be typed array or object with value as typed array"));
        if ((attributeName === "POSITION" || attributeName === "positions") && !attribute.size) {
          attribute.size = 3;
        }
        if (attributeName === "indices") {
          assert6(!this.indices);
          this.indices = attribute;
        } else {
          this.attributes[attributeName] = attribute;
        }
      }
      if (this.indices && this.indices.isIndexed !== void 0) {
        this.indices = Object.assign({}, this.indices);
        delete this.indices.isIndexed;
      }
      return this;
    }
    _calculateVertexCount(attributes, indices) {
      if (indices) {
        return indices.value.length;
      }
      let vertexCount = Infinity;
      for (const attributeName in attributes) {
        const attribute = attributes[attributeName];
        const {
          value: value13,
          size: size5,
          constant
        } = attribute;
        if (!constant && value13 && size5 >= 1) {
          vertexCount = Math.min(vertexCount, value13.length / size5);
        }
      }
      assert6(Number.isFinite(vertexCount));
      return vertexCount;
    }
  };

  // node_modules/@luma.gl/engine/dist/esm/animation/timeline.js
  var channelHandles = 1;
  var animationHandles = 1;
  var Timeline = class {
    constructor() {
      this.time = 0;
      this.channels = /* @__PURE__ */ new Map();
      this.animations = /* @__PURE__ */ new Map();
      this.playing = false;
      this.lastEngineTime = -1;
    }
    addChannel(props) {
      const {
        delay: delay2 = 0,
        duration: duration2 = Number.POSITIVE_INFINITY,
        rate = 1,
        repeat = 1
      } = props;
      const handle = channelHandles++;
      const channel = {
        time: 0,
        delay: delay2,
        duration: duration2,
        rate,
        repeat
      };
      this._setChannelTime(channel, this.time);
      this.channels.set(handle, channel);
      return handle;
    }
    removeChannel(handle) {
      this.channels.delete(handle);
      for (const [animationHandle, animation] of this.animations) {
        if (animation.channel === handle) {
          this.detachAnimation(animationHandle);
        }
      }
    }
    isFinished(handle) {
      const channel = this.channels.get(handle);
      if (channel === void 0) {
        return false;
      }
      return this.time >= channel.delay + channel.duration * channel.repeat;
    }
    getTime(handle) {
      if (handle === void 0) {
        return this.time;
      }
      const channel = this.channels.get(handle);
      if (channel === void 0) {
        return -1;
      }
      return channel.time;
    }
    setTime(time) {
      this.time = Math.max(0, time);
      const channels = this.channels.values();
      for (const channel of channels) {
        this._setChannelTime(channel, this.time);
      }
      const animations = this.animations.values();
      for (const animationData of animations) {
        const {
          animation,
          channel
        } = animationData;
        animation.setTime(this.getTime(channel));
      }
    }
    play() {
      this.playing = true;
    }
    pause() {
      this.playing = false;
      this.lastEngineTime = -1;
    }
    reset() {
      this.setTime(0);
    }
    attachAnimation(animation, channelHandle) {
      const animationHandle = animationHandles++;
      this.animations.set(animationHandle, {
        animation,
        channel: channelHandle
      });
      animation.setTime(this.getTime(channelHandle));
      return animationHandle;
    }
    detachAnimation(handle) {
      this.animations.delete(handle);
    }
    update(engineTime) {
      if (this.playing) {
        if (this.lastEngineTime === -1) {
          this.lastEngineTime = engineTime;
        }
        this.setTime(this.time + (engineTime - this.lastEngineTime));
        this.lastEngineTime = engineTime;
      }
    }
    _setChannelTime(channel, time) {
      const offsetTime = time - channel.delay;
      const totalDuration = channel.duration * channel.repeat;
      if (offsetTime >= totalDuration) {
        channel.time = channel.duration * channel.rate;
      } else {
        channel.time = Math.max(0, offsetTime) % channel.duration;
        channel.time *= channel.rate;
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/effects/lighting/ambient-light.js
  var DEFAULT_LIGHT_COLOR = [255, 255, 255];
  var DEFAULT_LIGHT_INTENSITY = 1;
  var idCount = 0;
  var AmbientLight = class {
    constructor(props = {}) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "color", void 0);
      _defineProperty(this, "intensity", void 0);
      _defineProperty(this, "type", "ambient");
      const {
        color = DEFAULT_LIGHT_COLOR
      } = props;
      const {
        intensity = DEFAULT_LIGHT_INTENSITY
      } = props;
      this.id = props.id || "ambient-".concat(idCount++);
      this.color = color;
      this.intensity = intensity;
    }
  };

  // node_modules/@deck.gl/core/dist/esm/effects/lighting/directional-light.js
  var DEFAULT_LIGHT_COLOR2 = [255, 255, 255];
  var DEFAULT_LIGHT_INTENSITY2 = 1;
  var DEFAULT_LIGHT_DIRECTION = [0, 0, -1];
  var idCount2 = 0;
  var DirectionalLight = class {
    constructor(props = {}) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "color", void 0);
      _defineProperty(this, "intensity", void 0);
      _defineProperty(this, "type", "directional");
      _defineProperty(this, "direction", void 0);
      _defineProperty(this, "shadow", void 0);
      const {
        color = DEFAULT_LIGHT_COLOR2
      } = props;
      const {
        intensity = DEFAULT_LIGHT_INTENSITY2
      } = props;
      const {
        direction = DEFAULT_LIGHT_DIRECTION
      } = props;
      const {
        _shadow = false
      } = props;
      this.id = props.id || "directional-".concat(idCount2++);
      this.color = color;
      this.intensity = intensity;
      this.type = "directional";
      this.direction = new Vector3(direction).normalize().toArray();
      this.shadow = _shadow;
    }
    getProjectedLight(opts) {
      return this;
    }
  };

  // node_modules/@deck.gl/core/dist/esm/passes/pass.js
  var Pass = class {
    constructor(gl, props = {
      id: "pass"
    }) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "gl", void 0);
      _defineProperty(this, "props", void 0);
      const {
        id: id2
      } = props;
      this.id = id2;
      this.gl = gl;
      this.props = {
        ...props
      };
    }
    setProps(props) {
      Object.assign(this.props, props);
    }
    render(params) {
    }
    cleanup() {
    }
  };

  // node_modules/@deck.gl/core/dist/esm/passes/layers-pass.js
  var LayersPass = class extends Pass {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "_lastRenderIndex", -1);
    }
    render(options2) {
      const gl = this.gl;
      setParameters(gl, {
        framebuffer: options2.target
      });
      return this._drawLayers(options2);
    }
    _drawLayers(options2) {
      const {
        target: target5,
        moduleParameters,
        viewports,
        views,
        onViewportActive,
        clearStack = true,
        clearCanvas = true
      } = options2;
      options2.pass = options2.pass || "unknown";
      const gl = this.gl;
      if (clearCanvas) {
        clearGLCanvas(gl, target5);
      }
      if (clearStack) {
        this._lastRenderIndex = -1;
      }
      const renderStats = [];
      for (const viewport of viewports) {
        const view = views && views[viewport.id];
        onViewportActive === null || onViewportActive === void 0 ? void 0 : onViewportActive(viewport);
        const drawLayerParams = this._getDrawLayerParams(viewport, options2);
        const subViewports = viewport.subViewports || [viewport];
        for (const subViewport of subViewports) {
          const stats = this._drawLayersInViewport(gl, {
            target: target5,
            moduleParameters,
            viewport: subViewport,
            view,
            pass: options2.pass,
            layers: options2.layers
          }, drawLayerParams);
          renderStats.push(stats);
        }
      }
      return renderStats;
    }
    _getDrawLayerParams(viewport, {
      layers,
      pass: pass2,
      isPicking = false,
      layerFilter,
      cullRect,
      effects,
      moduleParameters
    }, evaluateShouldDrawOnly = false) {
      const drawLayerParams = [];
      const indexResolver = layerIndexResolver(this._lastRenderIndex + 1);
      const drawContext = {
        layer: layers[0],
        viewport,
        isPicking,
        renderPass: pass2,
        cullRect
      };
      const layerFilterCache = {};
      for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
        const layer = layers[layerIndex];
        const shouldDrawLayer = this._shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache);
        const layerParam = {
          shouldDrawLayer
        };
        if (shouldDrawLayer && !evaluateShouldDrawOnly) {
          layerParam.layerRenderIndex = indexResolver(layer, shouldDrawLayer);
          layerParam.moduleParameters = this._getModuleParameters(layer, effects, pass2, moduleParameters);
          layerParam.layerParameters = this.getLayerParameters(layer, layerIndex, viewport);
        }
        drawLayerParams[layerIndex] = layerParam;
      }
      return drawLayerParams;
    }
    _drawLayersInViewport(gl, {
      layers,
      moduleParameters: globalModuleParameters,
      pass: pass2,
      target: target5,
      viewport,
      view
    }, drawLayerParams) {
      const glViewport = getGLViewport(gl, {
        moduleParameters: globalModuleParameters,
        target: target5,
        viewport
      });
      if (view && view.props.clear) {
        const clearOpts = view.props.clear === true ? {
          color: true,
          depth: true
        } : view.props.clear;
        withParameters(gl, {
          scissorTest: true,
          scissor: glViewport
        }, () => clear(gl, clearOpts));
      }
      const renderStatus = {
        totalCount: layers.length,
        visibleCount: 0,
        compositeCount: 0,
        pickableCount: 0
      };
      setParameters(gl, {
        viewport: glViewport
      });
      for (let layerIndex = 0; layerIndex < layers.length; layerIndex++) {
        const layer = layers[layerIndex];
        const {
          shouldDrawLayer,
          layerRenderIndex,
          moduleParameters,
          layerParameters
        } = drawLayerParams[layerIndex];
        if (shouldDrawLayer && layer.props.pickable) {
          renderStatus.pickableCount++;
        }
        if (layer.isComposite) {
          renderStatus.compositeCount++;
        } else if (shouldDrawLayer) {
          renderStatus.visibleCount++;
          this._lastRenderIndex = Math.max(this._lastRenderIndex, layerRenderIndex);
          moduleParameters.viewport = viewport;
          try {
            layer._drawLayer({
              moduleParameters,
              uniforms: {
                layerIndex: layerRenderIndex
              },
              parameters: layerParameters
            });
          } catch (err) {
            layer.raiseError(err, "drawing ".concat(layer, " to ").concat(pass2));
          }
        }
      }
      return renderStatus;
    }
    shouldDrawLayer(layer) {
      return true;
    }
    getModuleParameters(layer, effects) {
      return null;
    }
    getLayerParameters(layer, layerIndex, viewport) {
      return layer.props.parameters;
    }
    _shouldDrawLayer(layer, drawContext, layerFilter, layerFilterCache) {
      const shouldDrawLayer = layer.props.visible && this.shouldDrawLayer(layer);
      if (!shouldDrawLayer) {
        return false;
      }
      drawContext.layer = layer;
      let parent2 = layer.parent;
      while (parent2) {
        if (!parent2.props.visible || !parent2.filterSubLayer(drawContext)) {
          return false;
        }
        drawContext.layer = parent2;
        parent2 = parent2.parent;
      }
      if (layerFilter) {
        const rootLayerId = drawContext.layer.id;
        if (!(rootLayerId in layerFilterCache)) {
          layerFilterCache[rootLayerId] = layerFilter(drawContext);
        }
        if (!layerFilterCache[rootLayerId]) {
          return false;
        }
      }
      layer.activateViewport(drawContext.viewport);
      return true;
    }
    _getModuleParameters(layer, effects, pass2, overrides) {
      var _layer$internalState;
      const moduleParameters = Object.assign(Object.create(((_layer$internalState = layer.internalState) === null || _layer$internalState === void 0 ? void 0 : _layer$internalState.propsInTransition) || layer.props), {
        autoWrapLongitude: layer.wrapLongitude,
        viewport: layer.context.viewport,
        mousePosition: layer.context.mousePosition,
        pickingActive: 0,
        devicePixelRatio: cssToDeviceRatio(this.gl)
      });
      if (effects) {
        for (const effect of effects) {
          var _effect$getModulePara;
          Object.assign(moduleParameters, (_effect$getModulePara = effect.getModuleParameters) === null || _effect$getModulePara === void 0 ? void 0 : _effect$getModulePara.call(effect, layer));
        }
      }
      return Object.assign(moduleParameters, this.getModuleParameters(layer, effects), overrides);
    }
  };
  function layerIndexResolver(startIndex = 0, layerIndices = {}) {
    const resolvers = {};
    const resolveLayerIndex = (layer, isDrawn) => {
      const indexOverride = layer.props._offset;
      const layerId = layer.id;
      const parentId = layer.parent && layer.parent.id;
      let index5;
      if (parentId && !(parentId in layerIndices)) {
        resolveLayerIndex(layer.parent, false);
      }
      if (parentId in resolvers) {
        const resolver = resolvers[parentId] = resolvers[parentId] || layerIndexResolver(layerIndices[parentId], layerIndices);
        index5 = resolver(layer, isDrawn);
        resolvers[layerId] = resolver;
      } else if (Number.isFinite(indexOverride)) {
        index5 = indexOverride + (layerIndices[parentId] || 0);
        resolvers[layerId] = null;
      } else {
        index5 = startIndex;
      }
      if (isDrawn && index5 >= startIndex) {
        startIndex = index5 + 1;
      }
      layerIndices[layerId] = index5;
      return index5;
    };
    return resolveLayerIndex;
  }
  function getGLViewport(gl, {
    moduleParameters,
    target: target5,
    viewport
  }) {
    const useTarget = target5 && target5.id !== "default-framebuffer";
    const pixelRatio3 = moduleParameters && moduleParameters.devicePixelRatio || cssToDeviceRatio(gl);
    const height8 = useTarget ? target5.height : gl.drawingBufferHeight;
    const dimensions = viewport;
    return [dimensions.x * pixelRatio3, height8 - (dimensions.y + dimensions.height) * pixelRatio3, dimensions.width * pixelRatio3, dimensions.height * pixelRatio3];
  }
  function clearGLCanvas(gl, targetFramebuffer) {
    const width8 = targetFramebuffer ? targetFramebuffer.width : gl.drawingBufferWidth;
    const height8 = targetFramebuffer ? targetFramebuffer.height : gl.drawingBufferHeight;
    setParameters(gl, {
      viewport: [0, 0, width8, height8]
    });
    gl.clear(16384 | 256);
  }

  // node_modules/@deck.gl/core/dist/esm/passes/shadow-pass.js
  var ShadowPass = class extends LayersPass {
    constructor(gl, props) {
      super(gl, props);
      _defineProperty(this, "shadowMap", void 0);
      _defineProperty(this, "depthBuffer", void 0);
      _defineProperty(this, "fbo", void 0);
      this.shadowMap = new Texture2D(gl, {
        width: 1,
        height: 1,
        parameters: {
          [10241]: 9729,
          [10240]: 9729,
          [10242]: 33071,
          [10243]: 33071
        }
      });
      this.depthBuffer = new Renderbuffer(gl, {
        format: 33189,
        width: 1,
        height: 1
      });
      this.fbo = new Framebuffer(gl, {
        id: "shadowmap",
        width: 1,
        height: 1,
        attachments: {
          [36064]: this.shadowMap,
          [36096]: this.depthBuffer
        }
      });
    }
    render(params) {
      const target5 = this.fbo;
      withParameters(this.gl, {
        depthRange: [0, 1],
        depthTest: true,
        blend: false,
        clearColor: [1, 1, 1, 1]
      }, () => {
        const viewport = params.viewports[0];
        const pixelRatio3 = cssToDeviceRatio(this.gl);
        const width8 = viewport.width * pixelRatio3;
        const height8 = viewport.height * pixelRatio3;
        if (width8 !== target5.width || height8 !== target5.height) {
          target5.resize({
            width: width8,
            height: height8
          });
        }
        super.render({
          ...params,
          target: target5,
          pass: "shadow"
        });
      });
    }
    shouldDrawLayer(layer) {
      return layer.props.shadowEnabled !== false;
    }
    getModuleParameters() {
      return {
        drawToShadowMap: true
      };
    }
    delete() {
      if (this.fbo) {
        this.fbo.delete();
        this.fbo = null;
      }
      if (this.shadowMap) {
        this.shadowMap.delete();
        this.shadowMap = null;
      }
      if (this.depthBuffer) {
        this.depthBuffer.delete();
        this.depthBuffer = null;
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/shaderlib/misc/geometry.js
  var defines = "#define SMOOTH_EDGE_RADIUS 0.5";
  var vs3 = "\n".concat(defines, "\n\nstruct VertexGeometry {\n  vec4 position;\n  vec3 worldPosition;\n  vec3 worldPositionAlt;\n  vec3 normal;\n  vec2 uv;\n  vec3 pickingColor;\n} geometry = VertexGeometry(\n  vec4(0.0, 0.0, 1.0, 0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec2(0.0),\n  vec3(0.0)\n);\n");
  var fs2 = "\n".concat(defines, "\n\nstruct FragmentGeometry {\n  vec2 uv;\n} geometry;\n\nfloat smoothedge(float edge, float x) {\n  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);\n}\n");
  var geometry_default = {
    name: "geometry",
    vs: vs3,
    fs: fs2
  };

  // node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.glsl.js
  var COORDINATE_SYSTEM_GLSL_CONSTANTS = Object.keys(COORDINATE_SYSTEM).map((key) => "const int COORDINATE_SYSTEM_".concat(key, " = ").concat(COORDINATE_SYSTEM[key], ";")).join("");
  var PROJECTION_MODE_GLSL_CONSTANTS = Object.keys(PROJECTION_MODE).map((key) => "const int PROJECTION_MODE_".concat(key, " = ").concat(PROJECTION_MODE[key], ";")).join("");
  var UNIT_GLSL_CONSTANTS = Object.keys(UNIT).map((key) => "const int UNIT_".concat(key.toUpperCase(), " = ").concat(UNIT[key], ";")).join("");
  var project_glsl_default = "".concat(COORDINATE_SYSTEM_GLSL_CONSTANTS, "\n").concat(PROJECTION_MODE_GLSL_CONSTANTS, "\n").concat(UNIT_GLSL_CONSTANTS, "\n\nuniform int project_uCoordinateSystem;\nuniform int project_uProjectionMode;\nuniform float project_uScale;\nuniform bool project_uWrapLongitude;\nuniform vec3 project_uCommonUnitsPerMeter;\nuniform vec3 project_uCommonUnitsPerWorldUnit;\nuniform vec3 project_uCommonUnitsPerWorldUnit2;\nuniform vec4 project_uCenter;\nuniform mat4 project_uModelMatrix;\nuniform mat4 project_uViewProjectionMatrix;\nuniform vec2 project_uViewportSize;\nuniform float project_uDevicePixelRatio;\nuniform float project_uFocalDistance;\nuniform vec3 project_uCameraPosition;\nuniform vec3 project_uCoordinateOrigin;\nuniform vec3 project_uCommonOrigin;\nuniform bool project_uPseudoMeters;\n\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\nconst vec3 ZERO_64_LOW = vec3(0.0);\nconst float EARTH_RADIUS = 6370972.0;\nconst float GLOBE_RADIUS = 256.0;\nfloat project_size_at_latitude(float lat) {\n  float y = clamp(lat, -89.9, 89.9);\n  return 1.0 / cos(radians(y));\n}\n\nfloat project_size() {\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR &&\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT &&\n    project_uPseudoMeters == false) {\n    \n    if (geometry.position.w == 0.0) {\n      return project_size_at_latitude(geometry.worldPosition.y);\n    }\n  \n    float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;\n    float y2 = y * y;\n    float y4 = y2 * y2;\n    float y6 = y4 * y2;\n    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;\n  }\n  return 1.0;\n}\n\nfloat project_size_at_latitude(float meters, float lat) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size_at_latitude(lat);\n}\nfloat project_size(float meters) {\n  return meters * project_uCommonUnitsPerMeter.z * project_size();\n}\n\nvec2 project_size(vec2 meters) {\n  return meters * project_uCommonUnitsPerMeter.xy * project_size();\n}\n\nvec3 project_size(vec3 meters) {\n  return meters * project_uCommonUnitsPerMeter * project_size();\n}\n\nvec4 project_size(vec4 meters) {\n  return vec4(meters.xyz * project_uCommonUnitsPerMeter, meters.w);\n}\nmat3 project_get_orientation_matrix(vec3 up) {\n  vec3 uz = normalize(up);\n  vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));\n  vec3 uy = cross(uz, ux);\n  return mat3(ux, uy, uz);\n}\n\nbool project_needs_rotation(vec3 commonPosition, out mat3 transform) {\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    transform = project_get_orientation_matrix(commonPosition);\n    return true;\n  }\n  return false;\n}\nvec3 project_normal(vec3 vector) {\n  vec4 normal_modelspace = project_uModelMatrix * vec4(vector, 0.0);\n  vec3 n = normalize(normal_modelspace.xyz * project_uCommonUnitsPerMeter);\n  mat3 rotation;\n  if (project_needs_rotation(geometry.position.xyz, rotation)) {\n    n = rotation * n;\n  }\n  return n;\n}\n\nvec4 project_offset_(vec4 offset) {\n  float dy = offset.y;\n  vec3 commonUnitsPerWorldUnit = project_uCommonUnitsPerWorldUnit + project_uCommonUnitsPerWorldUnit2 * dy;\n  return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\nvec2 project_mercator_(vec2 lnglat) {\n  float x = lnglat.x;\n  if (project_uWrapLongitude) {\n    x = mod(x + 180., 360.0) - 180.;\n  }\n  float y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2(\n    radians(x) + PI,\n    PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\nvec3 project_globe_(vec3 lnglatz) {\n  float lambda = radians(lnglatz.x);\n  float phi = radians(lnglatz.y);\n  float cosPhi = cos(phi);\n  float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;\n\n  return vec3(\n    sin(lambda) * cosPhi,\n    -cos(lambda) * cosPhi,\n    sin(phi)\n  ) * D;\n}\nvec4 project_position(vec4 position, vec3 position64Low) {\n  vec4 position_world = project_uModelMatrix * position;\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_mercator_(position_world.xy),\n        project_size_at_latitude(position_world.z, position_world.y),\n        position_world.w\n      );\n    }\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {\n      position_world.xyz += project_uCoordinateOrigin;\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_GLOBE) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4(\n        project_globe_(position_world.xyz),\n        position_world.w\n      );\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n    if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      if (abs(position_world.y - project_uCoordinateOrigin.y) > 0.25) {\n        return vec4(\n          project_mercator_(position_world.xy) - project_uCommonOrigin.xy,\n          project_size(position_world.z),\n          position_world.w\n        );\n      }\n    }\n  }\n  if (project_uProjectionMode == PROJECTION_MODE_IDENTITY ||\n    (project_uProjectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&\n    (project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n     project_uCoordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {\n    position_world.xyz -= project_uCoordinateOrigin;\n  }\n  return project_offset_(position_world + project_uModelMatrix * vec4(position64Low, 0.0));\n}\n\nvec4 project_position(vec4 position) {\n  return project_position(position, ZERO_64_LOW);\n}\n\nvec3 project_position(vec3 position, vec3 position64Low) {\n  vec4 projected_position = project_position(vec4(position, 1.0), position64Low);\n  return projected_position.xyz;\n}\n\nvec3 project_position(vec3 position) {\n  vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);\n  return projected_position.xyz;\n}\n\nvec2 project_position(vec2 position) {\n  vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);\n  return projected_position.xy;\n}\n\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\n  return viewProjectionMatrix * position + center;\n}\nvec4 project_common_position_to_clipspace(vec4 position) {\n  return project_common_position_to_clipspace(position, project_uViewProjectionMatrix, project_uCenter);\n}\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\n  vec2 offset = pixels / project_uViewportSize * project_uDevicePixelRatio * 2.0;\n  return offset * project_uFocalDistance;\n}\n\nfloat project_size_to_pixel(float meters) {\n  return project_size(meters) * project_uScale;\n}\nfloat project_size_to_pixel(float size, int unit) {\n  if (unit == UNIT_METERS) return project_size_to_pixel(size);\n  if (unit == UNIT_COMMON) return size * project_uScale;\n  return size;\n}\nfloat project_pixel_size(float pixels) {\n  return pixels / project_uScale;\n}\nvec2 project_pixel_size(vec2 pixels) {\n  return pixels / project_uScale;\n}\n");

  // node_modules/@deck.gl/core/dist/esm/utils/memoize.js
  function isEqual(a, b) {
    if (a === b) {
      return true;
    }
    if (Array.isArray(a)) {
      const len = a.length;
      if (!b || b.length !== len) {
        return false;
      }
      for (let i = 0; i < len; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  function memoize(compute) {
    let cachedArgs = {};
    let cachedResult;
    return (args) => {
      for (const key in args) {
        if (!isEqual(args[key], cachedArgs[key])) {
          cachedResult = compute(args);
          cachedArgs = args;
          break;
        }
      }
      return cachedResult;
    };
  }

  // node_modules/@deck.gl/core/dist/esm/shaderlib/project/viewport-uniforms.js
  var ZERO_VECTOR = [0, 0, 0, 0];
  var VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
  var IDENTITY_MATRIX2 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  var DEFAULT_PIXELS_PER_UNIT2 = [0, 0, 0];
  var DEFAULT_COORDINATE_ORIGIN = [0, 0, 0];
  var getMemoizedViewportUniforms = memoize(calculateViewportUniforms);
  function getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin = DEFAULT_COORDINATE_ORIGIN) {
    if (coordinateOrigin.length < 3) {
      coordinateOrigin = [coordinateOrigin[0], coordinateOrigin[1], 0];
    }
    let shaderCoordinateOrigin = coordinateOrigin;
    let geospatialOrigin;
    let offsetMode = true;
    if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT_OFFSETS || coordinateSystem === COORDINATE_SYSTEM.METER_OFFSETS) {
      geospatialOrigin = coordinateOrigin;
    } else {
      geospatialOrigin = viewport.isGeospatial ? [Math.fround(viewport.longitude), Math.fround(viewport.latitude), 0] : null;
    }
    switch (viewport.projectionMode) {
      case PROJECTION_MODE.WEB_MERCATOR:
        if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
          geospatialOrigin = [0, 0, 0];
          offsetMode = false;
        }
        break;
      case PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET:
        if (coordinateSystem === COORDINATE_SYSTEM.LNGLAT) {
          shaderCoordinateOrigin = geospatialOrigin;
        } else if (coordinateSystem === COORDINATE_SYSTEM.CARTESIAN) {
          shaderCoordinateOrigin = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1]), 0];
          geospatialOrigin = viewport.unprojectPosition(shaderCoordinateOrigin);
          shaderCoordinateOrigin[0] -= coordinateOrigin[0];
          shaderCoordinateOrigin[1] -= coordinateOrigin[1];
          shaderCoordinateOrigin[2] -= coordinateOrigin[2];
        }
        break;
      case PROJECTION_MODE.IDENTITY:
        shaderCoordinateOrigin = viewport.position.map(Math.fround);
        shaderCoordinateOrigin[2] = shaderCoordinateOrigin[2] || 0;
        break;
      case PROJECTION_MODE.GLOBE:
        offsetMode = false;
        geospatialOrigin = null;
        break;
      default:
        offsetMode = false;
    }
    return {
      geospatialOrigin,
      shaderCoordinateOrigin,
      offsetMode
    };
  }
  function calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin) {
    const {
      viewMatrixUncentered,
      projectionMatrix
    } = viewport;
    let {
      viewMatrix,
      viewProjectionMatrix
    } = viewport;
    let projectionCenter = ZERO_VECTOR;
    let originCommon = ZERO_VECTOR;
    let cameraPosCommon = viewport.cameraPosition;
    const {
      geospatialOrigin,
      shaderCoordinateOrigin,
      offsetMode
    } = getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin);
    if (offsetMode) {
      originCommon = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
      cameraPosCommon = [cameraPosCommon[0] - originCommon[0], cameraPosCommon[1] - originCommon[1], cameraPosCommon[2] - originCommon[2]];
      originCommon[3] = 1;
      projectionCenter = transformMat43([], originCommon, viewProjectionMatrix);
      viewMatrix = viewMatrixUncentered || viewMatrix;
      viewProjectionMatrix = multiply2([], projectionMatrix, viewMatrix);
      viewProjectionMatrix = multiply2([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);
    }
    return {
      viewMatrix,
      viewProjectionMatrix,
      projectionCenter,
      originCommon,
      cameraPosCommon,
      shaderCoordinateOrigin,
      geospatialOrigin
    };
  }
  function getUniformsFromViewport({
    viewport,
    devicePixelRatio = 1,
    modelMatrix = null,
    coordinateSystem = COORDINATE_SYSTEM.DEFAULT,
    coordinateOrigin = DEFAULT_COORDINATE_ORIGIN,
    autoWrapLongitude = false
  }) {
    if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
      coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
    }
    const uniforms = getMemoizedViewportUniforms({
      viewport,
      devicePixelRatio,
      coordinateSystem,
      coordinateOrigin
    });
    uniforms.project_uWrapLongitude = autoWrapLongitude;
    uniforms.project_uModelMatrix = modelMatrix || IDENTITY_MATRIX2;
    return uniforms;
  }
  function calculateViewportUniforms({
    viewport,
    devicePixelRatio,
    coordinateSystem,
    coordinateOrigin
  }) {
    const {
      projectionCenter,
      viewProjectionMatrix,
      originCommon,
      cameraPosCommon,
      shaderCoordinateOrigin,
      geospatialOrigin
    } = calculateMatrixAndOffset(viewport, coordinateSystem, coordinateOrigin);
    const distanceScales = viewport.getDistanceScales();
    const viewportSize = [viewport.width * devicePixelRatio, viewport.height * devicePixelRatio];
    const focalDistance = transformMat43([], [0, 0, -viewport.focalDistance, 1], viewport.projectionMatrix)[3] || 1;
    const uniforms = {
      project_uCoordinateSystem: coordinateSystem,
      project_uProjectionMode: viewport.projectionMode,
      project_uCoordinateOrigin: shaderCoordinateOrigin,
      project_uCommonOrigin: originCommon.slice(0, 3),
      project_uCenter: projectionCenter,
      project_uPseudoMeters: Boolean(viewport._pseudoMeters),
      project_uViewportSize: viewportSize,
      project_uDevicePixelRatio: devicePixelRatio,
      project_uFocalDistance: focalDistance,
      project_uCommonUnitsPerMeter: distanceScales.unitsPerMeter,
      project_uCommonUnitsPerWorldUnit: distanceScales.unitsPerMeter,
      project_uCommonUnitsPerWorldUnit2: DEFAULT_PIXELS_PER_UNIT2,
      project_uScale: viewport.scale,
      project_uWrapLongitude: false,
      project_uViewProjectionMatrix: viewProjectionMatrix,
      project_uModelMatrix: IDENTITY_MATRIX2,
      project_uCameraPosition: cameraPosCommon
    };
    if (geospatialOrigin) {
      const distanceScalesAtOrigin = viewport.getDistanceScales(geospatialOrigin);
      switch (coordinateSystem) {
        case COORDINATE_SYSTEM.METER_OFFSETS:
          uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerMeter;
          uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerMeter2;
          break;
        case COORDINATE_SYSTEM.LNGLAT:
        case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
          if (!viewport._pseudoMeters) {
            uniforms.project_uCommonUnitsPerMeter = distanceScalesAtOrigin.unitsPerMeter;
          }
          uniforms.project_uCommonUnitsPerWorldUnit = distanceScalesAtOrigin.unitsPerDegree;
          uniforms.project_uCommonUnitsPerWorldUnit2 = distanceScalesAtOrigin.unitsPerDegree2;
          break;
        case COORDINATE_SYSTEM.CARTESIAN:
          uniforms.project_uCommonUnitsPerWorldUnit = [1, 1, distanceScalesAtOrigin.unitsPerMeter[2]];
          uniforms.project_uCommonUnitsPerWorldUnit2 = [0, 0, distanceScalesAtOrigin.unitsPerMeter2[2]];
          break;
        default:
          break;
      }
    }
    return uniforms;
  }

  // node_modules/@deck.gl/core/dist/esm/shaderlib/project/project.js
  var INITIAL_MODULE_OPTIONS = {};
  function getUniforms2(opts = INITIAL_MODULE_OPTIONS) {
    if ("viewport" in opts) {
      return getUniformsFromViewport(opts);
    }
    return {};
  }
  var project_default = {
    name: "project",
    dependencies: [fp32, geometry_default],
    vs: project_glsl_default,
    getUniforms: getUniforms2
  };

  // node_modules/@math.gl/web-mercator/dist/esm/math-utils.js
  function createMat4() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  function transformVector(matrix, vector) {
    const result = transformMat43([], vector, matrix);
    scale3(result, result, 1 / result[3]);
    return result;
  }
  function mod2(value13, divisor) {
    const modulus = value13 % divisor;
    return modulus < 0 ? divisor + modulus : modulus;
  }
  function lerp3(start2, end, step2) {
    return step2 * end + (1 - step2) * start2;
  }
  function clamp2(x, min5, max6) {
    return x < min5 ? min5 : x > max6 ? max6 : x;
  }
  function ieLog2(x) {
    return Math.log(x) * Math.LOG2E;
  }
  var log22 = Math.log2 || ieLog2;

  // node_modules/@math.gl/web-mercator/dist/esm/assert.js
  function assert9(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "@math.gl/web-mercator: assertion failed.");
    }
  }

  // node_modules/@math.gl/web-mercator/dist/esm/web-mercator-utils.js
  var PI = Math.PI;
  var PI_4 = PI / 4;
  var DEGREES_TO_RADIANS2 = PI / 180;
  var RADIANS_TO_DEGREES2 = 180 / PI;
  var TILE_SIZE = 512;
  var EARTH_CIRCUMFERENCE = 4003e4;
  var MAX_LATITUDE = 85.051129;
  var DEFAULT_ALTITUDE = 1.5;
  function zoomToScale(zoom) {
    return Math.pow(2, zoom);
  }
  function scaleToZoom(scale4) {
    return log22(scale4);
  }
  function lngLatToWorld(lngLat) {
    const [lng2, lat2] = lngLat;
    assert9(Number.isFinite(lng2));
    assert9(Number.isFinite(lat2) && lat2 >= -90 && lat2 <= 90, "invalid latitude");
    const lambda2 = lng2 * DEGREES_TO_RADIANS2;
    const phi2 = lat2 * DEGREES_TO_RADIANS2;
    const x = TILE_SIZE * (lambda2 + PI) / (2 * PI);
    const y = TILE_SIZE * (PI + Math.log(Math.tan(PI_4 + phi2 * 0.5))) / (2 * PI);
    return [x, y];
  }
  function worldToLngLat(xy) {
    const [x, y] = xy;
    const lambda2 = x / TILE_SIZE * (2 * PI) - PI;
    const phi2 = 2 * (Math.atan(Math.exp(y / TILE_SIZE * (2 * PI) - PI)) - PI_4);
    return [lambda2 * RADIANS_TO_DEGREES2, phi2 * RADIANS_TO_DEGREES2];
  }
  function getMeterZoom(options2) {
    const {
      latitude
    } = options2;
    assert9(Number.isFinite(latitude));
    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
    return scaleToZoom(EARTH_CIRCUMFERENCE * latCosine) - 9;
  }
  function unitsPerMeter(latitude) {
    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
    return TILE_SIZE / EARTH_CIRCUMFERENCE / latCosine;
  }
  function getDistanceScales(options2) {
    const {
      latitude,
      longitude,
      highPrecision = false
    } = options2;
    assert9(Number.isFinite(latitude) && Number.isFinite(longitude));
    const worldSize = TILE_SIZE;
    const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS2);
    const unitsPerDegreeX = worldSize / 360;
    const unitsPerDegreeY = unitsPerDegreeX / latCosine;
    const altUnitsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;
    const result = {
      unitsPerMeter: [altUnitsPerMeter, altUnitsPerMeter, altUnitsPerMeter],
      metersPerUnit: [1 / altUnitsPerMeter, 1 / altUnitsPerMeter, 1 / altUnitsPerMeter],
      unitsPerDegree: [unitsPerDegreeX, unitsPerDegreeY, altUnitsPerMeter],
      degreesPerUnit: [1 / unitsPerDegreeX, 1 / unitsPerDegreeY, 1 / altUnitsPerMeter]
    };
    if (highPrecision) {
      const latCosine2 = DEGREES_TO_RADIANS2 * Math.tan(latitude * DEGREES_TO_RADIANS2) / latCosine;
      const unitsPerDegreeY2 = unitsPerDegreeX * latCosine2 / 2;
      const altUnitsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;
      const altUnitsPerMeter2 = altUnitsPerDegree2 / unitsPerDegreeY * altUnitsPerMeter;
      result.unitsPerDegree2 = [0, unitsPerDegreeY2, altUnitsPerDegree2];
      result.unitsPerMeter2 = [altUnitsPerMeter2, 0, altUnitsPerMeter2];
    }
    return result;
  }
  function addMetersToLngLat(lngLatZ, xyz) {
    const [longitude, latitude, z0] = lngLatZ;
    const [x, y, z] = xyz;
    const {
      unitsPerMeter: unitsPerMeter2,
      unitsPerMeter2: unitsPerMeter22
    } = getDistanceScales({
      longitude,
      latitude,
      highPrecision: true
    });
    const worldspace = lngLatToWorld(lngLatZ);
    worldspace[0] += x * (unitsPerMeter2[0] + unitsPerMeter22[0] * y);
    worldspace[1] += y * (unitsPerMeter2[1] + unitsPerMeter22[1] * y);
    const newLngLat = worldToLngLat(worldspace);
    const newZ = (z0 || 0) + (z || 0);
    return Number.isFinite(z0) || Number.isFinite(z) ? [newLngLat[0], newLngLat[1], newZ] : newLngLat;
  }
  function getViewMatrix(options2) {
    const {
      height: height8,
      pitch,
      bearing,
      altitude,
      scale: scale4,
      center
    } = options2;
    const vm = createMat4();
    translate(vm, vm, [0, 0, -altitude]);
    rotateX2(vm, vm, -pitch * DEGREES_TO_RADIANS2);
    rotateZ2(vm, vm, bearing * DEGREES_TO_RADIANS2);
    const relativeScale = scale4 / height8;
    scale2(vm, vm, [relativeScale, relativeScale, relativeScale]);
    if (center) {
      translate(vm, vm, negate3([], center));
    }
    return vm;
  }
  function getProjectionParameters(options2) {
    const {
      width: width8,
      height: height8,
      altitude,
      pitch = 0,
      offset,
      center,
      scale: scale4,
      nearZMultiplier = 1,
      farZMultiplier = 1
    } = options2;
    let {
      fovy = altitudeToFovy(DEFAULT_ALTITUDE)
    } = options2;
    if (altitude !== void 0) {
      fovy = altitudeToFovy(altitude);
    }
    const fovRadians = fovy * DEGREES_TO_RADIANS2;
    const pitchRadians = pitch * DEGREES_TO_RADIANS2;
    const focalDistance = fovyToAltitude(fovy);
    let cameraToSeaLevelDistance = focalDistance;
    if (center) {
      cameraToSeaLevelDistance += center[2] * scale4 / Math.cos(pitchRadians) / height8;
    }
    const fovAboveCenter = fovRadians * (0.5 + (offset ? offset[1] : 0) / height8);
    const topHalfSurfaceDistance = Math.sin(fovAboveCenter) * cameraToSeaLevelDistance / Math.sin(clamp2(Math.PI / 2 - pitchRadians - fovAboveCenter, 0.01, Math.PI - 0.01));
    const furthestDistance = Math.sin(pitchRadians) * topHalfSurfaceDistance + cameraToSeaLevelDistance;
    const horizonDistance = cameraToSeaLevelDistance * 10;
    const farZ = Math.min(furthestDistance * farZMultiplier, horizonDistance);
    return {
      fov: fovRadians,
      aspect: width8 / height8,
      focalDistance,
      near: nearZMultiplier,
      far: farZ
    };
  }
  function getProjectionMatrix(options2) {
    const {
      fov,
      aspect,
      near,
      far
    } = getProjectionParameters(options2);
    const projectionMatrix = perspective([], fov, aspect, near, far);
    return projectionMatrix;
  }
  function altitudeToFovy(altitude) {
    return 2 * Math.atan(0.5 / altitude) * RADIANS_TO_DEGREES2;
  }
  function fovyToAltitude(fovy) {
    return 0.5 / Math.tan(0.5 * fovy * DEGREES_TO_RADIANS2);
  }
  function worldToPixels(xyz, pixelProjectionMatrix) {
    const [x, y, z = 0] = xyz;
    assert9(Number.isFinite(x) && Number.isFinite(y) && Number.isFinite(z));
    return transformVector(pixelProjectionMatrix, [x, y, z, 1]);
  }
  function pixelsToWorld(xyz, pixelUnprojectionMatrix, targetZ = 0) {
    const [x, y, z] = xyz;
    assert9(Number.isFinite(x) && Number.isFinite(y), "invalid pixel coordinate");
    if (Number.isFinite(z)) {
      const coord = transformVector(pixelUnprojectionMatrix, [x, y, z, 1]);
      return coord;
    }
    const coord0 = transformVector(pixelUnprojectionMatrix, [x, y, 0, 1]);
    const coord1 = transformVector(pixelUnprojectionMatrix, [x, y, 1, 1]);
    const z0 = coord0[2];
    const z1 = coord1[2];
    const t = z0 === z1 ? 0 : ((targetZ || 0) - z0) / (z1 - z0);
    return lerp2([], coord0, coord1, t);
  }

  // node_modules/@math.gl/web-mercator/dist/esm/fit-bounds.js
  function fitBounds(options2) {
    const {
      width: width8,
      height: height8,
      bounds,
      minExtent = 0,
      maxZoom = 24,
      offset = [0, 0]
    } = options2;
    const [[west, south], [east, north]] = bounds;
    const padding = getPaddingObject(options2.padding);
    const nw = lngLatToWorld([west, clamp2(north, -MAX_LATITUDE, MAX_LATITUDE)]);
    const se = lngLatToWorld([east, clamp2(south, -MAX_LATITUDE, MAX_LATITUDE)]);
    const size5 = [Math.max(Math.abs(se[0] - nw[0]), minExtent), Math.max(Math.abs(se[1] - nw[1]), minExtent)];
    const targetSize = [width8 - padding.left - padding.right - Math.abs(offset[0]) * 2, height8 - padding.top - padding.bottom - Math.abs(offset[1]) * 2];
    assert9(targetSize[0] > 0 && targetSize[1] > 0);
    const scaleX2 = targetSize[0] / size5[0];
    const scaleY2 = targetSize[1] / size5[1];
    const offsetX = (padding.right - padding.left) / 2 / scaleX2;
    const offsetY = (padding.top - padding.bottom) / 2 / scaleY2;
    const center = [(se[0] + nw[0]) / 2 + offsetX, (se[1] + nw[1]) / 2 + offsetY];
    const centerLngLat = worldToLngLat(center);
    const zoom = Math.min(maxZoom, log22(Math.abs(Math.min(scaleX2, scaleY2))));
    assert9(Number.isFinite(zoom));
    return {
      longitude: centerLngLat[0],
      latitude: centerLngLat[1],
      zoom
    };
  }
  function getPaddingObject(padding = 0) {
    if (typeof padding === "number") {
      return {
        top: padding,
        bottom: padding,
        left: padding,
        right: padding
      };
    }
    assert9(Number.isFinite(padding.top) && Number.isFinite(padding.bottom) && Number.isFinite(padding.left) && Number.isFinite(padding.right));
    return padding;
  }

  // node_modules/@math.gl/web-mercator/dist/esm/get-bounds.js
  var DEGREES_TO_RADIANS3 = Math.PI / 180;
  function getBounds(viewport, z = 0) {
    const {
      width: width8,
      height: height8,
      unproject
    } = viewport;
    const unprojectOps = {
      targetZ: z
    };
    const bottomLeft = unproject([0, height8], unprojectOps);
    const bottomRight = unproject([width8, height8], unprojectOps);
    let topLeft;
    let topRight;
    const halfFov = viewport.fovy ? 0.5 * viewport.fovy * DEGREES_TO_RADIANS3 : Math.atan(0.5 / viewport.altitude);
    const angleToGround = (90 - viewport.pitch) * DEGREES_TO_RADIANS3;
    if (halfFov > angleToGround - 0.01) {
      topLeft = unprojectOnFarPlane(viewport, 0, z);
      topRight = unprojectOnFarPlane(viewport, width8, z);
    } else {
      topLeft = unproject([0, 0], unprojectOps);
      topRight = unproject([width8, 0], unprojectOps);
    }
    return [bottomLeft, bottomRight, topRight, topLeft];
  }
  function unprojectOnFarPlane(viewport, x, targetZ) {
    const {
      pixelUnprojectionMatrix
    } = viewport;
    const coord0 = transformVector(pixelUnprojectionMatrix, [x, 0, 1, 1]);
    const coord1 = transformVector(pixelUnprojectionMatrix, [x, viewport.height, 1, 1]);
    const z = targetZ * viewport.distanceScales.unitsPerMeter[2];
    const t = (z - coord0[2]) / (coord1[2] - coord0[2]);
    const coord = lerp2([], coord0, coord1, t);
    const result = worldToLngLat(coord);
    result.push(targetZ);
    return result;
  }

  // node_modules/@math.gl/web-mercator/dist/esm/web-mercator-viewport.js
  var WebMercatorViewport = class {
    constructor(props = {
      width: 1,
      height: 1
    }) {
      _defineProperty(this, "latitude", void 0);
      _defineProperty(this, "longitude", void 0);
      _defineProperty(this, "zoom", void 0);
      _defineProperty(this, "pitch", void 0);
      _defineProperty(this, "bearing", void 0);
      _defineProperty(this, "altitude", void 0);
      _defineProperty(this, "fovy", void 0);
      _defineProperty(this, "meterOffset", void 0);
      _defineProperty(this, "center", void 0);
      _defineProperty(this, "width", void 0);
      _defineProperty(this, "height", void 0);
      _defineProperty(this, "scale", void 0);
      _defineProperty(this, "distanceScales", void 0);
      _defineProperty(this, "viewMatrix", void 0);
      _defineProperty(this, "projectionMatrix", void 0);
      _defineProperty(this, "viewProjectionMatrix", void 0);
      _defineProperty(this, "pixelProjectionMatrix", void 0);
      _defineProperty(this, "pixelUnprojectionMatrix", void 0);
      _defineProperty(this, "equals", (viewport) => {
        if (!(viewport instanceof WebMercatorViewport)) {
          return false;
        }
        return viewport.width === this.width && viewport.height === this.height && equals2(viewport.projectionMatrix, this.projectionMatrix) && equals2(viewport.viewMatrix, this.viewMatrix);
      });
      _defineProperty(this, "project", (lngLatZ, options2 = {}) => {
        const {
          topLeft = true
        } = options2;
        const worldPosition = this.projectPosition(lngLatZ);
        const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);
        const [x, y] = coord;
        const y2 = topLeft ? y : this.height - y;
        return lngLatZ.length === 2 ? [x, y2] : [x, y2, coord[2]];
      });
      _defineProperty(this, "unproject", (xyz, options2 = {}) => {
        const {
          topLeft = true,
          targetZ = void 0
        } = options2;
        const [x, y, z] = xyz;
        const y2 = topLeft ? y : this.height - y;
        const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
        const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);
        const [X, Y, Z] = this.unprojectPosition(coord);
        if (Number.isFinite(z)) {
          return [X, Y, Z];
        }
        return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
      });
      _defineProperty(this, "projectPosition", (xyz) => {
        const [X, Y] = lngLatToWorld(xyz);
        const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
        return [X, Y, Z];
      });
      _defineProperty(this, "unprojectPosition", (xyz) => {
        const [X, Y] = worldToLngLat(xyz);
        const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
        return [X, Y, Z];
      });
      let {
        width: width8,
        height: height8,
        altitude = null,
        fovy = null
      } = props;
      const {
        latitude = 0,
        longitude = 0,
        zoom = 0,
        pitch = 0,
        bearing = 0,
        position: position2 = null,
        nearZMultiplier = 0.02,
        farZMultiplier = 1.01
      } = props;
      width8 = width8 || 1;
      height8 = height8 || 1;
      if (fovy === null && altitude === null) {
        altitude = DEFAULT_ALTITUDE;
        fovy = altitudeToFovy(altitude);
      } else if (fovy === null) {
        fovy = altitudeToFovy(altitude);
      } else if (altitude === null) {
        altitude = fovyToAltitude(fovy);
      }
      const scale4 = zoomToScale(zoom);
      altitude = Math.max(0.75, altitude);
      const distanceScales = getDistanceScales({
        longitude,
        latitude
      });
      const center = lngLatToWorld([longitude, latitude]);
      center.push(0);
      if (position2) {
        add3(center, center, mul2([], position2, distanceScales.unitsPerMeter));
      }
      this.projectionMatrix = getProjectionMatrix({
        width: width8,
        height: height8,
        scale: scale4,
        center,
        pitch,
        fovy,
        nearZMultiplier,
        farZMultiplier
      });
      this.viewMatrix = getViewMatrix({
        height: height8,
        scale: scale4,
        center,
        pitch,
        bearing,
        altitude
      });
      this.width = width8;
      this.height = height8;
      this.scale = scale4;
      this.latitude = latitude;
      this.longitude = longitude;
      this.zoom = zoom;
      this.pitch = pitch;
      this.bearing = bearing;
      this.altitude = altitude;
      this.fovy = fovy;
      this.center = center;
      this.meterOffset = position2 || [0, 0, 0];
      this.distanceScales = distanceScales;
      this._initMatrices();
      Object.freeze(this);
    }
    _initMatrices() {
      const {
        width: width8,
        height: height8,
        projectionMatrix,
        viewMatrix
      } = this;
      const vpm = createMat4();
      multiply2(vpm, vpm, projectionMatrix);
      multiply2(vpm, vpm, viewMatrix);
      this.viewProjectionMatrix = vpm;
      const m = createMat4();
      scale2(m, m, [width8 / 2, -height8 / 2, 1]);
      translate(m, m, [1, -1, 0]);
      multiply2(m, m, vpm);
      const mInverse = invert(createMat4(), m);
      if (!mInverse) {
        throw new Error("Pixel project matrix not invertible");
      }
      this.pixelProjectionMatrix = m;
      this.pixelUnprojectionMatrix = mInverse;
    }
    projectFlat(lngLat) {
      return lngLatToWorld(lngLat);
    }
    unprojectFlat(xy) {
      return worldToLngLat(xy);
    }
    getMapCenterByLngLatPosition({
      lngLat,
      pos
    }) {
      const fromLocation = pixelsToWorld(pos, this.pixelUnprojectionMatrix);
      const toLocation = lngLatToWorld(lngLat);
      const translate2 = add2([], toLocation, negate2([], fromLocation));
      const newCenter = add2([], this.center, translate2);
      return worldToLngLat(newCenter);
    }
    fitBounds(bounds, options2 = {}) {
      const {
        width: width8,
        height: height8
      } = this;
      const {
        longitude,
        latitude,
        zoom
      } = fitBounds(Object.assign({
        width: width8,
        height: height8,
        bounds
      }, options2));
      return new WebMercatorViewport({
        width: width8,
        height: height8,
        longitude,
        latitude,
        zoom
      });
    }
    getBounds(options2) {
      const corners = this.getBoundingRegion(options2);
      const west = Math.min(...corners.map((p) => p[0]));
      const east = Math.max(...corners.map((p) => p[0]));
      const south = Math.min(...corners.map((p) => p[1]));
      const north = Math.max(...corners.map((p) => p[1]));
      return [[west, south], [east, north]];
    }
    getBoundingRegion(options2 = {}) {
      return getBounds(this, options2.z || 0);
    }
    getLocationAtPoint({
      lngLat,
      pos
    }) {
      return this.getMapCenterByLngLatPosition({
        lngLat,
        pos
      });
    }
  };

  // node_modules/@math.gl/web-mercator/dist/esm/normalize-viewport-props.js
  var TILE_SIZE2 = 512;
  function normalizeViewportProps(props) {
    const {
      width: width8,
      height: height8,
      pitch = 0
    } = props;
    let {
      longitude,
      latitude,
      zoom,
      bearing = 0
    } = props;
    if (longitude < -180 || longitude > 180) {
      longitude = mod2(longitude + 180, 360) - 180;
    }
    if (bearing < -180 || bearing > 180) {
      bearing = mod2(bearing + 180, 360) - 180;
    }
    const minZoom = log22(height8 / TILE_SIZE2);
    if (zoom <= minZoom) {
      zoom = minZoom;
      latitude = 0;
    } else {
      const halfHeightPixels = height8 / 2 / Math.pow(2, zoom);
      const minLatitude = worldToLngLat([0, halfHeightPixels])[1];
      if (latitude < minLatitude) {
        latitude = minLatitude;
      } else {
        const maxLatitude = worldToLngLat([0, TILE_SIZE2 - halfHeightPixels])[1];
        if (latitude > maxLatitude) {
          latitude = maxLatitude;
        }
      }
    }
    return {
      width: width8,
      height: height8,
      longitude,
      latitude,
      zoom,
      pitch,
      bearing
    };
  }

  // node_modules/@math.gl/web-mercator/dist/esm/fly-to-viewport.js
  var EPSILON2 = 0.01;
  var VIEWPORT_TRANSITION_PROPS = ["longitude", "latitude", "zoom"];
  var DEFAULT_OPTS = {
    curve: 1.414,
    speed: 1.2
  };
  function flyToViewport(startProps, endProps, t, options2) {
    const {
      startZoom,
      startCenterXY,
      uDelta,
      w0,
      u1,
      S,
      rho,
      rho2,
      r0
    } = getFlyToTransitionParams(startProps, endProps, options2);
    if (u1 < EPSILON2) {
      const viewport = {};
      for (const key of VIEWPORT_TRANSITION_PROPS) {
        const startValue = startProps[key];
        const endValue = endProps[key];
        viewport[key] = lerp3(startValue, endValue, t);
      }
      return viewport;
    }
    const s = t * S;
    const w = Math.cosh(r0) / Math.cosh(r0 + rho * s);
    const u = w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2) / u1;
    const scaleIncrement = 1 / w;
    const newZoom = startZoom + scaleToZoom(scaleIncrement);
    const newCenterWorld = scale([], uDelta, u);
    add2(newCenterWorld, newCenterWorld, startCenterXY);
    const newCenter = worldToLngLat(newCenterWorld);
    return {
      longitude: newCenter[0],
      latitude: newCenter[1],
      zoom: newZoom
    };
  }
  function getFlyToDuration(startProps, endProps, options2) {
    const opts = {
      ...DEFAULT_OPTS,
      ...options2
    };
    const {
      screenSpeed,
      speed,
      maxDuration
    } = opts;
    const {
      S,
      rho
    } = getFlyToTransitionParams(startProps, endProps, opts);
    const length7 = 1e3 * S;
    let duration2;
    if (Number.isFinite(screenSpeed)) {
      duration2 = length7 / (screenSpeed / rho);
    } else {
      duration2 = length7 / speed;
    }
    return Number.isFinite(maxDuration) && duration2 > maxDuration ? 0 : duration2;
  }
  function getFlyToTransitionParams(startProps, endProps, opts) {
    opts = Object.assign({}, DEFAULT_OPTS, opts);
    const rho = opts.curve;
    const startZoom = startProps.zoom;
    const startCenter = [startProps.longitude, startProps.latitude];
    const startScale = zoomToScale(startZoom);
    const endZoom = endProps.zoom;
    const endCenter = [endProps.longitude, endProps.latitude];
    const scale4 = zoomToScale(endZoom - startZoom);
    const startCenterXY = lngLatToWorld(startCenter);
    const endCenterXY = lngLatToWorld(endCenter);
    const uDelta = sub2([], endCenterXY, startCenterXY);
    const w0 = Math.max(startProps.width, startProps.height);
    const w1 = w0 / scale4;
    const u1 = length(uDelta) * startScale;
    const _u1 = Math.max(u1, EPSILON2);
    const rho2 = rho * rho;
    const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);
    const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);
    const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);
    const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
    const S = (r1 - r0) / rho;
    return {
      startZoom,
      startCenterXY,
      uDelta,
      w0,
      u1,
      S,
      rho,
      rho2,
      r0,
      r1
    };
  }

  // node_modules/@deck.gl/core/dist/esm/shaderlib/shadow/shadow.js
  var vs4 = "\nconst int max_lights = 2;\nuniform mat4 shadow_uViewProjectionMatrices[max_lights];\nuniform vec4 shadow_uProjectCenters[max_lights];\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform int shadow_uLightId;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  if (shadow_uDrawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[shadow_uLightId], shadow_uProjectCenters[shadow_uLightId]);\n  }\n  if (shadow_uUseShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow_uLightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, shadow_uViewProjectionMatrices[i], shadow_uProjectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n";
  var fs3 = "\nconst int max_lights = 2;\nuniform bool shadow_uDrawShadowMap;\nuniform bool shadow_uUseShadowMap;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\nuniform vec4 shadow_uColor;\nuniform float shadow_uLightCount;\n\nvarying vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture2D(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow_uDrawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow_uUseShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow_uLightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow_uColor.a / shadow_uLightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow_uColor.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n";
  var getMemoizedViewportCenterPosition = memoize(getViewportCenterPosition);
  var getMemoizedViewProjectionMatrices = memoize(getViewProjectionMatrices);
  var DEFAULT_SHADOW_COLOR = [0, 0, 0, 1];
  var VECTOR_TO_POINT_MATRIX2 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];
  function screenToCommonSpace(xyz, pixelUnprojectionMatrix) {
    const [x, y, z] = xyz;
    const coord = pixelsToWorld([x, y, z], pixelUnprojectionMatrix);
    if (Number.isFinite(z)) {
      return coord;
    }
    return [coord[0], coord[1], 0];
  }
  function getViewportCenterPosition({
    viewport,
    center
  }) {
    return new Matrix4(viewport.viewProjectionMatrix).invert().transform(center);
  }
  function getViewProjectionMatrices({
    viewport,
    shadowMatrices
  }) {
    const projectionMatrices = [];
    const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;
    const farZ = viewport.isGeospatial ? void 0 : 1;
    const corners = [[0, 0, farZ], [viewport.width, 0, farZ], [0, viewport.height, farZ], [viewport.width, viewport.height, farZ], [0, 0, -1], [viewport.width, 0, -1], [0, viewport.height, -1], [viewport.width, viewport.height, -1]].map((pixel) => screenToCommonSpace(pixel, pixelUnprojectionMatrix));
    for (const shadowMatrix of shadowMatrices) {
      const viewMatrix = shadowMatrix.clone().translate(new Vector3(viewport.center).negate());
      const positions = corners.map((corner) => viewMatrix.transform(corner));
      const projectionMatrix = new Matrix4().ortho({
        left: Math.min(...positions.map((position2) => position2[0])),
        right: Math.max(...positions.map((position2) => position2[0])),
        bottom: Math.min(...positions.map((position2) => position2[1])),
        top: Math.max(...positions.map((position2) => position2[1])),
        near: Math.min(...positions.map((position2) => -position2[2])),
        far: Math.max(...positions.map((position2) => -position2[2]))
      });
      projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));
    }
    return projectionMatrices;
  }
  function createShadowUniforms(opts, context) {
    const {
      shadowEnabled = true
    } = opts;
    if (!shadowEnabled || !opts.shadowMatrices || !opts.shadowMatrices.length) {
      return {
        shadow_uDrawShadowMap: false,
        shadow_uUseShadowMap: false
      };
    }
    const uniforms = {
      shadow_uDrawShadowMap: Boolean(opts.drawToShadowMap),
      shadow_uUseShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,
      shadow_uColor: opts.shadowColor || DEFAULT_SHADOW_COLOR,
      shadow_uLightId: opts.shadowLightId || 0,
      shadow_uLightCount: opts.shadowMatrices.length
    };
    const center = getMemoizedViewportCenterPosition({
      viewport: opts.viewport,
      center: context.project_uCenter
    });
    const projectCenters = [];
    const viewProjectionMatrices = getMemoizedViewProjectionMatrices({
      shadowMatrices: opts.shadowMatrices,
      viewport: opts.viewport
    }).slice();
    for (let i = 0; i < opts.shadowMatrices.length; i++) {
      const viewProjectionMatrix = viewProjectionMatrices[i];
      const viewProjectionMatrixCentered = viewProjectionMatrix.clone().translate(new Vector3(opts.viewport.center).negate());
      if (context.project_uCoordinateSystem === COORDINATE_SYSTEM.LNGLAT && context.project_uProjectionMode === PROJECTION_MODE.WEB_MERCATOR) {
        viewProjectionMatrices[i] = viewProjectionMatrixCentered;
        projectCenters[i] = center;
      } else {
        viewProjectionMatrices[i] = viewProjectionMatrix.clone().multiplyRight(VECTOR_TO_POINT_MATRIX2);
        projectCenters[i] = viewProjectionMatrixCentered.transform(center);
      }
    }
    for (let i = 0; i < viewProjectionMatrices.length; i++) {
      uniforms["shadow_uViewProjectionMatrices[".concat(i, "]")] = viewProjectionMatrices[i];
      uniforms["shadow_uProjectCenters[".concat(i, "]")] = projectCenters[i];
      if (opts.shadowMaps && opts.shadowMaps.length > 0) {
        uniforms["shadow_uShadowMap".concat(i)] = opts.shadowMaps[i];
      } else {
        uniforms["shadow_uShadowMap".concat(i)] = opts.dummyShadowMap;
      }
    }
    return uniforms;
  }
  var shadow_default = {
    name: "shadow",
    dependencies: [project_default],
    vs: vs4,
    fs: fs3,
    inject: {
      "vs:DECKGL_FILTER_GL_POSITION": "\n    position = shadow_setVertexPosition(geometry.position);\n    ",
      "fs:DECKGL_FILTER_COLOR": "\n    color = shadow_filterShadowColor(color);\n    "
    },
    getUniforms: (opts = {}, context = {}) => {
      if ("viewport" in opts && (opts.drawToShadowMap || opts.shadowMaps && opts.shadowMaps.length > 0)) {
        return createShadowUniforms(opts, context);
      }
      return {};
    }
  };

  // node_modules/@deck.gl/core/dist/esm/effects/lighting/lighting-effect.js
  var DEFAULT_AMBIENT_LIGHT_PROPS = {
    color: [255, 255, 255],
    intensity: 1
  };
  var DEFAULT_DIRECTIONAL_LIGHT_PROPS = [{
    color: [255, 255, 255],
    intensity: 1,
    direction: [-1, 3, -1]
  }, {
    color: [255, 255, 255],
    intensity: 0.9,
    direction: [1, -8, -2.5]
  }];
  var DEFAULT_SHADOW_COLOR2 = [0, 0, 0, 200 / 255];
  var LightingEffect = class {
    constructor(props = {}) {
      _defineProperty(this, "id", "lighting-effect");
      _defineProperty(this, "props", void 0);
      _defineProperty(this, "shadowColor", DEFAULT_SHADOW_COLOR2);
      _defineProperty(this, "shadow", void 0);
      _defineProperty(this, "ambientLight", void 0);
      _defineProperty(this, "directionalLights", void 0);
      _defineProperty(this, "pointLights", void 0);
      _defineProperty(this, "shadowPasses", []);
      _defineProperty(this, "shadowMaps", []);
      _defineProperty(this, "dummyShadowMap", null);
      _defineProperty(this, "programManager", void 0);
      _defineProperty(this, "shadowMatrices", void 0);
      this.setProps(props);
    }
    setProps(props) {
      this.ambientLight = null;
      this.directionalLights = [];
      this.pointLights = [];
      for (const key in props) {
        const lightSource = props[key];
        switch (lightSource.type) {
          case "ambient":
            this.ambientLight = lightSource;
            break;
          case "directional":
            this.directionalLights.push(lightSource);
            break;
          case "point":
            this.pointLights.push(lightSource);
            break;
          default:
        }
      }
      this._applyDefaultLights();
      this.shadow = this.directionalLights.some((light) => light.shadow);
      this.props = props;
    }
    preRender(gl, {
      layers,
      layerFilter,
      viewports,
      onViewportActive,
      views
    }) {
      if (!this.shadow)
        return;
      this.shadowMatrices = this._calculateMatrices();
      if (this.shadowPasses.length === 0) {
        this._createShadowPasses(gl);
      }
      if (!this.programManager) {
        this.programManager = ProgramManager.getDefaultProgramManager(gl);
        if (shadow_default) {
          this.programManager.addDefaultModule(shadow_default);
        }
      }
      if (!this.dummyShadowMap) {
        this.dummyShadowMap = new Texture2D(gl, {
          width: 1,
          height: 1
        });
      }
      for (let i = 0; i < this.shadowPasses.length; i++) {
        const shadowPass = this.shadowPasses[i];
        shadowPass.render({
          layers,
          layerFilter,
          viewports,
          onViewportActive,
          views,
          moduleParameters: {
            shadowLightId: i,
            dummyShadowMap: this.dummyShadowMap,
            shadowMatrices: this.shadowMatrices
          }
        });
      }
    }
    getModuleParameters(layer) {
      const parameters = this.shadow ? {
        shadowMaps: this.shadowMaps,
        dummyShadowMap: this.dummyShadowMap,
        shadowColor: this.shadowColor,
        shadowMatrices: this.shadowMatrices
      } : {};
      parameters.lightSources = {
        ambientLight: this.ambientLight,
        directionalLights: this.directionalLights.map((directionalLight) => directionalLight.getProjectedLight({
          layer
        })),
        pointLights: this.pointLights.map((pointLight) => pointLight.getProjectedLight({
          layer
        }))
      };
      return parameters;
    }
    cleanup() {
      for (const shadowPass of this.shadowPasses) {
        shadowPass.delete();
      }
      this.shadowPasses.length = 0;
      this.shadowMaps.length = 0;
      if (this.dummyShadowMap) {
        this.dummyShadowMap.delete();
        this.dummyShadowMap = null;
      }
      if (this.shadow && this.programManager) {
        this.programManager.removeDefaultModule(shadow_default);
        this.programManager = null;
      }
    }
    _calculateMatrices() {
      const lightMatrices = [];
      for (const light of this.directionalLights) {
        const viewMatrix = new Matrix4().lookAt({
          eye: new Vector3(light.direction).negate()
        });
        lightMatrices.push(viewMatrix);
      }
      return lightMatrices;
    }
    _createShadowPasses(gl) {
      for (let i = 0; i < this.directionalLights.length; i++) {
        const shadowPass = new ShadowPass(gl);
        this.shadowPasses[i] = shadowPass;
        this.shadowMaps[i] = shadowPass.shadowMap;
      }
    }
    _applyDefaultLights() {
      const {
        ambientLight,
        pointLights,
        directionalLights
      } = this;
      if (!ambientLight && pointLights.length === 0 && directionalLights.length === 0) {
        this.ambientLight = new AmbientLight(DEFAULT_AMBIENT_LIGHT_PROPS);
        this.directionalLights.push(new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[0]), new DirectionalLight(DEFAULT_DIRECTIONAL_LIGHT_PROPS[1]));
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/utils/typed-array-manager.js
  var TypedArrayManager = class {
    constructor(options2 = {}) {
      _defineProperty(this, "_pool", []);
      _defineProperty(this, "opts", {
        overAlloc: 2,
        poolSize: 100
      });
      this.setOptions(options2);
    }
    setOptions(options2) {
      Object.assign(this.opts, options2);
    }
    allocate(typedArray, count2, {
      size: size5 = 1,
      type,
      padding = 0,
      copy: copy2 = false,
      initialize = false,
      maxCount
    }) {
      const Type = type || typedArray && typedArray.constructor || Float32Array;
      const newSize = count2 * size5 + padding;
      if (ArrayBuffer.isView(typedArray)) {
        if (newSize <= typedArray.length) {
          return typedArray;
        }
        if (newSize * typedArray.BYTES_PER_ELEMENT <= typedArray.buffer.byteLength) {
          return new Type(typedArray.buffer, 0, newSize);
        }
      }
      let maxSize = Infinity;
      if (maxCount) {
        maxSize = maxCount * size5 + padding;
      }
      const newArray = this._allocate(Type, newSize, initialize, maxSize);
      if (typedArray && copy2) {
        newArray.set(typedArray);
      } else if (!initialize) {
        newArray.fill(0, 0, 4);
      }
      this._release(typedArray);
      return newArray;
    }
    release(typedArray) {
      this._release(typedArray);
    }
    _allocate(Type, size5, initialize, maxSize) {
      let sizeToAllocate = Math.max(Math.ceil(size5 * this.opts.overAlloc), 1);
      if (sizeToAllocate > maxSize) {
        sizeToAllocate = maxSize;
      }
      const pool = this._pool;
      const byteLength = Type.BYTES_PER_ELEMENT * sizeToAllocate;
      const i = pool.findIndex((b) => b.byteLength >= byteLength);
      if (i >= 0) {
        const array2 = new Type(pool.splice(i, 1)[0], 0, sizeToAllocate);
        if (initialize) {
          array2.fill(0);
        }
        return array2;
      }
      return new Type(sizeToAllocate);
    }
    _release(typedArray) {
      if (!ArrayBuffer.isView(typedArray)) {
        return;
      }
      const pool = this._pool;
      const {
        buffer
      } = typedArray;
      const {
        byteLength
      } = buffer;
      const i = pool.findIndex((b) => b.byteLength >= byteLength);
      if (i < 0) {
        pool.push(buffer);
      } else if (i > 0 || pool.length < this.opts.poolSize) {
        pool.splice(i, 0, buffer);
      }
      if (pool.length > this.opts.poolSize) {
        pool.shift();
      }
    }
  };
  var typed_array_manager_default = new TypedArrayManager();

  // node_modules/@deck.gl/core/dist/esm/utils/math-utils.js
  function createMat42() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
  }
  function getCameraPosition(viewMatrixInverse) {
    return [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]];
  }
  function getFrustumPlanes(viewProjectionMatrix) {
    return {
      left: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[0], viewProjectionMatrix[7] + viewProjectionMatrix[4], viewProjectionMatrix[11] + viewProjectionMatrix[8], viewProjectionMatrix[15] + viewProjectionMatrix[12]),
      right: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[0], viewProjectionMatrix[7] - viewProjectionMatrix[4], viewProjectionMatrix[11] - viewProjectionMatrix[8], viewProjectionMatrix[15] - viewProjectionMatrix[12]),
      bottom: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[1], viewProjectionMatrix[7] + viewProjectionMatrix[5], viewProjectionMatrix[11] + viewProjectionMatrix[9], viewProjectionMatrix[15] + viewProjectionMatrix[13]),
      top: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[1], viewProjectionMatrix[7] - viewProjectionMatrix[5], viewProjectionMatrix[11] - viewProjectionMatrix[9], viewProjectionMatrix[15] - viewProjectionMatrix[13]),
      near: getFrustumPlane(viewProjectionMatrix[3] + viewProjectionMatrix[2], viewProjectionMatrix[7] + viewProjectionMatrix[6], viewProjectionMatrix[11] + viewProjectionMatrix[10], viewProjectionMatrix[15] + viewProjectionMatrix[14]),
      far: getFrustumPlane(viewProjectionMatrix[3] - viewProjectionMatrix[2], viewProjectionMatrix[7] - viewProjectionMatrix[6], viewProjectionMatrix[11] - viewProjectionMatrix[10], viewProjectionMatrix[15] - viewProjectionMatrix[14])
    };
  }
  var scratchVector = new Vector3();
  function getFrustumPlane(a, b, c, d) {
    scratchVector.set(a, b, c);
    const L = scratchVector.len();
    return {
      distance: d / L,
      normal: new Vector3(-a / L, -b / L, -c / L)
    };
  }
  function fp64LowPart(x) {
    return x - Math.fround(x);
  }
  var scratchArray;
  function toDoublePrecisionArray(typedArray, options2) {
    const {
      size: size5 = 1,
      startIndex = 0
    } = options2;
    const endIndex = options2.endIndex !== void 0 ? options2.endIndex : typedArray.length;
    const count2 = (endIndex - startIndex) / size5;
    scratchArray = typed_array_manager_default.allocate(scratchArray, count2, {
      type: Float32Array,
      size: size5 * 2
    });
    let sourceIndex = startIndex;
    let targetIndex = 0;
    while (sourceIndex < endIndex) {
      for (let j = 0; j < size5; j++) {
        const value13 = typedArray[sourceIndex++];
        scratchArray[targetIndex + j] = value13;
        scratchArray[targetIndex + j + size5] = fp64LowPart(value13);
      }
      targetIndex += size5 * 2;
    }
    return scratchArray.subarray(0, count2 * size5 * 2);
  }
  function mergeBounds(boundsList) {
    let mergedBounds = null;
    let isMerged = false;
    for (const bounds of boundsList) {
      if (!bounds)
        continue;
      if (!mergedBounds) {
        mergedBounds = bounds;
      } else {
        if (!isMerged) {
          mergedBounds = [[mergedBounds[0][0], mergedBounds[0][1]], [mergedBounds[1][0], mergedBounds[1][1]]];
          isMerged = true;
        }
        mergedBounds[0][0] = Math.min(mergedBounds[0][0], bounds[0][0]);
        mergedBounds[0][1] = Math.min(mergedBounds[0][1], bounds[0][1]);
        mergedBounds[1][0] = Math.max(mergedBounds[1][0], bounds[1][0]);
        mergedBounds[1][1] = Math.max(mergedBounds[1][1], bounds[1][1]);
      }
    }
    return mergedBounds;
  }

  // node_modules/@deck.gl/core/dist/esm/viewports/viewport.js
  var DEGREES_TO_RADIANS4 = Math.PI / 180;
  var IDENTITY2 = createMat42();
  var ZERO_VECTOR2 = [0, 0, 0];
  var DEFAULT_DISTANCE_SCALES = {
    unitsPerMeter: [1, 1, 1],
    metersPerUnit: [1, 1, 1]
  };
  function createProjectionMatrix({
    width: width8,
    height: height8,
    orthographic,
    fovyRadians,
    focalDistance,
    padding,
    near,
    far
  }) {
    const aspect = width8 / height8;
    const matrix = orthographic ? new Matrix4().orthographic({
      fovy: fovyRadians,
      aspect,
      focalDistance,
      near,
      far
    }) : new Matrix4().perspective({
      fovy: fovyRadians,
      aspect,
      near,
      far
    });
    if (padding) {
      const {
        left: left3 = 0,
        right = 0,
        top: top3 = 0,
        bottom: bottom3 = 0
      } = padding;
      const offsetX = clamp((left3 + width8 - right) / 2, 0, width8) - width8 / 2;
      const offsetY = clamp((top3 + height8 - bottom3) / 2, 0, height8) - height8 / 2;
      matrix[8] -= offsetX * 2 / width8;
      matrix[9] += offsetY * 2 / height8;
    }
    return matrix;
  }
  var Viewport = class {
    constructor(opts = {}) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "x", void 0);
      _defineProperty(this, "y", void 0);
      _defineProperty(this, "width", void 0);
      _defineProperty(this, "height", void 0);
      _defineProperty(this, "padding", void 0);
      _defineProperty(this, "isGeospatial", void 0);
      _defineProperty(this, "zoom", void 0);
      _defineProperty(this, "focalDistance", void 0);
      _defineProperty(this, "position", void 0);
      _defineProperty(this, "modelMatrix", void 0);
      _defineProperty(this, "distanceScales", void 0);
      _defineProperty(this, "scale", void 0);
      _defineProperty(this, "center", void 0);
      _defineProperty(this, "cameraPosition", void 0);
      _defineProperty(this, "projectionMatrix", void 0);
      _defineProperty(this, "viewMatrix", void 0);
      _defineProperty(this, "viewMatrixUncentered", void 0);
      _defineProperty(this, "viewMatrixInverse", void 0);
      _defineProperty(this, "viewProjectionMatrix", void 0);
      _defineProperty(this, "pixelProjectionMatrix", void 0);
      _defineProperty(this, "pixelUnprojectionMatrix", void 0);
      _defineProperty(this, "resolution", void 0);
      _defineProperty(this, "_frustumPlanes", {});
      this.id = opts.id || this.constructor.displayName || "viewport";
      this.x = opts.x || 0;
      this.y = opts.y || 0;
      this.width = opts.width || 1;
      this.height = opts.height || 1;
      this.zoom = opts.zoom || 0;
      this.padding = opts.padding;
      this.distanceScales = opts.distanceScales || DEFAULT_DISTANCE_SCALES;
      this.focalDistance = opts.focalDistance || 1;
      this.position = opts.position || ZERO_VECTOR2;
      this.modelMatrix = opts.modelMatrix || null;
      const {
        longitude,
        latitude
      } = opts;
      this.isGeospatial = Number.isFinite(latitude) && Number.isFinite(longitude);
      this._initProps(opts);
      this._initMatrices(opts);
      this.equals = this.equals.bind(this);
      this.project = this.project.bind(this);
      this.unproject = this.unproject.bind(this);
      this.projectPosition = this.projectPosition.bind(this);
      this.unprojectPosition = this.unprojectPosition.bind(this);
      this.projectFlat = this.projectFlat.bind(this);
      this.unprojectFlat = this.unprojectFlat.bind(this);
    }
    get subViewports() {
      return null;
    }
    get metersPerPixel() {
      return this.distanceScales.metersPerUnit[2] / this.scale;
    }
    get projectionMode() {
      if (this.isGeospatial) {
        return this.zoom < 12 ? PROJECTION_MODE.WEB_MERCATOR : PROJECTION_MODE.WEB_MERCATOR_AUTO_OFFSET;
      }
      return PROJECTION_MODE.IDENTITY;
    }
    equals(viewport) {
      if (!(viewport instanceof Viewport)) {
        return false;
      }
      if (this === viewport) {
        return true;
      }
      return viewport.width === this.width && viewport.height === this.height && viewport.scale === this.scale && equals(viewport.projectionMatrix, this.projectionMatrix) && equals(viewport.viewMatrix, this.viewMatrix);
    }
    project(xyz, {
      topLeft = true
    } = {}) {
      const worldPosition = this.projectPosition(xyz);
      const coord = worldToPixels(worldPosition, this.pixelProjectionMatrix);
      const [x, y] = coord;
      const y2 = topLeft ? y : this.height - y;
      return xyz.length === 2 ? [x, y2] : [x, y2, coord[2]];
    }
    unproject(xyz, {
      topLeft = true,
      targetZ
    } = {}) {
      const [x, y, z] = xyz;
      const y2 = topLeft ? y : this.height - y;
      const targetZWorld = targetZ && targetZ * this.distanceScales.unitsPerMeter[2];
      const coord = pixelsToWorld([x, y2, z], this.pixelUnprojectionMatrix, targetZWorld);
      const [X, Y, Z] = this.unprojectPosition(coord);
      if (Number.isFinite(z)) {
        return [X, Y, Z];
      }
      return Number.isFinite(targetZ) ? [X, Y, targetZ] : [X, Y];
    }
    projectPosition(xyz) {
      const [X, Y] = this.projectFlat(xyz);
      const Z = (xyz[2] || 0) * this.distanceScales.unitsPerMeter[2];
      return [X, Y, Z];
    }
    unprojectPosition(xyz) {
      const [X, Y] = this.unprojectFlat(xyz);
      const Z = (xyz[2] || 0) * this.distanceScales.metersPerUnit[2];
      return [X, Y, Z];
    }
    projectFlat(xyz) {
      if (this.isGeospatial) {
        const result = lngLatToWorld(xyz);
        result[1] = clamp(result[1], -318, 830);
        return result;
      }
      return xyz;
    }
    unprojectFlat(xyz) {
      if (this.isGeospatial) {
        return worldToLngLat(xyz);
      }
      return xyz;
    }
    getBounds(options2 = {}) {
      const unprojectOption = {
        targetZ: options2.z || 0
      };
      const topLeft = this.unproject([0, 0], unprojectOption);
      const topRight = this.unproject([this.width, 0], unprojectOption);
      const bottomLeft = this.unproject([0, this.height], unprojectOption);
      const bottomRight = this.unproject([this.width, this.height], unprojectOption);
      return [Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]), Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]), Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1])];
    }
    getDistanceScales(coordinateOrigin) {
      if (coordinateOrigin) {
        return getDistanceScales({
          longitude: coordinateOrigin[0],
          latitude: coordinateOrigin[1],
          highPrecision: true
        });
      }
      return this.distanceScales;
    }
    containsPixel({
      x,
      y,
      width: width8 = 1,
      height: height8 = 1
    }) {
      return x < this.x + this.width && this.x < x + width8 && y < this.y + this.height && this.y < y + height8;
    }
    getFrustumPlanes() {
      if (this._frustumPlanes.near) {
        return this._frustumPlanes;
      }
      Object.assign(this._frustumPlanes, getFrustumPlanes(this.viewProjectionMatrix));
      return this._frustumPlanes;
    }
    panByPosition(coords2, pixel) {
      return null;
    }
    _initProps(opts) {
      const longitude = opts.longitude;
      const latitude = opts.latitude;
      if (this.isGeospatial) {
        if (!Number.isFinite(opts.zoom)) {
          this.zoom = getMeterZoom({
            latitude
          }) + Math.log2(this.focalDistance);
        }
        this.distanceScales = opts.distanceScales || getDistanceScales({
          latitude,
          longitude
        });
      }
      const scale4 = Math.pow(2, this.zoom);
      this.scale = scale4;
      const {
        position: position2,
        modelMatrix
      } = opts;
      let meterOffset = ZERO_VECTOR2;
      if (position2) {
        meterOffset = modelMatrix ? new Matrix4(modelMatrix).transformAsVector(position2, []) : position2;
      }
      if (this.isGeospatial) {
        const center = this.projectPosition([longitude, latitude, 0]);
        this.center = new Vector3(meterOffset).scale(this.distanceScales.unitsPerMeter).add(center);
      } else {
        this.center = this.projectPosition(meterOffset);
      }
    }
    _initMatrices(opts) {
      const {
        viewMatrix = IDENTITY2,
        projectionMatrix = null,
        orthographic = false,
        fovyRadians,
        fovy = 75,
        near = 0.1,
        far = 1e3,
        padding = null,
        focalDistance = 1
      } = opts;
      this.viewMatrixUncentered = viewMatrix;
      this.viewMatrix = new Matrix4().multiplyRight(viewMatrix).translate(new Vector3(this.center).negate());
      this.projectionMatrix = projectionMatrix || createProjectionMatrix({
        width: this.width,
        height: this.height,
        orthographic,
        fovyRadians: fovyRadians || fovy * DEGREES_TO_RADIANS4,
        focalDistance,
        padding,
        near,
        far
      });
      const vpm = createMat42();
      multiply2(vpm, vpm, this.projectionMatrix);
      multiply2(vpm, vpm, this.viewMatrix);
      this.viewProjectionMatrix = vpm;
      this.viewMatrixInverse = invert([], this.viewMatrix) || this.viewMatrix;
      this.cameraPosition = getCameraPosition(this.viewMatrixInverse);
      const viewportMatrix = createMat42();
      const pixelProjectionMatrix = createMat42();
      scale2(viewportMatrix, viewportMatrix, [this.width / 2, -this.height / 2, 1]);
      translate(viewportMatrix, viewportMatrix, [1, -1, 0]);
      multiply2(pixelProjectionMatrix, viewportMatrix, this.viewProjectionMatrix);
      this.pixelProjectionMatrix = pixelProjectionMatrix;
      this.pixelUnprojectionMatrix = invert(createMat42(), this.pixelProjectionMatrix);
      if (!this.pixelUnprojectionMatrix) {
        log_default.warn("Pixel project matrix not invertible")();
      }
    }
  };
  _defineProperty(Viewport, "displayName", "Viewport");

  // node_modules/@deck.gl/core/dist/esm/viewports/web-mercator-viewport.js
  var WebMercatorViewport2 = class extends Viewport {
    constructor(opts = {}) {
      const {
        latitude = 0,
        longitude = 0,
        zoom = 0,
        pitch = 0,
        bearing = 0,
        nearZMultiplier = 0.1,
        farZMultiplier = 1.01,
        nearZ,
        farZ,
        orthographic = false,
        projectionMatrix,
        repeat = false,
        worldOffset = 0,
        position: position2,
        padding,
        legacyMeterSizes = false
      } = opts;
      let {
        width: width8,
        height: height8,
        altitude = 1.5
      } = opts;
      const scale4 = Math.pow(2, zoom);
      width8 = width8 || 1;
      height8 = height8 || 1;
      let fovy;
      let projectionParameters = null;
      if (projectionMatrix) {
        altitude = projectionMatrix[5] / 2;
        fovy = altitudeToFovy(altitude);
      } else {
        if (opts.fovy) {
          fovy = opts.fovy;
          altitude = fovyToAltitude(fovy);
        } else {
          fovy = altitudeToFovy(altitude);
        }
        let offset;
        if (padding) {
          const {
            top: top3 = 0,
            bottom: bottom3 = 0
          } = padding;
          offset = [0, clamp((top3 + height8 - bottom3) / 2, 0, height8) - height8 / 2];
        }
        projectionParameters = getProjectionParameters({
          width: width8,
          height: height8,
          scale: scale4,
          center: position2 && [0, 0, position2[2] * unitsPerMeter(latitude)],
          offset,
          pitch,
          fovy,
          nearZMultiplier,
          farZMultiplier
        });
        if (Number.isFinite(nearZ)) {
          projectionParameters.near = nearZ;
        }
        if (Number.isFinite(farZ)) {
          projectionParameters.far = farZ;
        }
      }
      let viewMatrixUncentered = getViewMatrix({
        height: height8,
        pitch,
        bearing,
        scale: scale4,
        altitude
      });
      if (worldOffset) {
        const viewOffset = new Matrix4().translate([512 * worldOffset, 0, 0]);
        viewMatrixUncentered = viewOffset.multiplyLeft(viewMatrixUncentered);
      }
      super({
        ...opts,
        width: width8,
        height: height8,
        viewMatrix: viewMatrixUncentered,
        longitude,
        latitude,
        zoom,
        ...projectionParameters,
        fovy,
        focalDistance: altitude
      });
      _defineProperty(this, "longitude", void 0);
      _defineProperty(this, "latitude", void 0);
      _defineProperty(this, "pitch", void 0);
      _defineProperty(this, "bearing", void 0);
      _defineProperty(this, "altitude", void 0);
      _defineProperty(this, "fovy", void 0);
      _defineProperty(this, "orthographic", void 0);
      _defineProperty(this, "_subViewports", void 0);
      _defineProperty(this, "_pseudoMeters", void 0);
      this.latitude = latitude;
      this.longitude = longitude;
      this.zoom = zoom;
      this.pitch = pitch;
      this.bearing = bearing;
      this.altitude = altitude;
      this.fovy = fovy;
      this.orthographic = orthographic;
      this._subViewports = repeat ? [] : null;
      this._pseudoMeters = legacyMeterSizes;
      Object.freeze(this);
    }
    get subViewports() {
      if (this._subViewports && !this._subViewports.length) {
        const bounds = this.getBounds();
        const minOffset = Math.floor((bounds[0] + 180) / 360);
        const maxOffset = Math.ceil((bounds[2] - 180) / 360);
        for (let x = minOffset; x <= maxOffset; x++) {
          const offsetViewport = x ? new WebMercatorViewport2({
            ...this,
            worldOffset: x
          }) : this;
          this._subViewports.push(offsetViewport);
        }
      }
      return this._subViewports;
    }
    projectPosition(xyz) {
      if (this._pseudoMeters) {
        return super.projectPosition(xyz);
      }
      const [X, Y] = this.projectFlat(xyz);
      const Z = (xyz[2] || 0) * unitsPerMeter(xyz[1]);
      return [X, Y, Z];
    }
    unprojectPosition(xyz) {
      if (this._pseudoMeters) {
        return super.unprojectPosition(xyz);
      }
      const [X, Y] = this.unprojectFlat(xyz);
      const Z = (xyz[2] || 0) / unitsPerMeter(Y);
      return [X, Y, Z];
    }
    addMetersToLngLat(lngLatZ, xyz) {
      return addMetersToLngLat(lngLatZ, xyz);
    }
    panByPosition(coords2, pixel) {
      const fromLocation = pixelsToWorld(pixel, this.pixelUnprojectionMatrix);
      const toLocation = this.projectFlat(coords2);
      const translate2 = add2([], toLocation, negate2([], fromLocation));
      const newCenter = add2([], this.center, translate2);
      const [longitude, latitude] = this.unprojectFlat(newCenter);
      return {
        longitude,
        latitude
      };
    }
    getBounds(options2 = {}) {
      const corners = getBounds(this, options2.z || 0);
      return [Math.min(corners[0][0], corners[1][0], corners[2][0], corners[3][0]), Math.min(corners[0][1], corners[1][1], corners[2][1], corners[3][1]), Math.max(corners[0][0], corners[1][0], corners[2][0], corners[3][0]), Math.max(corners[0][1], corners[1][1], corners[2][1], corners[3][1])];
    }
    fitBounds(bounds, options2 = {}) {
      const {
        width: width8,
        height: height8
      } = this;
      const {
        longitude,
        latitude,
        zoom
      } = fitBounds({
        width: width8,
        height: height8,
        bounds,
        ...options2
      });
      return new WebMercatorViewport2({
        width: width8,
        height: height8,
        longitude,
        latitude,
        zoom
      });
    }
  };
  _defineProperty(WebMercatorViewport2, "displayName", "WebMercatorViewport");

  // node_modules/@deck.gl/core/dist/esm/shaderlib/project/project-functions.js
  var DEFAULT_COORDINATE_ORIGIN2 = [0, 0, 0];
  function lngLatZToWorldPosition(lngLatZ, viewport, offsetMode = false) {
    const p = viewport.projectPosition(lngLatZ);
    if (offsetMode && viewport instanceof WebMercatorViewport2) {
      const [longitude, latitude, z = 0] = lngLatZ;
      const distanceScales = viewport.getDistanceScales([longitude, latitude]);
      p[2] = z * distanceScales.unitsPerMeter[2];
    }
    return p;
  }
  function normalizeParameters(opts) {
    const {
      viewport,
      modelMatrix,
      coordinateOrigin
    } = opts;
    let {
      coordinateSystem,
      fromCoordinateSystem,
      fromCoordinateOrigin
    } = opts;
    if (coordinateSystem === COORDINATE_SYSTEM.DEFAULT) {
      coordinateSystem = viewport.isGeospatial ? COORDINATE_SYSTEM.LNGLAT : COORDINATE_SYSTEM.CARTESIAN;
    }
    if (fromCoordinateSystem === void 0) {
      fromCoordinateSystem = coordinateSystem;
    }
    if (fromCoordinateOrigin === void 0) {
      fromCoordinateOrigin = coordinateOrigin;
    }
    return {
      viewport,
      coordinateSystem,
      coordinateOrigin,
      modelMatrix,
      fromCoordinateSystem,
      fromCoordinateOrigin
    };
  }
  function getWorldPosition(position2, {
    viewport,
    modelMatrix,
    coordinateSystem,
    coordinateOrigin,
    offsetMode
  }) {
    let [x, y, z = 0] = position2;
    if (modelMatrix) {
      [x, y, z] = transformMat43([], [x, y, z, 1], modelMatrix);
    }
    switch (coordinateSystem) {
      case COORDINATE_SYSTEM.LNGLAT:
        return lngLatZToWorldPosition([x, y, z], viewport, offsetMode);
      case COORDINATE_SYSTEM.LNGLAT_OFFSETS:
        return lngLatZToWorldPosition([x + coordinateOrigin[0], y + coordinateOrigin[1], z + (coordinateOrigin[2] || 0)], viewport, offsetMode);
      case COORDINATE_SYSTEM.METER_OFFSETS:
        return lngLatZToWorldPosition(addMetersToLngLat(coordinateOrigin, [x, y, z]), viewport, offsetMode);
      case COORDINATE_SYSTEM.CARTESIAN:
      default:
        return viewport.isGeospatial ? [x + coordinateOrigin[0], y + coordinateOrigin[1], z + coordinateOrigin[2]] : viewport.projectPosition([x, y, z]);
    }
  }
  function projectPosition(position2, params) {
    const {
      viewport,
      coordinateSystem,
      coordinateOrigin,
      modelMatrix,
      fromCoordinateSystem,
      fromCoordinateOrigin
    } = normalizeParameters(params);
    const {
      autoOffset = true
    } = params;
    const {
      geospatialOrigin = DEFAULT_COORDINATE_ORIGIN2,
      shaderCoordinateOrigin = DEFAULT_COORDINATE_ORIGIN2,
      offsetMode = false
    } = autoOffset ? getOffsetOrigin(viewport, coordinateSystem, coordinateOrigin) : {};
    const worldPosition = getWorldPosition(position2, {
      viewport,
      modelMatrix,
      coordinateSystem: fromCoordinateSystem,
      coordinateOrigin: fromCoordinateOrigin,
      offsetMode
    });
    if (offsetMode) {
      const positionCommonSpace = viewport.projectPosition(geospatialOrigin || shaderCoordinateOrigin);
      sub3(worldPosition, worldPosition, positionCommonSpace);
    }
    return worldPosition;
  }

  // node_modules/@deck.gl/core/dist/esm/passes/pick-layers-pass.js
  var PICKING_PARAMETERS = {
    blendFunc: [1, 0, 32771, 0],
    blendEquation: 32774
  };
  var PickLayersPass = class extends LayersPass {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "pickZ", void 0);
      _defineProperty(this, "_colorEncoderState", null);
    }
    render(props) {
      if ("pickingFBO" in props) {
        return this._drawPickingBuffer(props);
      }
      return super.render(props);
    }
    _drawPickingBuffer({
      layers,
      layerFilter,
      views,
      viewports,
      onViewportActive,
      pickingFBO,
      deviceRect: {
        x,
        y,
        width: width8,
        height: height8
      },
      cullRect,
      effects,
      pass: pass2 = "picking",
      pickZ,
      moduleParameters
    }) {
      const gl = this.gl;
      this.pickZ = pickZ;
      const colorEncoderState = this._resetColorEncoder(pickZ);
      const renderStatus = withParameters(gl, {
        scissorTest: true,
        scissor: [x, y, width8, height8],
        clearColor: [0, 0, 0, 0],
        depthMask: true,
        depthTest: true,
        depthRange: [0, 1],
        colorMask: [true, true, true, true],
        ...PICKING_PARAMETERS,
        blend: !pickZ
      }, () => super.render({
        target: pickingFBO,
        layers,
        layerFilter,
        views,
        viewports,
        onViewportActive,
        cullRect,
        effects: effects === null || effects === void 0 ? void 0 : effects.filter((e) => e.useInPicking),
        pass: pass2,
        isPicking: true,
        moduleParameters
      }));
      this._colorEncoderState = null;
      const decodePickingColor = colorEncoderState && decodeColor.bind(null, colorEncoderState);
      return {
        decodePickingColor,
        stats: renderStatus
      };
    }
    shouldDrawLayer(layer) {
      const {
        pickable,
        operation
      } = layer.props;
      return pickable && operation.includes("draw") || operation.includes("terrain") || operation.includes("mask");
    }
    getModuleParameters() {
      return {
        pickingActive: 1,
        pickingAttribute: this.pickZ,
        lightSources: {}
      };
    }
    getLayerParameters(layer, layerIndex, viewport) {
      const pickParameters = {
        ...layer.props.parameters
      };
      const {
        pickable,
        operation
      } = layer.props;
      if (!this._colorEncoderState) {
        pickParameters.blend = false;
      } else if (pickable && operation.includes("draw")) {
        Object.assign(pickParameters, PICKING_PARAMETERS);
        pickParameters.blend = true;
        pickParameters.blendColor = encodeColor(this._colorEncoderState, layer, viewport);
      }
      if (operation.includes("terrain")) {
        pickParameters.blend = false;
      }
      return pickParameters;
    }
    _resetColorEncoder(pickZ) {
      this._colorEncoderState = pickZ ? null : {
        byLayer: /* @__PURE__ */ new Map(),
        byAlpha: []
      };
      return this._colorEncoderState;
    }
  };
  function encodeColor(encoded, layer, viewport) {
    const {
      byLayer,
      byAlpha
    } = encoded;
    let a;
    let entry = byLayer.get(layer);
    if (entry) {
      entry.viewports.push(viewport);
      a = entry.a;
    } else {
      a = byLayer.size + 1;
      if (a <= 255) {
        entry = {
          a,
          layer,
          viewports: [viewport]
        };
        byLayer.set(layer, entry);
        byAlpha[a] = entry;
      } else {
        log_default.warn("Too many pickable layers, only picking the first 255")();
        a = 0;
      }
    }
    return [0, 0, 0, a / 255];
  }
  function decodeColor(encoded, pickedColor) {
    const entry = encoded.byAlpha[pickedColor[3]];
    return entry && {
      pickedLayer: entry.layer,
      pickedViewports: entry.viewports,
      pickedObjectIndex: entry.layer.decodePickingColor(pickedColor)
    };
  }

  // node_modules/@deck.gl/core/dist/esm/lifecycle/constants.js
  var LIFECYCLE = {
    NO_STATE: "Awaiting state",
    MATCHED: "Matched. State transferred from previous layer",
    INITIALIZED: "Initialized",
    AWAITING_GC: "Discarded. Awaiting garbage collection",
    AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
    FINALIZED: "Finalized! Awaiting garbage collection"
  };
  var COMPONENT_SYMBOL = Symbol.for("component");
  var PROP_TYPES_SYMBOL = Symbol.for("propTypes");
  var DEPRECATED_PROPS_SYMBOL = Symbol.for("deprecatedProps");
  var ASYNC_DEFAULTS_SYMBOL = Symbol.for("asyncPropDefaults");
  var ASYNC_ORIGINAL_SYMBOL = Symbol.for("asyncPropOriginal");
  var ASYNC_RESOLVED_SYMBOL = Symbol.for("asyncPropResolved");

  // node_modules/@deck.gl/core/dist/esm/utils/flatten.js
  function flatten(array2, filter3 = () => true) {
    if (!Array.isArray(array2)) {
      return filter3(array2) ? [array2] : [];
    }
    return flattenArray(array2, filter3, []);
  }
  function flattenArray(array2, filter3, result) {
    let index5 = -1;
    while (++index5 < array2.length) {
      const value13 = array2[index5];
      if (Array.isArray(value13)) {
        flattenArray(value13, filter3, result);
      } else if (filter3(value13)) {
        result.push(value13);
      }
    }
    return result;
  }
  function fillArray2({
    target: target5,
    source,
    start: start2 = 0,
    count: count2 = 1
  }) {
    const length7 = source.length;
    const total = count2 * length7;
    let copied = 0;
    for (let i = start2; copied < length7; copied++) {
      target5[i++] = source[copied];
    }
    while (copied < total) {
      if (copied < total - copied) {
        target5.copyWithin(start2 + copied, start2, start2 + copied);
        copied *= 2;
      } else {
        target5.copyWithin(start2 + copied, start2, start2 + total - copied);
        copied = total;
      }
    }
    return target5;
  }

  // node_modules/@deck.gl/core/dist/esm/lib/resource/resource.js
  var Resource2 = class {
    constructor(id2, data, context) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "context", void 0);
      _defineProperty(this, "isLoaded", void 0);
      _defineProperty(this, "persistent", void 0);
      _defineProperty(this, "_loadCount", 0);
      _defineProperty(this, "_subscribers", /* @__PURE__ */ new Set());
      _defineProperty(this, "_data", void 0);
      _defineProperty(this, "_loader", void 0);
      _defineProperty(this, "_error", void 0);
      _defineProperty(this, "_content", void 0);
      this.id = id2;
      this.context = context;
      this.setData(data);
    }
    subscribe(consumer) {
      this._subscribers.add(consumer);
    }
    unsubscribe(consumer) {
      this._subscribers.delete(consumer);
    }
    inUse() {
      return this._subscribers.size > 0;
    }
    delete() {
    }
    getData() {
      return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
    }
    setData(data, forceUpdate) {
      if (data === this._data && !forceUpdate) {
        return;
      }
      this._data = data;
      const loadCount = ++this._loadCount;
      let loader = data;
      if (typeof data === "string") {
        loader = load(data);
      }
      if (loader instanceof Promise) {
        this.isLoaded = false;
        this._loader = loader.then((result) => {
          if (this._loadCount === loadCount) {
            this.isLoaded = true;
            this._error = void 0;
            this._content = result;
          }
        }).catch((error3) => {
          if (this._loadCount === loadCount) {
            this.isLoaded = true;
            this._error = error3 || true;
          }
        });
      } else {
        this.isLoaded = true;
        this._error = void 0;
        this._content = data;
      }
      for (const subscriber of this._subscribers) {
        subscriber.onChange(this.getData());
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/lib/resource/resource-manager.js
  var ResourceManager = class {
    constructor({
      gl,
      protocol: protocol2
    }) {
      _defineProperty(this, "protocol", void 0);
      _defineProperty(this, "_context", void 0);
      _defineProperty(this, "_resources", void 0);
      _defineProperty(this, "_consumers", void 0);
      _defineProperty(this, "_pruneRequest", void 0);
      this.protocol = protocol2 || "resource://";
      this._context = {
        gl,
        resourceManager: this
      };
      this._resources = {};
      this._consumers = {};
      this._pruneRequest = null;
    }
    contains(resourceId) {
      if (resourceId.startsWith(this.protocol)) {
        return true;
      }
      return resourceId in this._resources;
    }
    add({
      resourceId,
      data,
      forceUpdate = false,
      persistent = true
    }) {
      let res = this._resources[resourceId];
      if (res) {
        res.setData(data, forceUpdate);
      } else {
        res = new Resource2(resourceId, data, this._context);
        this._resources[resourceId] = res;
      }
      res.persistent = persistent;
    }
    remove(resourceId) {
      const res = this._resources[resourceId];
      if (res) {
        res.delete();
        delete this._resources[resourceId];
      }
    }
    unsubscribe({
      consumerId
    }) {
      const consumer = this._consumers[consumerId];
      if (consumer) {
        for (const requestId in consumer) {
          const request2 = consumer[requestId];
          const resource = this._resources[request2.resourceId];
          if (resource) {
            resource.unsubscribe(request2);
          }
        }
        delete this._consumers[consumerId];
        this.prune();
      }
    }
    subscribe({
      resourceId,
      onChange,
      consumerId,
      requestId = "default"
    }) {
      const {
        _resources: resources,
        protocol: protocol2
      } = this;
      if (resourceId.startsWith(protocol2)) {
        resourceId = resourceId.replace(protocol2, "");
        if (!resources[resourceId]) {
          this.add({
            resourceId,
            data: null,
            persistent: false
          });
        }
      }
      const res = resources[resourceId];
      this._track(consumerId, requestId, res, onChange);
      if (res) {
        return res.getData();
      }
      return void 0;
    }
    prune() {
      if (!this._pruneRequest) {
        this._pruneRequest = setTimeout(() => this._prune(), 0);
      }
    }
    finalize() {
      for (const key in this._resources) {
        this._resources[key].delete();
      }
    }
    _track(consumerId, requestId, resource, onChange) {
      const consumers = this._consumers;
      const consumer = consumers[consumerId] = consumers[consumerId] || {};
      const request2 = consumer[requestId] || {};
      const oldResource = request2.resourceId && this._resources[request2.resourceId];
      if (oldResource) {
        oldResource.unsubscribe(request2);
        this.prune();
      }
      if (resource) {
        consumer[requestId] = request2;
        request2.onChange = onChange;
        request2.resourceId = resource.id;
        resource.subscribe(request2);
      }
    }
    _prune() {
      this._pruneRequest = null;
      for (const key of Object.keys(this._resources)) {
        const res = this._resources[key];
        if (!res.persistent && !res.inUse()) {
          res.delete();
          delete this._resources[key];
        }
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/shaderlib/project32/project32.js
  var vs5 = "\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition\n) {\n  vec3 projectedPosition = project_position(position, position64Low);\n  mat3 rotation;\n  if (project_needs_rotation(projectedPosition, rotation)) {\n    // offset is specified as ENU\n    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe\n    offset = rotation * offset;\n  }\n  commonPosition = vec4(projectedPosition + offset, 1.0);\n  return project_common_position_to_clipspace(commonPosition);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(position, position64Low, offset, commonPosition);\n}\n";
  var project32_default = {
    name: "project32",
    dependencies: [project_default],
    vs: vs5
  };

  // node_modules/@deck.gl/core/dist/esm/shaderlib/picking/picking.js
  var picking_default = {
    inject: {
      "vs:DECKGL_FILTER_GL_POSITION": "\n    // for picking depth values\n    picking_setPickingAttribute(position.z / position.w);\n  ",
      "vs:DECKGL_FILTER_COLOR": "\n  picking_setPickingColor(geometry.pickingColor);\n  ",
      "fs:#decl": "\nuniform bool picking_uAttribute;\n  ",
      "fs:DECKGL_FILTER_COLOR": {
        order: 99,
        injection: "\n  // use highlight color if this fragment belongs to the selected object.\n  color = picking_filterHighlightColor(color);\n\n  // use picking color if rendering to picking FBO.\n  color = picking_filterPickingColor(color);\n    "
      }
    },
    ...picking
  };

  // node_modules/@deck.gl/core/dist/esm/shaderlib/index.js
  var DEFAULT_MODULES = [project_default];
  var SHADER_HOOKS = ["vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)", "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)", "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)", "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"];
  function createProgramManager(gl) {
    const programManager = ProgramManager.getDefaultProgramManager(gl);
    for (const shaderModule of DEFAULT_MODULES) {
      programManager.addDefaultModule(shaderModule);
    }
    for (const shaderHook of SHADER_HOOKS) {
      programManager.addShaderHook(shaderHook);
    }
    return programManager;
  }

  // node_modules/@deck.gl/core/dist/esm/lib/layer-manager.js
  var TRACE_SET_LAYERS = "layerManager.setLayers";
  var TRACE_ACTIVATE_VIEWPORT = "layerManager.activateViewport";
  var LayerManager = class {
    constructor(gl, {
      deck,
      stats,
      viewport: _viewport,
      timeline
    } = {}) {
      _defineProperty(this, "layers", void 0);
      _defineProperty(this, "context", void 0);
      _defineProperty(this, "resourceManager", void 0);
      _defineProperty(this, "_lastRenderedLayers", []);
      _defineProperty(this, "_needsRedraw", false);
      _defineProperty(this, "_needsUpdate", false);
      _defineProperty(this, "_nextLayers", null);
      _defineProperty(this, "_debug", false);
      _defineProperty(this, "activateViewport", (viewport) => {
        debug(TRACE_ACTIVATE_VIEWPORT, this, viewport);
        if (viewport) {
          this.context.viewport = viewport;
        }
      });
      this.layers = [];
      this.resourceManager = new ResourceManager({
        gl,
        protocol: "deck://"
      });
      this.context = {
        mousePosition: null,
        userData: {},
        layerManager: this,
        gl,
        deck,
        programManager: gl && createProgramManager(gl),
        stats: stats || new Stats({
          id: "deck.gl"
        }),
        viewport: _viewport || new Viewport({
          id: "DEFAULT-INITIAL-VIEWPORT"
        }),
        timeline: timeline || new Timeline(),
        resourceManager: this.resourceManager,
        onError: void 0
      };
      Object.seal(this);
    }
    finalize() {
      this.resourceManager.finalize();
      for (const layer of this.layers) {
        this._finalizeLayer(layer);
      }
    }
    needsRedraw(opts = {
      clearRedrawFlags: false
    }) {
      let redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      for (const layer of this.layers) {
        const layerNeedsRedraw = layer.getNeedsRedraw(opts);
        redraw = redraw || layerNeedsRedraw;
      }
      return redraw;
    }
    needsUpdate() {
      if (this._nextLayers && this._nextLayers !== this._lastRenderedLayers) {
        return "layers changed";
      }
      return this._needsUpdate;
    }
    setNeedsRedraw(reason) {
      this._needsRedraw = this._needsRedraw || reason;
    }
    setNeedsUpdate(reason) {
      this._needsUpdate = this._needsUpdate || reason;
    }
    getLayers({
      layerIds
    } = {}) {
      return layerIds ? this.layers.filter((layer) => layerIds.find((layerId) => layer.id.indexOf(layerId) === 0)) : this.layers;
    }
    setProps(props) {
      if ("debug" in props) {
        this._debug = props.debug;
      }
      if ("userData" in props) {
        this.context.userData = props.userData;
      }
      if ("layers" in props) {
        this._nextLayers = props.layers;
      }
      if ("onError" in props) {
        this.context.onError = props.onError;
      }
    }
    setLayers(newLayers, reason) {
      debug(TRACE_SET_LAYERS, this, reason, newLayers);
      this._lastRenderedLayers = newLayers;
      const flatLayers = flatten(newLayers, Boolean);
      for (const layer of flatLayers) {
        layer.context = this.context;
      }
      this._updateLayers(this.layers, flatLayers);
    }
    updateLayers() {
      const reason = this.needsUpdate();
      if (reason) {
        this.setNeedsRedraw("updating layers: ".concat(reason));
        this.setLayers(this._nextLayers || this._lastRenderedLayers, reason);
      }
      this._nextLayers = null;
    }
    _handleError(stage, error3, layer) {
      layer.raiseError(error3, "".concat(stage, " of ").concat(layer));
    }
    _updateLayers(oldLayers, newLayers) {
      const oldLayerMap = {};
      for (const oldLayer of oldLayers) {
        if (oldLayerMap[oldLayer.id]) {
          log_default.warn("Multiple old layers with same id ".concat(oldLayer.id))();
        } else {
          oldLayerMap[oldLayer.id] = oldLayer;
        }
      }
      const generatedLayers = [];
      this._updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers);
      this._finalizeOldLayers(oldLayerMap);
      let needsUpdate = false;
      for (const layer of generatedLayers) {
        if (layer.hasUniformTransition()) {
          needsUpdate = "Uniform transition in ".concat(layer);
          break;
        }
      }
      this._needsUpdate = needsUpdate;
      this.layers = generatedLayers;
    }
    _updateSublayersRecursively(newLayers, oldLayerMap, generatedLayers) {
      for (const newLayer of newLayers) {
        newLayer.context = this.context;
        const oldLayer = oldLayerMap[newLayer.id];
        if (oldLayer === null) {
          log_default.warn("Multiple new layers with same id ".concat(newLayer.id))();
        }
        oldLayerMap[newLayer.id] = null;
        let sublayers = null;
        try {
          if (this._debug && oldLayer !== newLayer) {
            newLayer.validateProps();
          }
          if (!oldLayer) {
            this._initializeLayer(newLayer);
          } else {
            this._transferLayerState(oldLayer, newLayer);
            this._updateLayer(newLayer);
          }
          generatedLayers.push(newLayer);
          sublayers = newLayer.isComposite ? newLayer.getSubLayers() : null;
        } catch (err) {
          this._handleError("matching", err, newLayer);
        }
        if (sublayers) {
          this._updateSublayersRecursively(sublayers, oldLayerMap, generatedLayers);
        }
      }
    }
    _finalizeOldLayers(oldLayerMap) {
      for (const layerId in oldLayerMap) {
        const layer = oldLayerMap[layerId];
        if (layer) {
          this._finalizeLayer(layer);
        }
      }
    }
    _initializeLayer(layer) {
      try {
        layer._initialize();
        layer.lifecycle = LIFECYCLE.INITIALIZED;
      } catch (err) {
        this._handleError("initialization", err, layer);
      }
    }
    _transferLayerState(oldLayer, newLayer) {
      newLayer._transferState(oldLayer);
      newLayer.lifecycle = LIFECYCLE.MATCHED;
      if (newLayer !== oldLayer) {
        oldLayer.lifecycle = LIFECYCLE.AWAITING_GC;
      }
    }
    _updateLayer(layer) {
      try {
        layer._update();
      } catch (err) {
        this._handleError("update", err, layer);
      }
    }
    _finalizeLayer(layer) {
      this._needsRedraw = this._needsRedraw || "finalized ".concat(layer);
      layer.lifecycle = LIFECYCLE.AWAITING_FINALIZATION;
      try {
        layer._finalize();
        layer.lifecycle = LIFECYCLE.FINALIZED;
      } catch (err) {
        this._handleError("finalization", err, layer);
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/utils/deep-equal.js
  function deepEqual(a, b, depth) {
    if (a === b) {
      return true;
    }
    if (!depth || !a || !b) {
      return false;
    }
    if (Array.isArray(a)) {
      if (!Array.isArray(b) || a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (!deepEqual(a[i], b[i], depth - 1)) {
          return false;
        }
      }
      return true;
    }
    if (Array.isArray(b)) {
      return false;
    }
    if (typeof a === "object" && typeof b === "object") {
      const aKeys = Object.keys(a);
      const bKeys = Object.keys(b);
      if (aKeys.length !== bKeys.length) {
        return false;
      }
      for (const key of aKeys) {
        if (!b.hasOwnProperty(key)) {
          return false;
        }
        if (!deepEqual(a[key], b[key], depth - 1)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // node_modules/@deck.gl/core/dist/esm/lib/view-manager.js
  var ViewManager = class {
    constructor(props) {
      _defineProperty(this, "width", void 0);
      _defineProperty(this, "height", void 0);
      _defineProperty(this, "views", void 0);
      _defineProperty(this, "viewState", void 0);
      _defineProperty(this, "controllers", void 0);
      _defineProperty(this, "timeline", void 0);
      _defineProperty(this, "_viewports", void 0);
      _defineProperty(this, "_viewportMap", void 0);
      _defineProperty(this, "_isUpdating", void 0);
      _defineProperty(this, "_needsRedraw", void 0);
      _defineProperty(this, "_needsUpdate", void 0);
      _defineProperty(this, "_eventManager", void 0);
      _defineProperty(this, "_eventCallbacks", void 0);
      this.views = [];
      this.width = 100;
      this.height = 100;
      this.viewState = {};
      this.controllers = {};
      this.timeline = props.timeline;
      this._viewports = [];
      this._viewportMap = {};
      this._isUpdating = false;
      this._needsRedraw = "First render";
      this._needsUpdate = "Initialize";
      this._eventManager = props.eventManager;
      this._eventCallbacks = {
        onViewStateChange: props.onViewStateChange,
        onInteractionStateChange: props.onInteractionStateChange
      };
      Object.seal(this);
      this.setProps(props);
    }
    finalize() {
      for (const key in this.controllers) {
        const controller = this.controllers[key];
        if (controller) {
          controller.finalize();
        }
      }
      this.controllers = {};
    }
    needsRedraw(opts = {
      clearRedrawFlags: false
    }) {
      const redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      return redraw;
    }
    setNeedsUpdate(reason) {
      this._needsUpdate = this._needsUpdate || reason;
      this._needsRedraw = this._needsRedraw || reason;
    }
    updateViewStates() {
      for (const viewId in this.controllers) {
        const controller = this.controllers[viewId];
        if (controller) {
          controller.updateTransition();
        }
      }
    }
    getViewports(rect) {
      if (rect) {
        return this._viewports.filter((viewport) => viewport.containsPixel(rect));
      }
      return this._viewports;
    }
    getViews() {
      const viewMap = {};
      this.views.forEach((view) => {
        viewMap[view.id] = view;
      });
      return viewMap;
    }
    getView(viewId) {
      return this.views.find((view) => view.id === viewId);
    }
    getViewState(viewOrViewId) {
      const view = typeof viewOrViewId === "string" ? this.getView(viewOrViewId) : viewOrViewId;
      const viewState = view && this.viewState[view.getViewStateId()] || this.viewState;
      return view ? view.filterViewState(viewState) : viewState;
    }
    getViewport(viewId) {
      return this._viewportMap[viewId];
    }
    unproject(xyz, opts) {
      const viewports = this.getViewports();
      const pixel = {
        x: xyz[0],
        y: xyz[1]
      };
      for (let i = viewports.length - 1; i >= 0; --i) {
        const viewport = viewports[i];
        if (viewport.containsPixel(pixel)) {
          const p = xyz.slice();
          p[0] -= viewport.x;
          p[1] -= viewport.y;
          return viewport.unproject(p, opts);
        }
      }
      return null;
    }
    setProps(props) {
      if (props.views) {
        this._setViews(props.views);
      }
      if (props.viewState) {
        this._setViewState(props.viewState);
      }
      if ("width" in props || "height" in props) {
        this._setSize(props.width, props.height);
      }
      if (!this._isUpdating) {
        this._update();
      }
    }
    _update() {
      this._isUpdating = true;
      if (this._needsUpdate) {
        this._needsUpdate = false;
        this._rebuildViewports();
      }
      if (this._needsUpdate) {
        this._needsUpdate = false;
        this._rebuildViewports();
      }
      this._isUpdating = false;
    }
    _setSize(width8, height8) {
      if (width8 !== this.width || height8 !== this.height) {
        this.width = width8;
        this.height = height8;
        this.setNeedsUpdate("Size changed");
      }
    }
    _setViews(views) {
      views = flatten(views, Boolean);
      const viewsChanged = this._diffViews(views, this.views);
      if (viewsChanged) {
        this.setNeedsUpdate("views changed");
      }
      this.views = views;
    }
    _setViewState(viewState) {
      if (viewState) {
        const viewStateChanged = !deepEqual(viewState, this.viewState, 3);
        if (viewStateChanged) {
          this.setNeedsUpdate("viewState changed");
        }
        this.viewState = viewState;
      } else {
        log_default.warn("missing `viewState` or `initialViewState`")();
      }
    }
    _onViewStateChange(viewId, event) {
      if (this._eventCallbacks.onViewStateChange) {
        this._eventCallbacks.onViewStateChange({
          ...event,
          viewId
        });
      }
    }
    _createController(view, props) {
      const Controller2 = props.type;
      const controller = new Controller2({
        timeline: this.timeline,
        eventManager: this._eventManager,
        onViewStateChange: this._onViewStateChange.bind(this, props.id),
        onStateChange: this._eventCallbacks.onInteractionStateChange,
        makeViewport: (viewState) => {
          var _this$getView;
          return (_this$getView = this.getView(view.id)) === null || _this$getView === void 0 ? void 0 : _this$getView.makeViewport({
            viewState,
            width: this.width,
            height: this.height
          });
        }
      });
      return controller;
    }
    _updateController(view, viewState, viewport, controller) {
      const controllerProps = view.controller;
      if (controllerProps && viewport) {
        const resolvedProps = {
          ...viewState,
          ...controllerProps,
          id: view.id,
          x: viewport.x,
          y: viewport.y,
          width: viewport.width,
          height: viewport.height
        };
        if (!controller || controller.constructor !== controllerProps.type) {
          controller = this._createController(view, resolvedProps);
        }
        if (controller) {
          controller.setProps(resolvedProps);
        }
        return controller;
      }
      return null;
    }
    _rebuildViewports() {
      const {
        views
      } = this;
      const oldControllers = this.controllers;
      this._viewports = [];
      this.controllers = {};
      let invalidateControllers = false;
      for (let i = views.length; i--; ) {
        const view = views[i];
        const viewState = this.getViewState(view);
        const viewport = view.makeViewport({
          viewState,
          width: this.width,
          height: this.height
        });
        let oldController = oldControllers[view.id];
        const hasController = Boolean(view.controller);
        if (hasController && !oldController) {
          invalidateControllers = true;
        }
        if ((invalidateControllers || !hasController) && oldController) {
          oldController.finalize();
          oldController = null;
        }
        this.controllers[view.id] = this._updateController(view, viewState, viewport, oldController);
        if (viewport) {
          this._viewports.unshift(viewport);
        }
      }
      for (const id2 in oldControllers) {
        const oldController = oldControllers[id2];
        if (oldController && !this.controllers[id2]) {
          oldController.finalize();
        }
      }
      this._buildViewportMap();
    }
    _buildViewportMap() {
      this._viewportMap = {};
      this._viewports.forEach((viewport) => {
        if (viewport.id) {
          this._viewportMap[viewport.id] = this._viewportMap[viewport.id] || viewport;
        }
      });
    }
    _diffViews(newViews, oldViews) {
      if (newViews.length !== oldViews.length) {
        return true;
      }
      return newViews.some((_, i) => !newViews[i].equals(oldViews[i]));
    }
  };

  // node_modules/@deck.gl/core/dist/esm/utils/positions.js
  var PERCENT_OR_PIXELS_REGEX = /([0-9]+\.?[0-9]*)(%|px)/;
  function parsePosition(value13) {
    switch (typeof value13) {
      case "number":
        return {
          position: value13,
          relative: false
        };
      case "string":
        const match = PERCENT_OR_PIXELS_REGEX.exec(value13);
        if (match && match.length >= 3) {
          const relative = match[2] === "%";
          const position2 = parseFloat(match[1]);
          return {
            position: relative ? position2 / 100 : position2,
            relative
          };
        }
      default:
        throw new Error("Could not parse position string ".concat(value13));
    }
  }
  function getPosition(position2, extent) {
    return position2.relative ? Math.round(position2.position * extent) : position2.position;
  }

  // node_modules/@deck.gl/core/dist/esm/utils/assert.js
  function assert10(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "deck.gl: assertion failed.");
    }
  }

  // node_modules/@deck.gl/core/dist/esm/views/view.js
  var View = class {
    constructor(props) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "viewportInstance", void 0);
      _defineProperty(this, "_x", void 0);
      _defineProperty(this, "_y", void 0);
      _defineProperty(this, "_width", void 0);
      _defineProperty(this, "_height", void 0);
      _defineProperty(this, "_padding", void 0);
      _defineProperty(this, "props", void 0);
      const {
        id: id2,
        x = 0,
        y = 0,
        width: width8 = "100%",
        height: height8 = "100%",
        padding = null,
        viewportInstance
      } = props || {};
      assert10(!viewportInstance || viewportInstance instanceof Viewport);
      this.viewportInstance = viewportInstance;
      this.id = id2 || this.constructor.displayName || "view";
      this.props = {
        ...props,
        id: this.id
      };
      this._x = parsePosition(x);
      this._y = parsePosition(y);
      this._width = parsePosition(width8);
      this._height = parsePosition(height8);
      this._padding = padding && {
        left: parsePosition(padding.left || 0),
        right: parsePosition(padding.right || 0),
        top: parsePosition(padding.top || 0),
        bottom: parsePosition(padding.bottom || 0)
      };
      this.equals = this.equals.bind(this);
      Object.seal(this);
    }
    equals(view) {
      if (this === view) {
        return true;
      }
      if (this.viewportInstance) {
        return view.viewportInstance ? this.viewportInstance.equals(view.viewportInstance) : false;
      }
      return this.ViewportType === view.ViewportType && deepEqual(this.props, view.props, 2);
    }
    makeViewport({
      width: width8,
      height: height8,
      viewState
    }) {
      if (this.viewportInstance) {
        return this.viewportInstance;
      }
      viewState = this.filterViewState(viewState);
      const viewportDimensions = this.getDimensions({
        width: width8,
        height: height8
      });
      if (!viewportDimensions.height || !viewportDimensions.width) {
        return null;
      }
      return new this.ViewportType({
        ...viewState,
        ...this.props,
        ...viewportDimensions
      });
    }
    getViewStateId() {
      const {
        viewState
      } = this.props;
      if (typeof viewState === "string") {
        return viewState;
      }
      return (viewState === null || viewState === void 0 ? void 0 : viewState.id) || this.id;
    }
    filterViewState(viewState) {
      if (this.props.viewState && typeof this.props.viewState === "object") {
        if (!this.props.viewState.id) {
          return this.props.viewState;
        }
        const newViewState = {
          ...viewState
        };
        for (const key in this.props.viewState) {
          if (key !== "id") {
            newViewState[key] = this.props.viewState[key];
          }
        }
        return newViewState;
      }
      return viewState;
    }
    getDimensions({
      width: width8,
      height: height8
    }) {
      const dimensions = {
        x: getPosition(this._x, width8),
        y: getPosition(this._y, height8),
        width: getPosition(this._width, width8),
        height: getPosition(this._height, height8)
      };
      if (this._padding) {
        dimensions.padding = {
          left: getPosition(this._padding.left, width8),
          top: getPosition(this._padding.top, height8),
          right: getPosition(this._padding.right, width8),
          bottom: getPosition(this._padding.bottom, height8)
        };
      }
      return dimensions;
    }
    get controller() {
      const opts = this.props.controller;
      if (!opts) {
        return null;
      }
      if (opts === true) {
        return {
          type: this.ControllerType
        };
      }
      if (typeof opts === "function") {
        return {
          type: opts
        };
      }
      return {
        type: this.ControllerType,
        ...opts
      };
    }
  };

  // node_modules/@deck.gl/core/dist/esm/transitions/transition.js
  var Transition = class {
    constructor(timeline) {
      _defineProperty(this, "_inProgress", void 0);
      _defineProperty(this, "_handle", void 0);
      _defineProperty(this, "_timeline", void 0);
      _defineProperty(this, "time", void 0);
      _defineProperty(this, "settings", void 0);
      this._inProgress = false;
      this._handle = null;
      this._timeline = timeline;
      this.time = 0;
      this.settings = {
        duration: 0
      };
    }
    get inProgress() {
      return this._inProgress;
    }
    start(settings) {
      var _this$settings$onStar, _this$settings;
      this.cancel();
      this.settings = settings;
      this._inProgress = true;
      (_this$settings$onStar = (_this$settings = this.settings).onStart) === null || _this$settings$onStar === void 0 ? void 0 : _this$settings$onStar.call(_this$settings, this);
    }
    end() {
      if (this._inProgress) {
        var _this$settings$onEnd, _this$settings2;
        this._timeline.removeChannel(this._handle);
        this._handle = null;
        this._inProgress = false;
        (_this$settings$onEnd = (_this$settings2 = this.settings).onEnd) === null || _this$settings$onEnd === void 0 ? void 0 : _this$settings$onEnd.call(_this$settings2, this);
      }
    }
    cancel() {
      if (this._inProgress) {
        var _this$settings$onInte, _this$settings3;
        (_this$settings$onInte = (_this$settings3 = this.settings).onInterrupt) === null || _this$settings$onInte === void 0 ? void 0 : _this$settings$onInte.call(_this$settings3, this);
        this._timeline.removeChannel(this._handle);
        this._handle = null;
        this._inProgress = false;
      }
    }
    update() {
      var _this$settings$onUpda, _this$settings4;
      if (!this._inProgress) {
        return false;
      }
      if (this._handle === null) {
        const {
          _timeline: timeline,
          settings
        } = this;
        this._handle = timeline.addChannel({
          delay: timeline.getTime(),
          duration: settings.duration
        });
      }
      this.time = this._timeline.getTime(this._handle);
      this._onUpdate();
      (_this$settings$onUpda = (_this$settings4 = this.settings).onUpdate) === null || _this$settings$onUpda === void 0 ? void 0 : _this$settings$onUpda.call(_this$settings4, this);
      if (this._timeline.isFinished(this._handle)) {
        this.end();
      }
      return true;
    }
    _onUpdate() {
    }
  };

  // node_modules/@deck.gl/core/dist/esm/controllers/transition-manager.js
  var noop3 = () => {
  };
  var TRANSITION_EVENTS = {
    BREAK: 1,
    SNAP_TO_END: 2,
    IGNORE: 3
  };
  var DEFAULT_EASING = (t) => t;
  var DEFAULT_INTERRUPTION = TRANSITION_EVENTS.BREAK;
  var TransitionManager = class {
    constructor(opts) {
      _defineProperty(this, "getControllerState", void 0);
      _defineProperty(this, "props", void 0);
      _defineProperty(this, "propsInTransition", void 0);
      _defineProperty(this, "transition", void 0);
      _defineProperty(this, "onViewStateChange", void 0);
      _defineProperty(this, "onStateChange", void 0);
      _defineProperty(this, "_onTransitionUpdate", (transition) => {
        const {
          time,
          settings: {
            interpolator,
            startProps,
            endProps,
            duration: duration2,
            easing
          }
        } = transition;
        const t = easing(time / duration2);
        const viewport = interpolator.interpolateProps(startProps, endProps, t);
        this.propsInTransition = this.getControllerState({
          ...this.props,
          ...viewport
        }).getViewportProps();
        this.onViewStateChange({
          viewState: this.propsInTransition,
          oldViewState: this.props
        });
      });
      this.getControllerState = opts.getControllerState;
      this.propsInTransition = null;
      this.transition = new Transition(opts.timeline);
      this.onViewStateChange = opts.onViewStateChange || noop3;
      this.onStateChange = opts.onStateChange || noop3;
    }
    finalize() {
      this.transition.cancel();
    }
    getViewportInTransition() {
      return this.propsInTransition;
    }
    processViewStateChange(nextProps) {
      let transitionTriggered = false;
      const currentProps = this.props;
      this.props = nextProps;
      if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {
        return false;
      }
      if (this._isTransitionEnabled(nextProps)) {
        let startProps = currentProps;
        if (this.transition.inProgress) {
          const {
            interruption,
            endProps
          } = this.transition.settings;
          startProps = {
            ...currentProps,
            ...interruption === TRANSITION_EVENTS.SNAP_TO_END ? endProps : this.propsInTransition || currentProps
          };
        }
        this._triggerTransition(startProps, nextProps);
        transitionTriggered = true;
      } else {
        this.transition.cancel();
      }
      return transitionTriggered;
    }
    updateTransition() {
      this.transition.update();
    }
    _isTransitionEnabled(props) {
      const {
        transitionDuration,
        transitionInterpolator
      } = props;
      return (transitionDuration > 0 || transitionDuration === "auto") && Boolean(transitionInterpolator);
    }
    _isUpdateDueToCurrentTransition(props) {
      if (this.transition.inProgress && this.propsInTransition) {
        return this.transition.settings.interpolator.arePropsEqual(props, this.propsInTransition);
      }
      return false;
    }
    _shouldIgnoreViewportChange(currentProps, nextProps) {
      if (this.transition.inProgress) {
        return this.transition.settings.interruption === TRANSITION_EVENTS.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);
      }
      if (this._isTransitionEnabled(nextProps)) {
        return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);
      }
      return true;
    }
    _triggerTransition(startProps, endProps) {
      const startViewstate = this.getControllerState(startProps);
      const endViewStateProps = this.getControllerState(endProps).shortestPathFrom(startViewstate);
      const transitionInterpolator = endProps.transitionInterpolator;
      const duration2 = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;
      if (duration2 === 0) {
        return;
      }
      const initialProps = transitionInterpolator.initializeProps(startProps, endViewStateProps);
      this.propsInTransition = {};
      const transitionSettings = {
        duration: duration2,
        easing: endProps.transitionEasing || DEFAULT_EASING,
        interpolator: transitionInterpolator,
        interruption: endProps.transitionInterruption || DEFAULT_INTERRUPTION,
        startProps: initialProps.start,
        endProps: initialProps.end,
        onStart: endProps.onTransitionStart,
        onUpdate: this._onTransitionUpdate,
        onInterrupt: this._onTransitionEnd(endProps.onTransitionInterrupt),
        onEnd: this._onTransitionEnd(endProps.onTransitionEnd)
      };
      this.transition.start(transitionSettings);
      this.onStateChange({
        inTransition: true
      });
      this.updateTransition();
    }
    _onTransitionEnd(callback) {
      return (transition) => {
        this.propsInTransition = null;
        this.onStateChange({
          inTransition: false,
          isZooming: false,
          isPanning: false,
          isRotating: false
        });
        callback === null || callback === void 0 ? void 0 : callback(transition);
      };
    }
  };

  // node_modules/@deck.gl/core/dist/esm/transitions/transition-interpolator.js
  var TransitionInterpolator = class {
    constructor(opts) {
      _defineProperty(this, "_propsToCompare", void 0);
      _defineProperty(this, "_propsToExtract", void 0);
      _defineProperty(this, "_requiredProps", void 0);
      const {
        compare: compare2,
        extract: extract2,
        required: required4
      } = opts;
      this._propsToCompare = compare2;
      this._propsToExtract = extract2 || compare2;
      this._requiredProps = required4;
    }
    arePropsEqual(currentProps, nextProps) {
      for (const key of this._propsToCompare) {
        if (!(key in currentProps) || !(key in nextProps) || !equals(currentProps[key], nextProps[key])) {
          return false;
        }
      }
      return true;
    }
    initializeProps(startProps, endProps) {
      const startViewStateProps = {};
      const endViewStateProps = {};
      for (const key of this._propsToExtract) {
        if (key in startProps || key in endProps) {
          startViewStateProps[key] = startProps[key];
          endViewStateProps[key] = endProps[key];
        }
      }
      this._checkRequiredProps(startViewStateProps);
      this._checkRequiredProps(endViewStateProps);
      return {
        start: startViewStateProps,
        end: endViewStateProps
      };
    }
    getDuration(startProps, endProps) {
      return endProps.transitionDuration;
    }
    _checkRequiredProps(props) {
      if (!this._requiredProps) {
        return;
      }
      this._requiredProps.forEach((propName) => {
        const value13 = props[propName];
        assert10(Number.isFinite(value13) || Array.isArray(value13), "".concat(propName, " is required for transition"));
      });
    }
  };

  // node_modules/@deck.gl/core/dist/esm/transitions/linear-interpolator.js
  var DEFAULT_PROPS2 = ["longitude", "latitude", "zoom", "bearing", "pitch"];
  var DEFAULT_REQUIRED_PROPS = ["longitude", "latitude", "zoom"];
  var LinearInterpolator = class extends TransitionInterpolator {
    constructor(opts = {}) {
      const transitionProps = Array.isArray(opts) ? opts : opts.transitionProps;
      const normalizedOpts = Array.isArray(opts) ? {} : opts;
      normalizedOpts.transitionProps = Array.isArray(transitionProps) ? {
        compare: transitionProps,
        required: transitionProps
      } : transitionProps || {
        compare: DEFAULT_PROPS2,
        required: DEFAULT_REQUIRED_PROPS
      };
      super(normalizedOpts.transitionProps);
      _defineProperty(this, "opts", void 0);
      this.opts = normalizedOpts;
    }
    initializeProps(startProps, endProps) {
      const result = super.initializeProps(startProps, endProps);
      const {
        makeViewport,
        around
      } = this.opts;
      if (makeViewport && around) {
        const startViewport = makeViewport(startProps);
        const endViewport = makeViewport(endProps);
        const aroundPosition = startViewport.unproject(around);
        result.start.around = around;
        Object.assign(result.end, {
          around: endViewport.project(aroundPosition),
          aroundPosition,
          width: endProps.width,
          height: endProps.height
        });
      }
      return result;
    }
    interpolateProps(startProps, endProps, t) {
      const propsInTransition = {};
      for (const key of this._propsToExtract) {
        propsInTransition[key] = lerp(startProps[key] || 0, endProps[key] || 0, t);
      }
      if (endProps.aroundPosition && this.opts.makeViewport) {
        const viewport = this.opts.makeViewport({
          ...endProps,
          ...propsInTransition
        });
        Object.assign(propsInTransition, viewport.panByPosition(endProps.aroundPosition, lerp(startProps.around, endProps.around, t)));
      }
      return propsInTransition;
    }
  };

  // node_modules/@deck.gl/core/dist/esm/controllers/controller.js
  var NO_TRANSITION_PROPS = {
    transitionDuration: 0
  };
  var DEFAULT_INERTIA = 300;
  var INERTIA_EASING = (t) => 1 - (1 - t) * (1 - t);
  var EVENT_TYPES = {
    WHEEL: ["wheel"],
    PAN: ["panstart", "panmove", "panend"],
    PINCH: ["pinchstart", "pinchmove", "pinchend"],
    TRIPLE_PAN: ["tripanstart", "tripanmove", "tripanend"],
    DOUBLE_TAP: ["doubletap"],
    KEYBOARD: ["keydown"]
  };
  var pinchEventWorkaround = {};
  var Controller = class {
    constructor(opts) {
      _defineProperty(this, "props", void 0);
      _defineProperty(this, "state", {});
      _defineProperty(this, "transitionManager", void 0);
      _defineProperty(this, "eventManager", void 0);
      _defineProperty(this, "onViewStateChange", void 0);
      _defineProperty(this, "onStateChange", void 0);
      _defineProperty(this, "makeViewport", void 0);
      _defineProperty(this, "_controllerState", void 0);
      _defineProperty(this, "_events", {});
      _defineProperty(this, "_interactionState", {
        isDragging: false
      });
      _defineProperty(this, "_customEvents", []);
      _defineProperty(this, "_eventStartBlocked", null);
      _defineProperty(this, "_panMove", false);
      _defineProperty(this, "invertPan", false);
      _defineProperty(this, "dragMode", "rotate");
      _defineProperty(this, "inertia", 0);
      _defineProperty(this, "scrollZoom", true);
      _defineProperty(this, "dragPan", true);
      _defineProperty(this, "dragRotate", true);
      _defineProperty(this, "doubleClickZoom", true);
      _defineProperty(this, "touchZoom", true);
      _defineProperty(this, "touchRotate", false);
      _defineProperty(this, "keyboard", true);
      this.transitionManager = new TransitionManager({
        ...opts,
        getControllerState: (props) => new this.ControllerState(props),
        onViewStateChange: this._onTransition.bind(this),
        onStateChange: this._setInteractionState.bind(this)
      });
      this.handleEvent = this.handleEvent.bind(this);
      this.eventManager = opts.eventManager;
      this.onViewStateChange = opts.onViewStateChange || (() => {
      });
      this.onStateChange = opts.onStateChange || (() => {
      });
      this.makeViewport = opts.makeViewport;
    }
    set events(customEvents) {
      this.toggleEvents(this._customEvents, false);
      this.toggleEvents(customEvents, true);
      this._customEvents = customEvents;
      if (this.props) {
        this.setProps(this.props);
      }
    }
    finalize() {
      for (const eventName in this._events) {
        if (this._events[eventName]) {
          var _this$eventManager;
          (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 ? void 0 : _this$eventManager.off(eventName, this.handleEvent);
        }
      }
      this.transitionManager.finalize();
    }
    handleEvent(event) {
      this._controllerState = void 0;
      const eventStartBlocked = this._eventStartBlocked;
      switch (event.type) {
        case "panstart":
          return eventStartBlocked ? false : this._onPanStart(event);
        case "panmove":
          return this._onPan(event);
        case "panend":
          return this._onPanEnd(event);
        case "pinchstart":
          return eventStartBlocked ? false : this._onPinchStart(event);
        case "pinchmove":
          return this._onPinch(event);
        case "pinchend":
          return this._onPinchEnd(event);
        case "tripanstart":
          return eventStartBlocked ? false : this._onTriplePanStart(event);
        case "tripanmove":
          return this._onTriplePan(event);
        case "tripanend":
          return this._onTriplePanEnd(event);
        case "doubletap":
          return this._onDoubleTap(event);
        case "wheel":
          return this._onWheel(event);
        case "keydown":
          return this._onKeyDown(event);
        default:
          return false;
      }
    }
    get controllerState() {
      this._controllerState = this._controllerState || new this.ControllerState({
        makeViewport: this.makeViewport,
        ...this.props,
        ...this.state
      });
      return this._controllerState;
    }
    getCenter(event) {
      const {
        x,
        y
      } = this.props;
      const {
        offsetCenter
      } = event;
      return [offsetCenter.x - x, offsetCenter.y - y];
    }
    isPointInBounds(pos, event) {
      const {
        width: width8,
        height: height8
      } = this.props;
      if (event && event.handled) {
        return false;
      }
      const inside = pos[0] >= 0 && pos[0] <= width8 && pos[1] >= 0 && pos[1] <= height8;
      if (inside && event) {
        event.stopPropagation();
      }
      return inside;
    }
    isFunctionKeyPressed(event) {
      const {
        srcEvent
      } = event;
      return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
    }
    isDragging() {
      return this._interactionState.isDragging || false;
    }
    blockEvents(timeout) {
      const timer = setTimeout(() => {
        if (this._eventStartBlocked === timer) {
          this._eventStartBlocked = null;
        }
      }, timeout);
      this._eventStartBlocked = timer;
    }
    setProps(props) {
      if (props.dragMode) {
        this.dragMode = props.dragMode;
      }
      this.props = props;
      if (!("transitionInterpolator" in props)) {
        props.transitionInterpolator = this._getTransitionProps().transitionInterpolator;
      }
      this.transitionManager.processViewStateChange(props);
      const {
        inertia
      } = props;
      this.inertia = Number.isFinite(inertia) ? inertia : inertia === true ? DEFAULT_INERTIA : 0;
      const {
        scrollZoom = true,
        dragPan = true,
        dragRotate = true,
        doubleClickZoom = true,
        touchZoom = true,
        touchRotate = false,
        keyboard = true
      } = props;
      const isInteractive = Boolean(this.onViewStateChange);
      this.toggleEvents(EVENT_TYPES.WHEEL, isInteractive && scrollZoom);
      this.toggleEvents(EVENT_TYPES.PAN, isInteractive);
      this.toggleEvents(EVENT_TYPES.PINCH, isInteractive && (touchZoom || touchRotate));
      this.toggleEvents(EVENT_TYPES.TRIPLE_PAN, isInteractive && touchRotate);
      this.toggleEvents(EVENT_TYPES.DOUBLE_TAP, isInteractive && doubleClickZoom);
      this.toggleEvents(EVENT_TYPES.KEYBOARD, isInteractive && keyboard);
      this.scrollZoom = scrollZoom;
      this.dragPan = dragPan;
      this.dragRotate = dragRotate;
      this.doubleClickZoom = doubleClickZoom;
      this.touchZoom = touchZoom;
      this.touchRotate = touchRotate;
      this.keyboard = keyboard;
    }
    updateTransition() {
      this.transitionManager.updateTransition();
    }
    toggleEvents(eventNames, enabled) {
      if (this.eventManager) {
        eventNames.forEach((eventName) => {
          if (this._events[eventName] !== enabled) {
            this._events[eventName] = enabled;
            if (enabled) {
              this.eventManager.on(eventName, this.handleEvent);
            } else {
              this.eventManager.off(eventName, this.handleEvent);
            }
          }
        });
      }
    }
    updateViewport(newControllerState, extraProps = null, interactionState = {}) {
      const viewState = {
        ...newControllerState.getViewportProps(),
        ...extraProps
      };
      const changed = this.controllerState !== newControllerState;
      this.state = newControllerState.getState();
      this._setInteractionState(interactionState);
      if (changed) {
        const oldViewState = this.controllerState && this.controllerState.getViewportProps();
        if (this.onViewStateChange) {
          this.onViewStateChange({
            viewState,
            interactionState: this._interactionState,
            oldViewState
          });
        }
      }
    }
    _onTransition(params) {
      this.onViewStateChange({
        ...params,
        interactionState: this._interactionState
      });
    }
    _setInteractionState(newStates) {
      Object.assign(this._interactionState, newStates);
      this.onStateChange(this._interactionState);
    }
    _onPanStart(event) {
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      let alternateMode = this.isFunctionKeyPressed(event) || event.rightButton || false;
      if (this.invertPan || this.dragMode === "pan") {
        alternateMode = !alternateMode;
      }
      const newControllerState = this.controllerState[alternateMode ? "panStart" : "rotateStart"]({
        pos
      });
      this._panMove = alternateMode;
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true
      });
      return true;
    }
    _onPan(event) {
      if (!this.isDragging()) {
        return false;
      }
      return this._panMove ? this._onPanMove(event) : this._onPanRotate(event);
    }
    _onPanEnd(event) {
      if (!this.isDragging()) {
        return false;
      }
      return this._panMove ? this._onPanMoveEnd(event) : this._onPanRotateEnd(event);
    }
    _onPanMove(event) {
      if (!this.dragPan) {
        return false;
      }
      const pos = this.getCenter(event);
      const newControllerState = this.controllerState.pan({
        pos
      });
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isPanning: true
      });
      return true;
    }
    _onPanMoveEnd(event) {
      const {
        inertia
      } = this;
      if (this.dragPan && inertia && event.velocity) {
        const pos = this.getCenter(event);
        const endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
        const newControllerState = this.controllerState.pan({
          pos: endPos
        }).panEnd();
        this.updateViewport(newControllerState, {
          ...this._getTransitionProps(),
          transitionDuration: inertia,
          transitionEasing: INERTIA_EASING
        }, {
          isDragging: false,
          isPanning: true
        });
      } else {
        const newControllerState = this.controllerState.panEnd();
        this.updateViewport(newControllerState, null, {
          isDragging: false,
          isPanning: false
        });
      }
      return true;
    }
    _onPanRotate(event) {
      if (!this.dragRotate) {
        return false;
      }
      const pos = this.getCenter(event);
      const newControllerState = this.controllerState.rotate({
        pos
      });
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isRotating: true
      });
      return true;
    }
    _onPanRotateEnd(event) {
      const {
        inertia
      } = this;
      if (this.dragRotate && inertia && event.velocity) {
        const pos = this.getCenter(event);
        const endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
        const newControllerState = this.controllerState.rotate({
          pos: endPos
        }).rotateEnd();
        this.updateViewport(newControllerState, {
          ...this._getTransitionProps(),
          transitionDuration: inertia,
          transitionEasing: INERTIA_EASING
        }, {
          isDragging: false,
          isRotating: true
        });
      } else {
        const newControllerState = this.controllerState.rotateEnd();
        this.updateViewport(newControllerState, null, {
          isDragging: false,
          isRotating: false
        });
      }
      return true;
    }
    _onWheel(event) {
      if (!this.scrollZoom) {
        return false;
      }
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      event.srcEvent.preventDefault();
      const {
        speed = 0.01,
        smooth = false
      } = this.scrollZoom === true ? {} : this.scrollZoom;
      const {
        delta
      } = event;
      let scale4 = 2 / (1 + Math.exp(-Math.abs(delta * speed)));
      if (delta < 0 && scale4 !== 0) {
        scale4 = 1 / scale4;
      }
      const newControllerState = this.controllerState.zoom({
        pos,
        scale: scale4
      });
      this.updateViewport(newControllerState, {
        ...this._getTransitionProps({
          around: pos
        }),
        transitionDuration: smooth ? 250 : 1
      }, {
        isZooming: true,
        isPanning: true
      });
      return true;
    }
    _onTriplePanStart(event) {
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      const newControllerState = this.controllerState.rotateStart({
        pos
      });
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true
      });
      return true;
    }
    _onTriplePan(event) {
      if (!this.touchRotate) {
        return false;
      }
      if (!this.isDragging()) {
        return false;
      }
      const pos = this.getCenter(event);
      pos[0] -= event.deltaX;
      const newControllerState = this.controllerState.rotate({
        pos
      });
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isRotating: true
      });
      return true;
    }
    _onTriplePanEnd(event) {
      if (!this.isDragging()) {
        return false;
      }
      const {
        inertia
      } = this;
      if (this.touchRotate && inertia && event.velocityY) {
        const pos = this.getCenter(event);
        const endPos = [pos[0], pos[1] += event.velocityY * inertia / 2];
        const newControllerState = this.controllerState.rotate({
          pos: endPos
        });
        this.updateViewport(newControllerState, {
          ...this._getTransitionProps(),
          transitionDuration: inertia,
          transitionEasing: INERTIA_EASING
        }, {
          isDragging: false,
          isRotating: true
        });
        this.blockEvents(inertia);
      } else {
        const newControllerState = this.controllerState.rotateEnd();
        this.updateViewport(newControllerState, null, {
          isDragging: false,
          isRotating: false
        });
      }
      return true;
    }
    _onPinchStart(event) {
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      const newControllerState = this.controllerState.zoomStart({
        pos
      }).rotateStart({
        pos
      });
      pinchEventWorkaround._startPinchRotation = event.rotation;
      pinchEventWorkaround._lastPinchEvent = event;
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true
      });
      return true;
    }
    _onPinch(event) {
      if (!this.touchZoom && !this.touchRotate) {
        return false;
      }
      if (!this.isDragging()) {
        return false;
      }
      let newControllerState = this.controllerState;
      if (this.touchZoom) {
        const {
          scale: scale4
        } = event;
        const pos = this.getCenter(event);
        newControllerState = newControllerState.zoom({
          pos,
          scale: scale4
        });
      }
      if (this.touchRotate) {
        const {
          rotation
        } = event;
        newControllerState = newControllerState.rotate({
          deltaAngleX: pinchEventWorkaround._startPinchRotation - rotation
        });
      }
      this.updateViewport(newControllerState, NO_TRANSITION_PROPS, {
        isDragging: true,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: this.touchRotate
      });
      pinchEventWorkaround._lastPinchEvent = event;
      return true;
    }
    _onPinchEnd(event) {
      if (!this.isDragging()) {
        return false;
      }
      const {
        inertia
      } = this;
      const {
        _lastPinchEvent
      } = pinchEventWorkaround;
      if (this.touchZoom && inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {
        const pos = this.getCenter(event);
        let newControllerState = this.controllerState.rotateEnd();
        const z = Math.log2(event.scale);
        const velocityZ = (z - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);
        const endScale = Math.pow(2, z + velocityZ * inertia / 2);
        newControllerState = newControllerState.zoom({
          pos,
          scale: endScale
        }).zoomEnd();
        this.updateViewport(newControllerState, {
          ...this._getTransitionProps({
            around: pos
          }),
          transitionDuration: inertia,
          transitionEasing: INERTIA_EASING
        }, {
          isDragging: false,
          isPanning: this.touchZoom,
          isZooming: this.touchZoom,
          isRotating: false
        });
        this.blockEvents(inertia);
      } else {
        const newControllerState = this.controllerState.zoomEnd().rotateEnd();
        this.updateViewport(newControllerState, null, {
          isDragging: false,
          isPanning: false,
          isZooming: false,
          isRotating: false
        });
      }
      pinchEventWorkaround._startPinchRotation = null;
      pinchEventWorkaround._lastPinchEvent = null;
      return true;
    }
    _onDoubleTap(event) {
      if (!this.doubleClickZoom) {
        return false;
      }
      const pos = this.getCenter(event);
      if (!this.isPointInBounds(pos, event)) {
        return false;
      }
      const isZoomOut = this.isFunctionKeyPressed(event);
      const newControllerState = this.controllerState.zoom({
        pos,
        scale: isZoomOut ? 0.5 : 2
      });
      this.updateViewport(newControllerState, this._getTransitionProps({
        around: pos
      }), {
        isZooming: true,
        isPanning: true
      });
      this.blockEvents(100);
      return true;
    }
    _onKeyDown(event) {
      if (!this.keyboard) {
        return false;
      }
      const funcKey = this.isFunctionKeyPressed(event);
      const {
        zoomSpeed,
        moveSpeed,
        rotateSpeedX,
        rotateSpeedY
      } = this.keyboard === true ? {} : this.keyboard;
      const {
        controllerState
      } = this;
      let newControllerState;
      const interactionState = {};
      switch (event.srcEvent.code) {
        case "Minus":
          newControllerState = funcKey ? controllerState.zoomOut(zoomSpeed).zoomOut(zoomSpeed) : controllerState.zoomOut(zoomSpeed);
          interactionState.isZooming = true;
          break;
        case "Equal":
          newControllerState = funcKey ? controllerState.zoomIn(zoomSpeed).zoomIn(zoomSpeed) : controllerState.zoomIn(zoomSpeed);
          interactionState.isZooming = true;
          break;
        case "ArrowLeft":
          if (funcKey) {
            newControllerState = controllerState.rotateLeft(rotateSpeedX);
            interactionState.isRotating = true;
          } else {
            newControllerState = controllerState.moveLeft(moveSpeed);
            interactionState.isPanning = true;
          }
          break;
        case "ArrowRight":
          if (funcKey) {
            newControllerState = controllerState.rotateRight(rotateSpeedX);
            interactionState.isRotating = true;
          } else {
            newControllerState = controllerState.moveRight(moveSpeed);
            interactionState.isPanning = true;
          }
          break;
        case "ArrowUp":
          if (funcKey) {
            newControllerState = controllerState.rotateUp(rotateSpeedY);
            interactionState.isRotating = true;
          } else {
            newControllerState = controllerState.moveUp(moveSpeed);
            interactionState.isPanning = true;
          }
          break;
        case "ArrowDown":
          if (funcKey) {
            newControllerState = controllerState.rotateDown(rotateSpeedY);
            interactionState.isRotating = true;
          } else {
            newControllerState = controllerState.moveDown(moveSpeed);
            interactionState.isPanning = true;
          }
          break;
        default:
          return false;
      }
      this.updateViewport(newControllerState, this._getTransitionProps(), interactionState);
      return true;
    }
    _getTransitionProps(opts) {
      const {
        transition
      } = this;
      if (!transition || !transition.transitionInterpolator) {
        return NO_TRANSITION_PROPS;
      }
      return opts ? {
        ...transition,
        transitionInterpolator: new LinearInterpolator({
          ...opts,
          ...transition.transitionInterpolator.opts,
          makeViewport: this.controllerState.makeViewport
        })
      } : transition;
    }
  };

  // node_modules/@deck.gl/core/dist/esm/controllers/view-state.js
  var ViewState = class {
    constructor(props, state3) {
      _defineProperty(this, "_viewportProps", void 0);
      _defineProperty(this, "_state", void 0);
      this._viewportProps = this.applyConstraints(props);
      this._state = state3;
    }
    getViewportProps() {
      return this._viewportProps;
    }
    getState() {
      return this._state;
    }
  };

  // node_modules/@deck.gl/core/dist/esm/controllers/map-controller.js
  var PITCH_MOUSE_THRESHOLD = 5;
  var PITCH_ACCEL = 1.2;
  var MapState = class extends ViewState {
    constructor(options2) {
      const {
        width: width8,
        height: height8,
        latitude,
        longitude,
        zoom,
        bearing = 0,
        pitch = 0,
        altitude = 1.5,
        position: position2 = [0, 0, 0],
        maxZoom = 20,
        minZoom = 0,
        maxPitch = 60,
        minPitch = 0,
        startPanLngLat,
        startZoomLngLat,
        startRotatePos,
        startBearing,
        startPitch,
        startZoom,
        normalize = true
      } = options2;
      assert10(Number.isFinite(longitude));
      assert10(Number.isFinite(latitude));
      assert10(Number.isFinite(zoom));
      super({
        width: width8,
        height: height8,
        latitude,
        longitude,
        zoom,
        bearing,
        pitch,
        altitude,
        maxZoom,
        minZoom,
        maxPitch,
        minPitch,
        normalize,
        position: position2
      }, {
        startPanLngLat,
        startZoomLngLat,
        startRotatePos,
        startBearing,
        startPitch,
        startZoom
      });
      _defineProperty(this, "makeViewport", void 0);
      this.makeViewport = options2.makeViewport;
    }
    panStart({
      pos
    }) {
      return this._getUpdatedState({
        startPanLngLat: this._unproject(pos)
      });
    }
    pan({
      pos,
      startPos
    }) {
      const startPanLngLat = this.getState().startPanLngLat || this._unproject(startPos);
      if (!startPanLngLat) {
        return this;
      }
      const viewport = this.makeViewport(this.getViewportProps());
      const newProps = viewport.panByPosition(startPanLngLat, pos);
      return this._getUpdatedState(newProps);
    }
    panEnd() {
      return this._getUpdatedState({
        startPanLngLat: null
      });
    }
    rotateStart({
      pos
    }) {
      return this._getUpdatedState({
        startRotatePos: pos,
        startBearing: this.getViewportProps().bearing,
        startPitch: this.getViewportProps().pitch
      });
    }
    rotate({
      pos,
      deltaAngleX = 0,
      deltaAngleY = 0
    }) {
      const {
        startRotatePos,
        startBearing,
        startPitch
      } = this.getState();
      if (!startRotatePos || startBearing === void 0 || startPitch === void 0) {
        return this;
      }
      let newRotation;
      if (pos) {
        newRotation = this._getNewRotation(pos, startRotatePos, startPitch, startBearing);
      } else {
        newRotation = {
          bearing: startBearing + deltaAngleX,
          pitch: startPitch + deltaAngleY
        };
      }
      return this._getUpdatedState(newRotation);
    }
    rotateEnd() {
      return this._getUpdatedState({
        startBearing: null,
        startPitch: null
      });
    }
    zoomStart({
      pos
    }) {
      return this._getUpdatedState({
        startZoomLngLat: this._unproject(pos),
        startZoom: this.getViewportProps().zoom
      });
    }
    zoom({
      pos,
      startPos,
      scale: scale4
    }) {
      let {
        startZoom,
        startZoomLngLat
      } = this.getState();
      if (!startZoomLngLat) {
        startZoom = this.getViewportProps().zoom;
        startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
      }
      if (!startZoomLngLat) {
        return this;
      }
      const {
        maxZoom,
        minZoom
      } = this.getViewportProps();
      let zoom = startZoom + Math.log2(scale4);
      zoom = clamp(zoom, minZoom, maxZoom);
      const zoomedViewport = this.makeViewport({
        ...this.getViewportProps(),
        zoom
      });
      return this._getUpdatedState({
        zoom,
        ...zoomedViewport.panByPosition(startZoomLngLat, pos)
      });
    }
    zoomEnd() {
      return this._getUpdatedState({
        startZoomLngLat: null,
        startZoom: null
      });
    }
    zoomIn(speed = 2) {
      return this._zoomFromCenter(speed);
    }
    zoomOut(speed = 2) {
      return this._zoomFromCenter(1 / speed);
    }
    moveLeft(speed = 100) {
      return this._panFromCenter([speed, 0]);
    }
    moveRight(speed = 100) {
      return this._panFromCenter([-speed, 0]);
    }
    moveUp(speed = 100) {
      return this._panFromCenter([0, speed]);
    }
    moveDown(speed = 100) {
      return this._panFromCenter([0, -speed]);
    }
    rotateLeft(speed = 15) {
      return this._getUpdatedState({
        bearing: this.getViewportProps().bearing - speed
      });
    }
    rotateRight(speed = 15) {
      return this._getUpdatedState({
        bearing: this.getViewportProps().bearing + speed
      });
    }
    rotateUp(speed = 10) {
      return this._getUpdatedState({
        pitch: this.getViewportProps().pitch + speed
      });
    }
    rotateDown(speed = 10) {
      return this._getUpdatedState({
        pitch: this.getViewportProps().pitch - speed
      });
    }
    shortestPathFrom(viewState) {
      const fromProps = viewState.getViewportProps();
      const props = {
        ...this.getViewportProps()
      };
      const {
        bearing,
        longitude
      } = props;
      if (Math.abs(bearing - fromProps.bearing) > 180) {
        props.bearing = bearing < 0 ? bearing + 360 : bearing - 360;
      }
      if (Math.abs(longitude - fromProps.longitude) > 180) {
        props.longitude = longitude < 0 ? longitude + 360 : longitude - 360;
      }
      return props;
    }
    applyConstraints(props) {
      const {
        maxZoom,
        minZoom,
        zoom
      } = props;
      props.zoom = clamp(zoom, minZoom, maxZoom);
      const {
        maxPitch,
        minPitch,
        pitch
      } = props;
      props.pitch = clamp(pitch, minPitch, maxPitch);
      const {
        normalize = true
      } = props;
      if (normalize) {
        Object.assign(props, normalizeViewportProps(props));
      }
      return props;
    }
    _zoomFromCenter(scale4) {
      const {
        width: width8,
        height: height8
      } = this.getViewportProps();
      return this.zoom({
        pos: [width8 / 2, height8 / 2],
        scale: scale4
      });
    }
    _panFromCenter(offset) {
      const {
        width: width8,
        height: height8
      } = this.getViewportProps();
      return this.pan({
        startPos: [width8 / 2, height8 / 2],
        pos: [width8 / 2 + offset[0], height8 / 2 + offset[1]]
      });
    }
    _getUpdatedState(newProps) {
      return new this.constructor({
        makeViewport: this.makeViewport,
        ...this.getViewportProps(),
        ...this.getState(),
        ...newProps
      });
    }
    _unproject(pos) {
      const viewport = this.makeViewport(this.getViewportProps());
      return pos && viewport.unproject(pos);
    }
    _getNewRotation(pos, startPos, startPitch, startBearing) {
      const deltaX = pos[0] - startPos[0];
      const deltaY = pos[1] - startPos[1];
      const centerY = pos[1];
      const startY = startPos[1];
      const {
        width: width8,
        height: height8
      } = this.getViewportProps();
      const deltaScaleX = deltaX / width8;
      let deltaScaleY = 0;
      if (deltaY > 0) {
        if (Math.abs(height8 - startY) > PITCH_MOUSE_THRESHOLD) {
          deltaScaleY = deltaY / (startY - height8) * PITCH_ACCEL;
        }
      } else if (deltaY < 0) {
        if (startY > PITCH_MOUSE_THRESHOLD) {
          deltaScaleY = 1 - centerY / startY;
        }
      }
      deltaScaleY = clamp(deltaScaleY, -1, 1);
      const {
        minPitch,
        maxPitch
      } = this.getViewportProps();
      const bearing = startBearing + 180 * deltaScaleX;
      let pitch = startPitch;
      if (deltaScaleY > 0) {
        pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
      } else if (deltaScaleY < 0) {
        pitch = startPitch - deltaScaleY * (minPitch - startPitch);
      }
      return {
        pitch,
        bearing
      };
    }
  };
  var MapController = class extends Controller {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "ControllerState", MapState);
      _defineProperty(this, "transition", {
        transitionDuration: 300,
        transitionInterpolator: new LinearInterpolator({
          transitionProps: {
            compare: ["longitude", "latitude", "zoom", "bearing", "pitch", "position"],
            required: ["longitude", "latitude", "zoom"]
          }
        })
      });
      _defineProperty(this, "dragMode", "pan");
    }
    setProps(props) {
      props.position = props.position || [0, 0, 0];
      const oldProps = this.props;
      super.setProps(props);
      const dimensionChanged = !oldProps || oldProps.height !== props.height;
      if (dimensionChanged) {
        this.updateViewport(new this.ControllerState({
          makeViewport: this.makeViewport,
          ...props,
          ...this.state
        }));
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/views/map-view.js
  var MapView = class extends View {
    get ViewportType() {
      return WebMercatorViewport2;
    }
    get ControllerType() {
      return MapController;
    }
  };
  _defineProperty(MapView, "displayName", "MapView");

  // node_modules/@deck.gl/core/dist/esm/lib/effect-manager.js
  var DEFAULT_LIGHTING_EFFECT = new LightingEffect();
  function compareEffects(e1, e2) {
    var _e1$order, _e2$order;
    const o1 = (_e1$order = e1.order) !== null && _e1$order !== void 0 ? _e1$order : Infinity;
    const o2 = (_e2$order = e2.order) !== null && _e2$order !== void 0 ? _e2$order : Infinity;
    return o1 - o2;
  }
  var EffectManager = class {
    constructor() {
      _defineProperty(this, "effects", void 0);
      _defineProperty(this, "_resolvedEffects", []);
      _defineProperty(this, "_defaultEffects", []);
      _defineProperty(this, "_needsRedraw", void 0);
      this.effects = [];
      this._needsRedraw = "Initial render";
      this._setEffects([]);
    }
    addDefaultEffect(effect) {
      const defaultEffects = this._defaultEffects;
      if (!defaultEffects.find((e) => e.id === effect.id)) {
        const index5 = defaultEffects.findIndex((e) => compareEffects(e, effect) > 0);
        if (index5 < 0) {
          defaultEffects.push(effect);
        } else {
          defaultEffects.splice(index5, 0, effect);
        }
        this._setEffects(this.effects);
      }
    }
    setProps(props) {
      if ("effects" in props) {
        if (!deepEqual(props.effects, this.effects, 1)) {
          this._setEffects(props.effects);
        }
      }
    }
    needsRedraw(opts = {
      clearRedrawFlags: false
    }) {
      const redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      return redraw;
    }
    getEffects() {
      return this._resolvedEffects;
    }
    _setEffects(effects) {
      const oldEffectsMap = {};
      for (const effect of this.effects) {
        oldEffectsMap[effect.id] = effect;
      }
      const nextEffects = [];
      for (const effect of effects) {
        const oldEffect = oldEffectsMap[effect.id];
        if (oldEffect && oldEffect !== effect) {
          if (oldEffect.setProps) {
            oldEffect.setProps(effect.props);
            nextEffects.push(oldEffect);
          } else {
            oldEffect.cleanup();
            nextEffects.push(effect);
          }
        } else {
          nextEffects.push(effect);
        }
        delete oldEffectsMap[effect.id];
      }
      for (const removedEffectId in oldEffectsMap) {
        oldEffectsMap[removedEffectId].cleanup();
      }
      this.effects = nextEffects;
      this._resolvedEffects = nextEffects.concat(this._defaultEffects);
      if (!effects.some((effect) => effect instanceof LightingEffect)) {
        this._resolvedEffects.push(DEFAULT_LIGHTING_EFFECT);
      }
      this._needsRedraw = "effects changed";
    }
    finalize() {
      for (const effect of this._resolvedEffects) {
        effect.cleanup();
      }
      this.effects.length = 0;
      this._resolvedEffects.length = 0;
      this._defaultEffects.length = 0;
    }
  };

  // node_modules/@deck.gl/core/dist/esm/passes/draw-layers-pass.js
  var DrawLayersPass = class extends LayersPass {
    shouldDrawLayer(layer) {
      const {
        operation
      } = layer.props;
      return operation.includes("draw") || operation.includes("terrain");
    }
  };

  // node_modules/@deck.gl/core/dist/esm/lib/deck-renderer.js
  var TRACE_RENDER_LAYERS = "deckRenderer.renderLayers";
  var DeckRenderer = class {
    constructor(gl) {
      _defineProperty(this, "gl", void 0);
      _defineProperty(this, "layerFilter", void 0);
      _defineProperty(this, "drawPickingColors", void 0);
      _defineProperty(this, "drawLayersPass", void 0);
      _defineProperty(this, "pickLayersPass", void 0);
      _defineProperty(this, "renderCount", void 0);
      _defineProperty(this, "_needsRedraw", void 0);
      _defineProperty(this, "renderBuffers", void 0);
      _defineProperty(this, "lastPostProcessEffect", void 0);
      this.gl = gl;
      this.layerFilter = null;
      this.drawPickingColors = false;
      this.drawLayersPass = new DrawLayersPass(gl);
      this.pickLayersPass = new PickLayersPass(gl);
      this.renderCount = 0;
      this._needsRedraw = "Initial render";
      this.renderBuffers = [];
      this.lastPostProcessEffect = null;
    }
    setProps(props) {
      if (this.layerFilter !== props.layerFilter) {
        this.layerFilter = props.layerFilter;
        this._needsRedraw = "layerFilter changed";
      }
      if (this.drawPickingColors !== props.drawPickingColors) {
        this.drawPickingColors = props.drawPickingColors;
        this._needsRedraw = "drawPickingColors changed";
      }
    }
    renderLayers(opts) {
      if (!opts.viewports.length) {
        return;
      }
      const layerPass = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass;
      const renderOpts = {
        layerFilter: this.layerFilter,
        isPicking: this.drawPickingColors,
        ...opts,
        target: opts.target || Framebuffer.getDefaultFramebuffer(this.gl)
      };
      if (renderOpts.effects) {
        this._preRender(renderOpts.effects, renderOpts);
      }
      const outputBuffer = this.lastPostProcessEffect ? this.renderBuffers[0] : renderOpts.target;
      const renderStats = layerPass.render({
        ...renderOpts,
        target: outputBuffer
      });
      if (renderOpts.effects) {
        this._postRender(renderOpts.effects, renderOpts);
      }
      this.renderCount++;
      debug(TRACE_RENDER_LAYERS, this, renderStats, opts);
    }
    needsRedraw(opts = {
      clearRedrawFlags: false
    }) {
      const redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      return redraw;
    }
    finalize() {
      const {
        renderBuffers
      } = this;
      for (const buffer of renderBuffers) {
        buffer.delete();
      }
      renderBuffers.length = 0;
    }
    _preRender(effects, opts) {
      this.lastPostProcessEffect = null;
      opts.preRenderStats = opts.preRenderStats || {};
      for (const effect of effects) {
        opts.preRenderStats[effect.id] = effect.preRender(this.gl, opts);
        if (effect.postRender) {
          this.lastPostProcessEffect = effect.id;
        }
      }
      if (this.lastPostProcessEffect) {
        this._resizeRenderBuffers();
      }
    }
    _resizeRenderBuffers() {
      const {
        renderBuffers
      } = this;
      if (renderBuffers.length === 0) {
        renderBuffers.push(new Framebuffer(this.gl), new Framebuffer(this.gl));
      }
      for (const buffer of renderBuffers) {
        buffer.resize();
      }
    }
    _postRender(effects, opts) {
      const {
        renderBuffers
      } = this;
      const params = {
        ...opts,
        inputBuffer: renderBuffers[0],
        swapBuffer: renderBuffers[1],
        target: null
      };
      for (const effect of effects) {
        if (effect.postRender) {
          if (effect.id === this.lastPostProcessEffect) {
            params.target = opts.target;
            effect.postRender(this.gl, params);
            break;
          }
          const buffer = effect.postRender(this.gl, params);
          params.inputBuffer = buffer;
          params.swapBuffer = buffer === renderBuffers[0] ? renderBuffers[1] : renderBuffers[0];
        }
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/lib/picking/query-object.js
  var NO_PICKED_OBJECT = {
    pickedColor: null,
    pickedObjectIndex: -1
  };
  function getClosestObject({
    pickedColors,
    decodePickingColor,
    deviceX,
    deviceY,
    deviceRadius,
    deviceRect
  }) {
    const {
      x,
      y,
      width: width8,
      height: height8
    } = deviceRect;
    let minSquareDistanceToCenter = deviceRadius * deviceRadius;
    let closestPixelIndex = -1;
    let i = 0;
    for (let row = 0; row < height8; row++) {
      const dy = row + y - deviceY;
      const dy2 = dy * dy;
      if (dy2 > minSquareDistanceToCenter) {
        i += 4 * width8;
      } else {
        for (let col = 0; col < width8; col++) {
          const pickedLayerIndex = pickedColors[i + 3] - 1;
          if (pickedLayerIndex >= 0) {
            const dx = col + x - deviceX;
            const d2 = dx * dx + dy2;
            if (d2 <= minSquareDistanceToCenter) {
              minSquareDistanceToCenter = d2;
              closestPixelIndex = i;
            }
          }
          i += 4;
        }
      }
    }
    if (closestPixelIndex >= 0) {
      const pickedColor = pickedColors.slice(closestPixelIndex, closestPixelIndex + 4);
      const pickedObject = decodePickingColor(pickedColor);
      if (pickedObject) {
        const dy = Math.floor(closestPixelIndex / 4 / width8);
        const dx = closestPixelIndex / 4 - dy * width8;
        return {
          ...pickedObject,
          pickedColor,
          pickedX: x + dx,
          pickedY: y + dy
        };
      }
      log_default.error("Picked non-existent layer. Is picking buffer corrupt?")();
    }
    return NO_PICKED_OBJECT;
  }
  function getUniqueObjects({
    pickedColors,
    decodePickingColor
  }) {
    const uniqueColors = /* @__PURE__ */ new Map();
    if (pickedColors) {
      for (let i = 0; i < pickedColors.length; i += 4) {
        const pickedLayerIndex = pickedColors[i + 3] - 1;
        if (pickedLayerIndex >= 0) {
          const pickedColor = pickedColors.slice(i, i + 4);
          const colorKey = pickedColor.join(",");
          if (!uniqueColors.has(colorKey)) {
            const pickedObject = decodePickingColor(pickedColor);
            if (pickedObject) {
              uniqueColors.set(colorKey, {
                ...pickedObject,
                color: pickedColor
              });
            } else {
              log_default.error("Picked non-existent layer. Is picking buffer corrupt?")();
            }
          }
        }
      }
    }
    return Array.from(uniqueColors.values());
  }

  // node_modules/@deck.gl/core/dist/esm/lib/picking/pick-info.js
  function getEmptyPickingInfo({
    pickInfo,
    viewports,
    pixelRatio: pixelRatio3,
    x,
    y,
    z
  }) {
    let pickedViewport = viewports[0];
    if (viewports.length > 1) {
      pickedViewport = getViewportFromCoordinates((pickInfo === null || pickInfo === void 0 ? void 0 : pickInfo.pickedViewports) || viewports, {
        x,
        y
      });
    }
    let coordinate;
    if (pickedViewport) {
      const point = [x - pickedViewport.x, y - pickedViewport.y];
      if (z !== void 0) {
        point[2] = z;
      }
      coordinate = pickedViewport.unproject(point);
    }
    return {
      color: null,
      layer: null,
      viewport: pickedViewport,
      index: -1,
      picked: false,
      x,
      y,
      pixel: [x, y],
      coordinate,
      devicePixel: pickInfo && "pickedX" in pickInfo ? [pickInfo.pickedX, pickInfo.pickedY] : void 0,
      pixelRatio: pixelRatio3
    };
  }
  function processPickInfo(opts) {
    const {
      pickInfo,
      lastPickedInfo,
      mode,
      layers
    } = opts;
    const {
      pickedColor,
      pickedLayer,
      pickedObjectIndex
    } = pickInfo;
    const affectedLayers = pickedLayer ? [pickedLayer] : [];
    if (mode === "hover") {
      const lastPickedPixelIndex = lastPickedInfo.index;
      const lastPickedLayerId = lastPickedInfo.layerId;
      const pickedLayerId = pickedLayer ? pickedLayer.props.id : null;
      if (pickedLayerId !== lastPickedLayerId || pickedObjectIndex !== lastPickedPixelIndex) {
        if (pickedLayerId !== lastPickedLayerId) {
          const lastPickedLayer = layers.find((layer) => layer.props.id === lastPickedLayerId);
          if (lastPickedLayer) {
            affectedLayers.unshift(lastPickedLayer);
          }
        }
        lastPickedInfo.layerId = pickedLayerId;
        lastPickedInfo.index = pickedObjectIndex;
        lastPickedInfo.info = null;
      }
    }
    const baseInfo = getEmptyPickingInfo(opts);
    const infos = /* @__PURE__ */ new Map();
    infos.set(null, baseInfo);
    affectedLayers.forEach((layer) => {
      let info = {
        ...baseInfo
      };
      if (layer === pickedLayer) {
        info.color = pickedColor;
        info.index = pickedObjectIndex;
        info.picked = true;
      }
      info = getLayerPickingInfo({
        layer,
        info,
        mode
      });
      const rootLayer = info.layer;
      if (layer === pickedLayer && mode === "hover") {
        lastPickedInfo.info = info;
      }
      infos.set(rootLayer.id, info);
      if (mode === "hover") {
        rootLayer.updateAutoHighlight(info);
      }
    });
    return infos;
  }
  function getLayerPickingInfo({
    layer,
    info,
    mode
  }) {
    while (layer && info) {
      const sourceLayer = info.layer || null;
      info.sourceLayer = sourceLayer;
      info.layer = layer;
      info = layer.getPickingInfo({
        info,
        mode,
        sourceLayer
      });
      layer = layer.parent;
    }
    return info;
  }
  function getViewportFromCoordinates(viewports, pixel) {
    for (let i = viewports.length - 1; i >= 0; i--) {
      const viewport = viewports[i];
      if (viewport.containsPixel(pixel)) {
        return viewport;
      }
    }
    return viewports[0];
  }

  // node_modules/@deck.gl/core/dist/esm/lib/deck-picker.js
  var DeckPicker = class {
    constructor(gl) {
      _defineProperty(this, "gl", void 0);
      _defineProperty(this, "pickingFBO", void 0);
      _defineProperty(this, "depthFBO", void 0);
      _defineProperty(this, "pickLayersPass", void 0);
      _defineProperty(this, "layerFilter", void 0);
      _defineProperty(this, "lastPickedInfo", void 0);
      _defineProperty(this, "_pickable", true);
      this.gl = gl;
      this.pickLayersPass = new PickLayersPass(gl);
      this.lastPickedInfo = {
        index: -1,
        layerId: null,
        info: null
      };
    }
    setProps(props) {
      if ("layerFilter" in props) {
        this.layerFilter = props.layerFilter;
      }
      if ("_pickable" in props) {
        this._pickable = props._pickable;
      }
    }
    finalize() {
      if (this.pickingFBO) {
        this.pickingFBO.delete();
      }
      if (this.depthFBO) {
        this.depthFBO.color.delete();
        this.depthFBO.delete();
      }
    }
    pickObject(opts) {
      return this._pickClosestObject(opts);
    }
    pickObjects(opts) {
      return this._pickVisibleObjects(opts);
    }
    getLastPickedObject({
      x,
      y,
      layers,
      viewports
    }, lastPickedInfo = this.lastPickedInfo.info) {
      const lastPickedLayerId = lastPickedInfo && lastPickedInfo.layer && lastPickedInfo.layer.id;
      const lastPickedViewportId = lastPickedInfo && lastPickedInfo.viewport && lastPickedInfo.viewport.id;
      const layer = lastPickedLayerId ? layers.find((l) => l.id === lastPickedLayerId) : null;
      const viewport = lastPickedViewportId && viewports.find((v) => v.id === lastPickedViewportId) || viewports[0];
      const coordinate = viewport && viewport.unproject([x - viewport.x, y - viewport.y]);
      const info = {
        x,
        y,
        viewport,
        coordinate,
        layer
      };
      return {
        ...lastPickedInfo,
        ...info
      };
    }
    _resizeBuffer() {
      var _this$pickingFBO, _this$depthFBO;
      const {
        gl
      } = this;
      if (!this.pickingFBO) {
        this.pickingFBO = new Framebuffer(gl);
        if (Framebuffer.isSupported(gl, {
          colorBufferFloat: true
        })) {
          const depthFBO = new Framebuffer(gl);
          depthFBO.attach({
            [36064]: new Texture2D(gl, {
              format: isWebGL2(gl) ? 34836 : 6408,
              type: 5126
            })
          });
          this.depthFBO = depthFBO;
        }
      }
      (_this$pickingFBO = this.pickingFBO) === null || _this$pickingFBO === void 0 ? void 0 : _this$pickingFBO.resize({
        width: gl.canvas.width,
        height: gl.canvas.height
      });
      (_this$depthFBO = this.depthFBO) === null || _this$depthFBO === void 0 ? void 0 : _this$depthFBO.resize({
        width: gl.canvas.width,
        height: gl.canvas.height
      });
    }
    _getPickable(layers) {
      if (this._pickable === false) {
        return null;
      }
      const pickableLayers = layers.filter((layer) => this.pickLayersPass.shouldDrawLayer(layer) && !layer.isComposite);
      return pickableLayers.length ? pickableLayers : null;
    }
    _pickClosestObject({
      layers,
      views,
      viewports,
      x,
      y,
      radius = 0,
      depth = 1,
      mode = "query",
      unproject3D,
      onViewportActive,
      effects
    }) {
      const pickableLayers = this._getPickable(layers);
      const pixelRatio3 = cssToDeviceRatio(this.gl);
      if (!pickableLayers) {
        return {
          result: [],
          emptyInfo: getEmptyPickingInfo({
            viewports,
            x,
            y,
            pixelRatio: pixelRatio3
          })
        };
      }
      this._resizeBuffer();
      const devicePixelRange = cssToDevicePixels(this.gl, [x, y], true);
      const devicePixel = [devicePixelRange.x + Math.floor(devicePixelRange.width / 2), devicePixelRange.y + Math.floor(devicePixelRange.height / 2)];
      const deviceRadius = Math.round(radius * pixelRatio3);
      const {
        width: width8,
        height: height8
      } = this.pickingFBO;
      const deviceRect = this._getPickingRect({
        deviceX: devicePixel[0],
        deviceY: devicePixel[1],
        deviceRadius,
        deviceWidth: width8,
        deviceHeight: height8
      });
      const cullRect = {
        x: x - radius,
        y: y - radius,
        width: radius * 2 + 1,
        height: radius * 2 + 1
      };
      let infos;
      const result = [];
      const affectedLayers = /* @__PURE__ */ new Set();
      for (let i = 0; i < depth; i++) {
        let pickInfo;
        if (deviceRect) {
          const pickedResult = this._drawAndSample({
            layers: pickableLayers,
            views,
            viewports,
            onViewportActive,
            deviceRect,
            cullRect,
            effects,
            pass: "picking:".concat(mode)
          });
          pickInfo = getClosestObject({
            ...pickedResult,
            deviceX: devicePixel[0],
            deviceY: devicePixel[1],
            deviceRadius,
            deviceRect
          });
        } else {
          pickInfo = {
            pickedColor: null,
            pickedObjectIndex: -1
          };
        }
        let z;
        if (pickInfo.pickedLayer && unproject3D && this.depthFBO) {
          const {
            pickedColors: pickedColors2
          } = this._drawAndSample({
            layers: [pickInfo.pickedLayer],
            views,
            viewports,
            onViewportActive,
            deviceRect: {
              x: pickInfo.pickedX,
              y: pickInfo.pickedY,
              width: 1,
              height: 1
            },
            cullRect,
            effects,
            pass: "picking:".concat(mode, ":z")
          }, true);
          if (pickedColors2[3]) {
            z = pickedColors2[0];
          }
        }
        if (pickInfo.pickedLayer && i + 1 < depth) {
          affectedLayers.add(pickInfo.pickedLayer);
          pickInfo.pickedLayer.disablePickingIndex(pickInfo.pickedObjectIndex);
        }
        infos = processPickInfo({
          pickInfo,
          lastPickedInfo: this.lastPickedInfo,
          mode,
          layers: pickableLayers,
          viewports,
          x,
          y,
          z,
          pixelRatio: pixelRatio3
        });
        for (const info of infos.values()) {
          if (info.layer) {
            result.push(info);
          }
        }
        if (!pickInfo.pickedColor) {
          break;
        }
      }
      for (const layer of affectedLayers) {
        layer.restorePickingColors();
      }
      return {
        result,
        emptyInfo: infos.get(null)
      };
    }
    _pickVisibleObjects({
      layers,
      views,
      viewports,
      x,
      y,
      width: width8 = 1,
      height: height8 = 1,
      mode = "query",
      maxObjects = null,
      onViewportActive,
      effects
    }) {
      const pickableLayers = this._getPickable(layers);
      if (!pickableLayers) {
        return [];
      }
      this._resizeBuffer();
      const pixelRatio3 = cssToDeviceRatio(this.gl);
      const leftTop = cssToDevicePixels(this.gl, [x, y], true);
      const deviceLeft = leftTop.x;
      const deviceTop = leftTop.y + leftTop.height;
      const rightBottom = cssToDevicePixels(this.gl, [x + width8, y + height8], true);
      const deviceRight = rightBottom.x + rightBottom.width;
      const deviceBottom = rightBottom.y;
      const deviceRect = {
        x: deviceLeft,
        y: deviceBottom,
        width: deviceRight - deviceLeft,
        height: deviceTop - deviceBottom
      };
      const pickedResult = this._drawAndSample({
        layers: pickableLayers,
        views,
        viewports,
        onViewportActive,
        deviceRect,
        cullRect: {
          x,
          y,
          width: width8,
          height: height8
        },
        effects,
        pass: "picking:".concat(mode)
      });
      const pickInfos = getUniqueObjects(pickedResult);
      const uniqueInfos = /* @__PURE__ */ new Map();
      const isMaxObjects = Number.isFinite(maxObjects);
      for (let i = 0; i < pickInfos.length; i++) {
        var _info$object;
        if (isMaxObjects && maxObjects && uniqueInfos.size >= maxObjects) {
          break;
        }
        const pickInfo = pickInfos[i];
        let info = {
          color: pickInfo.pickedColor,
          layer: null,
          index: pickInfo.pickedObjectIndex,
          picked: true,
          x,
          y,
          pixelRatio: pixelRatio3
        };
        info = getLayerPickingInfo({
          layer: pickInfo.pickedLayer,
          info,
          mode
        });
        const pickedObjectKey = (_info$object = info.object) !== null && _info$object !== void 0 ? _info$object : "".concat(info.layer.id, "[").concat(info.index, "]");
        if (!uniqueInfos.has(pickedObjectKey)) {
          uniqueInfos.set(pickedObjectKey, info);
        }
      }
      return Array.from(uniqueInfos.values());
    }
    _drawAndSample({
      layers,
      views,
      viewports,
      onViewportActive,
      deviceRect,
      cullRect,
      effects,
      pass: pass2
    }, pickZ = false) {
      const pickingFBO = pickZ ? this.depthFBO : this.pickingFBO;
      const opts = {
        layers,
        layerFilter: this.layerFilter,
        views,
        viewports,
        onViewportActive,
        pickingFBO,
        deviceRect,
        cullRect,
        effects,
        pass: pass2,
        pickZ,
        preRenderStats: {}
      };
      for (const effect of effects) {
        if (effect.useInPicking) {
          opts.preRenderStats[effect.id] = effect.preRender(this.gl, opts);
        }
      }
      const {
        decodePickingColor
      } = this.pickLayersPass.render(opts);
      const {
        x,
        y,
        width: width8,
        height: height8
      } = deviceRect;
      const pickedColors = new (pickZ ? Float32Array : Uint8Array)(width8 * height8 * 4);
      readPixelsToArray(pickingFBO, {
        sourceX: x,
        sourceY: y,
        sourceWidth: width8,
        sourceHeight: height8,
        target: pickedColors
      });
      return {
        pickedColors,
        decodePickingColor
      };
    }
    _getPickingRect({
      deviceX,
      deviceY,
      deviceRadius,
      deviceWidth,
      deviceHeight
    }) {
      const x = Math.max(0, deviceX - deviceRadius);
      const y = Math.max(0, deviceY - deviceRadius);
      const width8 = Math.min(deviceWidth, deviceX + deviceRadius + 1) - x;
      const height8 = Math.min(deviceHeight, deviceY + deviceRadius + 1) - y;
      if (width8 <= 0 || height8 <= 0) {
        return null;
      }
      return {
        x,
        y,
        width: width8,
        height: height8
      };
    }
  };

  // node_modules/@deck.gl/core/dist/esm/lib/tooltip.js
  var defaultStyle = {
    zIndex: "1",
    position: "absolute",
    pointerEvents: "none",
    color: "#a0a7b4",
    backgroundColor: "#29323c",
    padding: "10px",
    top: "0",
    left: "0",
    display: "none"
  };
  var Tooltip = class {
    constructor(canvas) {
      _defineProperty(this, "el", null);
      _defineProperty(this, "isVisible", false);
      const canvasParent = canvas.parentElement;
      if (canvasParent) {
        this.el = document.createElement("div");
        this.el.className = "deck-tooltip";
        Object.assign(this.el.style, defaultStyle);
        canvasParent.appendChild(this.el);
      }
    }
    setTooltip(displayInfo, x, y) {
      const el = this.el;
      if (!el) {
        return;
      }
      if (typeof displayInfo === "string") {
        el.innerText = displayInfo;
      } else if (!displayInfo) {
        this.isVisible = false;
        el.style.display = "none";
        return;
      } else {
        if (displayInfo.text) {
          el.innerText = displayInfo.text;
        }
        if (displayInfo.html) {
          el.innerHTML = displayInfo.html;
        }
        if (displayInfo.className) {
          el.className = displayInfo.className;
        }
      }
      this.isVisible = true;
      el.style.display = "block";
      el.style.transform = "translate(".concat(x, "px, ").concat(y, "px)");
      if (displayInfo && typeof displayInfo === "object" && "style" in displayInfo) {
        Object.assign(el.style, displayInfo.style);
      }
    }
    remove() {
      if (this.el) {
        this.el.remove();
        this.el = null;
      }
    }
  };

  // node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js
  var hammerjs = __toESM(require_hammer());

  // node_modules/mjolnir.js/dist/esm/utils/hammer-overrides.js
  var INPUT_START = 1;
  var INPUT_MOVE = 2;
  var INPUT_END = 4;
  var MOUSE_INPUT_MAP = {
    mousedown: INPUT_START,
    mousemove: INPUT_MOVE,
    mouseup: INPUT_END
  };
  function some(array2, predict) {
    for (let i = 0; i < array2.length; i++) {
      if (predict(array2[i])) {
        return true;
      }
    }
    return false;
  }
  function enhancePointerEventInput(PointerEventInput2) {
    const oldHandler = PointerEventInput2.prototype.handler;
    PointerEventInput2.prototype.handler = function handler(ev) {
      const store = this.store;
      if (ev.button > 0 && ev.type === "pointerdown") {
        if (!some(store, (e) => e.pointerId === ev.pointerId)) {
          store.push(ev);
        }
      }
      oldHandler.call(this, ev);
    };
  }
  function enhanceMouseInput(MouseInput2) {
    MouseInput2.prototype.handler = function handler(ev) {
      let eventType = MOUSE_INPUT_MAP[ev.type];
      if (eventType & INPUT_START && ev.button >= 0) {
        this.pressed = true;
      }
      if (eventType & INPUT_MOVE && ev.which === 0) {
        eventType = INPUT_END;
      }
      if (!this.pressed) {
        return;
      }
      if (eventType & INPUT_END) {
        this.pressed = false;
      }
      this.callback(this.manager, eventType, {
        pointers: [ev],
        changedPointers: [ev],
        pointerType: "mouse",
        srcEvent: ev
      });
    };
  }

  // node_modules/mjolnir.js/dist/esm/utils/hammer.browser.js
  enhancePointerEventInput(hammerjs.PointerEventInput);
  enhanceMouseInput(hammerjs.MouseInput);
  var Manager2 = hammerjs.Manager;
  var hammer_browser_default = hammerjs;

  // node_modules/mjolnir.js/dist/esm/inputs/input.js
  var Input = class {
    constructor(element, callback, options2) {
      this.element = element;
      this.callback = callback;
      this.options = { enable: true, ...options2 };
    }
  };

  // node_modules/mjolnir.js/dist/esm/constants.js
  var RECOGNIZERS = hammer_browser_default ? [
    [hammer_browser_default.Pan, { event: "tripan", pointers: 3, threshold: 0, enable: false }],
    [hammer_browser_default.Rotate, { enable: false }],
    [hammer_browser_default.Pinch, { enable: false }],
    [hammer_browser_default.Swipe, { enable: false }],
    [hammer_browser_default.Pan, { threshold: 0, enable: false }],
    [hammer_browser_default.Press, { enable: false }],
    [hammer_browser_default.Tap, { event: "doubletap", taps: 2, enable: false }],
    [hammer_browser_default.Tap, { event: "anytap", enable: false }],
    [hammer_browser_default.Tap, { enable: false }]
  ] : null;
  var RECOGNIZER_COMPATIBLE_MAP = {
    tripan: ["rotate", "pinch", "pan"],
    rotate: ["pinch"],
    pinch: ["pan"],
    pan: ["press", "doubletap", "anytap", "tap"],
    doubletap: ["anytap"],
    anytap: ["tap"]
  };
  var RECOGNIZER_FALLBACK_MAP = {
    doubletap: ["tap"]
  };
  var BASIC_EVENT_ALIASES = {
    pointerdown: "pointerdown",
    pointermove: "pointermove",
    pointerup: "pointerup",
    touchstart: "pointerdown",
    touchmove: "pointermove",
    touchend: "pointerup",
    mousedown: "pointerdown",
    mousemove: "pointermove",
    mouseup: "pointerup"
  };
  var INPUT_EVENT_TYPES = {
    KEY_EVENTS: ["keydown", "keyup"],
    MOUSE_EVENTS: ["mousedown", "mousemove", "mouseup", "mouseover", "mouseout", "mouseleave"],
    WHEEL_EVENTS: [
      "wheel",
      "mousewheel"
    ]
  };
  var EVENT_RECOGNIZER_MAP = {
    tap: "tap",
    anytap: "anytap",
    doubletap: "doubletap",
    press: "press",
    pinch: "pinch",
    pinchin: "pinch",
    pinchout: "pinch",
    pinchstart: "pinch",
    pinchmove: "pinch",
    pinchend: "pinch",
    pinchcancel: "pinch",
    rotate: "rotate",
    rotatestart: "rotate",
    rotatemove: "rotate",
    rotateend: "rotate",
    rotatecancel: "rotate",
    tripan: "tripan",
    tripanstart: "tripan",
    tripanmove: "tripan",
    tripanup: "tripan",
    tripandown: "tripan",
    tripanleft: "tripan",
    tripanright: "tripan",
    tripanend: "tripan",
    tripancancel: "tripan",
    pan: "pan",
    panstart: "pan",
    panmove: "pan",
    panup: "pan",
    pandown: "pan",
    panleft: "pan",
    panright: "pan",
    panend: "pan",
    pancancel: "pan",
    swipe: "swipe",
    swipeleft: "swipe",
    swiperight: "swipe",
    swipeup: "swipe",
    swipedown: "swipe"
  };
  var GESTURE_EVENT_ALIASES = {
    click: "tap",
    anyclick: "anytap",
    dblclick: "doubletap",
    mousedown: "pointerdown",
    mousemove: "pointermove",
    mouseup: "pointerup",
    mouseover: "pointerover",
    mouseout: "pointerout",
    mouseleave: "pointerleave"
  };

  // node_modules/mjolnir.js/dist/esm/utils/globals.js
  var userAgent = typeof navigator !== "undefined" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "";
  var window_5 = typeof window !== "undefined" ? window : global;
  var passiveSupported = false;
  try {
    const options2 = {
      get passive() {
        passiveSupported = true;
        return true;
      }
    };
    window_5.addEventListener("test", null, options2);
    window_5.removeEventListener("test", null);
  } catch (err) {
    passiveSupported = false;
  }

  // node_modules/mjolnir.js/dist/esm/inputs/wheel-input.js
  var firefox = userAgent.indexOf("firefox") !== -1;
  var { WHEEL_EVENTS } = INPUT_EVENT_TYPES;
  var EVENT_TYPE = "wheel";
  var WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
  var WHEEL_DELTA_PER_LINE = 40;
  var SHIFT_MULTIPLIER = 0.25;
  var WheelInput = class extends Input {
    constructor(element, callback, options2) {
      super(element, callback, options2);
      this.handleEvent = (event) => {
        if (!this.options.enable) {
          return;
        }
        let value13 = event.deltaY;
        if (window_5.WheelEvent) {
          if (firefox && event.deltaMode === window_5.WheelEvent.DOM_DELTA_PIXEL) {
            value13 /= window_5.devicePixelRatio;
          }
          if (event.deltaMode === window_5.WheelEvent.DOM_DELTA_LINE) {
            value13 *= WHEEL_DELTA_PER_LINE;
          }
        }
        if (value13 !== 0 && value13 % WHEEL_DELTA_MAGIC_SCALER === 0) {
          value13 = Math.floor(value13 / WHEEL_DELTA_MAGIC_SCALER);
        }
        if (event.shiftKey && value13) {
          value13 = value13 * SHIFT_MULTIPLIER;
        }
        this.callback({
          type: EVENT_TYPE,
          center: {
            x: event.clientX,
            y: event.clientY
          },
          delta: -value13,
          srcEvent: event,
          pointerType: "mouse",
          target: event.target
        });
      };
      this.events = (this.options.events || []).concat(WHEEL_EVENTS);
      this.events.forEach((event) => element.addEventListener(event, this.handleEvent, passiveSupported ? { passive: false } : false));
    }
    destroy() {
      this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
    }
    enableEventType(eventType, enabled) {
      if (eventType === EVENT_TYPE) {
        this.options.enable = enabled;
      }
    }
  };

  // node_modules/mjolnir.js/dist/esm/inputs/move-input.js
  var { MOUSE_EVENTS } = INPUT_EVENT_TYPES;
  var MOVE_EVENT_TYPE = "pointermove";
  var OVER_EVENT_TYPE = "pointerover";
  var OUT_EVENT_TYPE = "pointerout";
  var ENTER_EVENT_TYPE = "pointerenter";
  var LEAVE_EVENT_TYPE = "pointerleave";
  var MoveInput = class extends Input {
    constructor(element, callback, options2) {
      super(element, callback, options2);
      this.handleEvent = (event) => {
        this.handleOverEvent(event);
        this.handleOutEvent(event);
        this.handleEnterEvent(event);
        this.handleLeaveEvent(event);
        this.handleMoveEvent(event);
      };
      this.pressed = false;
      const { enable: enable2 } = this.options;
      this.enableMoveEvent = enable2;
      this.enableLeaveEvent = enable2;
      this.enableEnterEvent = enable2;
      this.enableOutEvent = enable2;
      this.enableOverEvent = enable2;
      this.events = (this.options.events || []).concat(MOUSE_EVENTS);
      this.events.forEach((event) => element.addEventListener(event, this.handleEvent));
    }
    destroy() {
      this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
    }
    enableEventType(eventType, enabled) {
      if (eventType === MOVE_EVENT_TYPE) {
        this.enableMoveEvent = enabled;
      }
      if (eventType === OVER_EVENT_TYPE) {
        this.enableOverEvent = enabled;
      }
      if (eventType === OUT_EVENT_TYPE) {
        this.enableOutEvent = enabled;
      }
      if (eventType === ENTER_EVENT_TYPE) {
        this.enableEnterEvent = enabled;
      }
      if (eventType === LEAVE_EVENT_TYPE) {
        this.enableLeaveEvent = enabled;
      }
    }
    handleOverEvent(event) {
      if (this.enableOverEvent) {
        if (event.type === "mouseover") {
          this._emit(OVER_EVENT_TYPE, event);
        }
      }
    }
    handleOutEvent(event) {
      if (this.enableOutEvent) {
        if (event.type === "mouseout") {
          this._emit(OUT_EVENT_TYPE, event);
        }
      }
    }
    handleEnterEvent(event) {
      if (this.enableEnterEvent) {
        if (event.type === "mouseenter") {
          this._emit(ENTER_EVENT_TYPE, event);
        }
      }
    }
    handleLeaveEvent(event) {
      if (this.enableLeaveEvent) {
        if (event.type === "mouseleave") {
          this._emit(LEAVE_EVENT_TYPE, event);
        }
      }
    }
    handleMoveEvent(event) {
      if (this.enableMoveEvent) {
        switch (event.type) {
          case "mousedown":
            if (event.button >= 0) {
              this.pressed = true;
            }
            break;
          case "mousemove":
            if (event.which === 0) {
              this.pressed = false;
            }
            if (!this.pressed) {
              this._emit(MOVE_EVENT_TYPE, event);
            }
            break;
          case "mouseup":
            this.pressed = false;
            break;
          default:
        }
      }
    }
    _emit(type, event) {
      this.callback({
        type,
        center: {
          x: event.clientX,
          y: event.clientY
        },
        srcEvent: event,
        pointerType: "mouse",
        target: event.target
      });
    }
  };

  // node_modules/mjolnir.js/dist/esm/inputs/key-input.js
  var { KEY_EVENTS } = INPUT_EVENT_TYPES;
  var DOWN_EVENT_TYPE = "keydown";
  var UP_EVENT_TYPE = "keyup";
  var KeyInput = class extends Input {
    constructor(element, callback, options2) {
      super(element, callback, options2);
      this.handleEvent = (event) => {
        const targetElement = event.target || event.srcElement;
        if (targetElement.tagName === "INPUT" && targetElement.type === "text" || targetElement.tagName === "TEXTAREA") {
          return;
        }
        if (this.enableDownEvent && event.type === "keydown") {
          this.callback({
            type: DOWN_EVENT_TYPE,
            srcEvent: event,
            key: event.key,
            target: event.target
          });
        }
        if (this.enableUpEvent && event.type === "keyup") {
          this.callback({
            type: UP_EVENT_TYPE,
            srcEvent: event,
            key: event.key,
            target: event.target
          });
        }
      };
      this.enableDownEvent = this.options.enable;
      this.enableUpEvent = this.options.enable;
      this.events = (this.options.events || []).concat(KEY_EVENTS);
      element.tabIndex = this.options.tabIndex || 0;
      element.style.outline = "none";
      this.events.forEach((event) => element.addEventListener(event, this.handleEvent));
    }
    destroy() {
      this.events.forEach((event) => this.element.removeEventListener(event, this.handleEvent));
    }
    enableEventType(eventType, enabled) {
      if (eventType === DOWN_EVENT_TYPE) {
        this.enableDownEvent = enabled;
      }
      if (eventType === UP_EVENT_TYPE) {
        this.enableUpEvent = enabled;
      }
    }
  };

  // node_modules/mjolnir.js/dist/esm/inputs/contextmenu-input.js
  var EVENT_TYPE2 = "contextmenu";
  var ContextmenuInput = class extends Input {
    constructor(element, callback, options2) {
      super(element, callback, options2);
      this.handleEvent = (event) => {
        if (!this.options.enable) {
          return;
        }
        this.callback({
          type: EVENT_TYPE2,
          center: {
            x: event.clientX,
            y: event.clientY
          },
          srcEvent: event,
          pointerType: "mouse",
          target: event.target
        });
      };
      element.addEventListener("contextmenu", this.handleEvent);
    }
    destroy() {
      this.element.removeEventListener("contextmenu", this.handleEvent);
    }
    enableEventType(eventType, enabled) {
      if (eventType === EVENT_TYPE2) {
        this.options.enable = enabled;
      }
    }
  };

  // node_modules/mjolnir.js/dist/esm/utils/event-utils.js
  var DOWN_EVENT = 1;
  var MOVE_EVENT = 2;
  var UP_EVENT = 4;
  var MOUSE_EVENTS2 = {
    pointerdown: DOWN_EVENT,
    pointermove: MOVE_EVENT,
    pointerup: UP_EVENT,
    mousedown: DOWN_EVENT,
    mousemove: MOVE_EVENT,
    mouseup: UP_EVENT
  };
  var MOUSE_EVENT_WHICH_LEFT = 1;
  var MOUSE_EVENT_WHICH_MIDDLE = 2;
  var MOUSE_EVENT_WHICH_RIGHT = 3;
  var MOUSE_EVENT_BUTTON_LEFT = 0;
  var MOUSE_EVENT_BUTTON_MIDDLE = 1;
  var MOUSE_EVENT_BUTTON_RIGHT = 2;
  var MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
  var MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
  var MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;
  function whichButtons(event) {
    const eventType = MOUSE_EVENTS2[event.srcEvent.type];
    if (!eventType) {
      return null;
    }
    const { buttons, button, which } = event.srcEvent;
    let leftButton = false;
    let middleButton = false;
    let rightButton = false;
    if (eventType === UP_EVENT || eventType === MOVE_EVENT && !Number.isFinite(buttons)) {
      leftButton = which === MOUSE_EVENT_WHICH_LEFT;
      middleButton = which === MOUSE_EVENT_WHICH_MIDDLE;
      rightButton = which === MOUSE_EVENT_WHICH_RIGHT;
    } else if (eventType === MOVE_EVENT) {
      leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);
      middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
      rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);
    } else if (eventType === DOWN_EVENT) {
      leftButton = button === MOUSE_EVENT_BUTTON_LEFT;
      middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;
      rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;
    }
    return { leftButton, middleButton, rightButton };
  }
  function getOffsetPosition(event, rootElement) {
    const center = event.center;
    if (!center) {
      return null;
    }
    const rect = rootElement.getBoundingClientRect();
    const scaleX2 = rect.width / rootElement.offsetWidth || 1;
    const scaleY2 = rect.height / rootElement.offsetHeight || 1;
    const offsetCenter = {
      x: (center.x - rect.left - rootElement.clientLeft) / scaleX2,
      y: (center.y - rect.top - rootElement.clientTop) / scaleY2
    };
    return { center, offsetCenter };
  }

  // node_modules/mjolnir.js/dist/esm/utils/event-registrar.js
  var DEFAULT_OPTIONS = {
    srcElement: "root",
    priority: 0
  };
  var EventRegistrar = class {
    constructor(eventManager) {
      this.handleEvent = (event) => {
        if (this.isEmpty()) {
          return;
        }
        const mjolnirEvent = this._normalizeEvent(event);
        let target5 = event.srcEvent.target;
        while (target5 && target5 !== mjolnirEvent.rootElement) {
          this._emit(mjolnirEvent, target5);
          if (mjolnirEvent.handled) {
            return;
          }
          target5 = target5.parentNode;
        }
        this._emit(mjolnirEvent, "root");
      };
      this.eventManager = eventManager;
      this.handlers = [];
      this.handlersByElement = /* @__PURE__ */ new Map();
      this._active = false;
    }
    isEmpty() {
      return !this._active;
    }
    add(type, handler, options2, once = false, passive = false) {
      const { handlers, handlersByElement } = this;
      let opts = DEFAULT_OPTIONS;
      if (typeof options2 === "string" || options2 && options2.addEventListener) {
        opts = { ...DEFAULT_OPTIONS, srcElement: options2 };
      } else if (options2) {
        opts = { ...DEFAULT_OPTIONS, ...options2 };
      }
      let entries = handlersByElement.get(opts.srcElement);
      if (!entries) {
        entries = [];
        handlersByElement.set(opts.srcElement, entries);
      }
      const entry = {
        type,
        handler,
        srcElement: opts.srcElement,
        priority: opts.priority
      };
      if (once) {
        entry.once = true;
      }
      if (passive) {
        entry.passive = true;
      }
      handlers.push(entry);
      this._active = this._active || !entry.passive;
      let insertPosition = entries.length - 1;
      while (insertPosition >= 0) {
        if (entries[insertPosition].priority >= entry.priority) {
          break;
        }
        insertPosition--;
      }
      entries.splice(insertPosition + 1, 0, entry);
    }
    remove(type, handler) {
      const { handlers, handlersByElement } = this;
      for (let i = handlers.length - 1; i >= 0; i--) {
        const entry = handlers[i];
        if (entry.type === type && entry.handler === handler) {
          handlers.splice(i, 1);
          const entries = handlersByElement.get(entry.srcElement);
          entries.splice(entries.indexOf(entry), 1);
          if (entries.length === 0) {
            handlersByElement.delete(entry.srcElement);
          }
        }
      }
      this._active = handlers.some((entry) => !entry.passive);
    }
    _emit(event, srcElement) {
      const entries = this.handlersByElement.get(srcElement);
      if (entries) {
        let immediatePropagationStopped = false;
        const stopPropagation = () => {
          event.handled = true;
        };
        const stopImmediatePropagation = () => {
          event.handled = true;
          immediatePropagationStopped = true;
        };
        const entriesToRemove = [];
        for (let i = 0; i < entries.length; i++) {
          const { type, handler, once } = entries[i];
          handler({
            ...event,
            type,
            stopPropagation,
            stopImmediatePropagation
          });
          if (once) {
            entriesToRemove.push(entries[i]);
          }
          if (immediatePropagationStopped) {
            break;
          }
        }
        for (let i = 0; i < entriesToRemove.length; i++) {
          const { type, handler } = entriesToRemove[i];
          this.remove(type, handler);
        }
      }
    }
    _normalizeEvent(event) {
      const rootElement = this.eventManager.getElement();
      return {
        ...event,
        ...whichButtons(event),
        ...getOffsetPosition(event, rootElement),
        preventDefault: () => {
          event.srcEvent.preventDefault();
        },
        stopImmediatePropagation: null,
        stopPropagation: null,
        handled: false,
        rootElement
      };
    }
  };

  // node_modules/mjolnir.js/dist/esm/event-manager.js
  var DEFAULT_OPTIONS2 = {
    events: null,
    recognizers: null,
    recognizerOptions: {},
    Manager: Manager2,
    touchAction: "none",
    tabIndex: 0
  };
  var EventManager = class {
    constructor(element = null, options2) {
      this._onBasicInput = (event) => {
        const { srcEvent } = event;
        const alias = BASIC_EVENT_ALIASES[srcEvent.type];
        if (alias) {
          this.manager.emit(alias, event);
        }
      };
      this._onOtherEvent = (event) => {
        this.manager.emit(event.type, event);
      };
      this.options = { ...DEFAULT_OPTIONS2, ...options2 };
      this.events = /* @__PURE__ */ new Map();
      this.setElement(element);
      const { events } = this.options;
      if (events) {
        this.on(events);
      }
    }
    getElement() {
      return this.element;
    }
    setElement(element) {
      if (this.element) {
        this.destroy();
      }
      this.element = element;
      if (!element) {
        return;
      }
      const { options: options2 } = this;
      const ManagerClass = options2.Manager;
      this.manager = new ManagerClass(element, {
        touchAction: options2.touchAction,
        recognizers: options2.recognizers || RECOGNIZERS
      }).on("hammer.input", this._onBasicInput);
      if (!options2.recognizers) {
        Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach((name16) => {
          const recognizer = this.manager.get(name16);
          if (recognizer) {
            RECOGNIZER_COMPATIBLE_MAP[name16].forEach((otherName) => {
              recognizer.recognizeWith(otherName);
            });
          }
        });
      }
      for (const recognizerName in options2.recognizerOptions) {
        const recognizer = this.manager.get(recognizerName);
        if (recognizer) {
          const recognizerOption = options2.recognizerOptions[recognizerName];
          delete recognizerOption.enable;
          recognizer.set(recognizerOption);
        }
      }
      this.wheelInput = new WheelInput(element, this._onOtherEvent, {
        enable: false
      });
      this.moveInput = new MoveInput(element, this._onOtherEvent, {
        enable: false
      });
      this.keyInput = new KeyInput(element, this._onOtherEvent, {
        enable: false,
        tabIndex: options2.tabIndex
      });
      this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {
        enable: false
      });
      for (const [eventAlias, eventRegistrar] of this.events) {
        if (!eventRegistrar.isEmpty()) {
          this._toggleRecognizer(eventRegistrar.recognizerName, true);
          this.manager.on(eventAlias, eventRegistrar.handleEvent);
        }
      }
    }
    destroy() {
      if (this.element) {
        this.wheelInput.destroy();
        this.moveInput.destroy();
        this.keyInput.destroy();
        this.contextmenuInput.destroy();
        this.manager.destroy();
        this.wheelInput = null;
        this.moveInput = null;
        this.keyInput = null;
        this.contextmenuInput = null;
        this.manager = null;
        this.element = null;
      }
    }
    on(event, handler, opts) {
      this._addEventHandler(event, handler, opts, false);
    }
    once(event, handler, opts) {
      this._addEventHandler(event, handler, opts, true);
    }
    watch(event, handler, opts) {
      this._addEventHandler(event, handler, opts, false, true);
    }
    off(event, handler) {
      this._removeEventHandler(event, handler);
    }
    _toggleRecognizer(name16, enabled) {
      const { manager } = this;
      if (!manager) {
        return;
      }
      const recognizer = manager.get(name16);
      if (recognizer && recognizer.options.enable !== enabled) {
        recognizer.set({ enable: enabled });
        const fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name16];
        if (fallbackRecognizers && !this.options.recognizers) {
          fallbackRecognizers.forEach((otherName) => {
            const otherRecognizer = manager.get(otherName);
            if (enabled) {
              otherRecognizer.requireFailure(name16);
              recognizer.dropRequireFailure(otherName);
            } else {
              otherRecognizer.dropRequireFailure(name16);
            }
          });
        }
      }
      this.wheelInput.enableEventType(name16, enabled);
      this.moveInput.enableEventType(name16, enabled);
      this.keyInput.enableEventType(name16, enabled);
      this.contextmenuInput.enableEventType(name16, enabled);
    }
    _addEventHandler(event, handler, opts, once, passive) {
      if (typeof event !== "string") {
        opts = handler;
        for (const eventName in event) {
          this._addEventHandler(eventName, event[eventName], opts, once, passive);
        }
        return;
      }
      const { manager, events } = this;
      const eventAlias = GESTURE_EVENT_ALIASES[event] || event;
      let eventRegistrar = events.get(eventAlias);
      if (!eventRegistrar) {
        eventRegistrar = new EventRegistrar(this);
        events.set(eventAlias, eventRegistrar);
        eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
        if (manager) {
          manager.on(eventAlias, eventRegistrar.handleEvent);
        }
      }
      eventRegistrar.add(event, handler, opts, once, passive);
      if (!eventRegistrar.isEmpty()) {
        this._toggleRecognizer(eventRegistrar.recognizerName, true);
      }
    }
    _removeEventHandler(event, handler) {
      if (typeof event !== "string") {
        for (const eventName in event) {
          this._removeEventHandler(eventName, event[eventName]);
        }
        return;
      }
      const { events } = this;
      const eventAlias = GESTURE_EVENT_ALIASES[event] || event;
      const eventRegistrar = events.get(eventAlias);
      if (!eventRegistrar) {
        return;
      }
      eventRegistrar.remove(event, handler);
      if (eventRegistrar.isEmpty()) {
        const { recognizerName } = eventRegistrar;
        let isRecognizerUsed = false;
        for (const eh of events.values()) {
          if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
            isRecognizerUsed = true;
            break;
          }
        }
        if (!isRecognizerUsed) {
          this._toggleRecognizer(recognizerName, false);
        }
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/lib/deck.js
  function noop4() {
  }
  var getCursor = ({
    isDragging
  }) => isDragging ? "grabbing" : "grab";
  var defaultProps = {
    id: "",
    width: "100%",
    height: "100%",
    style: null,
    viewState: null,
    initialViewState: null,
    pickingRadius: 0,
    layerFilter: null,
    glOptions: {},
    parameters: {},
    parent: null,
    gl: null,
    canvas: null,
    layers: [],
    effects: [],
    views: null,
    controller: null,
    useDevicePixels: true,
    touchAction: "none",
    eventRecognizerOptions: {},
    _framebuffer: null,
    _animate: false,
    _pickable: true,
    _typedArrayManagerProps: {},
    _customRender: null,
    onWebGLInitialized: noop4,
    onResize: noop4,
    onViewStateChange: noop4,
    onInteractionStateChange: noop4,
    onBeforeRender: noop4,
    onAfterRender: noop4,
    onLoad: noop4,
    onError: (error3) => log_default.error(error3.message, error3.cause)(),
    onHover: null,
    onClick: null,
    onDragStart: null,
    onDrag: null,
    onDragEnd: null,
    _onMetrics: null,
    getCursor,
    getTooltip: null,
    debug: false,
    drawPickingColors: false
  };
  var Deck = class {
    constructor(props) {
      _defineProperty(this, "props", void 0);
      _defineProperty(this, "width", 0);
      _defineProperty(this, "height", 0);
      _defineProperty(this, "userData", {});
      _defineProperty(this, "canvas", null);
      _defineProperty(this, "viewManager", null);
      _defineProperty(this, "layerManager", null);
      _defineProperty(this, "effectManager", null);
      _defineProperty(this, "deckRenderer", null);
      _defineProperty(this, "deckPicker", null);
      _defineProperty(this, "eventManager", null);
      _defineProperty(this, "tooltip", null);
      _defineProperty(this, "metrics", void 0);
      _defineProperty(this, "animationLoop", void 0);
      _defineProperty(this, "stats", void 0);
      _defineProperty(this, "viewState", void 0);
      _defineProperty(this, "cursorState", void 0);
      _defineProperty(this, "_needsRedraw", void 0);
      _defineProperty(this, "_pickRequest", void 0);
      _defineProperty(this, "_lastPointerDownInfo", null);
      _defineProperty(this, "_metricsCounter", void 0);
      _defineProperty(this, "_onPointerMove", (event) => {
        const {
          _pickRequest
        } = this;
        if (event.type === "pointerleave") {
          _pickRequest.x = -1;
          _pickRequest.y = -1;
          _pickRequest.radius = 0;
        } else if (event.leftButton || event.rightButton) {
          return;
        } else {
          const pos = event.offsetCenter;
          if (!pos) {
            return;
          }
          _pickRequest.x = pos.x;
          _pickRequest.y = pos.y;
          _pickRequest.radius = this.props.pickingRadius;
        }
        if (this.layerManager) {
          this.layerManager.context.mousePosition = {
            x: _pickRequest.x,
            y: _pickRequest.y
          };
        }
        _pickRequest.event = event;
      });
      _defineProperty(this, "_onEvent", (event) => {
        const eventOptions = EVENTS[event.type];
        const pos = event.offsetCenter;
        if (!eventOptions || !pos || !this.layerManager) {
          return;
        }
        const layers = this.layerManager.getLayers();
        const info = this.deckPicker.getLastPickedObject({
          x: pos.x,
          y: pos.y,
          layers,
          viewports: this.getViewports(pos)
        }, this._lastPointerDownInfo);
        const {
          layer
        } = info;
        const layerHandler = layer && (layer[eventOptions.handler] || layer.props[eventOptions.handler]);
        const rootHandler = this.props[eventOptions.handler];
        let handled = false;
        if (layerHandler) {
          handled = layerHandler.call(layer, info, event);
        }
        if (!handled && rootHandler) {
          rootHandler(info, event);
        }
      });
      _defineProperty(this, "_onPointerDown", (event) => {
        const pos = event.offsetCenter;
        const pickedInfo = this._pick("pickObject", "pickObject Time", {
          x: pos.x,
          y: pos.y,
          radius: this.props.pickingRadius
        });
        this._lastPointerDownInfo = pickedInfo.result[0] || pickedInfo.emptyInfo;
      });
      this.props = {
        ...defaultProps,
        ...props
      };
      props = this.props;
      this._needsRedraw = "Initial render";
      this._pickRequest = {
        mode: "hover",
        x: -1,
        y: -1,
        radius: 0,
        event: null
      };
      this.cursorState = {
        isHovering: false,
        isDragging: false
      };
      if (props.viewState && props.initialViewState) {
        log_default.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")();
      }
      if (getBrowser() === "IE") {
        log_default.warn("IE 11 is not supported")();
      }
      this.viewState = props.initialViewState;
      if (!props.gl) {
        if (typeof document !== "undefined") {
          this.canvas = this._createCanvas(props);
        }
      }
      this.animationLoop = this._createAnimationLoop(props);
      this.stats = new Stats({
        id: "deck.gl"
      });
      this.metrics = {
        fps: 0,
        setPropsTime: 0,
        updateAttributesTime: 0,
        framesRedrawn: 0,
        pickTime: 0,
        pickCount: 0,
        gpuTime: 0,
        gpuTimePerFrame: 0,
        cpuTime: 0,
        cpuTimePerFrame: 0,
        bufferMemory: 0,
        textureMemory: 0,
        renderbufferMemory: 0,
        gpuMemory: 0
      };
      this._metricsCounter = 0;
      this.setProps(props);
      if (props._typedArrayManagerProps) {
        typed_array_manager_default.setOptions(props._typedArrayManagerProps);
      }
      this.animationLoop.start();
    }
    finalize() {
      var _this$animationLoop, _this$layerManager, _this$viewManager, _this$effectManager, _this$deckRenderer, _this$deckPicker, _this$eventManager, _this$tooltip;
      (_this$animationLoop = this.animationLoop) === null || _this$animationLoop === void 0 ? void 0 : _this$animationLoop.stop();
      this.animationLoop = null;
      this._lastPointerDownInfo = null;
      (_this$layerManager = this.layerManager) === null || _this$layerManager === void 0 ? void 0 : _this$layerManager.finalize();
      this.layerManager = null;
      (_this$viewManager = this.viewManager) === null || _this$viewManager === void 0 ? void 0 : _this$viewManager.finalize();
      this.viewManager = null;
      (_this$effectManager = this.effectManager) === null || _this$effectManager === void 0 ? void 0 : _this$effectManager.finalize();
      this.effectManager = null;
      (_this$deckRenderer = this.deckRenderer) === null || _this$deckRenderer === void 0 ? void 0 : _this$deckRenderer.finalize();
      this.deckRenderer = null;
      (_this$deckPicker = this.deckPicker) === null || _this$deckPicker === void 0 ? void 0 : _this$deckPicker.finalize();
      this.deckPicker = null;
      (_this$eventManager = this.eventManager) === null || _this$eventManager === void 0 ? void 0 : _this$eventManager.destroy();
      this.eventManager = null;
      (_this$tooltip = this.tooltip) === null || _this$tooltip === void 0 ? void 0 : _this$tooltip.remove();
      this.tooltip = null;
      if (!this.props.canvas && !this.props.gl && this.canvas) {
        var _this$canvas$parentEl;
        (_this$canvas$parentEl = this.canvas.parentElement) === null || _this$canvas$parentEl === void 0 ? void 0 : _this$canvas$parentEl.removeChild(this.canvas);
        this.canvas = null;
      }
    }
    setProps(props) {
      this.stats.get("setProps Time").timeStart();
      if ("onLayerHover" in props) {
        log_default.removed("onLayerHover", "onHover")();
      }
      if ("onLayerClick" in props) {
        log_default.removed("onLayerClick", "onClick")();
      }
      if (props.initialViewState && !deepEqual(this.props.initialViewState, props.initialViewState, 3)) {
        this.viewState = props.initialViewState;
      }
      Object.assign(this.props, props);
      this._setCanvasSize(this.props);
      const resolvedProps = Object.create(this.props);
      Object.assign(resolvedProps, {
        views: this._getViews(),
        width: this.width,
        height: this.height,
        viewState: this._getViewState()
      });
      this.animationLoop.setProps(resolvedProps);
      if (this.layerManager) {
        this.viewManager.setProps(resolvedProps);
        this.layerManager.activateViewport(this.getViewports()[0]);
        this.layerManager.setProps(resolvedProps);
        this.effectManager.setProps(resolvedProps);
        this.deckRenderer.setProps(resolvedProps);
        this.deckPicker.setProps(resolvedProps);
      }
      this.stats.get("setProps Time").timeEnd();
    }
    needsRedraw(opts = {
      clearRedrawFlags: false
    }) {
      if (!this.layerManager) {
        return false;
      }
      if (this.props._animate) {
        return "Deck._animate";
      }
      let redraw = this._needsRedraw;
      if (opts.clearRedrawFlags) {
        this._needsRedraw = false;
      }
      const viewManagerNeedsRedraw = this.viewManager.needsRedraw(opts);
      const layerManagerNeedsRedraw = this.layerManager.needsRedraw(opts);
      const effectManagerNeedsRedraw = this.effectManager.needsRedraw(opts);
      const deckRendererNeedsRedraw = this.deckRenderer.needsRedraw(opts);
      redraw = redraw || viewManagerNeedsRedraw || layerManagerNeedsRedraw || effectManagerNeedsRedraw || deckRendererNeedsRedraw;
      return redraw;
    }
    redraw(reason) {
      if (!this.layerManager) {
        return;
      }
      let redrawReason = this.needsRedraw({
        clearRedrawFlags: true
      });
      redrawReason = reason || redrawReason;
      if (!redrawReason) {
        return;
      }
      this.stats.get("Redraw Count").incrementCount();
      if (this.props._customRender) {
        this.props._customRender(redrawReason);
      } else {
        this._drawLayers(redrawReason);
      }
    }
    get isInitialized() {
      return this.viewManager !== null;
    }
    getViews() {
      assert10(this.viewManager);
      return this.viewManager.views;
    }
    getViewports(rect) {
      assert10(this.viewManager);
      return this.viewManager.getViewports(rect);
    }
    getCanvas() {
      return this.canvas;
    }
    pickObject(opts) {
      const infos = this._pick("pickObject", "pickObject Time", opts).result;
      return infos.length ? infos[0] : null;
    }
    pickMultipleObjects(opts) {
      opts.depth = opts.depth || 10;
      return this._pick("pickObject", "pickMultipleObjects Time", opts).result;
    }
    pickObjects(opts) {
      return this._pick("pickObjects", "pickObjects Time", opts);
    }
    _addResources(resources, forceUpdate = false) {
      for (const id2 in resources) {
        this.layerManager.resourceManager.add({
          resourceId: id2,
          data: resources[id2],
          forceUpdate
        });
      }
    }
    _removeResources(resourceIds) {
      for (const id2 of resourceIds) {
        this.layerManager.resourceManager.remove(id2);
      }
    }
    _addDefaultEffect(effect) {
      this.effectManager.addDefaultEffect(effect);
    }
    _pick(method2, statKey, opts) {
      assert10(this.deckPicker);
      const {
        stats
      } = this;
      stats.get("Pick Count").incrementCount();
      stats.get(statKey).timeStart();
      const infos = this.deckPicker[method2]({
        layers: this.layerManager.getLayers(opts),
        views: this.viewManager.getViews(),
        viewports: this.getViewports(opts),
        onViewportActive: this.layerManager.activateViewport,
        effects: this.effectManager.getEffects(),
        ...opts
      });
      stats.get(statKey).timeEnd();
      return infos;
    }
    _createCanvas(props) {
      let canvas = props.canvas;
      if (typeof canvas === "string") {
        canvas = document.getElementById(canvas);
        assert10(canvas);
      }
      if (!canvas) {
        canvas = document.createElement("canvas");
        canvas.id = props.id || "deckgl-overlay";
        const parent2 = props.parent || document.body;
        parent2.appendChild(canvas);
      }
      Object.assign(canvas.style, props.style);
      return canvas;
    }
    _setCanvasSize(props) {
      if (!this.canvas) {
        return;
      }
      const {
        width: width8,
        height: height8
      } = props;
      if (width8 || width8 === 0) {
        const cssWidth = Number.isFinite(width8) ? "".concat(width8, "px") : width8;
        this.canvas.style.width = cssWidth;
      }
      if (height8 || height8 === 0) {
        var _props$style;
        const cssHeight = Number.isFinite(height8) ? "".concat(height8, "px") : height8;
        this.canvas.style.position = ((_props$style = props.style) === null || _props$style === void 0 ? void 0 : _props$style.position) || "absolute";
        this.canvas.style.height = cssHeight;
      }
    }
    _updateCanvasSize() {
      var _canvas$clientWidth, _canvas$clientHeight;
      const {
        canvas
      } = this;
      if (!canvas) {
        return;
      }
      const newWidth = (_canvas$clientWidth = canvas.clientWidth) !== null && _canvas$clientWidth !== void 0 ? _canvas$clientWidth : canvas.width;
      const newHeight = (_canvas$clientHeight = canvas.clientHeight) !== null && _canvas$clientHeight !== void 0 ? _canvas$clientHeight : canvas.height;
      if (newWidth !== this.width || newHeight !== this.height) {
        var _this$viewManager2, _this$layerManager2;
        this.width = newWidth;
        this.height = newHeight;
        (_this$viewManager2 = this.viewManager) === null || _this$viewManager2 === void 0 ? void 0 : _this$viewManager2.setProps({
          width: newWidth,
          height: newHeight
        });
        (_this$layerManager2 = this.layerManager) === null || _this$layerManager2 === void 0 ? void 0 : _this$layerManager2.activateViewport(this.getViewports()[0]);
        this.props.onResize({
          width: newWidth,
          height: newHeight
        });
      }
    }
    _createAnimationLoop(props) {
      const {
        width: width8,
        height: height8,
        gl,
        glOptions,
        debug: debug2,
        onError,
        onBeforeRender,
        onAfterRender,
        useDevicePixels
      } = props;
      return new AnimationLoop({
        width: width8,
        height: height8,
        useDevicePixels,
        autoResizeDrawingBuffer: !gl,
        autoResizeViewport: false,
        gl,
        onCreateContext: (opts) => createGLContext({
          ...glOptions,
          ...opts,
          canvas: this.canvas,
          debug: debug2,
          onContextLost: () => this._onContextLost()
        }),
        onInitialize: (context) => this._setGLContext(context.gl),
        onRender: this._onRenderFrame.bind(this),
        onBeforeRender,
        onAfterRender,
        onError
      });
    }
    _getViewState() {
      return this.props.viewState || this.viewState;
    }
    _getViews() {
      let views = this.props.views || [new MapView({
        id: "default-view"
      })];
      views = Array.isArray(views) ? views : [views];
      if (views.length && this.props.controller) {
        views[0].props.controller = this.props.controller;
      }
      return views;
    }
    _onContextLost() {
      const {
        onError
      } = this.props;
      if (this.animationLoop && onError) {
        onError(new Error("WebGL context is lost"));
      }
    }
    _pickAndCallback() {
      const {
        _pickRequest
      } = this;
      if (_pickRequest.event) {
        const {
          result,
          emptyInfo
        } = this._pick("pickObject", "pickObject Time", _pickRequest);
        this.cursorState.isHovering = result.length > 0;
        let pickedInfo = emptyInfo;
        let handled = false;
        for (const info of result) {
          var _info$layer;
          pickedInfo = info;
          handled = ((_info$layer = info.layer) === null || _info$layer === void 0 ? void 0 : _info$layer.onHover(info, _pickRequest.event)) || handled;
        }
        if (!handled && this.props.onHover) {
          this.props.onHover(pickedInfo, _pickRequest.event);
        }
        if (this.props.getTooltip && this.tooltip) {
          const displayInfo = this.props.getTooltip(pickedInfo);
          this.tooltip.setTooltip(displayInfo, pickedInfo.x, pickedInfo.y);
        }
        _pickRequest.event = null;
      }
    }
    _updateCursor() {
      const container = this.props.parent || this.canvas;
      if (container) {
        container.style.cursor = this.props.getCursor(this.cursorState);
      }
    }
    _setGLContext(gl) {
      if (this.layerManager) {
        return;
      }
      if (!this.canvas) {
        this.canvas = gl.canvas;
        instrumentGLContext(gl, {
          enable: true,
          copyState: true
        });
      }
      this.tooltip = new Tooltip(this.canvas);
      setParameters(gl, {
        blend: true,
        blendFunc: [770, 771, 1, 771],
        polygonOffsetFill: true,
        depthTest: true,
        depthFunc: 515
      });
      this.props.onWebGLInitialized(gl);
      const timeline = new Timeline();
      timeline.play();
      this.animationLoop.attachTimeline(timeline);
      this.eventManager = new EventManager(this.props.parent || gl.canvas, {
        touchAction: this.props.touchAction,
        recognizerOptions: this.props.eventRecognizerOptions,
        events: {
          pointerdown: this._onPointerDown,
          pointermove: this._onPointerMove,
          pointerleave: this._onPointerMove
        }
      });
      for (const eventType in EVENTS) {
        this.eventManager.on(eventType, this._onEvent);
      }
      this.viewManager = new ViewManager({
        timeline,
        eventManager: this.eventManager,
        onViewStateChange: this._onViewStateChange.bind(this),
        onInteractionStateChange: this._onInteractionStateChange.bind(this),
        views: this._getViews(),
        viewState: this._getViewState(),
        width: this.width,
        height: this.height
      });
      const viewport = this.viewManager.getViewports()[0];
      this.layerManager = new LayerManager(gl, {
        deck: this,
        stats: this.stats,
        viewport,
        timeline
      });
      this.effectManager = new EffectManager();
      this.deckRenderer = new DeckRenderer(gl);
      this.deckPicker = new DeckPicker(gl);
      this.setProps(this.props);
      this._updateCanvasSize();
      this.props.onLoad();
    }
    _drawLayers(redrawReason, renderOptions) {
      const {
        gl
      } = this.layerManager.context;
      setParameters(gl, this.props.parameters);
      this.props.onBeforeRender({
        gl
      });
      this.deckRenderer.renderLayers({
        target: this.props._framebuffer,
        layers: this.layerManager.getLayers(),
        viewports: this.viewManager.getViewports(),
        onViewportActive: this.layerManager.activateViewport,
        views: this.viewManager.getViews(),
        pass: "screen",
        effects: this.effectManager.getEffects(),
        ...renderOptions
      });
      this.props.onAfterRender({
        gl
      });
    }
    _onRenderFrame(animationProps) {
      this._getFrameStats();
      if (this._metricsCounter++ % 60 === 0) {
        this._getMetrics();
        this.stats.reset();
        log_default.table(4, this.metrics)();
        if (this.props._onMetrics) {
          this.props._onMetrics(this.metrics);
        }
      }
      this._updateCanvasSize();
      this._updateCursor();
      if (this.tooltip.isVisible && this.viewManager.needsRedraw()) {
        this.tooltip.setTooltip(null);
      }
      this.layerManager.updateLayers();
      this._pickAndCallback();
      this.redraw();
      if (this.viewManager) {
        this.viewManager.updateViewStates();
      }
    }
    _onViewStateChange(params) {
      const viewState = this.props.onViewStateChange(params) || params.viewState;
      if (this.viewState) {
        this.viewState = {
          ...this.viewState,
          [params.viewId]: viewState
        };
        if (!this.props.viewState) {
          if (this.viewManager) {
            this.viewManager.setProps({
              viewState: this.viewState
            });
          }
        }
      }
    }
    _onInteractionStateChange(interactionState) {
      this.cursorState.isDragging = interactionState.isDragging || false;
      this.props.onInteractionStateChange(interactionState);
    }
    _getFrameStats() {
      const {
        stats
      } = this;
      stats.get("frameRate").timeEnd();
      stats.get("frameRate").timeStart();
      const animationLoopStats = this.animationLoop.stats;
      stats.get("GPU Time").addTime(animationLoopStats.get("GPU Time").lastTiming);
      stats.get("CPU Time").addTime(animationLoopStats.get("CPU Time").lastTiming);
    }
    _getMetrics() {
      const {
        metrics,
        stats
      } = this;
      metrics.fps = stats.get("frameRate").getHz();
      metrics.setPropsTime = stats.get("setProps Time").time;
      metrics.updateAttributesTime = stats.get("Update Attributes").time;
      metrics.framesRedrawn = stats.get("Redraw Count").count;
      metrics.pickTime = stats.get("pickObject Time").time + stats.get("pickMultipleObjects Time").time + stats.get("pickObjects Time").time;
      metrics.pickCount = stats.get("Pick Count").count;
      metrics.gpuTime = stats.get("GPU Time").time;
      metrics.cpuTime = stats.get("CPU Time").time;
      metrics.gpuTimePerFrame = stats.get("GPU Time").getAverageTime();
      metrics.cpuTimePerFrame = stats.get("CPU Time").getAverageTime();
      const memoryStats = lumaStats.get("Memory Usage");
      metrics.bufferMemory = memoryStats.get("Buffer Memory").count;
      metrics.textureMemory = memoryStats.get("Texture Memory").count;
      metrics.renderbufferMemory = memoryStats.get("Renderbuffer Memory").count;
      metrics.gpuMemory = memoryStats.get("GPU Memory").count;
    }
  };
  _defineProperty(Deck, "defaultProps", defaultProps);
  _defineProperty(Deck, "VERSION", VERSION5);

  // node_modules/@deck.gl/core/dist/esm/lib/attribute/shader-attribute.js
  var ShaderAttribute = class {
    constructor(dataColumn, opts) {
      _defineProperty(this, "opts", void 0);
      _defineProperty(this, "source", void 0);
      this.opts = opts;
      this.source = dataColumn;
    }
    get value() {
      return this.source.value;
    }
    getValue() {
      const buffer = this.source.getBuffer();
      const accessor = this.getAccessor();
      if (buffer) {
        return [buffer, accessor];
      }
      const {
        value: value13
      } = this.source;
      const {
        size: size5
      } = accessor;
      let constantValue = value13;
      if (value13 && value13.length !== size5) {
        constantValue = new Float32Array(size5);
        const index5 = accessor.elementOffset || 0;
        for (let i = 0; i < size5; ++i) {
          constantValue[i] = value13[index5 + i];
        }
      }
      return constantValue;
    }
    getAccessor() {
      return {
        ...this.source.getAccessor(),
        ...this.opts
      };
    }
  };

  // node_modules/@deck.gl/core/dist/esm/lib/attribute/gl-utils.js
  function glArrayFromType(glType) {
    switch (glType) {
      case 5126:
        return Float32Array;
      case 5130:
        return Float64Array;
      case 5123:
      case 33635:
      case 32819:
      case 32820:
        return Uint16Array;
      case 5125:
        return Uint32Array;
      case 5121:
        return Uint8ClampedArray;
      case 5120:
        return Int8Array;
      case 5122:
        return Int16Array;
      case 5124:
        return Int32Array;
      default:
        throw new Error("Unknown GL type");
    }
  }

  // node_modules/@deck.gl/core/dist/esm/lib/attribute/data-column.js
  function getStride(accessor) {
    return accessor.stride || accessor.size * accessor.bytesPerElement;
  }
  function resolveShaderAttribute(baseAccessor, shaderAttributeOptions) {
    if (shaderAttributeOptions.offset) {
      log_default.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
    }
    const stride = getStride(baseAccessor);
    const vertexOffset = shaderAttributeOptions.vertexOffset !== void 0 ? shaderAttributeOptions.vertexOffset : baseAccessor.vertexOffset || 0;
    const elementOffset = shaderAttributeOptions.elementOffset || 0;
    const offset = vertexOffset * stride + elementOffset * baseAccessor.bytesPerElement + (baseAccessor.offset || 0);
    return {
      ...shaderAttributeOptions,
      offset,
      stride
    };
  }
  function resolveDoublePrecisionShaderAttributes(baseAccessor, shaderAttributeOptions) {
    const resolvedOptions = resolveShaderAttribute(baseAccessor, shaderAttributeOptions);
    return {
      high: resolvedOptions,
      low: {
        ...resolvedOptions,
        offset: resolvedOptions.offset + baseAccessor.size * 4
      }
    };
  }
  var DataColumn = class {
    constructor(gl, opts, state3) {
      _defineProperty(this, "gl", void 0);
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "size", void 0);
      _defineProperty(this, "settings", void 0);
      _defineProperty(this, "value", void 0);
      _defineProperty(this, "doublePrecision", void 0);
      _defineProperty(this, "_buffer", void 0);
      _defineProperty(this, "state", void 0);
      this.gl = gl;
      this.id = opts.id || "";
      this.size = opts.size || 1;
      const logicalType = opts.logicalType || opts.type;
      const doublePrecision = logicalType === 5130;
      let {
        defaultValue: defaultValue4
      } = opts;
      defaultValue4 = Number.isFinite(defaultValue4) ? [defaultValue4] : defaultValue4 || new Array(this.size).fill(0);
      let bufferType;
      if (doublePrecision) {
        bufferType = 5126;
      } else if (!logicalType && opts.isIndexed) {
        bufferType = gl && hasFeature(gl, FEATURES.ELEMENT_INDEX_UINT32) ? 5125 : 5123;
      } else {
        bufferType = logicalType || 5126;
      }
      let defaultType = glArrayFromType(logicalType || bufferType || 5126);
      this.doublePrecision = doublePrecision;
      if (doublePrecision && opts.fp64 === false) {
        defaultType = Float32Array;
      }
      this.value = null;
      this.settings = {
        ...opts,
        defaultType,
        defaultValue: defaultValue4,
        logicalType,
        type: bufferType,
        size: this.size,
        bytesPerElement: defaultType.BYTES_PER_ELEMENT
      };
      this.state = {
        ...state3,
        externalBuffer: null,
        bufferAccessor: this.settings,
        allocatedValue: null,
        numInstances: 0,
        bounds: null,
        constant: false
      };
      this._buffer = null;
    }
    get isConstant() {
      return this.state.constant;
    }
    get buffer() {
      if (!this._buffer) {
        const {
          isIndexed,
          type
        } = this.settings;
        this._buffer = new Buffer2(this.gl, {
          id: this.id,
          target: isIndexed ? 34963 : 34962,
          accessor: {
            type
          }
        });
      }
      return this._buffer;
    }
    get byteOffset() {
      const accessor = this.getAccessor();
      if (accessor.vertexOffset) {
        return accessor.vertexOffset * getStride(accessor);
      }
      return 0;
    }
    get numInstances() {
      return this.state.numInstances;
    }
    set numInstances(n) {
      this.state.numInstances = n;
    }
    delete() {
      if (this._buffer) {
        this._buffer.delete();
        this._buffer = null;
      }
      typed_array_manager_default.release(this.state.allocatedValue);
    }
    getShaderAttributes(id2, options2) {
      if (this.doublePrecision) {
        const shaderAttributes = {};
        const isBuffer64Bit = this.value instanceof Float64Array;
        const doubleShaderAttributeDefs = resolveDoublePrecisionShaderAttributes(this.getAccessor(), options2 || {});
        shaderAttributes[id2] = new ShaderAttribute(this, doubleShaderAttributeDefs.high);
        shaderAttributes["".concat(id2, "64Low")] = isBuffer64Bit ? new ShaderAttribute(this, doubleShaderAttributeDefs.low) : new Float32Array(this.size);
        return shaderAttributes;
      }
      if (options2) {
        const shaderAttributeDef = resolveShaderAttribute(this.getAccessor(), options2);
        return {
          [id2]: new ShaderAttribute(this, shaderAttributeDef)
        };
      }
      return {
        [id2]: this
      };
    }
    getBuffer() {
      if (this.state.constant) {
        return null;
      }
      return this.state.externalBuffer || this._buffer;
    }
    getValue() {
      if (this.state.constant) {
        return this.value;
      }
      return [this.getBuffer(), this.getAccessor()];
    }
    getAccessor() {
      return this.state.bufferAccessor;
    }
    getBounds() {
      if (this.state.bounds) {
        return this.state.bounds;
      }
      let result = null;
      if (this.state.constant && this.value) {
        const min5 = Array.from(this.value);
        result = [min5, min5];
      } else {
        const {
          value: value13,
          numInstances,
          size: size5
        } = this;
        const len = numInstances * size5;
        if (value13 && len && value13.length >= len) {
          const min5 = new Array(size5).fill(Infinity);
          const max6 = new Array(size5).fill(-Infinity);
          for (let i = 0; i < len; ) {
            for (let j = 0; j < size5; j++) {
              const v = value13[i++];
              if (v < min5[j])
                min5[j] = v;
              if (v > max6[j])
                max6[j] = v;
            }
          }
          result = [min5, max6];
        }
      }
      this.state.bounds = result;
      return result;
    }
    setData(data) {
      const {
        state: state3
      } = this;
      let opts;
      if (ArrayBuffer.isView(data)) {
        opts = {
          value: data
        };
      } else if (data instanceof Buffer2) {
        opts = {
          buffer: data
        };
      } else {
        opts = data;
      }
      const accessor = {
        ...this.settings,
        ...opts
      };
      state3.bufferAccessor = accessor;
      state3.bounds = null;
      if (opts.constant) {
        let value13 = opts.value;
        value13 = this._normalizeValue(value13, [], 0);
        if (this.settings.normalized) {
          value13 = this.normalizeConstant(value13);
        }
        const hasChanged = !state3.constant || !this._areValuesEqual(value13, this.value);
        if (!hasChanged) {
          return false;
        }
        state3.externalBuffer = null;
        state3.constant = true;
        this.value = value13;
      } else if (opts.buffer) {
        const buffer = opts.buffer;
        state3.externalBuffer = buffer;
        state3.constant = false;
        this.value = opts.value || null;
        const isBuffer64Bit = opts.value instanceof Float64Array;
        accessor.type = opts.type || buffer.accessor.type;
        accessor.bytesPerElement = buffer.accessor.BYTES_PER_ELEMENT * (isBuffer64Bit ? 2 : 1);
        accessor.stride = getStride(accessor);
      } else if (opts.value) {
        this._checkExternalBuffer(opts);
        let value13 = opts.value;
        state3.externalBuffer = null;
        state3.constant = false;
        this.value = value13;
        accessor.bytesPerElement = value13.BYTES_PER_ELEMENT;
        accessor.stride = getStride(accessor);
        const {
          buffer,
          byteOffset
        } = this;
        if (this.doublePrecision && value13 instanceof Float64Array) {
          value13 = toDoublePrecisionArray(value13, accessor);
        }
        const requiredBufferSize = value13.byteLength + byteOffset + accessor.stride * 2;
        if (buffer.byteLength < requiredBufferSize) {
          buffer.reallocate(requiredBufferSize);
        }
        buffer.setAccessor(null);
        buffer.subData({
          data: value13,
          offset: byteOffset
        });
        accessor.type = opts.type || buffer.accessor.type;
      }
      return true;
    }
    updateSubBuffer(opts = {}) {
      this.state.bounds = null;
      const value13 = this.value;
      const {
        startOffset = 0,
        endOffset
      } = opts;
      this.buffer.subData({
        data: this.doublePrecision && value13 instanceof Float64Array ? toDoublePrecisionArray(value13, {
          size: this.size,
          startIndex: startOffset,
          endIndex: endOffset
        }) : value13.subarray(startOffset, endOffset),
        offset: startOffset * value13.BYTES_PER_ELEMENT + this.byteOffset
      });
    }
    allocate(numInstances, copy2 = false) {
      const {
        state: state3
      } = this;
      const oldValue = state3.allocatedValue;
      const value13 = typed_array_manager_default.allocate(oldValue, numInstances + 1, {
        size: this.size,
        type: this.settings.defaultType,
        copy: copy2
      });
      this.value = value13;
      const {
        buffer,
        byteOffset
      } = this;
      if (buffer.byteLength < value13.byteLength + byteOffset) {
        buffer.reallocate(value13.byteLength + byteOffset);
        if (copy2 && oldValue) {
          buffer.subData({
            data: oldValue instanceof Float64Array ? toDoublePrecisionArray(oldValue, this) : oldValue,
            offset: byteOffset
          });
        }
      }
      state3.allocatedValue = value13;
      state3.constant = false;
      state3.externalBuffer = null;
      state3.bufferAccessor = this.settings;
      return true;
    }
    _checkExternalBuffer(opts) {
      const {
        value: value13
      } = opts;
      if (!ArrayBuffer.isView(value13)) {
        throw new Error("Attribute ".concat(this.id, " value is not TypedArray"));
      }
      const ArrayType = this.settings.defaultType;
      let illegalArrayType = false;
      if (this.doublePrecision) {
        illegalArrayType = value13.BYTES_PER_ELEMENT < 4;
      }
      if (illegalArrayType) {
        throw new Error("Attribute ".concat(this.id, " does not support ").concat(value13.constructor.name));
      }
      if (!(value13 instanceof ArrayType) && this.settings.normalized && !("normalized" in opts)) {
        log_default.warn("Attribute ".concat(this.id, " is normalized"))();
      }
    }
    normalizeConstant(value13) {
      switch (this.settings.type) {
        case 5120:
          return new Float32Array(value13).map((x) => (x + 128) / 255 * 2 - 1);
        case 5122:
          return new Float32Array(value13).map((x) => (x + 32768) / 65535 * 2 - 1);
        case 5121:
          return new Float32Array(value13).map((x) => x / 255);
        case 5123:
          return new Float32Array(value13).map((x) => x / 65535);
        default:
          return value13;
      }
    }
    _normalizeValue(value13, out, start2) {
      const {
        defaultValue: defaultValue4,
        size: size5
      } = this.settings;
      if (Number.isFinite(value13)) {
        out[start2] = value13;
        return out;
      }
      if (!value13) {
        let i = size5;
        while (--i >= 0) {
          out[start2 + i] = defaultValue4[i];
        }
        return out;
      }
      switch (size5) {
        case 4:
          out[start2 + 3] = Number.isFinite(value13[3]) ? value13[3] : defaultValue4[3];
        case 3:
          out[start2 + 2] = Number.isFinite(value13[2]) ? value13[2] : defaultValue4[2];
        case 2:
          out[start2 + 1] = Number.isFinite(value13[1]) ? value13[1] : defaultValue4[1];
        case 1:
          out[start2 + 0] = Number.isFinite(value13[0]) ? value13[0] : defaultValue4[0];
          break;
        default:
          let i = size5;
          while (--i >= 0) {
            out[start2 + i] = Number.isFinite(value13[i]) ? value13[i] : defaultValue4[i];
          }
      }
      return out;
    }
    _areValuesEqual(value1, value22) {
      if (!value1 || !value22) {
        return false;
      }
      const {
        size: size5
      } = this;
      for (let i = 0; i < size5; i++) {
        if (value1[i] !== value22[i]) {
          return false;
        }
      }
      return true;
    }
  };

  // node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js
  var EMPTY_ARRAY = [];
  var placeholderArray = [];
  function createIterable(data, startRow = 0, endRow = Infinity) {
    let iterable = EMPTY_ARRAY;
    const objectInfo = {
      index: -1,
      data,
      target: []
    };
    if (!data) {
      iterable = EMPTY_ARRAY;
    } else if (typeof data[Symbol.iterator] === "function") {
      iterable = data;
    } else if (data.length > 0) {
      placeholderArray.length = data.length;
      iterable = placeholderArray;
    }
    if (startRow > 0 || Number.isFinite(endRow)) {
      iterable = (Array.isArray(iterable) ? iterable : Array.from(iterable)).slice(startRow, endRow);
      objectInfo.index = startRow - 1;
    }
    return {
      iterable,
      objectInfo
    };
  }
  function isAsyncIterable2(data) {
    return data && data[Symbol.asyncIterator];
  }
  function getAccessorFromBuffer(typedArray, options2) {
    const {
      size: size5,
      stride,
      offset,
      startIndices,
      nested
    } = options2;
    const bytesPerElement = typedArray.BYTES_PER_ELEMENT;
    const elementStride = stride ? stride / bytesPerElement : size5;
    const elementOffset = offset ? offset / bytesPerElement : 0;
    const vertexCount = Math.floor((typedArray.length - elementOffset) / elementStride);
    return (_, {
      index: index5,
      target: target5
    }) => {
      if (!startIndices) {
        const sourceIndex = index5 * elementStride + elementOffset;
        for (let j = 0; j < size5; j++) {
          target5[j] = typedArray[sourceIndex + j];
        }
        return target5;
      }
      const startIndex = startIndices[index5];
      const endIndex = startIndices[index5 + 1] || vertexCount;
      let result;
      if (nested) {
        result = new Array(endIndex - startIndex);
        for (let i = startIndex; i < endIndex; i++) {
          const sourceIndex = i * elementStride + elementOffset;
          target5 = new Array(size5);
          for (let j = 0; j < size5; j++) {
            target5[j] = typedArray[sourceIndex + j];
          }
          result[i - startIndex] = target5;
        }
      } else if (elementStride === size5) {
        result = typedArray.subarray(startIndex * size5 + elementOffset, endIndex * size5 + elementOffset);
      } else {
        result = new typedArray.constructor((endIndex - startIndex) * size5);
        let targetIndex = 0;
        for (let i = startIndex; i < endIndex; i++) {
          const sourceIndex = i * elementStride + elementOffset;
          for (let j = 0; j < size5; j++) {
            result[targetIndex++] = typedArray[sourceIndex + j];
          }
        }
      }
      return result;
    };
  }

  // node_modules/@deck.gl/core/dist/esm/utils/range.js
  var EMPTY = [];
  var FULL = [[0, Infinity]];
  function add4(rangeList, range3) {
    if (rangeList === FULL) {
      return rangeList;
    }
    if (range3[0] < 0) {
      range3[0] = 0;
    }
    if (range3[0] >= range3[1]) {
      return rangeList;
    }
    const newRangeList = [];
    const len = rangeList.length;
    let insertPosition = 0;
    for (let i = 0; i < len; i++) {
      const range0 = rangeList[i];
      if (range0[1] < range3[0]) {
        newRangeList.push(range0);
        insertPosition = i + 1;
      } else if (range0[0] > range3[1]) {
        newRangeList.push(range0);
      } else {
        range3 = [Math.min(range0[0], range3[0]), Math.max(range0[1], range3[1])];
      }
    }
    newRangeList.splice(insertPosition, 0, range3);
    return newRangeList;
  }

  // node_modules/@deck.gl/core/dist/esm/utils/array-utils.js
  function padArrayChunk(options2) {
    const {
      source,
      target: target5,
      start: start2 = 0,
      size: size5,
      getData
    } = options2;
    const end = options2.end || target5.length;
    const sourceLength = source.length;
    const targetLength = end - start2;
    if (sourceLength > targetLength) {
      target5.set(source.subarray(0, targetLength), start2);
      return;
    }
    target5.set(source, start2);
    if (!getData) {
      return;
    }
    let i = sourceLength;
    while (i < targetLength) {
      const datum = getData(i, source);
      for (let j = 0; j < size5; j++) {
        target5[start2 + i] = datum[j] || 0;
        i++;
      }
    }
  }
  function padArray({
    source,
    target: target5,
    size: size5,
    getData,
    sourceStartIndices,
    targetStartIndices
  }) {
    if (!Array.isArray(targetStartIndices)) {
      padArrayChunk({
        source,
        target: target5,
        size: size5,
        getData
      });
      return target5;
    }
    let sourceIndex = 0;
    let targetIndex = 0;
    const getChunkData = getData && ((i, chunk) => getData(i + targetIndex, chunk));
    const n = Math.min(sourceStartIndices.length, targetStartIndices.length);
    for (let i = 1; i < n; i++) {
      const nextSourceIndex = sourceStartIndices[i] * size5;
      const nextTargetIndex = targetStartIndices[i] * size5;
      padArrayChunk({
        source: source.subarray(sourceIndex, nextSourceIndex),
        target: target5,
        start: targetIndex,
        end: nextTargetIndex,
        size: size5,
        getData: getChunkData
      });
      sourceIndex = nextSourceIndex;
      targetIndex = nextTargetIndex;
    }
    if (targetIndex < target5.length) {
      padArrayChunk({
        source: [],
        target: target5,
        start: targetIndex,
        size: size5,
        getData: getChunkData
      });
    }
    return target5;
  }

  // node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-utils.js
  var DEFAULT_TRANSITION_SETTINGS = {
    interpolation: {
      duration: 0,
      easing: (t) => t
    },
    spring: {
      stiffness: 0.05,
      damping: 0.5
    }
  };
  function normalizeTransitionSettings(userSettings, layerSettings) {
    if (!userSettings) {
      return null;
    }
    if (Number.isFinite(userSettings)) {
      userSettings = {
        type: "interpolation",
        duration: userSettings
      };
    }
    const type = userSettings.type || "interpolation";
    return {
      ...DEFAULT_TRANSITION_SETTINGS[type],
      ...layerSettings,
      ...userSettings,
      type
    };
  }
  function getSourceBufferAttribute(gl, attribute) {
    const buffer = attribute.getBuffer();
    if (buffer) {
      return [buffer, {
        divisor: 0,
        size: attribute.size,
        normalized: attribute.settings.normalized
      }];
    }
    return attribute.value;
  }
  function getAttributeTypeFromSize(size5) {
    switch (size5) {
      case 1:
        return "float";
      case 2:
        return "vec2";
      case 3:
        return "vec3";
      case 4:
        return "vec4";
      default:
        throw new Error('No defined attribute type for size "'.concat(size5, '"'));
    }
  }
  function cycleBuffers(buffers) {
    buffers.push(buffers.shift());
  }
  function getAttributeBufferLength(attribute, numInstances) {
    const {
      doublePrecision,
      settings,
      value: value13,
      size: size5
    } = attribute;
    const multiplier = doublePrecision && value13 instanceof Float64Array ? 2 : 1;
    return (settings.noAlloc ? value13.length : numInstances * size5) * multiplier;
  }
  function padBuffer({
    buffer,
    numInstances,
    attribute,
    fromLength,
    fromStartIndices,
    getData = (x) => x
  }) {
    const precisionMultiplier = attribute.doublePrecision && attribute.value instanceof Float64Array ? 2 : 1;
    const size5 = attribute.size * precisionMultiplier;
    const byteOffset = attribute.byteOffset;
    const toStartIndices = attribute.startIndices;
    const hasStartIndices = fromStartIndices && toStartIndices;
    const toLength = getAttributeBufferLength(attribute, numInstances);
    const isConstant = attribute.isConstant;
    if (!hasStartIndices && fromLength >= toLength) {
      return;
    }
    const toData = isConstant ? attribute.value : attribute.getBuffer().getData({
      srcByteOffset: byteOffset
    });
    if (attribute.settings.normalized && !isConstant) {
      const getter = getData;
      getData = (value13, chunk) => attribute.normalizeConstant(getter(value13, chunk));
    }
    const getMissingData = isConstant ? (i, chunk) => getData(toData, chunk) : (i, chunk) => getData(toData.subarray(i, i + size5), chunk);
    const source = buffer.getData({
      length: fromLength
    });
    const data = new Float32Array(toLength);
    padArray({
      source,
      target: data,
      sourceStartIndices: fromStartIndices,
      targetStartIndices: toStartIndices,
      size: size5,
      getData: getMissingData
    });
    if (buffer.byteLength < data.byteLength + byteOffset) {
      buffer.reallocate(data.byteLength + byteOffset);
    }
    buffer.subData({
      data,
      offset: byteOffset
    });
  }

  // node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute.js
  var Attribute = class extends DataColumn {
    constructor(gl, opts) {
      super(gl, opts, {
        startIndices: null,
        lastExternalBuffer: null,
        binaryValue: null,
        binaryAccessor: null,
        needsUpdate: true,
        needsRedraw: false,
        updateRanges: FULL
      });
      _defineProperty(this, "constant", false);
      this.settings.update = opts.update || (opts.accessor ? this._autoUpdater : void 0);
      Object.seal(this.settings);
      Object.seal(this.state);
      this._validateAttributeUpdaters();
    }
    get startIndices() {
      return this.state.startIndices;
    }
    set startIndices(layout) {
      this.state.startIndices = layout;
    }
    needsUpdate() {
      return this.state.needsUpdate;
    }
    needsRedraw({
      clearChangedFlags = false
    } = {}) {
      const needsRedraw = this.state.needsRedraw;
      this.state.needsRedraw = needsRedraw && !clearChangedFlags;
      return needsRedraw;
    }
    getUpdateTriggers() {
      const {
        accessor
      } = this.settings;
      return [this.id].concat(typeof accessor !== "function" && accessor || []);
    }
    supportsTransition() {
      return Boolean(this.settings.transition);
    }
    getTransitionSetting(opts) {
      if (!opts || !this.supportsTransition()) {
        return null;
      }
      const {
        accessor
      } = this.settings;
      const layerSettings = this.settings.transition;
      const userSettings = Array.isArray(accessor) ? opts[accessor.find((a) => opts[a])] : opts[accessor];
      return normalizeTransitionSettings(userSettings, layerSettings);
    }
    setNeedsUpdate(reason = this.id, dataRange) {
      this.state.needsUpdate = this.state.needsUpdate || reason;
      this.setNeedsRedraw(reason);
      if (dataRange) {
        const {
          startRow = 0,
          endRow = Infinity
        } = dataRange;
        this.state.updateRanges = add4(this.state.updateRanges, [startRow, endRow]);
      } else {
        this.state.updateRanges = FULL;
      }
    }
    clearNeedsUpdate() {
      this.state.needsUpdate = false;
      this.state.updateRanges = EMPTY;
    }
    setNeedsRedraw(reason = this.id) {
      this.state.needsRedraw = this.state.needsRedraw || reason;
    }
    allocate(numInstances) {
      const {
        state: state3,
        settings
      } = this;
      if (settings.noAlloc) {
        return false;
      }
      if (settings.update) {
        super.allocate(numInstances, state3.updateRanges !== FULL);
        return true;
      }
      return false;
    }
    updateBuffer({
      numInstances,
      data,
      props,
      context
    }) {
      if (!this.needsUpdate()) {
        return false;
      }
      const {
        state: {
          updateRanges
        },
        settings: {
          update,
          noAlloc
        }
      } = this;
      let updated = true;
      if (update) {
        for (const [startRow, endRow] of updateRanges) {
          update.call(context, this, {
            data,
            startRow,
            endRow,
            props,
            numInstances
          });
        }
        if (!this.value) {
        } else if (this.constant || this.buffer.byteLength < this.value.byteLength + this.byteOffset) {
          this.setData({
            value: this.value,
            constant: this.constant
          });
          this.constant = false;
        } else {
          for (const [startRow, endRow] of updateRanges) {
            const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;
            const endOffset = Number.isFinite(endRow) ? this.getVertexOffset(endRow) : noAlloc || !Number.isFinite(numInstances) ? this.value.length : numInstances * this.size;
            super.updateSubBuffer({
              startOffset,
              endOffset
            });
          }
        }
        this._checkAttributeArray();
      } else {
        updated = false;
      }
      this.clearNeedsUpdate();
      this.setNeedsRedraw();
      return updated;
    }
    setConstantValue(value13) {
      if (value13 === void 0 || typeof value13 === "function") {
        return false;
      }
      const hasChanged = this.setData({
        constant: true,
        value: value13
      });
      if (hasChanged) {
        this.setNeedsRedraw();
      }
      this.clearNeedsUpdate();
      return true;
    }
    setExternalBuffer(buffer) {
      const {
        state: state3
      } = this;
      if (!buffer) {
        state3.lastExternalBuffer = null;
        return false;
      }
      this.clearNeedsUpdate();
      if (state3.lastExternalBuffer === buffer) {
        return true;
      }
      state3.lastExternalBuffer = buffer;
      this.setNeedsRedraw();
      this.setData(buffer);
      return true;
    }
    setBinaryValue(buffer, startIndices = null) {
      const {
        state: state3,
        settings
      } = this;
      if (!buffer) {
        state3.binaryValue = null;
        state3.binaryAccessor = null;
        return false;
      }
      if (settings.noAlloc) {
        return false;
      }
      if (state3.binaryValue === buffer) {
        this.clearNeedsUpdate();
        return true;
      }
      state3.binaryValue = buffer;
      this.setNeedsRedraw();
      const needsUpdate = settings.transform || startIndices !== this.startIndices;
      if (needsUpdate) {
        if (ArrayBuffer.isView(buffer)) {
          buffer = {
            value: buffer
          };
        }
        const binaryValue = buffer;
        assert10(ArrayBuffer.isView(binaryValue.value), "invalid ".concat(settings.accessor));
        const needsNormalize = Boolean(binaryValue.size) && binaryValue.size !== this.size;
        state3.binaryAccessor = getAccessorFromBuffer(binaryValue.value, {
          size: binaryValue.size || this.size,
          stride: binaryValue.stride,
          offset: binaryValue.offset,
          startIndices,
          nested: needsNormalize
        });
        return false;
      }
      this.clearNeedsUpdate();
      this.setData(buffer);
      return true;
    }
    getVertexOffset(row) {
      const {
        startIndices
      } = this;
      const vertexIndex = startIndices ? row < startIndices.length ? startIndices[row] : this.numInstances : row;
      return vertexIndex * this.size;
    }
    getShaderAttributes() {
      const shaderAttributeDefs = this.settings.shaderAttributes || {
        [this.id]: null
      };
      const shaderAttributes = {};
      for (const shaderAttributeName in shaderAttributeDefs) {
        Object.assign(shaderAttributes, super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName]));
      }
      return shaderAttributes;
    }
    _autoUpdater(attribute, {
      data,
      startRow,
      endRow,
      props,
      numInstances
    }) {
      if (attribute.constant) {
        return;
      }
      const {
        settings,
        state: state3,
        value: value13,
        size: size5,
        startIndices
      } = attribute;
      const {
        accessor,
        transform: transform2
      } = settings;
      const accessorFunc = state3.binaryAccessor || (typeof accessor === "function" ? accessor : props[accessor]);
      assert10(typeof accessorFunc === "function", 'accessor "'.concat(accessor, '" is not a function'));
      let i = attribute.getVertexOffset(startRow);
      const {
        iterable,
        objectInfo
      } = createIterable(data, startRow, endRow);
      for (const object12 of iterable) {
        objectInfo.index++;
        let objectValue = accessorFunc(object12, objectInfo);
        if (transform2) {
          objectValue = transform2.call(this, objectValue);
        }
        if (startIndices) {
          const numVertices = (objectInfo.index < startIndices.length - 1 ? startIndices[objectInfo.index + 1] : numInstances) - startIndices[objectInfo.index];
          if (objectValue && Array.isArray(objectValue[0])) {
            let startIndex = i;
            for (const item of objectValue) {
              attribute._normalizeValue(item, value13, startIndex);
              startIndex += size5;
            }
          } else if (objectValue && objectValue.length > size5) {
            value13.set(objectValue, i);
          } else {
            attribute._normalizeValue(objectValue, objectInfo.target, 0);
            fillArray2({
              target: value13,
              source: objectInfo.target,
              start: i,
              count: numVertices
            });
          }
          i += numVertices * size5;
        } else {
          attribute._normalizeValue(objectValue, value13, i);
          i += size5;
        }
      }
    }
    _validateAttributeUpdaters() {
      const {
        settings
      } = this;
      const hasUpdater = settings.noAlloc || typeof settings.update === "function";
      if (!hasUpdater) {
        throw new Error("Attribute ".concat(this.id, " missing update or accessor"));
      }
    }
    _checkAttributeArray() {
      const {
        value: value13
      } = this;
      const limit = Math.min(4, this.size);
      if (value13 && value13.length >= limit) {
        let valid = true;
        switch (limit) {
          case 4:
            valid = valid && Number.isFinite(value13[3]);
          case 3:
            valid = valid && Number.isFinite(value13[2]);
          case 2:
            valid = valid && Number.isFinite(value13[1]);
          case 1:
            valid = valid && Number.isFinite(value13[0]);
            break;
          default:
            valid = false;
        }
        if (!valid) {
          throw new Error("Illegal attribute generated for ".concat(this.id));
        }
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/transitions/gpu-interpolation-transition.js
  var GPUInterpolationTransition = class {
    constructor({
      gl,
      attribute,
      timeline
    }) {
      _defineProperty(this, "gl", void 0);
      _defineProperty(this, "type", "interpolation");
      _defineProperty(this, "attributeInTransition", void 0);
      _defineProperty(this, "settings", void 0);
      _defineProperty(this, "attribute", void 0);
      _defineProperty(this, "transition", void 0);
      _defineProperty(this, "currentStartIndices", void 0);
      _defineProperty(this, "currentLength", void 0);
      _defineProperty(this, "transform", void 0);
      _defineProperty(this, "buffers", void 0);
      this.gl = gl;
      this.transition = new Transition(timeline);
      this.attribute = attribute;
      this.attributeInTransition = new Attribute(gl, attribute.settings);
      this.currentStartIndices = attribute.startIndices;
      this.currentLength = 0;
      this.transform = getTransform(gl, attribute);
      const bufferOpts = {
        byteLength: 0,
        usage: 35050
      };
      this.buffers = [new Buffer2(gl, bufferOpts), new Buffer2(gl, bufferOpts)];
    }
    get inProgress() {
      return this.transition.inProgress;
    }
    start(transitionSettings, numInstances) {
      if (transitionSettings.duration <= 0) {
        this.transition.cancel();
        return;
      }
      this.settings = transitionSettings;
      const {
        gl,
        buffers,
        attribute
      } = this;
      cycleBuffers(buffers);
      const padBufferOpts = {
        numInstances,
        attribute,
        fromLength: this.currentLength,
        fromStartIndices: this.currentStartIndices,
        getData: transitionSettings.enter
      };
      for (const buffer of buffers) {
        padBuffer({
          buffer,
          ...padBufferOpts
        });
      }
      this.currentStartIndices = attribute.startIndices;
      this.currentLength = getAttributeBufferLength(attribute, numInstances);
      this.attributeInTransition.setData({
        buffer: buffers[1],
        value: attribute.value
      });
      this.transition.start(transitionSettings);
      this.transform.update({
        elementCount: Math.floor(this.currentLength / attribute.size),
        sourceBuffers: {
          aFrom: buffers[0],
          aTo: getSourceBufferAttribute(gl, attribute)
        },
        feedbackBuffers: {
          vCurrent: buffers[1]
        }
      });
    }
    update() {
      const updated = this.transition.update();
      if (updated) {
        const {
          duration: duration2,
          easing
        } = this.settings;
        const {
          time
        } = this.transition;
        let t = time / duration2;
        if (easing) {
          t = easing(t);
        }
        this.transform.run({
          uniforms: {
            time: t
          }
        });
      }
      return updated;
    }
    cancel() {
      this.transition.cancel();
      this.transform.delete();
      for (const buffer of this.buffers) {
        buffer.delete();
      }
      this.buffers.length = 0;
    }
  };
  var vs6 = "\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nuniform float time;\nattribute ATTRIBUTE_TYPE aFrom;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, time);\n  gl_Position = vec4(0.0);\n}\n";
  function getTransform(gl, attribute) {
    const attributeType = getAttributeTypeFromSize(attribute.size);
    return new Transform(gl, {
      vs: vs6,
      defines: {
        ATTRIBUTE_TYPE: attributeType
      },
      varyings: ["vCurrent"]
    });
  }

  // node_modules/@deck.gl/core/dist/esm/transitions/gpu-spring-transition.js
  var GPUSpringTransition = class {
    constructor({
      gl,
      attribute,
      timeline
    }) {
      _defineProperty(this, "gl", void 0);
      _defineProperty(this, "type", "spring");
      _defineProperty(this, "attributeInTransition", void 0);
      _defineProperty(this, "settings", void 0);
      _defineProperty(this, "attribute", void 0);
      _defineProperty(this, "transition", void 0);
      _defineProperty(this, "currentStartIndices", void 0);
      _defineProperty(this, "currentLength", void 0);
      _defineProperty(this, "texture", void 0);
      _defineProperty(this, "framebuffer", void 0);
      _defineProperty(this, "transform", void 0);
      _defineProperty(this, "buffers", void 0);
      this.gl = gl;
      this.type = "spring";
      this.transition = new Transition(timeline);
      this.attribute = attribute;
      this.attributeInTransition = new Attribute(gl, {
        ...attribute.settings,
        normalized: false
      });
      this.currentStartIndices = attribute.startIndices;
      this.currentLength = 0;
      this.texture = getTexture(gl);
      this.framebuffer = getFramebuffer2(gl, this.texture);
      this.transform = getTransform2(gl, attribute, this.framebuffer);
      const bufferOpts = {
        byteLength: 0,
        usage: 35050
      };
      this.buffers = [new Buffer2(gl, bufferOpts), new Buffer2(gl, bufferOpts), new Buffer2(gl, bufferOpts)];
    }
    get inProgress() {
      return this.transition.inProgress;
    }
    start(transitionSettings, numInstances) {
      const {
        gl,
        buffers,
        attribute
      } = this;
      const padBufferOpts = {
        numInstances,
        attribute,
        fromLength: this.currentLength,
        fromStartIndices: this.currentStartIndices,
        getData: transitionSettings.enter
      };
      for (const buffer of buffers) {
        padBuffer({
          buffer,
          ...padBufferOpts
        });
      }
      this.settings = transitionSettings;
      this.currentStartIndices = attribute.startIndices;
      this.currentLength = getAttributeBufferLength(attribute, numInstances);
      this.attributeInTransition.setData({
        buffer: buffers[1],
        value: attribute.value
      });
      this.transition.start({
        ...transitionSettings,
        duration: Infinity
      });
      this.transform.update({
        elementCount: Math.floor(this.currentLength / attribute.size),
        sourceBuffers: {
          aTo: getSourceBufferAttribute(gl, attribute)
        }
      });
    }
    update() {
      const {
        buffers,
        transform: transform2,
        framebuffer,
        transition
      } = this;
      const updated = transition.update();
      if (!updated) {
        return false;
      }
      const settings = this.settings;
      transform2.update({
        sourceBuffers: {
          aPrev: buffers[0],
          aCur: buffers[1]
        },
        feedbackBuffers: {
          vNext: buffers[2]
        }
      });
      transform2.run({
        framebuffer,
        discard: false,
        clearRenderTarget: true,
        uniforms: {
          stiffness: settings.stiffness,
          damping: settings.damping
        },
        parameters: {
          depthTest: false,
          blend: true,
          viewport: [0, 0, 1, 1],
          blendFunc: [1, 1],
          blendEquation: [32776, 32776]
        }
      });
      cycleBuffers(buffers);
      this.attributeInTransition.setData({
        buffer: buffers[1],
        value: this.attribute.value
      });
      const isTransitioning = readPixelsToArray(framebuffer)[0] > 0;
      if (!isTransitioning) {
        transition.end();
      }
      return true;
    }
    cancel() {
      this.transition.cancel();
      this.transform.delete();
      for (const buffer of this.buffers) {
        buffer.delete();
      }
      this.buffers.length = 0;
      this.texture.delete();
      this.framebuffer.delete();
    }
  };
  function getTransform2(gl, attribute, framebuffer) {
    const attributeType = getAttributeTypeFromSize(attribute.size);
    return new Transform(gl, {
      framebuffer,
      vs: "\n#define SHADER_NAME spring-transition-vertex-shader\n\n#define EPSILON 0.00001\n\nuniform float stiffness;\nuniform float damping;\nattribute ATTRIBUTE_TYPE aPrev;\nattribute ATTRIBUTE_TYPE aCur;\nattribute ATTRIBUTE_TYPE aTo;\nvarying ATTRIBUTE_TYPE vNext;\nvarying float vIsTransitioningFlag;\n\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\n  ATTRIBUTE_TYPE velocity = cur - prev;\n  ATTRIBUTE_TYPE delta = dest - cur;\n  ATTRIBUTE_TYPE spring = delta * stiffness;\n  ATTRIBUTE_TYPE damper = velocity * -1.0 * damping;\n  return spring + damper + velocity + cur;\n}\n\nvoid main(void) {\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\n\n  vNext = getNextValue(aCur, aPrev, aTo);\n  gl_Position = vec4(0, 0, 0, 1);\n  gl_PointSize = 100.0;\n}\n",
      fs: "\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\n\nvarying float vIsTransitioningFlag;\n\nvoid main(void) {\n  if (vIsTransitioningFlag == 0.0) {\n    discard;\n  }\n  gl_FragColor = vec4(1.0);\n}",
      defines: {
        ATTRIBUTE_TYPE: attributeType
      },
      varyings: ["vNext"]
    });
  }
  function getTexture(gl) {
    return new Texture2D(gl, {
      data: new Uint8Array(4),
      format: 6408,
      type: 5121,
      border: 0,
      mipmaps: false,
      dataFormat: 6408,
      width: 1,
      height: 1
    });
  }
  function getFramebuffer2(gl, texture) {
    return new Framebuffer(gl, {
      id: "spring-transition-is-transitioning-framebuffer",
      width: 1,
      height: 1,
      attachments: {
        [36064]: texture
      }
    });
  }

  // node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-transition-manager.js
  var TRANSITION_TYPES = {
    interpolation: GPUInterpolationTransition,
    spring: GPUSpringTransition
  };
  var AttributeTransitionManager = class {
    constructor(gl, {
      id: id2,
      timeline
    }) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "isSupported", void 0);
      _defineProperty(this, "gl", void 0);
      _defineProperty(this, "timeline", void 0);
      _defineProperty(this, "transitions", void 0);
      _defineProperty(this, "needsRedraw", void 0);
      _defineProperty(this, "numInstances", void 0);
      this.id = id2;
      this.gl = gl;
      this.timeline = timeline;
      this.transitions = {};
      this.needsRedraw = false;
      this.numInstances = 1;
      this.isSupported = Transform.isSupported(gl);
    }
    finalize() {
      for (const attributeName in this.transitions) {
        this._removeTransition(attributeName);
      }
    }
    update({
      attributes,
      transitions,
      numInstances
    }) {
      this.numInstances = numInstances || 1;
      for (const attributeName in attributes) {
        const attribute = attributes[attributeName];
        const settings = attribute.getTransitionSetting(transitions);
        if (!settings)
          continue;
        this._updateAttribute(attributeName, attribute, settings);
      }
      for (const attributeName in this.transitions) {
        const attribute = attributes[attributeName];
        if (!attribute || !attribute.getTransitionSetting(transitions)) {
          this._removeTransition(attributeName);
        }
      }
    }
    hasAttribute(attributeName) {
      const transition = this.transitions[attributeName];
      return transition && transition.inProgress;
    }
    getAttributes() {
      const animatedAttributes = {};
      for (const attributeName in this.transitions) {
        const transition = this.transitions[attributeName];
        if (transition.inProgress) {
          animatedAttributes[attributeName] = transition.attributeInTransition;
        }
      }
      return animatedAttributes;
    }
    run() {
      if (!this.isSupported || this.numInstances === 0) {
        return false;
      }
      for (const attributeName in this.transitions) {
        const updated = this.transitions[attributeName].update();
        if (updated) {
          this.needsRedraw = true;
        }
      }
      const needsRedraw = this.needsRedraw;
      this.needsRedraw = false;
      return needsRedraw;
    }
    _removeTransition(attributeName) {
      this.transitions[attributeName].cancel();
      delete this.transitions[attributeName];
    }
    _updateAttribute(attributeName, attribute, settings) {
      const transition = this.transitions[attributeName];
      let isNew = !transition || transition.type !== settings.type;
      if (isNew) {
        if (!this.isSupported) {
          log_default.warn("WebGL2 not supported by this browser. Transition for ".concat(attributeName, " is disabled."))();
          return;
        }
        if (transition) {
          this._removeTransition(attributeName);
        }
        const TransitionType = TRANSITION_TYPES[settings.type];
        if (TransitionType) {
          this.transitions[attributeName] = new TransitionType({
            attribute,
            timeline: this.timeline,
            gl: this.gl
          });
        } else {
          log_default.error("unsupported transition type '".concat(settings.type, "'"))();
          isNew = false;
        }
      }
      if (isNew || attribute.needsRedraw()) {
        this.needsRedraw = true;
        this.transitions[attributeName].start(settings, this.numInstances);
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/lib/attribute/attribute-manager.js
  var TRACE_INVALIDATE = "attributeManager.invalidate";
  var TRACE_UPDATE_START = "attributeManager.updateStart";
  var TRACE_UPDATE_END = "attributeManager.updateEnd";
  var TRACE_ATTRIBUTE_UPDATE_START = "attribute.updateStart";
  var TRACE_ATTRIBUTE_ALLOCATE = "attribute.allocate";
  var TRACE_ATTRIBUTE_UPDATE_END = "attribute.updateEnd";
  var AttributeManager = class {
    constructor(gl, {
      id: id2 = "attribute-manager",
      stats,
      timeline
    } = {}) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "gl", void 0);
      _defineProperty(this, "attributes", void 0);
      _defineProperty(this, "updateTriggers", void 0);
      _defineProperty(this, "needsRedraw", void 0);
      _defineProperty(this, "userData", void 0);
      _defineProperty(this, "stats", void 0);
      _defineProperty(this, "attributeTransitionManager", void 0);
      _defineProperty(this, "mergeBoundsMemoized", memoize(mergeBounds));
      this.id = id2;
      this.gl = gl;
      this.attributes = {};
      this.updateTriggers = {};
      this.needsRedraw = true;
      this.userData = {};
      this.stats = stats;
      this.attributeTransitionManager = new AttributeTransitionManager(gl, {
        id: "".concat(id2, "-transitions"),
        timeline
      });
      Object.seal(this);
    }
    finalize() {
      for (const attributeName in this.attributes) {
        this.attributes[attributeName].delete();
      }
      this.attributeTransitionManager.finalize();
    }
    getNeedsRedraw(opts = {
      clearRedrawFlags: false
    }) {
      const redraw = this.needsRedraw;
      this.needsRedraw = this.needsRedraw && !opts.clearRedrawFlags;
      return redraw && this.id;
    }
    setNeedsRedraw() {
      this.needsRedraw = true;
    }
    add(attributes) {
      this._add(attributes);
    }
    addInstanced(attributes) {
      this._add(attributes, {
        instanced: 1
      });
    }
    remove(attributeNameArray) {
      for (const name16 of attributeNameArray) {
        if (this.attributes[name16] !== void 0) {
          this.attributes[name16].delete();
          delete this.attributes[name16];
        }
      }
    }
    invalidate(triggerName, dataRange) {
      const invalidatedAttributes = this._invalidateTrigger(triggerName, dataRange);
      debug(TRACE_INVALIDATE, this, triggerName, invalidatedAttributes);
    }
    invalidateAll(dataRange) {
      for (const attributeName in this.attributes) {
        this.attributes[attributeName].setNeedsUpdate(attributeName, dataRange);
      }
      debug(TRACE_INVALIDATE, this, "all");
    }
    update({
      data,
      numInstances,
      startIndices = null,
      transitions,
      props = {},
      buffers = {},
      context = {}
    }) {
      let updated = false;
      debug(TRACE_UPDATE_START, this);
      if (this.stats) {
        this.stats.get("Update Attributes").timeStart();
      }
      for (const attributeName in this.attributes) {
        const attribute = this.attributes[attributeName];
        const accessorName = attribute.settings.accessor;
        attribute.startIndices = startIndices;
        attribute.numInstances = numInstances;
        if (props[attributeName]) {
          log_default.removed("props.".concat(attributeName), "data.attributes.".concat(attributeName))();
        }
        if (attribute.setExternalBuffer(buffers[attributeName])) {
        } else if (attribute.setBinaryValue(typeof accessorName === "string" ? buffers[accessorName] : void 0, data.startIndices)) {
        } else if (typeof accessorName === "string" && !buffers[accessorName] && attribute.setConstantValue(props[accessorName])) {
        } else if (attribute.needsUpdate()) {
          updated = true;
          this._updateAttribute({
            attribute,
            numInstances,
            data,
            props,
            context
          });
        }
        this.needsRedraw = this.needsRedraw || attribute.needsRedraw();
      }
      if (updated) {
        debug(TRACE_UPDATE_END, this, numInstances);
      }
      if (this.stats) {
        this.stats.get("Update Attributes").timeEnd();
      }
      this.attributeTransitionManager.update({
        attributes: this.attributes,
        numInstances,
        transitions
      });
    }
    updateTransition() {
      const {
        attributeTransitionManager
      } = this;
      const transitionUpdated = attributeTransitionManager.run();
      this.needsRedraw = this.needsRedraw || transitionUpdated;
      return transitionUpdated;
    }
    getAttributes() {
      return this.attributes;
    }
    getBounds(attributeNames) {
      const bounds = attributeNames.map((attributeName) => {
        var _this$attributes$attr;
        return (_this$attributes$attr = this.attributes[attributeName]) === null || _this$attributes$attr === void 0 ? void 0 : _this$attributes$attr.getBounds();
      });
      return this.mergeBoundsMemoized(bounds);
    }
    getChangedAttributes(opts = {
      clearChangedFlags: false
    }) {
      const {
        attributes,
        attributeTransitionManager
      } = this;
      const changedAttributes = {
        ...attributeTransitionManager.getAttributes()
      };
      for (const attributeName in attributes) {
        const attribute = attributes[attributeName];
        if (attribute.needsRedraw(opts) && !attributeTransitionManager.hasAttribute(attributeName)) {
          changedAttributes[attributeName] = attribute;
        }
      }
      return changedAttributes;
    }
    getShaderAttributes(attributes, excludeAttributes = {}) {
      if (!attributes) {
        attributes = this.getAttributes();
      }
      const shaderAttributes = {};
      for (const attributeName in attributes) {
        if (!excludeAttributes[attributeName]) {
          Object.assign(shaderAttributes, attributes[attributeName].getShaderAttributes());
        }
      }
      return shaderAttributes;
    }
    _add(attributes, extraProps = {}) {
      for (const attributeName in attributes) {
        const attribute = attributes[attributeName];
        this.attributes[attributeName] = this._createAttribute(attributeName, attribute, extraProps);
      }
      this._mapUpdateTriggersToAttributes();
    }
    _createAttribute(name16, attribute, extraProps) {
      const props = {
        ...attribute,
        id: name16,
        size: attribute.isIndexed && 1 || attribute.size || 1,
        divisor: extraProps.instanced ? 1 : attribute.divisor || 0
      };
      return new Attribute(this.gl, props);
    }
    _mapUpdateTriggersToAttributes() {
      const triggers = {};
      for (const attributeName in this.attributes) {
        const attribute = this.attributes[attributeName];
        attribute.getUpdateTriggers().forEach((triggerName) => {
          if (!triggers[triggerName]) {
            triggers[triggerName] = [];
          }
          triggers[triggerName].push(attributeName);
        });
      }
      this.updateTriggers = triggers;
    }
    _invalidateTrigger(triggerName, dataRange) {
      const {
        attributes,
        updateTriggers
      } = this;
      const invalidatedAttributes = updateTriggers[triggerName];
      if (invalidatedAttributes) {
        invalidatedAttributes.forEach((name16) => {
          const attribute = attributes[name16];
          if (attribute) {
            attribute.setNeedsUpdate(attribute.id, dataRange);
          }
        });
      }
      return invalidatedAttributes;
    }
    _updateAttribute(opts) {
      const {
        attribute,
        numInstances
      } = opts;
      debug(TRACE_ATTRIBUTE_UPDATE_START, attribute);
      if (attribute.constant) {
        attribute.setConstantValue(attribute.value);
        return;
      }
      if (attribute.allocate(numInstances)) {
        debug(TRACE_ATTRIBUTE_ALLOCATE, attribute, numInstances);
      }
      const updated = attribute.updateBuffer(opts);
      if (updated) {
        this.needsRedraw = true;
        debug(TRACE_ATTRIBUTE_UPDATE_END, attribute, numInstances);
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/transitions/cpu-interpolation-transition.js
  var CPUInterpolationTransition = class extends Transition {
    get value() {
      return this._value;
    }
    _onUpdate() {
      const {
        time,
        settings: {
          fromValue,
          toValue,
          duration: duration2,
          easing
        }
      } = this;
      const t = easing(time / duration2);
      this._value = lerp(fromValue, toValue, t);
    }
  };

  // node_modules/@deck.gl/core/dist/esm/transitions/cpu-spring-transition.js
  var EPSILON3 = 1e-5;
  function updateSpringElement(prev, cur, dest, damping, stiffness) {
    const velocity = cur - prev;
    const delta = dest - cur;
    const spring = delta * stiffness;
    const damper = -velocity * damping;
    return spring + damper + velocity + cur;
  }
  function updateSpring(prev, cur, dest, damping, stiffness) {
    if (Array.isArray(dest)) {
      const next = [];
      for (let i = 0; i < dest.length; i++) {
        next[i] = updateSpringElement(prev[i], cur[i], dest[i], damping, stiffness);
      }
      return next;
    }
    return updateSpringElement(prev, cur, dest, damping, stiffness);
  }
  function distance(value1, value22) {
    if (Array.isArray(value1)) {
      let distanceSquare = 0;
      for (let i = 0; i < value1.length; i++) {
        const d = value1[i] - value22[i];
        distanceSquare += d * d;
      }
      return Math.sqrt(distanceSquare);
    }
    return Math.abs(value1 - value22);
  }
  var CPUSpringTransition = class extends Transition {
    get value() {
      return this._currValue;
    }
    _onUpdate() {
      const {
        fromValue,
        toValue,
        damping,
        stiffness
      } = this.settings;
      const {
        _prevValue = fromValue,
        _currValue = fromValue
      } = this;
      let nextValue = updateSpring(_prevValue, _currValue, toValue, damping, stiffness);
      const delta = distance(nextValue, toValue);
      const velocity = distance(nextValue, _currValue);
      if (delta < EPSILON3 && velocity < EPSILON3) {
        nextValue = toValue;
        this.end();
      }
      this._prevValue = _currValue;
      this._currValue = nextValue;
    }
  };

  // node_modules/@deck.gl/core/dist/esm/lib/uniform-transition-manager.js
  var TRANSITION_TYPES2 = {
    interpolation: CPUInterpolationTransition,
    spring: CPUSpringTransition
  };
  var UniformTransitionManager = class {
    constructor(timeline) {
      this.transitions = /* @__PURE__ */ new Map();
      this.timeline = timeline;
    }
    get active() {
      return this.transitions.size > 0;
    }
    add(key, fromValue, toValue, settings) {
      const {
        transitions
      } = this;
      if (transitions.has(key)) {
        const transition2 = transitions.get(key);
        const {
          value: value13 = transition2.settings.fromValue
        } = transition2;
        fromValue = value13;
        this.remove(key);
      }
      settings = normalizeTransitionSettings(settings);
      if (!settings) {
        return;
      }
      const TransitionType = TRANSITION_TYPES2[settings.type];
      if (!TransitionType) {
        log_default.error("unsupported transition type '".concat(settings.type, "'"))();
        return;
      }
      const transition = new TransitionType(this.timeline);
      transition.start({
        ...settings,
        fromValue,
        toValue
      });
      transitions.set(key, transition);
    }
    remove(key) {
      const {
        transitions
      } = this;
      if (transitions.has(key)) {
        transitions.get(key).cancel();
        transitions.delete(key);
      }
    }
    update() {
      const propsInTransition = {};
      for (const [key, transition] of this.transitions) {
        transition.update();
        propsInTransition[key] = transition.value;
        if (!transition.inProgress) {
          this.remove(key);
        }
      }
      return propsInTransition;
    }
    clear() {
      for (const key of this.transitions.keys()) {
        this.remove(key);
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/lifecycle/props.js
  function validateProps(props) {
    const propTypes16 = props[PROP_TYPES_SYMBOL];
    for (const propName in propTypes16) {
      const propType = propTypes16[propName];
      const {
        validate
      } = propType;
      if (validate && !validate(props[propName], propType)) {
        throw new Error("Invalid prop ".concat(propName, ": ").concat(props[propName]));
      }
    }
  }
  function diffProps(props, oldProps) {
    const propsChangedReason = compareProps({
      newProps: props,
      oldProps,
      propTypes: props[PROP_TYPES_SYMBOL],
      ignoreProps: {
        data: null,
        updateTriggers: null,
        extensions: null,
        transitions: null
      }
    });
    const dataChangedReason = diffDataProps(props, oldProps);
    let updateTriggersChangedReason = false;
    if (!dataChangedReason) {
      updateTriggersChangedReason = diffUpdateTriggers(props, oldProps);
    }
    return {
      dataChanged: dataChangedReason,
      propsChanged: propsChangedReason,
      updateTriggersChanged: updateTriggersChangedReason,
      extensionsChanged: diffExtensions(props, oldProps),
      transitionsChanged: diffTransitions(props, oldProps)
    };
  }
  function diffTransitions(props, oldProps) {
    if (!props.transitions) {
      return false;
    }
    const result = {};
    const propTypes16 = props[PROP_TYPES_SYMBOL];
    let changed = false;
    for (const key in props.transitions) {
      const propType = propTypes16[key];
      const type = propType && propType.type;
      const isTransitionable = type === "number" || type === "color" || type === "array";
      if (isTransitionable && comparePropValues(props[key], oldProps[key], propType)) {
        result[key] = true;
        changed = true;
      }
    }
    return changed ? result : false;
  }
  function compareProps({
    newProps,
    oldProps,
    ignoreProps = {},
    propTypes: propTypes16 = {},
    triggerName = "props"
  }) {
    if (oldProps === newProps) {
      return false;
    }
    if (typeof newProps !== "object" || newProps === null) {
      return "".concat(triggerName, " changed shallowly");
    }
    if (typeof oldProps !== "object" || oldProps === null) {
      return "".concat(triggerName, " changed shallowly");
    }
    for (const key of Object.keys(newProps)) {
      if (!(key in ignoreProps)) {
        if (!(key in oldProps)) {
          return "".concat(triggerName, ".").concat(key, " added");
        }
        const changed = comparePropValues(newProps[key], oldProps[key], propTypes16[key]);
        if (changed) {
          return "".concat(triggerName, ".").concat(key, " ").concat(changed);
        }
      }
    }
    for (const key of Object.keys(oldProps)) {
      if (!(key in ignoreProps)) {
        if (!(key in newProps)) {
          return "".concat(triggerName, ".").concat(key, " dropped");
        }
        if (!Object.hasOwnProperty.call(newProps, key)) {
          const changed = comparePropValues(newProps[key], oldProps[key], propTypes16[key]);
          if (changed) {
            return "".concat(triggerName, ".").concat(key, " ").concat(changed);
          }
        }
      }
    }
    return false;
  }
  function comparePropValues(newProp, oldProp, propType) {
    let equal = propType && propType.equal;
    if (equal && !equal(newProp, oldProp, propType)) {
      return "changed deeply";
    }
    if (!equal) {
      equal = newProp && oldProp && newProp.equals;
      if (equal && !equal.call(newProp, oldProp)) {
        return "changed deeply";
      }
    }
    if (!equal && oldProp !== newProp) {
      return "changed shallowly";
    }
    return null;
  }
  function diffDataProps(props, oldProps) {
    if (oldProps === null) {
      return "oldProps is null, initial diff";
    }
    let dataChanged = false;
    const {
      dataComparator,
      _dataDiff
    } = props;
    if (dataComparator) {
      if (!dataComparator(props.data, oldProps.data)) {
        dataChanged = "Data comparator detected a change";
      }
    } else if (props.data !== oldProps.data) {
      dataChanged = "A new data container was supplied";
    }
    if (dataChanged && _dataDiff) {
      dataChanged = _dataDiff(props.data, oldProps.data) || dataChanged;
    }
    return dataChanged;
  }
  function diffUpdateTriggers(props, oldProps) {
    if (oldProps === null) {
      return {
        all: true
      };
    }
    if ("all" in props.updateTriggers) {
      const diffReason = diffUpdateTrigger(props, oldProps, "all");
      if (diffReason) {
        return {
          all: true
        };
      }
    }
    const reason = {};
    let changed = false;
    for (const triggerName in props.updateTriggers) {
      if (triggerName !== "all") {
        const diffReason = diffUpdateTrigger(props, oldProps, triggerName);
        if (diffReason) {
          reason[triggerName] = true;
          changed = true;
        }
      }
    }
    return changed ? reason : false;
  }
  function diffExtensions(props, oldProps) {
    if (oldProps === null) {
      return true;
    }
    const oldExtensions = oldProps.extensions;
    const {
      extensions
    } = props;
    if (extensions === oldExtensions) {
      return false;
    }
    if (!oldExtensions || !extensions) {
      return true;
    }
    if (extensions.length !== oldExtensions.length) {
      return true;
    }
    for (let i = 0; i < extensions.length; i++) {
      if (!extensions[i].equals(oldExtensions[i])) {
        return true;
      }
    }
    return false;
  }
  function diffUpdateTrigger(props, oldProps, triggerName) {
    let newTriggers = props.updateTriggers[triggerName];
    newTriggers = newTriggers === void 0 || newTriggers === null ? {} : newTriggers;
    let oldTriggers = oldProps.updateTriggers[triggerName];
    oldTriggers = oldTriggers === void 0 || oldTriggers === null ? {} : oldTriggers;
    const diffReason = compareProps({
      oldProps: oldTriggers,
      newProps: newTriggers,
      triggerName
    });
    return diffReason;
  }

  // node_modules/@deck.gl/core/dist/esm/utils/count.js
  var ERR_NOT_OBJECT = "count(): argument not an object";
  var ERR_NOT_CONTAINER = "count(): argument not a container";
  function count(container) {
    if (!isObject2(container)) {
      throw new Error(ERR_NOT_OBJECT);
    }
    if (typeof container.count === "function") {
      return container.count();
    }
    if (Number.isFinite(container.size)) {
      return container.size;
    }
    if (Number.isFinite(container.length)) {
      return container.length;
    }
    if (isPlainObject(container)) {
      return Object.keys(container).length;
    }
    throw new Error(ERR_NOT_CONTAINER);
  }
  function isPlainObject(value13) {
    return value13 !== null && typeof value13 === "object" && value13.constructor === Object;
  }
  function isObject2(value13) {
    return value13 !== null && typeof value13 === "object";
  }

  // node_modules/@deck.gl/core/dist/esm/utils/shader.js
  function mergeShaders(target5, source) {
    if (!source) {
      return target5;
    }
    const result = {
      ...target5,
      ...source
    };
    if ("defines" in source) {
      result.defines = {
        ...target5.defines,
        ...source.defines
      };
    }
    if ("modules" in source) {
      result.modules = (target5.modules || []).concat(source.modules);
      if (source.modules.some((module) => module.name === "project64")) {
        const index5 = result.modules.findIndex((module) => module.name === "project32");
        if (index5 >= 0) {
          result.modules.splice(index5, 1);
        }
      }
    }
    if ("inject" in source) {
      if (!target5.inject) {
        result.inject = source.inject;
      } else {
        const mergedInjection = {
          ...target5.inject
        };
        for (const key in source.inject) {
          mergedInjection[key] = (mergedInjection[key] || "") + source.inject[key];
        }
        result.inject = mergedInjection;
      }
    }
    return result;
  }

  // node_modules/@deck.gl/core/dist/esm/utils/texture.js
  var DEFAULT_TEXTURE_PARAMETERS = {
    [10241]: 9987,
    [10240]: 9729,
    [10242]: 33071,
    [10243]: 33071
  };
  var internalTextures = {};
  function createTexture(owner, gl, image, parameters) {
    if (image instanceof Texture2D) {
      return image;
    } else if (image.constructor && image.constructor.name !== "Object") {
      image = {
        data: image
      };
    }
    let specialTextureParameters = null;
    if (image.compressed) {
      specialTextureParameters = {
        [10241]: image.data.length > 1 ? 9985 : 9729
      };
    }
    const texture = new Texture2D(gl, {
      ...image,
      parameters: {
        ...DEFAULT_TEXTURE_PARAMETERS,
        ...specialTextureParameters,
        ...parameters
      }
    });
    internalTextures[texture.id] = owner;
    return texture;
  }
  function destroyTexture(owner, texture) {
    if (!texture || !(texture instanceof Texture2D)) {
      return;
    }
    if (internalTextures[texture.id] === owner) {
      texture.delete();
      delete internalTextures[texture.id];
    }
  }

  // node_modules/@deck.gl/core/dist/esm/lifecycle/prop-types.js
  var TYPE_DEFINITIONS2 = {
    boolean: {
      validate(value13, propType) {
        return true;
      },
      equal(value1, value22, propType) {
        return Boolean(value1) === Boolean(value22);
      }
    },
    number: {
      validate(value13, propType) {
        return Number.isFinite(value13) && (!("max" in propType) || value13 <= propType.max) && (!("min" in propType) || value13 >= propType.min);
      }
    },
    color: {
      validate(value13, propType) {
        return propType.optional && !value13 || isArray3(value13) && (value13.length === 3 || value13.length === 4);
      },
      equal(value1, value22, propType) {
        return deepEqual(value1, value22, 1);
      }
    },
    accessor: {
      validate(value13, propType) {
        const valueType = getTypeOf2(value13);
        return valueType === "function" || valueType === getTypeOf2(propType.value);
      },
      equal(value1, value22, propType) {
        if (typeof value22 === "function") {
          return true;
        }
        return deepEqual(value1, value22, 1);
      }
    },
    array: {
      validate(value13, propType) {
        return propType.optional && !value13 || isArray3(value13);
      },
      equal(value1, value22, propType) {
        const {
          compare: compare2
        } = propType;
        const depth = Number.isInteger(compare2) ? compare2 : compare2 ? 1 : 0;
        return compare2 ? deepEqual(value1, value22, depth) : value1 === value22;
      }
    },
    object: {
      equal(value1, value22, propType) {
        if (propType.ignore) {
          return true;
        }
        const {
          compare: compare2
        } = propType;
        const depth = Number.isInteger(compare2) ? compare2 : compare2 ? 1 : 0;
        return compare2 ? deepEqual(value1, value22, depth) : value1 === value22;
      }
    },
    function: {
      validate(value13, propType) {
        return propType.optional && !value13 || typeof value13 === "function";
      },
      equal(value1, value22, propType) {
        const shouldIgnore = !propType.compare && propType.ignore !== false;
        return shouldIgnore || value1 === value22;
      }
    },
    data: {
      transform: (value13, propType, component2) => {
        const {
          dataTransform
        } = component2.props;
        return dataTransform && value13 ? dataTransform(value13) : value13;
      }
    },
    image: {
      transform: (value13, propType, component2) => {
        const context = component2.context;
        if (!context || !context.gl) {
          return null;
        }
        return createTexture(component2.id, context.gl, value13, {
          ...propType.parameters,
          ...component2.props.textureParameters
        });
      },
      release: (value13, propType, component2) => {
        destroyTexture(component2.id, value13);
      }
    }
  };
  function parsePropTypes2(propDefs) {
    const propTypes16 = {};
    const defaultProps19 = {};
    const deprecatedProps = {};
    for (const [propName, propDef] of Object.entries(propDefs)) {
      const deprecated = propDef === null || propDef === void 0 ? void 0 : propDef.deprecatedFor;
      if (deprecated) {
        deprecatedProps[propName] = Array.isArray(deprecated) ? deprecated : [deprecated];
      } else {
        const propType = parsePropType2(propName, propDef);
        propTypes16[propName] = propType;
        defaultProps19[propName] = propType.value;
      }
    }
    return {
      propTypes: propTypes16,
      defaultProps: defaultProps19,
      deprecatedProps
    };
  }
  function parsePropType2(name16, propDef) {
    switch (getTypeOf2(propDef)) {
      case "object":
        return normalizePropDefinition(name16, propDef);
      case "array":
        return normalizePropDefinition(name16, {
          type: "array",
          value: propDef,
          compare: false
        });
      case "boolean":
        return normalizePropDefinition(name16, {
          type: "boolean",
          value: propDef
        });
      case "number":
        return normalizePropDefinition(name16, {
          type: "number",
          value: propDef
        });
      case "function":
        return normalizePropDefinition(name16, {
          type: "function",
          value: propDef,
          compare: true
        });
      default:
        return {
          name: name16,
          type: "unknown",
          value: propDef
        };
    }
  }
  function normalizePropDefinition(name16, propDef) {
    if (!("type" in propDef)) {
      if (!("value" in propDef)) {
        return {
          name: name16,
          type: "object",
          value: propDef
        };
      }
      return {
        name: name16,
        type: getTypeOf2(propDef.value),
        ...propDef
      };
    }
    return {
      name: name16,
      ...TYPE_DEFINITIONS2[propDef.type],
      ...propDef
    };
  }
  function isArray3(value13) {
    return Array.isArray(value13) || ArrayBuffer.isView(value13);
  }
  function getTypeOf2(value13) {
    if (isArray3(value13)) {
      return "array";
    }
    if (value13 === null) {
      return "null";
    }
    return typeof value13;
  }

  // node_modules/@deck.gl/core/dist/esm/lifecycle/create-props.js
  function createProps(component2, propObjects) {
    let extensions;
    for (let i = propObjects.length - 1; i >= 0; i--) {
      const props = propObjects[i];
      if ("extensions" in props) {
        extensions = props.extensions;
      }
    }
    const propsPrototype = getPropsPrototype(component2.constructor, extensions);
    const propsInstance = Object.create(propsPrototype);
    propsInstance[COMPONENT_SYMBOL] = component2;
    propsInstance[ASYNC_ORIGINAL_SYMBOL] = {};
    propsInstance[ASYNC_RESOLVED_SYMBOL] = {};
    for (let i = 0; i < propObjects.length; ++i) {
      const props = propObjects[i];
      for (const key in props) {
        propsInstance[key] = props[key];
      }
    }
    Object.freeze(propsInstance);
    return propsInstance;
  }
  var MergedDefaultPropsCacheKey = "_mergedDefaultProps";
  function getPropsPrototype(componentClass, extensions) {
    let cacheKey = MergedDefaultPropsCacheKey;
    if (extensions) {
      for (const extension of extensions) {
        const ExtensionClass = extension.constructor;
        if (ExtensionClass) {
          cacheKey += ":".concat(ExtensionClass.extensionName || ExtensionClass.name);
        }
      }
    }
    const defaultProps19 = getOwnProperty(componentClass, cacheKey);
    if (!defaultProps19) {
      return componentClass[cacheKey] = createPropsPrototypeAndTypes(componentClass, extensions || []);
    }
    return defaultProps19;
  }
  function createPropsPrototypeAndTypes(componentClass, extensions) {
    const parent2 = componentClass.prototype;
    if (!parent2) {
      return null;
    }
    const parentClass = Object.getPrototypeOf(componentClass);
    const parentDefaultProps = getPropsPrototype(parentClass);
    const componentDefaultProps = getOwnProperty(componentClass, "defaultProps") || {};
    const componentPropDefs = parsePropTypes2(componentDefaultProps);
    const defaultProps19 = Object.assign(/* @__PURE__ */ Object.create(null), parentDefaultProps, componentPropDefs.defaultProps);
    const propTypes16 = Object.assign(/* @__PURE__ */ Object.create(null), parentDefaultProps === null || parentDefaultProps === void 0 ? void 0 : parentDefaultProps[PROP_TYPES_SYMBOL], componentPropDefs.propTypes);
    const deprecatedProps = Object.assign(/* @__PURE__ */ Object.create(null), parentDefaultProps === null || parentDefaultProps === void 0 ? void 0 : parentDefaultProps[DEPRECATED_PROPS_SYMBOL], componentPropDefs.deprecatedProps);
    for (const extension of extensions) {
      const extensionDefaultProps = getPropsPrototype(extension.constructor);
      if (extensionDefaultProps) {
        Object.assign(defaultProps19, extensionDefaultProps);
        Object.assign(propTypes16, extensionDefaultProps[PROP_TYPES_SYMBOL]);
        Object.assign(deprecatedProps, extensionDefaultProps[DEPRECATED_PROPS_SYMBOL]);
      }
    }
    createPropsPrototype(defaultProps19, componentClass);
    addAsyncPropsToPropPrototype(defaultProps19, propTypes16);
    addDeprecatedPropsToPropPrototype(defaultProps19, deprecatedProps);
    defaultProps19[PROP_TYPES_SYMBOL] = propTypes16;
    defaultProps19[DEPRECATED_PROPS_SYMBOL] = deprecatedProps;
    if (extensions.length === 0 && !hasOwnProperty2(componentClass, "_propTypes")) {
      componentClass._propTypes = propTypes16;
    }
    return defaultProps19;
  }
  function createPropsPrototype(defaultProps19, componentClass) {
    const id2 = getComponentName(componentClass);
    Object.defineProperties(defaultProps19, {
      id: {
        writable: true,
        value: id2
      }
    });
  }
  function addDeprecatedPropsToPropPrototype(defaultProps19, deprecatedProps) {
    for (const propName in deprecatedProps) {
      Object.defineProperty(defaultProps19, propName, {
        enumerable: false,
        set(newValue) {
          const nameStr = "".concat(this.id, ": ").concat(propName);
          for (const newPropName of deprecatedProps[propName]) {
            if (!hasOwnProperty2(this, newPropName)) {
              this[newPropName] = newValue;
            }
          }
          log_default.deprecated(nameStr, deprecatedProps[propName].join("/"))();
        }
      });
    }
  }
  function addAsyncPropsToPropPrototype(defaultProps19, propTypes16) {
    const defaultValues = {};
    const descriptors = {};
    for (const propName in propTypes16) {
      const propType = propTypes16[propName];
      const {
        name: name16,
        value: value13
      } = propType;
      if (propType.async) {
        defaultValues[name16] = value13;
        descriptors[name16] = getDescriptorForAsyncProp(name16);
      }
    }
    defaultProps19[ASYNC_DEFAULTS_SYMBOL] = defaultValues;
    defaultProps19[ASYNC_ORIGINAL_SYMBOL] = {};
    Object.defineProperties(defaultProps19, descriptors);
  }
  function getDescriptorForAsyncProp(name16) {
    return {
      enumerable: true,
      set(newValue) {
        if (typeof newValue === "string" || newValue instanceof Promise || isAsyncIterable2(newValue)) {
          this[ASYNC_ORIGINAL_SYMBOL][name16] = newValue;
        } else {
          this[ASYNC_RESOLVED_SYMBOL][name16] = newValue;
        }
      },
      get() {
        if (this[ASYNC_RESOLVED_SYMBOL]) {
          if (name16 in this[ASYNC_RESOLVED_SYMBOL]) {
            const value13 = this[ASYNC_RESOLVED_SYMBOL][name16];
            return value13 || this[ASYNC_DEFAULTS_SYMBOL][name16];
          }
          if (name16 in this[ASYNC_ORIGINAL_SYMBOL]) {
            const state3 = this[COMPONENT_SYMBOL] && this[COMPONENT_SYMBOL].internalState;
            if (state3 && state3.hasAsyncProp(name16)) {
              return state3.getAsyncProp(name16) || this[ASYNC_DEFAULTS_SYMBOL][name16];
            }
          }
        }
        return this[ASYNC_DEFAULTS_SYMBOL][name16];
      }
    };
  }
  function hasOwnProperty2(object12, prop) {
    return Object.prototype.hasOwnProperty.call(object12, prop);
  }
  function getOwnProperty(object12, prop) {
    return hasOwnProperty2(object12, prop) && object12[prop];
  }
  function getComponentName(componentClass) {
    const componentName = componentClass.componentName;
    if (!componentName) {
      log_default.warn("".concat(componentClass.name, ".componentName not specified"))();
    }
    return componentName || componentClass.name;
  }

  // node_modules/@deck.gl/core/dist/esm/lifecycle/component.js
  var counter = 0;
  var Component = class {
    constructor(...propObjects) {
      _defineProperty(this, "id", void 0);
      _defineProperty(this, "props", void 0);
      _defineProperty(this, "count", void 0);
      this.props = createProps(this, propObjects);
      this.id = this.props.id;
      this.count = counter++;
    }
    clone(newProps) {
      const {
        props
      } = this;
      const asyncProps = {};
      for (const key in props[ASYNC_DEFAULTS_SYMBOL]) {
        if (key in props[ASYNC_RESOLVED_SYMBOL]) {
          asyncProps[key] = props[ASYNC_RESOLVED_SYMBOL][key];
        } else if (key in props[ASYNC_ORIGINAL_SYMBOL]) {
          asyncProps[key] = props[ASYNC_ORIGINAL_SYMBOL][key];
        }
      }
      return new this.constructor({
        ...props,
        ...asyncProps,
        ...newProps
      });
    }
  };
  _defineProperty(Component, "componentName", "Component");
  _defineProperty(Component, "defaultProps", {});

  // node_modules/@deck.gl/core/dist/esm/lifecycle/component-state.js
  var EMPTY_PROPS = Object.freeze({});
  var ComponentState = class {
    constructor(component2) {
      _defineProperty(this, "component", void 0);
      _defineProperty(this, "onAsyncPropUpdated", void 0);
      _defineProperty(this, "asyncProps", void 0);
      _defineProperty(this, "oldProps", void 0);
      _defineProperty(this, "oldAsyncProps", void 0);
      this.component = component2;
      this.asyncProps = {};
      this.onAsyncPropUpdated = () => {
      };
      this.oldProps = null;
      this.oldAsyncProps = null;
    }
    finalize() {
      for (const propName in this.asyncProps) {
        const asyncProp = this.asyncProps[propName];
        if (asyncProp && asyncProp.type && asyncProp.type.release) {
          asyncProp.type.release(asyncProp.resolvedValue, asyncProp.type, this.component);
        }
      }
      this.asyncProps = {};
      this.component = null;
      this.resetOldProps();
    }
    getOldProps() {
      return this.oldAsyncProps || this.oldProps || EMPTY_PROPS;
    }
    resetOldProps() {
      this.oldAsyncProps = null;
      this.oldProps = this.component ? this.component.props : null;
    }
    hasAsyncProp(propName) {
      return propName in this.asyncProps;
    }
    getAsyncProp(propName) {
      const asyncProp = this.asyncProps[propName];
      return asyncProp && asyncProp.resolvedValue;
    }
    isAsyncPropLoading(propName) {
      if (propName) {
        const asyncProp = this.asyncProps[propName];
        return Boolean(asyncProp && asyncProp.pendingLoadCount > 0 && asyncProp.pendingLoadCount !== asyncProp.resolvedLoadCount);
      }
      for (const key in this.asyncProps) {
        if (this.isAsyncPropLoading(key)) {
          return true;
        }
      }
      return false;
    }
    reloadAsyncProp(propName, value13) {
      this._watchPromise(propName, Promise.resolve(value13));
    }
    setAsyncProps(props) {
      this.component = props[COMPONENT_SYMBOL] || this.component;
      const resolvedValues = props[ASYNC_RESOLVED_SYMBOL] || {};
      const originalValues = props[ASYNC_ORIGINAL_SYMBOL] || props;
      const defaultValues = props[ASYNC_DEFAULTS_SYMBOL] || {};
      for (const propName in resolvedValues) {
        const value13 = resolvedValues[propName];
        this._createAsyncPropData(propName, defaultValues[propName]);
        this._updateAsyncProp(propName, value13);
        resolvedValues[propName] = this.getAsyncProp(propName);
      }
      for (const propName in originalValues) {
        const value13 = originalValues[propName];
        this._createAsyncPropData(propName, defaultValues[propName]);
        this._updateAsyncProp(propName, value13);
      }
    }
    _fetch(propName, url) {
      return null;
    }
    _onResolve(propName, value13) {
    }
    _onError(propName, error3) {
    }
    _updateAsyncProp(propName, value13) {
      if (!this._didAsyncInputValueChange(propName, value13)) {
        return;
      }
      if (typeof value13 === "string") {
        value13 = this._fetch(propName, value13);
      }
      if (value13 instanceof Promise) {
        this._watchPromise(propName, value13);
        return;
      }
      if (isAsyncIterable2(value13)) {
        this._resolveAsyncIterable(propName, value13);
        return;
      }
      this._setPropValue(propName, value13);
    }
    _freezeAsyncOldProps() {
      if (!this.oldAsyncProps && this.oldProps) {
        this.oldAsyncProps = Object.create(this.oldProps);
        for (const propName in this.asyncProps) {
          Object.defineProperty(this.oldAsyncProps, propName, {
            enumerable: true,
            value: this.oldProps[propName]
          });
        }
      }
    }
    _didAsyncInputValueChange(propName, value13) {
      const asyncProp = this.asyncProps[propName];
      if (value13 === asyncProp.resolvedValue || value13 === asyncProp.lastValue) {
        return false;
      }
      asyncProp.lastValue = value13;
      return true;
    }
    _setPropValue(propName, value13) {
      this._freezeAsyncOldProps();
      const asyncProp = this.asyncProps[propName];
      if (asyncProp) {
        value13 = this._postProcessValue(asyncProp, value13);
        asyncProp.resolvedValue = value13;
        asyncProp.pendingLoadCount++;
        asyncProp.resolvedLoadCount = asyncProp.pendingLoadCount;
      }
    }
    _setAsyncPropValue(propName, value13, loadCount) {
      const asyncProp = this.asyncProps[propName];
      if (asyncProp && loadCount >= asyncProp.resolvedLoadCount && value13 !== void 0) {
        this._freezeAsyncOldProps();
        asyncProp.resolvedValue = value13;
        asyncProp.resolvedLoadCount = loadCount;
        this.onAsyncPropUpdated(propName, value13);
      }
    }
    _watchPromise(propName, promise) {
      const asyncProp = this.asyncProps[propName];
      if (asyncProp) {
        asyncProp.pendingLoadCount++;
        const loadCount = asyncProp.pendingLoadCount;
        promise.then((data) => {
          if (!this.component) {
            return;
          }
          data = this._postProcessValue(asyncProp, data);
          this._setAsyncPropValue(propName, data, loadCount);
          this._onResolve(propName, data);
        }).catch((error3) => {
          this._onError(propName, error3);
        });
      }
    }
    async _resolveAsyncIterable(propName, iterable) {
      if (propName !== "data") {
        this._setPropValue(propName, iterable);
        return;
      }
      const asyncProp = this.asyncProps[propName];
      if (!asyncProp) {
        return;
      }
      asyncProp.pendingLoadCount++;
      const loadCount = asyncProp.pendingLoadCount;
      let data = [];
      let count2 = 0;
      for await (const chunk of iterable) {
        if (!this.component) {
          return;
        }
        const {
          dataTransform
        } = this.component.props;
        if (dataTransform) {
          data = dataTransform(chunk, data);
        } else {
          data = data.concat(chunk);
        }
        Object.defineProperty(data, "__diff", {
          enumerable: false,
          value: [{
            startRow: count2,
            endRow: data.length
          }]
        });
        count2 = data.length;
        this._setAsyncPropValue(propName, data, loadCount);
      }
      this._onResolve(propName, data);
    }
    _postProcessValue(asyncProp, value13) {
      const propType = asyncProp.type;
      if (propType && this.component) {
        if (propType.release) {
          propType.release(asyncProp.resolvedValue, propType, this.component);
        }
        if (propType.transform) {
          return propType.transform(value13, propType, this.component);
        }
      }
      return value13;
    }
    _createAsyncPropData(propName, defaultValue4) {
      const asyncProp = this.asyncProps[propName];
      if (!asyncProp) {
        const propTypes16 = this.component && this.component.props[PROP_TYPES_SYMBOL];
        this.asyncProps[propName] = {
          type: propTypes16 && propTypes16[propName],
          lastValue: null,
          resolvedValue: defaultValue4,
          pendingLoadCount: 0,
          resolvedLoadCount: 0
        };
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/lib/layer-state.js
  var LayerState = class extends ComponentState {
    constructor({
      attributeManager,
      layer
    }) {
      super(layer);
      _defineProperty(this, "attributeManager", void 0);
      _defineProperty(this, "needsRedraw", void 0);
      _defineProperty(this, "needsUpdate", void 0);
      _defineProperty(this, "subLayers", void 0);
      _defineProperty(this, "usesPickingColorCache", void 0);
      _defineProperty(this, "hasPickingBuffer", void 0);
      _defineProperty(this, "changeFlags", void 0);
      _defineProperty(this, "viewport", void 0);
      _defineProperty(this, "uniformTransitions", void 0);
      _defineProperty(this, "propsInTransition", void 0);
      this.attributeManager = attributeManager;
      this.needsRedraw = true;
      this.needsUpdate = true;
      this.subLayers = null;
      this.usesPickingColorCache = false;
    }
    get layer() {
      return this.component;
    }
    _fetch(propName, url) {
      const layer = this.layer;
      const fetch2 = layer === null || layer === void 0 ? void 0 : layer.props.fetch;
      if (fetch2) {
        return fetch2(url, {
          propName,
          layer
        });
      }
      return super._fetch(propName, url);
    }
    _onResolve(propName, value13) {
      const layer = this.layer;
      if (layer) {
        const onDataLoad = layer.props.onDataLoad;
        if (propName === "data" && onDataLoad) {
          onDataLoad(value13, {
            propName,
            layer
          });
        }
      }
    }
    _onError(propName, error3) {
      const layer = this.layer;
      if (layer) {
        layer.raiseError(error3, "loading ".concat(propName, " of ").concat(this.layer));
      }
    }
  };

  // node_modules/@deck.gl/core/dist/esm/lib/layer.js
  var TRACE_CHANGE_FLAG = "layer.changeFlag";
  var TRACE_INITIALIZE = "layer.initialize";
  var TRACE_UPDATE = "layer.update";
  var TRACE_FINALIZE = "layer.finalize";
  var TRACE_MATCHED = "layer.matched";
  var MAX_PICKING_COLOR_CACHE_SIZE = 2 ** 24 - 1;
  var EMPTY_ARRAY2 = Object.freeze([]);
  var areViewportsEqual = memoize(({
    oldViewport,
    viewport
  }) => {
    return oldViewport.equals(viewport);
  });
  var pickingColorCache = new Uint8ClampedArray(0);
  var defaultProps2 = {
    data: {
      type: "data",
      value: EMPTY_ARRAY2,
      async: true
    },
    dataComparator: {
      type: "function",
      value: null,
      optional: true
    },
    _dataDiff: {
      type: "function",
      value: (data) => data && data.__diff,
      optional: true
    },
    dataTransform: {
      type: "function",
      value: null,
      optional: true
    },
    onDataLoad: {
      type: "function",
      value: null,
      optional: true
    },
    onError: {
      type: "function",
      value: null,
      optional: true
    },
    fetch: {
      type: "function",
      value: (url, {
        propName,
        layer,
        loaders,
        loadOptions,
        signal
      }) => {
        const {
          resourceManager
        } = layer.context;
        loadOptions = loadOptions || layer.getLoadOptions();
        loaders = loaders || layer.props.loaders;
        if (signal) {
          var _loadOptions;
          loadOptions = {
            ...loadOptions,
            fetch: {
              ...(_loadOptions = loadOptions) === null || _loadOptions === void 0 ? void 0 : _loadOptions.fetch,
              signal
            }
          };
        }
        let inResourceManager = resourceManager.contains(url);
        if (!inResourceManager && !loadOptions) {
          resourceManager.add({
            resourceId: url,
            data: load(url, loaders),
            persistent: false
          });
          inResourceManager = true;
        }
        if (inResourceManager) {
          return resourceManager.subscribe({
            resourceId: url,
            onChange: (data) => {
              var _layer$internalState;
              return (_layer$internalState = layer.internalState) === null || _layer$internalState === void 0 ? void 0 : _layer$internalState.reloadAsyncProp(propName, data);
            },
            consumerId: layer.id,
            requestId: propName
          });
        }
        return load(url, loaders, loadOptions);
      }
    },
    updateTriggers: {},
    visible: true,
    pickable: false,
    opacity: {
      type: "number",
      min: 0,
      max: 1,
      value: 1
    },
    operation: "draw",
    onHover: {
      type: "function",
      value: null,
      optional: true
    },
    onClick: {
      type: "function",
      value: null,
      optional: true
    },
    onDragStart: {
      type: "function",
      value: null,
      optional: true
    },
    onDrag: {
      type: "function",
      value: null,
      optional: true
    },
    onDragEnd: {
      type: "function",
      value: null,
      optional: true
    },
    coordinateSystem: COORDINATE_SYSTEM.DEFAULT,
    coordinateOrigin: {
      type: "array",
      value: [0, 0, 0],
      compare: true
    },
    modelMatrix: {
      type: "array",
      value: null,
      compare: true,
      optional: true
    },
    wrapLongitude: false,
    positionFormat: "XYZ",
    colorFormat: "RGBA",
    parameters: {
      type: "object",
      value: {},
      optional: true,
      compare: 2
    },
    loadOptions: {
      type: "object",
      value: null,
      optional: true,
      ignore: true
    },
    transitions: null,
    extensions: [],
    loaders: {
      type: "array",
      value: [],
      optional: true,
      ignore: true
    },
    getPolygonOffset: {
      type: "function",
      value: ({
        layerIndex
      }) => [0, -layerIndex * 100]
    },
    highlightedObjectIndex: null,
    autoHighlight: false,
    highlightColor: {
      type: "accessor",
      value: [0, 0, 128, 128]
    }
  };
  var Layer = class extends Component {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "internalState", null);
      _defineProperty(this, "lifecycle", LIFECYCLE.NO_STATE);
      _defineProperty(this, "context", void 0);
      _defineProperty(this, "state", void 0);
      _defineProperty(this, "parent", null);
    }
    static get componentName() {
      return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
    }
    get root() {
      let layer = this;
      while (layer.parent) {
        layer = layer.parent;
      }
      return layer;
    }
    toString() {
      const className = this.constructor.layerName || this.constructor.name;
      return "".concat(className, "({id: '").concat(this.props.id, "'})");
    }
    project(xyz) {
      assert10(this.internalState);
      const viewport = this.internalState.viewport || this.context.viewport;
      const worldPosition = getWorldPosition(xyz, {
        viewport,
        modelMatrix: this.props.modelMatrix,
        coordinateOrigin: this.props.coordinateOrigin,
        coordinateSystem: this.props.coordinateSystem
      });
      const [x, y, z] = worldToPixels(worldPosition, viewport.pixelProjectionMatrix);
      return xyz.length === 2 ? [x, y] : [x, y, z];
    }
    unproject(xy) {
      assert10(this.internalState);
      const viewport = this.internalState.viewport || this.context.viewport;
      return viewport.unproject(xy);
    }
    projectPosition(xyz, params) {
      assert10(this.internalState);
      const viewport = this.internalState.viewport || this.context.viewport;
      return projectPosition(xyz, {
        viewport,
        modelMatrix: this.props.modelMatrix,
        coordinateOrigin: this.props.coordinateOrigin,
        coordinateSystem: this.props.coordinateSystem,
        ...params
      });
    }
    get isComposite() {
      return false;
    }
    setState(partialState) {
      this.setChangeFlags({
        stateChanged: true
      });
      Object.assign(this.state, partialState);
      this.setNeedsRedraw();
    }
    setNeedsRedraw() {
      if (this.internalState) {
        this.internalState.needsRedraw = true;
      }
    }
    setNeedsUpdate() {
      if (this.internalState) {
        this.context.layerManager.setNeedsUpdate(String(this));
        this.internalState.needsUpdate = true;
      }
    }
    get isLoaded() {
      return this.internalState ? !this.internalState.isAsyncPropLoading() : false;
    }
    get wrapLongitude() {
      return this.props.wrapLongitude;
    }
    isPickable() {
      return this.props.pickable && this.props.visible;
    }
    getModels() {
      return this.state && (this.state.models || this.state.model && [this.state.model]) || [];
    }
    setModuleParameters(moduleParameters) {
      for (const model of this.getModels()) {
        model.updateModuleSettings(moduleParameters);
      }
    }
    getAttributeManager() {
      return this.internalState && this.internalState.attributeManager;
    }
    getCurrentLayer() {
      return this.internalState && this.internalState.layer;
    }
    getLoadOptions() {
      return this.props.loadOptions;
    }
    use64bitPositions() {
      const {
        coordinateSystem
      } = this.props;
      return coordinateSystem === COORDINATE_SYSTEM.DEFAULT || coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.CARTESIAN;
    }
    onHover(info, pickingEvent) {
      if (this.props.onHover) {
        return this.props.onHover(info, pickingEvent) || false;
      }
      return false;
    }
    onClick(info, pickingEvent) {
      if (this.props.onClick) {
        return this.props.onClick(info, pickingEvent) || false;
      }
      return false;
    }
    nullPickingColor() {
      return [0, 0, 0];
    }
    encodePickingColor(i, target5 = []) {
      target5[0] = i + 1 & 255;
      target5[1] = i + 1 >> 8 & 255;
      target5[2] = i + 1 >> 8 >> 8 & 255;
      return target5;
    }
    decodePickingColor(color) {
      assert10(color instanceof Uint8Array);
      const [i1, i2, i3] = color;
      const index5 = i1 + i2 * 256 + i3 * 65536 - 1;
      return index5;
    }
    getNumInstances() {
      if (Number.isFinite(this.props.numInstances)) {
        return this.props.numInstances;
      }
      if (this.state && this.state.numInstances !== void 0) {
        return this.state.numInstances;
      }
      return count(this.props.data);
    }
    getStartIndices() {
      if (this.props.startIndices) {
        return this.props.startIndices;
      }
      if (this.state && this.state.startIndices) {
        return this.state.startIndices;
      }
      return null;
    }
    getBounds() {
      var _this$getAttributeMan;
      return (_this$getAttributeMan = this.getAttributeManager()) === null || _this$getAttributeMan === void 0 ? void 0 : _this$getAttributeMan.getBounds(["positions", "instancePositions"]);
    }
    getShaders(shaders) {
      for (const extension of this.props.extensions) {
        shaders = mergeShaders(shaders, extension.getShaders.call(this, extension));
      }
      return shaders;
    }
    shouldUpdateState(params) {
      return params.changeFlags.propsOrDataChanged;
    }
    updateState(params) {
      const attributeManager = this.getAttributeManager();
      const {
        dataChanged
      } = params.changeFlags;
      if (dataChanged && attributeManager) {
        if (Array.isArray(dataChanged)) {
          for (const dataRange of dataChanged) {
            attributeManager.invalidateAll(dataRange);
          }
        } else {
          attributeManager.invalidateAll();
        }
      }
      if (attributeManager) {
        const {
          props
        } = params;
        const hasPickingBuffer = this.internalState.hasPickingBuffer;
        const needsPickingBuffer = Number.isInteger(props.highlightedObjectIndex) || props.pickable || props.extensions.some((extension) => extension.getNeedsPickingBuffer.call(this, extension));
        if (hasPickingBuffer !== needsPickingBuffer) {
          this.internalState.hasPickingBuffer = needsPickingBuffer;
          const {
            pickingColors,
            instancePickingColors
          } = attributeManager.attributes;
          const pickingColorsAttribute = pickingColors || instancePickingColors;
          if (pickingColorsAttribute) {
            if (needsPickingBuffer && pickingColorsAttribute.constant) {
              pickingColorsAttribute.constant = false;
              attributeManager.invalidate(pickingColorsAttribute.id);
            }
            if (!pickingColorsAttribute.value && !needsPickingBuffer) {
              pickingColorsAttribute.constant = true;
              pickingColorsAttribute.value = [0, 0, 0];
            }
          }
        }
      }
    }
    finalizeState(context) {
      for (const model of this.getModels()) {
        model.delete();
      }
      const attributeManager = this.getAttributeManager();
      if (attributeManager) {
        attributeManager.finalize();
      }
      if (this.context) {
        this.context.resourceManager.unsubscribe({
          consumerId: this.id
        });
      }
      if (this.internalState) {
        this.internalState.uniformTransitions.clear();
        this.internalState.finalize();
      }
    }
    draw(opts) {
      for (const model of this.getModels()) {
        model.draw(opts);
      }
    }
    getPickingInfo({
      info,
      mode,
      sourceLayer
    }) {
      const {
        index: index5
      } = info;
      if (index5 >= 0) {
        if (Array.isArray(this.props.data)) {
          info.object = this.props.data[index5];
        }
      }
      return info;
    }
    raiseError(error3, message2) {
      var _this$props$onError, _this$props;
      if (message2) {
        error3 = new Error("".concat(message2, ": ").concat(error3.message), {
          cause: error3
        });
      }
      if (!((_this$props$onError = (_this$props = this.props).onError) !== null && _this$props$onError !== void 0 && _this$props$onError.call(_this$props, error3))) {
        var _this$context, _this$context$onError;
        (_this$context = this.context) === null || _this$context === void 0 ? void 0 : (_this$context$onError = _this$context.onError) === null || _this$context$onError === void 0 ? void 0 : _this$context$onError.call(_this$context, error3, this);
      }
    }
    getNeedsRedraw(opts = {
      clearRedrawFlags: false
    }) {
      return this._getNeedsRedraw(opts);
    }
    needsUpdate() {
      if (!this.internalState) {
        return false;
      }
      return this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams());
    }
    hasUniformTransition() {
      var _this$internalState;
      return ((_this$internalState = this.internalState) === null || _this$internalState === void 0 ? void 0 : _this$internalState.uniformTransitions.active) || false;
    }
    activateViewport(viewport) {
      if (!this.internalState) {
        return;
      }
      const oldViewport = this.internalState.viewport;
      this.internalState.viewport = viewport;
      if (!oldViewport || !areViewportsEqual({
        oldViewport,
        viewport
      })) {
        this.setChangeFlags({
          viewportChanged: true
        });
        if (this.isComposite) {
          if (this.needsUpdate()) {
            this.setNeedsUpdate();
          }
        } else {
          this._update();
        }
      }
    }
    invalidateAttribute(name16 = "all") {
      const attributeManager = this.getAttributeManager();
      if (!attributeManager) {
        return;
      }
      if (name16 === "all") {
        attributeManager.invalidateAll();
      } else {
        attributeManager.invalidate(name16);
      }
    }
    updateAttributes(changedAttributes) {
      for (const model of this.getModels()) {
        this._setModelAttributes(model, changedAttributes);
      }
    }
    _updateAttributes() {
      const attributeManager = this.getAttributeManager();
      if (!attributeManager) {
        return;
      }
      const props = this.props;
      const numInstances = this.getNumInstances();
      const startIndices = this.getStartIndices();
      attributeManager.update({
        data: props.data,
        numInstances,
        startIndices,
        props,
        transitions: props.transitions,
        buffers: props.data.attributes,
        context: this
      });
      const changedAttributes = attributeManager.getChangedAttributes({
        clearChangedFlags: true
      });
      this.updateAttributes(changedAttributes);
    }
    _updateAttributeTransition() {
      const attributeManager = this.getAttributeManager();
      if (attributeManager) {
        attributeManager.updateTransition();
      }
    }
    _updateUniformTransition() {
      const {
        uniformTransitions
      } = this.internalState;
      if (uniformTransitions.active) {
        const propsInTransition = uniformTransitions.update();
        const props = Object.create(this.props);
        for (const key in propsInTransition) {
          Object.defineProperty(props, key, {
            value: propsInTransition[key]
          });
        }
        return props;
      }
      return this.props;
    }
    calculateInstancePickingColors(attribute, {
      numInstances
    }) {
      if (attribute.constant) {
        return;
      }
      const cacheSize = Math.floor(pickingColorCache.length / 3);
      this.internalState.usesPickingColorCache = true;
      if (cacheSize < numInstances) {
        if (numInstances > MAX_PICKING_COLOR_CACHE_SIZE) {
          log_default.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")();
        }
        pickingColorCache = typed_array_manager_default.allocate(pickingColorCache, numInstances, {
          size: 3,
          copy: true,
          maxCount: Math.max(numInstances, MAX_PICKING_COLOR_CACHE_SIZE)
        });
        const newCacheSize = Math.floor(pickingColorCache.length / 3);
        const pickingColor = [];
        for (let i = cacheSize; i < newCacheSize; i++) {
          this.encodePickingColor(i, pickingColor);
          pickingColorCache[i * 3 + 0] = pickingColor[0];
          pickingColorCache[i * 3 + 1] = pickingColor[1];
          pickingColorCache[i * 3 + 2] = pickingColor[2];
        }
      }
      attribute.value = pickingColorCache.subarray(0, numInstances * 3);
    }
    _setModelAttributes(model, changedAttributes) {
      const attributeManager = this.getAttributeManager();
      const excludeAttributes = model.userData.excludeAttributes || {};
      const shaderAttributes = attributeManager.getShaderAttributes(changedAttributes, excludeAttributes);
      model.setAttributes(shaderAttributes);
    }
    disablePickingIndex(objectIndex) {
      const data = this.props.data;
      if (!("attributes" in data)) {
        this._disablePickingIndex(objectIndex);
        return;
      }
      const {
        pickingColors,
        instancePickingColors
      } = this.getAttributeManager().attributes;
      const colors = pickingColors || instancePickingColors;
      const externalColorAttribute = colors && data.attributes && data.attributes[colors.id];
      if (externalColorAttribute && externalColorAttribute.value) {
        const values2 = externalColorAttribute.value;
        const objectColor = this.encodePickingColor(objectIndex);
        for (let index5 = 0; index5 < data.length; index5++) {
          const i = colors.getVertexOffset(index5);
          if (values2[i] === objectColor[0] && values2[i + 1] === objectColor[1] && values2[i + 2] === objectColor[2]) {
            this._disablePickingIndex(index5);
          }
        }
      } else {
        this._disablePickingIndex(objectIndex);
      }
    }
    _disablePickingIndex(objectIndex) {
      const {
        pickingColors,
        instancePickingColors
      } = this.getAttributeManager().attributes;
      const colors = pickingColors || instancePickingColors;
      if (!colors) {
        return;
      }
      const start2 = colors.getVertexOffset(objectIndex);
      const end = colors.getVertexOffset(objectIndex + 1);
      colors.buffer.subData({
        data: new Uint8Array(end - start2),
        offset: start2
      });
    }
    restorePickingColors() {
      const {
        pickingColors,
        instancePickingColors
      } = this.getAttributeManager().attributes;
      const colors = pickingColors || instancePickingColors;
      if (!colors) {
        return;
      }
      if (this.internalState.usesPickingColorCache && colors.value.buffer !== pickingColorCache.buffer) {
        colors.value = pickingColorCache.subarray(0, colors.value.length);
      }
      colors.updateSubBuffer({
        startOffset: 0
      });
    }
    _initialize() {
      assert10(!this.internalState);
      assert10(Number.isFinite(this.props.coordinateSystem));
      debug(TRACE_INITIALIZE, this);
      const attributeManager = this._getAttributeManager();
      if (attributeManager) {
        attributeManager.addInstanced({
          instancePickingColors: {
            type: 5121,
            size: 3,
            noAlloc: true,
            update: this.calculateInstancePickingColors
          }
        });
      }
      this.internalState = new LayerState({
        attributeManager,
        layer: this
      });
      this._clearChangeFlags();
      this.state = {};
      Object.defineProperty(this.state, "attributeManager", {
        get: () => {
          log_default.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")();
          return attributeManager;
        }
      });
      this.internalState.uniformTransitions = new UniformTransitionManager(this.context.timeline);
      this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this);
      this.internalState.setAsyncProps(this.props);
      this.initializeState(this.context);
      for (const extension of this.props.extensions) {
        extension.initializeState.call(this, this.context, extension);
      }
      this.setChangeFlags({
        dataChanged: "init",
        propsChanged: "init",
        viewportChanged: true,
        extensionsChanged: true
      });
      this._update();
    }
    _transferState(oldLayer) {
      debug(TRACE_MATCHED, this, this === oldLayer);
      const {
        state: state3,
        internalState
      } = oldLayer;
      if (this === oldLayer) {
        return;
      }
      this.internalState = internalState;
      this.state = state3;
      this.internalState.setAsyncProps(this.props);
      this._diffProps(this.props, this.internalState.getOldProps());
    }
    _update() {
      const stateNeedsUpdate = this.needsUpdate();
      debug(TRACE_UPDATE, this, stateNeedsUpdate);
      if (!stateNeedsUpdate) {
        return;
      }
      const currentProps = this.props;
      const context = this.context;
      const internalState = this.internalState;
      const currentViewport = context.viewport;
      const propsInTransition = this._updateUniformTransition();
      internalState.propsInTransition = propsInTransition;
      context.viewport = internalState.viewport || currentViewport;
      this.props = propsInTransition;
      try {
        const updateParams = this._getUpdateParams();
        const oldModels = this.getModels();
        if (context.gl) {
          this.updateState(updateParams);
        } else {
          try {
            this.updateState(updateParams);
          } catch (error3) {
          }
        }
        for (const extension of this.props.extensions) {
          extension.updateState.call(this, updateParams, extension);
        }
        const modelChanged = this.getModels()[0] !== oldModels[0];
        this._postUpdate(updateParams, modelChanged);
      } finally {
        context.viewport = currentViewport;
        this.props = currentProps;
        this._clearChangeFlags();
        internalState.needsUpdate = false;
        internalState.resetOldProps();
      }
    }
    _finalize() {
      debug(TRACE_FINALIZE, this);
      this.finalizeState(this.context);
      for (const extension of this.props.extensions) {
        extension.finalizeState.call(this, this.context, extension);
      }
    }
    _drawLayer({
      moduleParameters = null,
      uniforms = {},
      parameters = {}
    }) {
      this._updateAttributeTransition();
      const currentProps = this.props;
      const context = this.context;
      this.props = this.internalState.propsInTransition || currentProps;
      const opacity = this.props.opacity;
      uniforms.opacity = Math.pow(opacity, 1 / 2.2);
      try {
        if (moduleParameters) {
          this.setModuleParameters(moduleParameters);
        }
        const {
          getPolygonOffset
        } = this.props;
        const offsets = getPolygonOffset && getPolygonOffset(uniforms) || [0, 0];
        setParameters(context.gl, {
          polygonOffset: offsets
        });
        withParameters(context.gl, parameters, () => {
          const opts = {
            moduleParameters,
            uniforms,
            parameters,
            context
          };
          for (const extension of this.props.extensions) {
            extension.draw.call(this, opts, extension);
          }
          this.draw(opts);
        });
      } finally {
        this.props = currentProps;
      }
    }
    getChangeFlags() {
      var _this$internalState2;
      return (_this$internalState2 = this.internalState) === null || _this$internalState2 === void 0 ? void 0 : _this$internalState2.changeFlags;
    }
    setChangeFlags(flags) {
      if (!this.internalState) {
        return;
      }
      const {
        changeFlags
      } = this.internalState;
      for (const key in flags) {
        if (flags[key]) {
          let flagChanged = false;
          switch (key) {
            case "dataChanged":
              const dataChangedReason = flags[key];
              const prevDataChangedReason = changeFlags[key];
              if (dataChangedReason && Array.isArray(prevDataChangedReason)) {
                changeFlags.dataChanged = Array.isArray(dataChangedReason) ? prevDataChangedReason.concat(dataChangedReason) : dataChangedReason;
                flagChanged = true;
              }
            default:
              if (!changeFlags[key]) {
                changeFlags[key] = flags[key];
                flagChanged = true;
              }
          }
          if (flagChanged) {
            debug(TRACE_CHANGE_FLAG, this, key, flags);
          }
        }
      }
      const propsOrDataChanged = Boolean(changeFlags.dataChanged || changeFlags.updateTriggersChanged || changeFlags.propsChanged || changeFlags.extensionsChanged);
      changeFlags.propsOrDataChanged = propsOrDataChanged;
      changeFlags.somethingChanged = propsOrDataChanged || changeFlags.viewportChanged || changeFlags.stateChanged;
    }
    _clearChangeFlags() {
      this.internalState.changeFlags = {
        dataChanged: false,
        propsChanged: false,
        updateTriggersChanged: false,
        viewportChanged: false,
        stateChanged: false,
        extensionsChanged: false,
        propsOrDataChanged: false,
        somethingChanged: false
      };
    }
    _diffProps(newProps, oldProps) {
      const changeFlags = diffProps(newProps, oldProps);
      if (changeFlags.updateTriggersChanged) {
        for (const key in changeFlags.updateTriggersChanged) {
          if (changeFlags.updateTriggersChanged[key]) {
            this.invalidateAttribute(key);
          }
        }
      }
      if (changeFlags.transitionsChanged) {
        for (const key in changeFlags.transitionsChanged) {
          var _newProps$transitions;
          this.internalState.uniformTransitions.add(key, oldProps[key], newProps[key], (_newProps$transitions = newProps.transitions) === null || _newProps$transitions === void 0 ? void 0 : _newProps$transitions[key]);
        }
      }
      return this.setChangeFlags(changeFlags);
    }
    validateProps() {
      validateProps(this.props);
    }
    updateAutoHighlight(info) {
      if (this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex)) {
        this._updateAutoHighlight(info);
      }
    }
    _updateAutoHighlight(info) {
      const pickingModuleParameters = {
        pickingSelectedColor: info.picked ? info.color : null
      };
      const {
        highlightColor
      } = this.props;
      if (info.picked && typeof highlightColor === "function") {
        pickingModuleParameters.pickingHighlightColor = highlightColor(info);
      }
      this.setModuleParameters(pickingModuleParameters);
      this.setNeedsRedraw();
    }
    _getAttributeManager() {
      const context = this.context;
      return new AttributeManager(context.gl, {
        id: this.props.id,
        stats: context.stats,
        timeline: context.timeline
      });
    }
    _postUpdate(updateParams, forceUpdate) {
      const {
        props,
        oldProps
      } = updateParams;
      this.setNeedsRedraw();
      this._updateAttributes();
      const {
        model
      } = this.state;
      model === null || model === void 0 ? void 0 : model.setInstanceCount(this.getNumInstances());
      const {
        autoHighlight,
        highlightedObjectIndex,
        highlightColor
      } = props;
      if (forceUpdate || oldProps.autoHighlight !== autoHighlight || oldProps.highlightedObjectIndex !== highlightedObjectIndex || oldProps.highlightColor !== highlightColor) {
        const parameters = {};
        if (!autoHighlight) {
          parameters.pickingSelectedColor = null;
        }
        if (Array.isArray(highlightColor)) {
          parameters.pickingHighlightColor = highlightColor;
        }
        if (forceUpdate || highlightedObjectIndex !== oldProps.highlightedObjectIndex) {
          parameters.pickingSelectedColor = Number.isFinite(highlightedObjectIndex) && highlightedObjectIndex >= 0 ? this.encodePickingColor(highlightedObjectIndex) : null;
        }
        this.setModuleParameters(parameters);
      }
    }
    _getUpdateParams() {
      return {
        props: this.props,
        oldProps: this.internalState.getOldProps(),
        context: this.context,
        changeFlags: this.internalState.changeFlags
      };
    }
    _getNeedsRedraw(opts) {
      if (!this.internalState) {
        return false;
      }
      let redraw = false;
      redraw = redraw || this.internalState.needsRedraw && this.id;
      const attributeManager = this.getAttributeManager();
      const attributeManagerNeedsRedraw = attributeManager ? attributeManager.getNeedsRedraw(opts) : false;
      redraw = redraw || attributeManagerNeedsRedraw;
      if (redraw) {
        for (const extension of this.props.extensions) {
          extension.onNeedsRedraw.call(this, extension);
        }
      }
      this.internalState.needsRedraw = this.internalState.needsRedraw && !opts.clearRedrawFlags;
      return redraw;
    }
    _onAsyncPropUpdated() {
      this._diffProps(this.props, this.internalState.getOldProps());
      this.setNeedsUpdate();
    }
  };
  _defineProperty(Layer, "defaultProps", defaultProps2);
  _defineProperty(Layer, "layerName", "Layer");

  // node_modules/@deck.gl/core/dist/esm/utils/tesselator.js
  var Tesselator = class {
    constructor(opts) {
      _defineProperty(this, "opts", void 0);
      _defineProperty(this, "typedArrayManager", void 0);
      _defineProperty(this, "indexStarts", [0]);
      _defineProperty(this, "vertexStarts", [0]);
      _defineProperty(this, "vertexCount", 0);
      _defineProperty(this, "instanceCount", 0);
      _defineProperty(this, "attributes", void 0);
      _defineProperty(this, "_attributeDefs", void 0);
      _defineProperty(this, "data", void 0);
      _defineProperty(this, "getGeometry", void 0);
      _defineProperty(this, "geometryBuffer", void 0);
      _defineProperty(this, "buffers", void 0);
      _defineProperty(this, "positionSize", void 0);
      _defineProperty(this, "normalize", void 0);
      const {
        attributes = {}
      } = opts;
      this.typedArrayManager = typed_array_manager_default;
      this.attributes = {};
      this._attributeDefs = attributes;
      this.opts = opts;
      this.updateGeometry(opts);
    }
    updateGeometry(opts) {
      Object.assign(this.opts, opts);
      const {
        data,
        buffers = {},
        getGeometry,
        geometryBuffer,
        positionFormat,
        dataChanged,
        normalize = true
      } = this.opts;
      this.data = data;
      this.getGeometry = getGeometry;
      this.positionSize = geometryBuffer && geometryBuffer.size || (positionFormat === "XY" ? 2 : 3);
      this.buffers = buffers;
      this.normalize = normalize;
      if (geometryBuffer) {
        assert10(data.startIndices);
        this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);
        if (!normalize) {
          buffers.positions = geometryBuffer;
        }
      }
      this.geometryBuffer = buffers.positions;
      if (Array.isArray(dataChanged)) {
        for (const dataRange of dataChanged) {
          this._rebuildGeometry(dataRange);
        }
      } else {
        this._rebuildGeometry();
      }
    }
    updatePartialGeometry({
      startRow,
      endRow
    }) {
      this._rebuildGeometry({
        startRow,
        endRow
      });
    }
    getGeometryFromBuffer(geometryBuffer) {
      const value13 = geometryBuffer.value || geometryBuffer;
      if (!ArrayBuffer.isView(value13)) {
        return null;
      }
      return getAccessorFromBuffer(value13, {
        size: this.positionSize,
        offset: geometryBuffer.offset,
        stride: geometryBuffer.stride,
        startIndices: this.data.startIndices
      });
    }
    _allocate(instanceCount, copy2) {
      const {
        attributes,
        buffers,
        _attributeDefs,
        typedArrayManager
      } = this;
      for (const name16 in _attributeDefs) {
        if (name16 in buffers) {
          typedArrayManager.release(attributes[name16]);
          attributes[name16] = null;
        } else {
          const def = _attributeDefs[name16];
          def.copy = copy2;
          attributes[name16] = typedArrayManager.allocate(attributes[name16], instanceCount, def);
        }
      }
    }
    _forEachGeometry(visitor, startRow, endRow) {
      const {
        data,
        getGeometry
      } = this;
      const {
        iterable,
        objectInfo
      } = createIterable(data, startRow, endRow);
      for (const object12 of iterable) {
        objectInfo.index++;
        const geometry = getGeometry ? getGeometry(object12, objectInfo) : null;
        visitor(geometry, objectInfo.index);
      }
    }
    _rebuildGeometry(dataRange) {
      if (!this.data) {
        return;
      }
      let {
        indexStarts,
        vertexStarts,
        instanceCount
      } = this;
      const {
        data,
        geometryBuffer
      } = this;
      const {
        startRow = 0,
        endRow = Infinity
      } = dataRange || {};
      const normalizedData = {};
      if (!dataRange) {
        indexStarts = [0];
        vertexStarts = [0];
      }
      if (this.normalize || !geometryBuffer) {
        this._forEachGeometry((geometry, dataIndex) => {
          const normalizedGeometry = geometry && this.normalizeGeometry(geometry);
          normalizedData[dataIndex] = normalizedGeometry;
          vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + (normalizedGeometry ? this.getGeometrySize(normalizedGeometry) : 0);
        }, startRow, endRow);
        instanceCount = vertexStarts[vertexStarts.length - 1];
      } else {
        vertexStarts = data.startIndices;
        instanceCount = vertexStarts[data.length] || 0;
        if (ArrayBuffer.isView(geometryBuffer)) {
          instanceCount = instanceCount || geometryBuffer.length / this.positionSize;
        } else if (geometryBuffer instanceof Buffer2) {
          const byteStride = geometryBuffer.accessor.stride || this.positionSize * 4;
          instanceCount = instanceCount || geometryBuffer.byteLength / byteStride;
        } else if (geometryBuffer.buffer) {
          const byteStride = geometryBuffer.stride || this.positionSize * 4;
          instanceCount = instanceCount || geometryBuffer.buffer.byteLength / byteStride;
        } else if (geometryBuffer.value) {
          const bufferValue = geometryBuffer.value;
          const elementStride = geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;
          instanceCount = instanceCount || bufferValue.length / elementStride;
        }
      }
      this._allocate(instanceCount, Boolean(dataRange));
      this.indexStarts = indexStarts;
      this.vertexStarts = vertexStarts;
      this.instanceCount = instanceCount;
      const context = {};
      this._forEachGeometry((geometry, dataIndex) => {
        const normalizedGeometry = normalizedData[dataIndex] || geometry;
        context.vertexStart = vertexStarts[dataIndex];
        context.indexStart = indexStarts[dataIndex];
        const vertexEnd = dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;
        context.geometrySize = vertexEnd - vertexStarts[dataIndex];
        context.geometryIndex = dataIndex;
        this.updateGeometryAttributes(normalizedGeometry, context);
      }, startRow, endRow);
      this.vertexCount = indexStarts[indexStarts.length - 1];
    }
  };

  // node_modules/@math.gl/polygon/dist/esm/utils.js
  function push(target5, source) {
    const size5 = source.length;
    const startIndex = target5.length;
    if (startIndex > 0) {
      let isDuplicate = true;
      for (let i = 0; i < size5; i++) {
        if (target5[startIndex - size5 + i] !== source[i]) {
          isDuplicate = false;
          break;
        }
      }
      if (isDuplicate) {
        return false;
      }
    }
    for (let i = 0; i < size5; i++) {
      target5[startIndex + i] = source[i];
    }
    return true;
  }
  function copy(target5, source) {
    const size5 = source.length;
    for (let i = 0; i < size5; i++) {
      target5[i] = source[i];
    }
  }
  function getPointAtIndex(positions, index5, size5, offset, out = []) {
    const startI = offset + index5 * size5;
    for (let i = 0; i < size5; i++) {
      out[i] = positions[startI + i];
    }
    return out;
  }

  // node_modules/@math.gl/polygon/dist/esm/lineclip.js
  function intersect(a, b, edge, bbox, out = []) {
    let t;
    let snap;
    if (edge & 8) {
      t = (bbox[3] - a[1]) / (b[1] - a[1]);
      snap = 3;
    } else if (edge & 4) {
      t = (bbox[1] - a[1]) / (b[1] - a[1]);
      snap = 1;
    } else if (edge & 2) {
      t = (bbox[2] - a[0]) / (b[0] - a[0]);
      snap = 2;
    } else if (edge & 1) {
      t = (bbox[0] - a[0]) / (b[0] - a[0]);
      snap = 0;
    } else {
      return null;
    }
    for (let i = 0; i < a.length; i++) {
      out[i] = (snap & 1) === i ? bbox[snap] : t * (b[i] - a[i]) + a[i];
    }
    return out;
  }
  function bitCode(p, bbox) {
    let code = 0;
    if (p[0] < bbox[0])
      code |= 1;
    else if (p[0] > bbox[2])
      code |= 2;
    if (p[1] < bbox[1])
      code |= 4;
    else if (p[1] > bbox[3])
      code |= 8;
    return code;
  }

  // node_modules/@math.gl/polygon/dist/esm/cut-by-grid.js
  function cutPolylineByGrid(positions, options2) {
    const {
      size: size5 = 2,
      broken = false,
      gridResolution = 10,
      gridOffset = [0, 0],
      startIndex = 0,
      endIndex = positions.length
    } = options2 || {};
    const numPoints = (endIndex - startIndex) / size5;
    let part = [];
    const result = [part];
    const a = getPointAtIndex(positions, 0, size5, startIndex);
    let b;
    let codeB;
    const cell = getGridCell(a, gridResolution, gridOffset, []);
    const scratchPoint = [];
    push(part, a);
    for (let i = 1; i < numPoints; i++) {
      b = getPointAtIndex(positions, i, size5, startIndex, b);
      codeB = bitCode(b, cell);
      while (codeB) {
        intersect(a, b, codeB, cell, scratchPoint);
        const codeAlt = bitCode(scratchPoint, cell);
        if (codeAlt) {
          intersect(a, scratchPoint, codeAlt, cell, scratchPoint);
          codeB = codeAlt;
        }
        push(part, scratchPoint);
        copy(a, scratchPoint);
        moveToNeighborCell(cell, gridResolution, codeB);
        if (broken && part.length > size5) {
          part = [];
          result.push(part);
          push(part, a);
        }
        codeB = bitCode(b, cell);
      }
      push(part, b);
      copy(a, b);
    }
    return broken ? result : result[0];
  }
  function getGridCell(p, gridResolution, gridOffset, out) {
    const left3 = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];
    const bottom3 = Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];
    out[0] = left3;
    out[1] = bottom3;
    out[2] = left3 + gridResolution;
    out[3] = bottom3 + gridResolution;
    return out;
  }
  function moveToNeighborCell(cell, gridResolution, edge) {
    if (edge & 8) {
      cell[1] += gridResolution;
      cell[3] += gridResolution;
    } else if (edge & 4) {
      cell[1] -= gridResolution;
      cell[3] -= gridResolution;
    } else if (edge & 2) {
      cell[0] += gridResolution;
      cell[2] += gridResolution;
    } else if (edge & 1) {
      cell[0] -= gridResolution;
      cell[2] -= gridResolution;
    }
  }

  // node_modules/@math.gl/polygon/dist/esm/cut-by-mercator-bounds.js
  function cutPolylineByMercatorBounds(positions, options2) {
    const {
      size: size5 = 2,
      startIndex = 0,
      endIndex = positions.length,
      normalize = true
    } = options2 || {};
    const newPositions = positions.slice(startIndex, endIndex);
    wrapLongitudesForShortestPath(newPositions, size5, 0, endIndex - startIndex);
    const parts = cutPolylineByGrid(newPositions, {
      size: size5,
      broken: true,
      gridResolution: 360,
      gridOffset: [-180, -180]
    });
    if (normalize) {
      for (const part of parts) {
        shiftLongitudesIntoRange(part, size5);
      }
    }
    return parts;
  }
  function wrapLongitudesForShortestPath(positions, size5, startIndex, endIndex) {
    let prevLng = positions[0];
    let lng2;
    for (let i = startIndex; i < endIndex; i += size5) {
      lng2 = positions[i];
      const delta = lng2 - prevLng;
      if (delta > 180 || delta < -180) {
        lng2 -= Math.round(delta / 360) * 360;
      }
      positions[i] = prevLng = lng2;
    }
  }
  function shiftLongitudesIntoRange(positions, size5) {
    let refLng;
    const pointCount = positions.length / size5;
    for (let i = 0; i < pointCount; i++) {
      refLng = positions[i * size5];
      if ((refLng + 180) % 360 !== 0) {
        break;
      }
    }
    const delta = -Math.round(refLng / 360) * 360;
    if (delta === 0) {
      return;
    }
    for (let i = 0; i < pointCount; i++) {
      positions[i * size5] += delta;
    }
  }

  // node_modules/@deck.gl/layers/dist/esm/path-layer/path.js
  function normalizePath(path, size5, gridResolution, wrapLongitude) {
    let flatPath;
    if (Array.isArray(path[0])) {
      const length7 = path.length * size5;
      flatPath = new Array(length7);
      for (let i = 0; i < path.length; i++) {
        for (let j = 0; j < size5; j++) {
          flatPath[i * size5 + j] = path[i][j] || 0;
        }
      }
    } else {
      flatPath = path;
    }
    if (gridResolution) {
      return cutPolylineByGrid(flatPath, {
        size: size5,
        gridResolution
      });
    }
    if (wrapLongitude) {
      return cutPolylineByMercatorBounds(flatPath, {
        size: size5
      });
    }
    return flatPath;
  }

  // node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js
  var START_CAP = 1;
  var END_CAP = 2;
  var INVALID = 4;
  var PathTesselator = class extends Tesselator {
    constructor(opts) {
      super({
        ...opts,
        attributes: {
          positions: {
            size: 3,
            padding: 18,
            initialize: true,
            type: opts.fp64 ? Float64Array : Float32Array
          },
          segmentTypes: {
            size: 1,
            type: Uint8ClampedArray
          }
        }
      });
    }
    get(attributeName) {
      return this.attributes[attributeName];
    }
    getGeometryFromBuffer(buffer) {
      if (this.normalize) {
        return super.getGeometryFromBuffer(buffer);
      }
      return null;
    }
    normalizeGeometry(path) {
      if (this.normalize) {
        return normalizePath(path, this.positionSize, this.opts.resolution, this.opts.wrapLongitude);
      }
      return path;
    }
    getGeometrySize(path) {
      if (isCut(path)) {
        let size5 = 0;
        for (const subPath of path) {
          size5 += this.getGeometrySize(subPath);
        }
        return size5;
      }
      const numPoints = this.getPathLength(path);
      if (numPoints < 2) {
        return 0;
      }
      if (this.isClosed(path)) {
        return numPoints < 3 ? 0 : numPoints + 2;
      }
      return numPoints;
    }
    updateGeometryAttributes(path, context) {
      if (context.geometrySize === 0) {
        return;
      }
      if (path && isCut(path)) {
        for (const subPath of path) {
          const geometrySize = this.getGeometrySize(subPath);
          context.geometrySize = geometrySize;
          this.updateGeometryAttributes(subPath, context);
          context.vertexStart += geometrySize;
        }
      } else {
        this._updateSegmentTypes(path, context);
        this._updatePositions(path, context);
      }
    }
    _updateSegmentTypes(path, context) {
      const segmentTypes = this.attributes.segmentTypes;
      const isPathClosed = path ? this.isClosed(path) : false;
      const {
        vertexStart,
        geometrySize
      } = context;
      segmentTypes.fill(0, vertexStart, vertexStart + geometrySize);
      if (isPathClosed) {
        segmentTypes[vertexStart] = INVALID;
        segmentTypes[vertexStart + geometrySize - 2] = INVALID;
      } else {
        segmentTypes[vertexStart] += START_CAP;
        segmentTypes[vertexStart + geometrySize - 2] += END_CAP;
      }
      segmentTypes[vertexStart + geometrySize - 1] = INVALID;
    }
    _updatePositions(path, context) {
      const {
        positions
      } = this.attributes;
      if (!positions || !path) {
        return;
      }
      const {
        vertexStart,
        geometrySize
      } = context;
      const p = new Array(3);
      for (let i = vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {
        this.getPointOnPath(path, ptIndex, p);
        positions[i * 3] = p[0];
        positions[i * 3 + 1] = p[1];
        positions[i * 3 + 2] = p[2];
      }
    }
    getPathLength(path) {
      return path.length / this.positionSize;
    }
    getPointOnPath(path, index5, target5 = []) {
      const {
        positionSize
      } = this;
      if (index5 * positionSize >= path.length) {
        index5 += 1 - path.length / positionSize;
      }
      const i = index5 * positionSize;
      target5[0] = path[i];
      target5[1] = path[i + 1];
      target5[2] = positionSize === 3 && path[i + 2] || 0;
      return target5;
    }
    isClosed(path) {
      if (!this.normalize) {
        return Boolean(this.opts.loop);
      }
      const {
        positionSize
      } = this;
      const lastPointIndex = path.length - positionSize;
      return path[0] === path[lastPointIndex] && path[1] === path[lastPointIndex + 1] && (positionSize === 2 || path[2] === path[lastPointIndex + 2]);
    }
  };
  function isCut(path) {
    return Array.isArray(path[0]);
  }

  // node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js
  var path_layer_vertex_glsl_default = "#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec2 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec3 instanceLeftPositions64Low;\nattribute vec3 instanceStartPositions64Low;\nattribute vec3 instanceEndPositions64Low;\nattribute vec3 instanceRightPositions64Low;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float capType;\nuniform float miterLimit;\nuniform bool billboard;\nuniform int widthUnits;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 getLineJoinOffset(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  vec2 width\n) {\n  bool isEnd = positions.x > 0.0;\n  float sideOfPath = positions.y;\n  float isJoint = float(sideOfPath == 0.0);\n\n  vec3 deltaA3 = (currPoint - prevPoint);\n  vec3 deltaB3 = (nextPoint - currPoint);\n\n  mat3 rotationMatrix;\n  bool needsRotation = !billboard && project_needs_rotation(currPoint, rotationMatrix);\n  if (needsRotation) {\n    deltaA3 = deltaA3 * rotationMatrix;\n    deltaB3 = deltaB3 * rotationMatrix;\n  }\n  vec2 deltaA = deltaA3.xy / width;\n  vec2 deltaB = deltaB3.xy / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = dirA + dirB;\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 dir = isEnd ? dirA : dirB;\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n  float turnDirection = flipIfTrue(dirA.x * dirB.y >= dirA.y * dirB.x);\n  float cornerPosition = sideOfPath * turnDirection;\n\n  float miterSize = 1.0 / max(sinHalfA, EPSILON);\n  miterSize = mix(\n    min(miterSize, max(lenA, lenB) / max(cosHalfA, EPSILON)),\n    miterSize,\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec * miterSize, perp, step(0.5, cornerPosition))\n    * (sideOfPath + isJoint * turnDirection);\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n  if (isCap) {\n    offsetVec = mix(perp * sideOfPath, dir * capType * 4.0 * flipIfTrue(isStartCap), isJoint);\n    vJointType = capType;\n  } else {\n    vJointType = jointType;\n  }\n  vPathLength = L;\n  vCornerOffset = offsetVec;\n  vMiterLength = dot(vCornerOffset, miterVec * turnDirection);\n  vMiterLength = isCap ? isJoint : vMiterLength;\n\n  vec2 offsetFromStartOfPath = vCornerOffset + deltaA * float(isEnd);\n  vPathPosition = vec2(\n    dot(offsetFromStartOfPath, perp),\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(offsetVec * width * isValid, 0.0);\n\n  if (needsRotation) {\n    offset = rotationMatrix * offset;\n  }\n  return offset;\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.pickingColor = instancePickingColors;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec3 prevPosition64Low = mix(instanceLeftPositions64Low, instanceStartPositions64Low, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec3 currPosition64Low = mix(instanceStartPositions64Low, instanceEndPositions64Low, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec3 nextPosition64Low = mix(instanceEndPositions64Low, instanceRightPositions64Low, isEnd);\n\n  geometry.worldPosition = currPosition;\n  vec2 widthPixels = vec2(clamp(\n    project_size_to_pixel(instanceStrokeWidths * widthScale, widthUnits),\n    widthMinPixels, widthMaxPixels) / 2.0);\n  vec3 width;\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64Low, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64Low, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64Low, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    width = vec3(widthPixels, 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w,\n      project_pixel_size_to_clipspace(width.xy)\n    );\n\n    DECKGL_FILTER_GL_POSITION(currPositionScreen, geometry);\n    gl_Position = vec4(currPositionScreen.xyz + offset * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64Low);\n    currPosition = project_position(currPosition, currPosition64Low);\n    nextPosition = project_position(nextPosition, nextPosition64Low);\n\n    width = vec3(project_pixel_size(widthPixels), 0.0);\n    DECKGL_FILTER_SIZE(width, geometry);\n\n    vec3 offset = getLineJoinOffset(prevPosition, currPosition, nextPosition, width.xy);\n    geometry.position = vec4(currPosition + offset, 1.0);\n    gl_Position = project_common_position_to_clipspace(geometry.position);\n    DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  }\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n";

  // node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js
  var path_layer_fragment_glsl_default = "#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float miterLimit;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nvarying float vJointType;\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n\n  if (vPathPosition.y < 0.0 || vPathPosition.y > vPathLength) {\n    if (vJointType > 0.5 && length(vCornerOffset) > 1.0) {\n      discard;\n    }\n    if (vJointType < 0.5 && vMiterLength > miterLimit + 1.0) {\n      discard;\n    }\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";

  // node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js
  var DEFAULT_COLOR = [0, 0, 0, 255];
  var defaultProps3 = {
    widthUnits: "meters",
    widthScale: {
      type: "number",
      min: 0,
      value: 1
    },
    widthMinPixels: {
      type: "number",
      min: 0,
      value: 0
    },
    widthMaxPixels: {
      type: "number",
      min: 0,
      value: Number.MAX_SAFE_INTEGER
    },
    jointRounded: false,
    capRounded: false,
    miterLimit: {
      type: "number",
      min: 0,
      value: 4
    },
    billboard: false,
    _pathType: null,
    getPath: {
      type: "accessor",
      value: (object12) => object12.path
    },
    getColor: {
      type: "accessor",
      value: DEFAULT_COLOR
    },
    getWidth: {
      type: "accessor",
      value: 1
    },
    rounded: {
      deprecatedFor: ["jointRounded", "capRounded"]
    }
  };
  var ATTRIBUTE_TRANSITION = {
    enter: (value13, chunk) => {
      return chunk.length ? chunk.subarray(chunk.length - value13.length) : value13;
    }
  };
  var PathLayer = class extends Layer {
    constructor(...args) {
      super(...args);
      _defineProperty(this, "state", void 0);
    }
    getShaders() {
      return super.getShaders({
        vs: path_layer_vertex_glsl_default,
        fs: path_layer_fragment_glsl_default,
        modules: [project32_default, picking_default]
      });
    }
    get wrapLongitude() {
      return false;
    }
    initializeState() {
      const noAlloc = true;
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        positions: {
          size: 3,
          vertexOffset: 1,
          type: 5130,
          fp64: this.use64bitPositions(),
          transition: ATTRIBUTE_TRANSITION,
          accessor: "getPath",
          update: this.calculatePositions,
          noAlloc,
          shaderAttributes: {
            instanceLeftPositions: {
              vertexOffset: 0
            },
            instanceStartPositions: {
              vertexOffset: 1
            },
            instanceEndPositions: {
              vertexOffset: 2
            },
            instanceRightPositions: {
              vertexOffset: 3
            }
          }
        },
        instanceTypes: {
          size: 1,
          type: 5121,
          update: this.calculateSegmentTypes,
          noAlloc
        },
        instanceStrokeWidths: {
          size: 1,
          accessor: "getWidth",
          transition: ATTRIBUTE_TRANSITION,
          defaultValue: 1
        },
        instanceColors: {
          size: this.props.colorFormat.length,
          type: 5121,
          normalized: true,
          accessor: "getColor",
          transition: ATTRIBUTE_TRANSITION,
          defaultValue: DEFAULT_COLOR
        },
        instancePickingColors: {
          size: 3,
          type: 5121,
          accessor: (object12, {
            index: index5,
            target: value13
          }) => this.encodePickingColor(object12 && object12.__source ? object12.__source.index : index5, value13)
        }
      });
      this.setState({
        pathTesselator: new PathTesselator({
          fp64: this.use64bitPositions()
        })
      });
    }
    updateState(params) {
      super.updateState(params);
      const {
        props,
        changeFlags
      } = params;
      const attributeManager = this.getAttributeManager();
      const geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);
      if (geometryChanged) {
        const {
          pathTesselator
        } = this.state;
        const buffers = props.data.attributes || {};
        pathTesselator.updateGeometry({
          data: props.data,
          geometryBuffer: buffers.getPath,
          buffers,
          normalize: !props._pathType,
          loop: props._pathType === "loop",
          getGeometry: props.getPath,
          positionFormat: props.positionFormat,
          wrapLongitude: props.wrapLongitude,
          resolution: this.context.viewport.resolution,
          dataChanged: changeFlags.dataChanged
        });
        this.setState({
          numInstances: pathTesselator.instanceCount,
          startIndices: pathTesselator.vertexStarts
        });
        if (!changeFlags.dataChanged) {
          attributeManager.invalidateAll();
        }
      }
      if (changeFlags.extensionsChanged) {
        var _this$state$model;
        const {
          gl
        } = this.context;
        (_this$state$model = this.state.model) === null || _this$state$model === void 0 ? void 0 : _this$state$model.delete();
        this.state.model = this._getModel(gl);
        attributeManager.invalidateAll();
      }
    }
    getPickingInfo(params) {
      const info = super.getPickingInfo(params);
      const {
        index: index5
      } = info;
      const {
        data
      } = this.props;
      if (data[0] && data[0].__source) {
        info.object = data.find((d) => d.__source.index === index5);
      }
      return info;
    }
    disablePickingIndex(objectIndex) {
      const {
        data
      } = this.props;
      if (data[0] && data[0].__source) {
        for (let i = 0; i < data.length; i++) {
          if (data[i].__source.index === objectIndex) {
            this._disablePickingIndex(i);
          }
        }
      } else {
        super.disablePickingIndex(objectIndex);
      }
    }
    draw({
      uniforms
    }) {
      const {
        jointRounded,
        capRounded,
        billboard,
        miterLimit,
        widthUnits,
        widthScale,
        widthMinPixels,
        widthMaxPixels
      } = this.props;
      this.state.model.setUniforms(uniforms).setUniforms({
        jointType: Number(jointRounded),
        capType: Number(capRounded),
        billboard,
        widthUnits: UNIT[widthUnits],
        widthScale,
        miterLimit,
        widthMinPixels,
        widthMaxPixels
      }).draw();
    }
    _getModel(gl) {
      const SEGMENT_INDICES = [0, 1, 2, 1, 4, 2, 1, 3, 4, 3, 5, 4];
      const SEGMENT_POSITIONS = [0, 0, 0, -1, 0, 1, 1, -1, 1, 1, 1, 0];
      return new Model(gl, {
        ...this.getShaders(),
        id: this.props.id,
        geometry: new Geometry({
          drawMode: 4,
          attributes: {
            indices: new Uint16Array(SEGMENT_INDICES),
            positions: {
              value: new Float32Array(SEGMENT_POSITIONS),
              size: 2
            }
          }
        }),
        isInstanced: true
      });
    }
    calculatePositions(attribute) {
      const {
        pathTesselator
      } = this.state;
      attribute.startIndices = pathTesselator.vertexStarts;
      attribute.value = pathTesselator.get("positions");
    }
    calculateSegmentTypes(attribute) {
      const {
        pathTesselator
      } = this.state;
      attribute.startIndices = pathTesselator.vertexStarts;
      attribute.value = pathTesselator.get("segmentTypes");
    }
  };
  _defineProperty(PathLayer, "defaultProps", defaultProps3);
  _defineProperty(PathLayer, "layerName", "PathLayer");

  // node_modules/@deck.gl/geo-layers/dist/esm/trips-layer/trips-layer.js
  var defaultProps4 = {
    fadeTrail: true,
    trailLength: {
      type: "number",
      value: 120,
      min: 0
    },
    currentTime: {
      type: "number",
      value: 0,
      min: 0
    },
    getTimestamps: {
      type: "accessor",
      value: (d) => d.timestamps
    }
  };
  var TripsLayer = class extends PathLayer {
    getShaders() {
      const shaders = super.getShaders();
      shaders.inject = {
        "vs:#decl": "uniform float trailLength;\nattribute float instanceTimestamps;\nattribute float instanceNextTimestamps;\nvarying float vTime;\n",
        "vs:#main-end": "vTime = instanceTimestamps + (instanceNextTimestamps - instanceTimestamps) * vPathPosition.y / vPathLength;\n",
        "fs:#decl": "uniform bool fadeTrail;\nuniform float trailLength;\nuniform float currentTime;\nvarying float vTime;\n",
        "fs:#main-start": "if(vTime > currentTime || (fadeTrail && (vTime < currentTime - trailLength))) {\n  discard;\n}\n",
        "fs:DECKGL_FILTER_COLOR": "if(fadeTrail) {\n  color.a *= 1.0 - (currentTime - vTime) / trailLength;\n}\n"
      };
      return shaders;
    }
    initializeState() {
      super.initializeState();
      const attributeManager = this.getAttributeManager();
      attributeManager.addInstanced({
        timestamps: {
          size: 1,
          accessor: "getTimestamps",
          shaderAttributes: {
            instanceTimestamps: {
              vertexOffset: 0
            },
            instanceNextTimestamps: {
              vertexOffset: 1
            }
          }
        }
      });
    }
    draw(params) {
      const {
        fadeTrail,
        trailLength,
        currentTime: currentTime2
      } = this.props;
      params.uniforms = {
        ...params.uniforms,
        fadeTrail,
        trailLength,
        currentTime: currentTime2
      };
      super.draw(params);
    }
  };
  _defineProperty(TripsLayer, "layerName", "TripsLayer");
  _defineProperty(TripsLayer, "defaultProps", defaultProps4);

  // node_modules/@deck.gl/react/dist/esm/deckgl.js
  var import_react5 = __toESM(require_react());

  // node_modules/@deck.gl/react/dist/esm/utils/use-isomorphic-layout-effect.js
  var import_react = __toESM(require_react());
  var useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
  var use_isomorphic_layout_effect_default = useIsomorphicLayoutEffect;

  // node_modules/@deck.gl/react/dist/esm/utils/extract-jsx-layers.js
  var React = __toESM(require_react());
  var import_react3 = __toESM(require_react());

  // node_modules/@deck.gl/react/dist/esm/utils/inherits-from.js
  function inheritsFrom(Type, ParentType) {
    while (Type) {
      if (Type === ParentType) {
        return true;
      }
      Type = Object.getPrototypeOf(Type);
    }
    return false;
  }

  // node_modules/@deck.gl/react/dist/esm/utils/evaluate-children.js
  var import_react2 = __toESM(require_react());
  var MAP_STYLE = {
    position: "absolute",
    zIndex: -1
  };
  function evaluateChildren(children, childProps) {
    if (typeof children === "function") {
      return children(childProps);
    }
    if (Array.isArray(children)) {
      return children.map((child) => evaluateChildren(child, childProps));
    }
    if (isComponent(children)) {
      if (isReactMap(children)) {
        childProps.style = MAP_STYLE;
        return (0, import_react2.cloneElement)(children, childProps);
      }
      if (needsDeckGLViewProps(children)) {
        return (0, import_react2.cloneElement)(children, childProps);
      }
    }
    return children;
  }
  function isComponent(child) {
    return child && typeof child === "object" && "type" in child || false;
  }
  function isReactMap(child) {
    var _child$props;
    return (_child$props = child.props) === null || _child$props === void 0 ? void 0 : _child$props.mapStyle;
  }
  function needsDeckGLViewProps(child) {
    const componentClass = child.type;
    return componentClass && componentClass.deckGLViewProps;
  }

  // node_modules/@deck.gl/react/dist/esm/utils/extract-jsx-layers.js
  function wrapInView(node) {
    if (typeof node === "function") {
      return (0, import_react3.createElement)(View, {}, node);
    }
    if (Array.isArray(node)) {
      return node.map(wrapInView);
    }
    if (isComponent(node)) {
      if (node.type === React.Fragment) {
        return wrapInView(node.props.children);
      }
      if (inheritsFrom(node.type, View)) {
        return node;
      }
    }
    return node;
  }
  function extractJSXLayers({
    children,
    layers = [],
    views = null
  }) {
    const reactChildren = [];
    const jsxLayers = [];
    const jsxViews = {};
    React.Children.forEach(wrapInView(children), (reactElement) => {
      if (isComponent(reactElement)) {
        const ElementType = reactElement.type;
        if (inheritsFrom(ElementType, Layer)) {
          const layer = createLayer(ElementType, reactElement.props);
          jsxLayers.push(layer);
        } else {
          reactChildren.push(reactElement);
        }
        if (inheritsFrom(ElementType, View) && ElementType !== View && reactElement.props.id) {
          const view = new ElementType(reactElement.props);
          jsxViews[view.id] = view;
        }
      } else if (reactElement) {
        reactChildren.push(reactElement);
      }
    });
    if (Object.keys(jsxViews).length > 0) {
      if (Array.isArray(views)) {
        views.forEach((view) => {
          jsxViews[view.id] = view;
        });
      } else if (views) {
        jsxViews[views.id] = views;
      }
      views = Object.values(jsxViews);
    }
    layers = jsxLayers.length > 0 ? [...jsxLayers, ...layers] : layers;
    return {
      layers,
      children: reactChildren,
      views
    };
  }
  function createLayer(LayerType, reactProps) {
    const props = {};
    const defaultProps19 = LayerType.defaultProps || {};
    for (const key in reactProps) {
      if (defaultProps19[key] !== reactProps[key]) {
        props[key] = reactProps[key];
      }
    }
    return new LayerType(props);
  }

  // node_modules/@deck.gl/react/dist/esm/utils/position-children-under-views.js
  var import_react4 = __toESM(require_react());
  function positionChildrenUnderViews({
    children,
    deck,
    ContextProvider
  }) {
    const {
      viewManager
    } = deck || {};
    if (!viewManager || !viewManager.views.length) {
      return [];
    }
    const views = {};
    const defaultViewId = viewManager.views[0].id;
    for (const child of children) {
      let viewId = defaultViewId;
      let viewChildren = child;
      if (isComponent(child) && inheritsFrom(child.type, View)) {
        viewId = child.props.id || defaultViewId;
        viewChildren = child.props.children;
      }
      const viewport = viewManager.getViewport(viewId);
      const viewState = viewManager.getViewState(viewId);
      if (viewport) {
        viewState.padding = viewport.padding;
        const {
          x,
          y,
          width: width8,
          height: height8
        } = viewport;
        viewChildren = evaluateChildren(viewChildren, {
          x,
          y,
          width: width8,
          height: height8,
          viewport,
          viewState
        });
        if (!views[viewId]) {
          views[viewId] = {
            viewport,
            children: []
          };
        }
        views[viewId].children.push(viewChildren);
      }
    }
    return Object.keys(views).map((viewId) => {
      const {
        viewport,
        children: viewChildren
      } = views[viewId];
      const {
        x,
        y,
        width: width8,
        height: height8
      } = viewport;
      const style = {
        position: "absolute",
        left: x,
        top: y,
        width: width8,
        height: height8
      };
      const key = "view-".concat(viewId);
      const viewElement = (0, import_react4.createElement)("div", {
        key,
        id: key,
        style
      }, ...viewChildren);
      if (ContextProvider) {
        const contextValue = {
          viewport,
          container: deck.canvas.offsetParent,
          eventManager: deck.eventManager,
          onViewStateChange: (params) => {
            params.viewId = viewId;
            deck._onViewStateChange(params);
          }
        };
        return (0, import_react4.createElement)(ContextProvider, {
          key,
          value: contextValue
        }, viewElement);
      }
      return viewElement;
    });
  }

  // node_modules/@deck.gl/react/dist/esm/utils/extract-styles.js
  var CANVAS_ONLY_STYLES = {
    mixBlendMode: null
  };
  function extractStyles({
    width: width8,
    height: height8,
    style
  }) {
    const containerStyle = {
      position: "absolute",
      zIndex: 0,
      left: 0,
      top: 0,
      width: width8,
      height: height8
    };
    const canvasStyle = {
      left: 0,
      top: 0
    };
    if (style) {
      for (const key in style) {
        if (key in CANVAS_ONLY_STYLES) {
          canvasStyle[key] = style[key];
        } else {
          containerStyle[key] = style[key];
        }
      }
    }
    return {
      containerStyle,
      canvasStyle
    };
  }

  // node_modules/@deck.gl/react/dist/esm/deckgl.js
  function getRefHandles(thisRef) {
    return {
      get deck() {
        return thisRef.deck;
      },
      pickObject: (opts) => thisRef.deck.pickObject(opts),
      pickMultipleObjects: (opts) => thisRef.deck.pickMultipleObjects(opts),
      pickObjects: (opts) => thisRef.deck.pickObjects(opts)
    };
  }
  function redrawDeck(thisRef) {
    if (thisRef.redrawReason) {
      thisRef.deck._drawLayers(thisRef.redrawReason);
      thisRef.redrawReason = null;
    }
  }
  function createDeckInstance(thisRef, DeckClass, props) {
    const deck = new DeckClass({
      ...props,
      _customRender: (redrawReason) => {
        thisRef.redrawReason = redrawReason;
        const viewports = deck.getViewports();
        if (thisRef.lastRenderedViewports !== viewports) {
          thisRef.forceUpdate();
        } else {
          redrawDeck(thisRef);
        }
      }
    });
    return deck;
  }
  var DeckGL = (0, import_react5.forwardRef)((props, ref) => {
    const [version, setVersion] = (0, import_react5.useState)(0);
    const _thisRef = (0, import_react5.useRef)({
      control: null,
      version,
      forceUpdate: () => setVersion((v) => v + 1)
    });
    const thisRef = _thisRef.current;
    const containerRef = (0, import_react5.useRef)(null);
    const canvasRef = (0, import_react5.useRef)(null);
    const jsxProps = (0, import_react5.useMemo)(() => extractJSXLayers(props), [props.layers, props.views, props.children]);
    let inRender = true;
    const handleViewStateChange = (params) => {
      var _props$onViewStateCha;
      if (inRender && props.viewState) {
        thisRef.viewStateUpdateRequested = params;
        return null;
      }
      thisRef.viewStateUpdateRequested = null;
      return (_props$onViewStateCha = props.onViewStateChange) === null || _props$onViewStateCha === void 0 ? void 0 : _props$onViewStateCha.call(props, params);
    };
    const handleInteractionStateChange = (params) => {
      if (inRender) {
        thisRef.interactionStateUpdateRequested = params;
      } else {
        var _props$onInteractionS;
        thisRef.interactionStateUpdateRequested = null;
        (_props$onInteractionS = props.onInteractionStateChange) === null || _props$onInteractionS === void 0 ? void 0 : _props$onInteractionS.call(props, params);
      }
    };
    const deckProps = (0, import_react5.useMemo)(() => {
      const forwardProps = {
        ...props,
        style: null,
        width: "100%",
        height: "100%",
        parent: containerRef.current,
        canvas: canvasRef.current,
        layers: jsxProps.layers,
        views: jsxProps.views,
        onViewStateChange: handleViewStateChange,
        onInteractionStateChange: handleInteractionStateChange
      };
      delete forwardProps._customRender;
      if (thisRef.deck) {
        thisRef.deck.setProps(forwardProps);
      }
      return forwardProps;
    }, [props]);
    (0, import_react5.useEffect)(() => {
      const DeckClass = props.Deck || Deck;
      thisRef.deck = createDeckInstance(thisRef, DeckClass, {
        ...deckProps,
        parent: containerRef.current,
        canvas: canvasRef.current
      });
      return () => {
        var _thisRef$deck;
        return (_thisRef$deck = thisRef.deck) === null || _thisRef$deck === void 0 ? void 0 : _thisRef$deck.finalize();
      };
    }, []);
    use_isomorphic_layout_effect_default(() => {
      redrawDeck(thisRef);
      const {
        viewStateUpdateRequested,
        interactionStateUpdateRequested
      } = thisRef;
      if (viewStateUpdateRequested) {
        handleViewStateChange(viewStateUpdateRequested);
      }
      if (interactionStateUpdateRequested) {
        handleInteractionStateChange(interactionStateUpdateRequested);
      }
    });
    (0, import_react5.useImperativeHandle)(ref, () => getRefHandles(thisRef), []);
    const currentViewports = thisRef.deck && thisRef.deck.isInitialized ? thisRef.deck.getViewports() : void 0;
    const {
      ContextProvider,
      width: width8,
      height: height8,
      id: id2,
      style
    } = props;
    const {
      containerStyle,
      canvasStyle
    } = (0, import_react5.useMemo)(() => extractStyles({
      width: width8,
      height: height8,
      style
    }), [width8, height8, style]);
    if (!thisRef.viewStateUpdateRequested && thisRef.lastRenderedViewports === currentViewports || thisRef.version !== version) {
      thisRef.lastRenderedViewports = currentViewports;
      thisRef.version = version;
      const childrenUnderViews = positionChildrenUnderViews({
        children: jsxProps.children,
        deck: thisRef.deck,
        ContextProvider
      });
      const canvas = (0, import_react5.createElement)("canvas", {
        key: "canvas",
        id: id2 || "deckgl-overlay",
        ref: canvasRef,
        style: canvasStyle
      });
      thisRef.control = (0, import_react5.createElement)("div", {
        id: "".concat(id2 || "deckgl", "-wrapper"),
        ref: containerRef,
        style: containerStyle
      }, [canvas, childrenUnderViews]);
    }
    inRender = false;
    return thisRef.control;
  });
  DeckGL.defaultProps = Deck.defaultProps;
  var deckgl_default = DeckGL;

  // output/DeckGL.Layer.Trips/foreign.js
  var makeTripsLayer = function(props) {
    return new TripsLayer(props);
  };
  var defaultTripsProps = TripsLayer.defaultProps;

  // output/Partial.Unsafe/foreign.js
  var _unsafePartial = function(f) {
    return f();
  };

  // output/Partial/foreign.js
  var _crashWith = function(msg) {
    throw new Error(msg);
  };

  // output/Partial/index.js
  var crashWith = function() {
    return _crashWith;
  };

  // output/Partial.Unsafe/index.js
  var crashWith2 = /* @__PURE__ */ crashWith();
  var unsafePartial = _unsafePartial;
  var unsafeCrashWith = function(msg) {
    return unsafePartial(function() {
      return crashWith2(msg);
    });
  };

  // output/WebMercator.LngLat/index.js
  var make = function(p) {
    return [p.lng, p.lat];
  };
  var lng = function(v) {
    if (v.length === 2) {
      return v[0];
    }
    ;
    return unsafeCrashWith("Array representing LngLat must contain 2 values");
  };
  var lat = function(v) {
    if (v.length === 2) {
      return v[1];
    }
    ;
    return unsafeCrashWith("Array representing LngLat must contain 2 values");
  };

  // output/App.Layer.Trip/index.js
  var map5 = /* @__PURE__ */ map(functorArray);
  var un2 = /* @__PURE__ */ un();
  var fromJust4 = /* @__PURE__ */ fromJust();
  var minimum2 = /* @__PURE__ */ minimum(ordNumber)(foldableArray);
  var maximum2 = /* @__PURE__ */ maximum(ordNumber)(foldableArray);
  var mkTripR = function(v) {
    return {
      path: map5(function(v1) {
        return make({
          lng: v1.lon,
          lat: v1.lat
        });
      })(v.points),
      timestamps: function() {
        var ts = map5(function() {
          var $17 = un2(Milliseconds);
          return function($18) {
            return $17(unInstant(fromDateTime($18)));
          };
        }())(v.timestamps);
        var start2 = fromJust4(minimum2(ts));
        var duration2 = fromJust4(maximum2(ts)) - start2;
        return map5(function(t) {
          return (t - start2) / duration2;
        })(ts);
      }()
    };
  };
  var fallbackColor = [253, 128, 93];
  var mkTripsLayer = function(props) {
    return makeTripsLayer({
      pickable: defaultTripsProps.pickable,
      onHover: defaultTripsProps.onHover,
      onClick: defaultTripsProps.onClick,
      autoHighlight: defaultTripsProps.autoHighlight,
      highlightedObjectIndex: defaultTripsProps.highlightedObjectIndex,
      highlightColor: defaultTripsProps.highlightColor,
      getTrip: defaultTripsProps.getTrip,
      id: "trip-layer",
      data: props.data,
      getPath: function(v1) {
        return v1.path;
      },
      getTimestamps: function(v1) {
        return v1.timestamps;
      },
      currentTime: props.time,
      opacity: 0.9,
      getColor: $$const(fallbackColor),
      trailLength: 0.05,
      visible: true
    });
  };

  // output/DeckGL/foreign.js
  var defaultDeckGLProps = deckgl_default.defaultProps;
  var deckGL = deckgl_default;

  // output/React/foreign.js
  var import_react7 = __toESM(require_react(), 1);
  function createClass(baseClass) {
    function invoke1(f) {
      return f === void 0 ? f : function(a) {
        return f(a)();
      };
    }
    function invoke2(f) {
      return f === void 0 ? f : function(a, b) {
        return f(a)(b)();
      };
    }
    function invoke3(f) {
      return f === void 0 ? f : function(a, b, c) {
        return f(a)(b)(c)();
      };
    }
    return function(displayName) {
      return function(ctrFn) {
        var Constructor = function(props) {
          baseClass.call(this, props);
          var spec = ctrFn(this)();
          this.state = spec.state;
          this.render = spec.render;
          this.componentDidMount = spec.componentDidMount;
          this.componentWillUnmount = spec.componentWillUnmount;
          this.componentDidCatch = invoke2(spec.componentDidCatch);
          this.componentWillUpdate = invoke2(spec.componentWillUpdate);
          this.shouldComponentUpdate = invoke2(spec.shouldComponentUpdate);
          this.getSnapshotBeforeUpdate = invoke2(spec.getSnapshotBeforeUpdate);
          this.componentDidUpdate = invoke3(spec.componentDidUpdate);
          this.UNSAFE_componentWillMount = spec.unsafeComponentWillMount;
          this.UNSAFE_componentWillReceiveProps = invoke1(spec.unsafeComponentWillReceiveProps);
          this.UNSAFE_componentWillUpdate = invoke2(spec.unsafeComponentWillUpdate);
        };
        Constructor.displayName = displayName;
        Constructor.prototype = Object.create(baseClass.prototype);
        Constructor.prototype.constructor = Constructor;
        return Constructor;
      };
    };
  }
  var componentImpl = createClass(import_react7.default.Component);
  function createClassWithDerivedState(classCtr) {
    return function(displayName) {
      return function(getDerivedStateFromProps) {
        return function(ctrFn) {
          var Constructor = componentImpl(displayName)(ctrFn);
          Constructor.getDerivedStateFromProps = function(a, b) {
            return getDerivedStateFromProps(a)(b);
          };
          return Constructor;
        };
      };
    };
  }
  var componentWithDerivedStateImpl = createClassWithDerivedState(componentImpl);
  var pureComponentImpl = createClass(import_react7.default.PureComponent);
  var pureComponentWithDerivedStateImpl = createClassWithDerivedState(pureComponentImpl);
  var fragment = import_react7.default.Fragment;
  function getProps(this_) {
    return function() {
      return this_.props;
    };
  }
  var childrenToArray = import_react7.default.Children.toArray;
  var childrenCount = import_react7.default.Children.count;
  function setStateImpl(this_) {
    return function(state3) {
      return function() {
        this_.setState(state3);
      };
    };
  }
  function getState(this_) {
    return function() {
      if (!this_.state) {
        throw new Error("[purescript-react] Cannot get state within constructor");
      }
      return this_.state;
    };
  }
  function createElement4(class_) {
    return function(props) {
      return function(children) {
        return import_react7.default.createElement.apply(import_react7.default, [class_, props].concat(children));
      };
    };
  }
  function createLeafElement(class_) {
    return function(props) {
      return import_react7.default.createElement(class_, props);
    };
  }

  // output/Effect/foreign.js
  var pureE = function(a) {
    return function() {
      return a;
    };
  };
  var bindE = function(a) {
    return function(f) {
      return function() {
        return f(a())();
      };
    };
  };

  // output/Control.Monad/index.js
  var ap = function(dictMonad) {
    var bind19 = bind(dictMonad.Bind1());
    var pure17 = pure(dictMonad.Applicative0());
    return function(f) {
      return function(a) {
        return bind19(f)(function(f$prime) {
          return bind19(a)(function(a$prime) {
            return pure17(f$prime(a$prime));
          });
        });
      };
    };
  };

  // output/Effect/index.js
  var $runtime_lazy2 = function(name16, moduleName, init3) {
    var state3 = 0;
    var val;
    return function(lineNumber) {
      if (state3 === 2)
        return val;
      if (state3 === 1)
        throw new ReferenceError(name16 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
      state3 = 1;
      val = init3();
      state3 = 2;
      return val;
    };
  };
  var monadEffect = {
    Applicative0: function() {
      return applicativeEffect;
    },
    Bind1: function() {
      return bindEffect;
    }
  };
  var bindEffect = {
    bind: bindE,
    Apply0: function() {
      return $lazy_applyEffect(0);
    }
  };
  var applicativeEffect = {
    pure: pureE,
    Apply0: function() {
      return $lazy_applyEffect(0);
    }
  };
  var $lazy_functorEffect = /* @__PURE__ */ $runtime_lazy2("functorEffect", "Effect", function() {
    return {
      map: liftA1(applicativeEffect)
    };
  });
  var $lazy_applyEffect = /* @__PURE__ */ $runtime_lazy2("applyEffect", "Effect", function() {
    return {
      apply: ap(monadEffect),
      Functor0: function() {
        return $lazy_functorEffect(0);
      }
    };
  });
  var functorEffect = /* @__PURE__ */ $lazy_functorEffect(20);
  var applyEffect = /* @__PURE__ */ $lazy_applyEffect(23);
  var lift22 = /* @__PURE__ */ lift2(applyEffect);
  var semigroupEffect = function(dictSemigroup) {
    return {
      append: lift22(append(dictSemigroup))
    };
  };
  var monoidEffect = function(dictMonoid) {
    var semigroupEffect1 = semigroupEffect(dictMonoid.Semigroup0());
    return {
      mempty: pureE(mempty(dictMonoid)),
      Semigroup0: function() {
        return semigroupEffect1;
      }
    };
  };

  // output/React/index.js
  var modifyState = setStateImpl;
  var createLeafElement2 = function() {
    return createLeafElement;
  };
  var createElement5 = function() {
    return createElement4;
  };
  var component = function() {
    return componentImpl;
  };

  // output/App.Component.DeckGL/index.js
  var createLeafElement3 = /* @__PURE__ */ createLeafElement2();
  var unwrap2 = /* @__PURE__ */ unwrap();
  var deckGLClass = /* @__PURE__ */ function() {
    var render2 = function($$this) {
      return function __do2() {
        var props = getProps($$this)();
        var tripsLayer = mkTripsLayer(props);
        return createLeafElement3(deckGL)({
          getTooltip: defaultDeckGLProps.getTooltip,
          onClick: defaultDeckGLProps.onClick,
          onHover: defaultDeckGLProps.onHover,
          layers: [tripsLayer],
          viewState: unwrap2(props.viewport)
        });
      };
    };
    return component()("IconLayer")(function($$this) {
      return function __do2() {
        var props = getProps($$this)();
        return {
          render: render2($$this),
          state: {}
        };
      };
    });
  }();

  // output/Affjax/foreign.js
  function _ajax(platformSpecificDriver, timeoutErrorMessageIdent, requestFailedMessageIdent, mkHeader, options2) {
    return function(errback, callback) {
      var xhr = platformSpecificDriver.newXHR();
      var fixedUrl = platformSpecificDriver.fixupUrl(options2.url, xhr);
      xhr.open(options2.method || "GET", fixedUrl, true, options2.username, options2.password);
      if (options2.headers) {
        try {
          for (var i = 0, header; (header = options2.headers[i]) != null; i++) {
            xhr.setRequestHeader(header.field, header.value);
          }
        } catch (e) {
          errback(e);
        }
      }
      var onerror = function(msgIdent) {
        return function() {
          errback(new Error(msgIdent));
        };
      };
      xhr.onerror = onerror(requestFailedMessageIdent);
      xhr.ontimeout = onerror(timeoutErrorMessageIdent);
      xhr.onload = function() {
        callback({
          status: xhr.status,
          statusText: xhr.statusText,
          headers: xhr.getAllResponseHeaders().split("\r\n").filter(function(header2) {
            return header2.length > 0;
          }).map(function(header2) {
            var i2 = header2.indexOf(":");
            return mkHeader(header2.substring(0, i2))(header2.substring(i2 + 2));
          }),
          body: xhr.response
        });
      };
      xhr.responseType = options2.responseType;
      xhr.withCredentials = options2.withCredentials;
      xhr.timeout = options2.timeout;
      xhr.send(options2.content);
      return function(error3, cancelErrback, cancelCallback) {
        try {
          xhr.abort();
        } catch (e) {
          return cancelErrback(e);
        }
        return cancelCallback();
      };
    };
  }

  // output/Data.MediaType.Common/index.js
  var applicationJSON = "application/json";
  var applicationFormURLEncoded = "application/x-www-form-urlencoded";

  // output/Affjax.RequestBody/index.js
  var ArrayView = /* @__PURE__ */ function() {
    function ArrayView2(value0) {
      this.value0 = value0;
    }
    ;
    ArrayView2.create = function(value0) {
      return new ArrayView2(value0);
    };
    return ArrayView2;
  }();
  var Blob2 = /* @__PURE__ */ function() {
    function Blob4(value0) {
      this.value0 = value0;
    }
    ;
    Blob4.create = function(value0) {
      return new Blob4(value0);
    };
    return Blob4;
  }();
  var Document = /* @__PURE__ */ function() {
    function Document3(value0) {
      this.value0 = value0;
    }
    ;
    Document3.create = function(value0) {
      return new Document3(value0);
    };
    return Document3;
  }();
  var $$String = /* @__PURE__ */ function() {
    function $$String3(value0) {
      this.value0 = value0;
    }
    ;
    $$String3.create = function(value0) {
      return new $$String3(value0);
    };
    return $$String3;
  }();
  var FormData = /* @__PURE__ */ function() {
    function FormData2(value0) {
      this.value0 = value0;
    }
    ;
    FormData2.create = function(value0) {
      return new FormData2(value0);
    };
    return FormData2;
  }();
  var FormURLEncoded = /* @__PURE__ */ function() {
    function FormURLEncoded2(value0) {
      this.value0 = value0;
    }
    ;
    FormURLEncoded2.create = function(value0) {
      return new FormURLEncoded2(value0);
    };
    return FormURLEncoded2;
  }();
  var Json = /* @__PURE__ */ function() {
    function Json3(value0) {
      this.value0 = value0;
    }
    ;
    Json3.create = function(value0) {
      return new Json3(value0);
    };
    return Json3;
  }();
  var toMediaType = function(v) {
    if (v instanceof FormURLEncoded) {
      return new Just(applicationFormURLEncoded);
    }
    ;
    if (v instanceof Json) {
      return new Just(applicationJSON);
    }
    ;
    return Nothing.value;
  };

  // output/Affjax.RequestHeader/index.js
  var unwrap3 = /* @__PURE__ */ unwrap();
  var Accept = /* @__PURE__ */ function() {
    function Accept2(value0) {
      this.value0 = value0;
    }
    ;
    Accept2.create = function(value0) {
      return new Accept2(value0);
    };
    return Accept2;
  }();
  var ContentType = /* @__PURE__ */ function() {
    function ContentType2(value0) {
      this.value0 = value0;
    }
    ;
    ContentType2.create = function(value0) {
      return new ContentType2(value0);
    };
    return ContentType2;
  }();
  var RequestHeader = /* @__PURE__ */ function() {
    function RequestHeader2(value0, value1) {
      this.value0 = value0;
      this.value1 = value1;
    }
    ;
    RequestHeader2.create = function(value0) {
      return function(value1) {
        return new RequestHeader2(value0, value1);
      };
    };
    return RequestHeader2;
  }();
  var value = function(v) {
    if (v instanceof Accept) {
      return unwrap3(v.value0);
    }
    ;
    if (v instanceof ContentType) {
      return unwrap3(v.value0);
    }
    ;
    if (v instanceof RequestHeader) {
      return v.value1;
    }
    ;
    throw new Error("Failed pattern match at Affjax.RequestHeader (line 26, column 1 - line 26, column 33): " + [v.constructor.name]);
  };
  var name = function(v) {
    if (v instanceof Accept) {
      return "Accept";
    }
    ;
    if (v instanceof ContentType) {
      return "Content-Type";
    }
    ;
    if (v instanceof RequestHeader) {
      return v.value0;
    }
    ;
    throw new Error("Failed pattern match at Affjax.RequestHeader (line 21, column 1 - line 21, column 32): " + [v.constructor.name]);
  };

  // output/Affjax.ResponseFormat/index.js
  var identity6 = /* @__PURE__ */ identity(categoryFn);
  var $$ArrayBuffer = /* @__PURE__ */ function() {
    function $$ArrayBuffer2(value0) {
      this.value0 = value0;
    }
    ;
    $$ArrayBuffer2.create = function(value0) {
      return new $$ArrayBuffer2(value0);
    };
    return $$ArrayBuffer2;
  }();
  var Blob3 = /* @__PURE__ */ function() {
    function Blob4(value0) {
      this.value0 = value0;
    }
    ;
    Blob4.create = function(value0) {
      return new Blob4(value0);
    };
    return Blob4;
  }();
  var Document2 = /* @__PURE__ */ function() {
    function Document3(value0) {
      this.value0 = value0;
    }
    ;
    Document3.create = function(value0) {
      return new Document3(value0);
    };
    return Document3;
  }();
  var Json2 = /* @__PURE__ */ function() {
    function Json3(value0) {
      this.value0 = value0;
    }
    ;
    Json3.create = function(value0) {
      return new Json3(value0);
    };
    return Json3;
  }();
  var $$String2 = /* @__PURE__ */ function() {
    function $$String3(value0) {
      this.value0 = value0;
    }
    ;
    $$String3.create = function(value0) {
      return new $$String3(value0);
    };
    return $$String3;
  }();
  var Ignore = /* @__PURE__ */ function() {
    function Ignore2(value0) {
      this.value0 = value0;
    }
    ;
    Ignore2.create = function(value0) {
      return new Ignore2(value0);
    };
    return Ignore2;
  }();
  var toResponseType = function(v) {
    if (v instanceof $$ArrayBuffer) {
      return "arraybuffer";
    }
    ;
    if (v instanceof Blob3) {
      return "blob";
    }
    ;
    if (v instanceof Document2) {
      return "document";
    }
    ;
    if (v instanceof Json2) {
      return "text";
    }
    ;
    if (v instanceof $$String2) {
      return "text";
    }
    ;
    if (v instanceof Ignore) {
      return "";
    }
    ;
    throw new Error("Failed pattern match at Affjax.ResponseFormat (line 44, column 3 - line 50, column 19): " + [v.constructor.name]);
  };
  var toMediaType2 = function(v) {
    if (v instanceof Json2) {
      return new Just(applicationJSON);
    }
    ;
    return Nothing.value;
  };
  var json = /* @__PURE__ */ function() {
    return new Json2(identity6);
  }();
  var ignore = /* @__PURE__ */ function() {
    return new Ignore(identity6);
  }();

  // output/Affjax.ResponseHeader/index.js
  var ResponseHeader = /* @__PURE__ */ function() {
    function ResponseHeader2(value0, value1) {
      this.value0 = value0;
      this.value1 = value1;
    }
    ;
    ResponseHeader2.create = function(value0) {
      return function(value1) {
        return new ResponseHeader2(value0, value1);
      };
    };
    return ResponseHeader2;
  }();

  // output/Effect.Exception/foreign.js
  function error2(msg) {
    return new Error(msg);
  }
  function message(e) {
    return e.message;
  }
  function throwException(e) {
    return function() {
      throw e;
    };
  }

  // output/Effect.Exception/index.js
  var $$throw = function($4) {
    return throwException(error2($4));
  };

  // output/Control.Monad.Error.Class/index.js
  var throwError = function(dict) {
    return dict.throwError;
  };
  var monadThrowEither = /* @__PURE__ */ function() {
    return {
      throwError: Left.create,
      Monad0: function() {
        return monadEither;
      }
    };
  }();
  var catchError = function(dict) {
    return dict.catchError;
  };
  var $$try = function(dictMonadError) {
    var catchError1 = catchError(dictMonadError);
    var Monad0 = dictMonadError.MonadThrow0().Monad0();
    var map16 = map(Monad0.Bind1().Apply0().Functor0());
    var pure17 = pure(Monad0.Applicative0());
    return function(a) {
      return catchError1(map16(Right.create)(a))(function($52) {
        return pure17(Left.create($52));
      });
    };
  };

  // output/Control.Monad.Rec.Class/index.js
  var Loop = /* @__PURE__ */ function() {
    function Loop2(value0) {
      this.value0 = value0;
    }
    ;
    Loop2.create = function(value0) {
      return new Loop2(value0);
    };
    return Loop2;
  }();
  var Done = /* @__PURE__ */ function() {
    function Done2(value0) {
      this.value0 = value0;
    }
    ;
    Done2.create = function(value0) {
      return new Done2(value0);
    };
    return Done2;
  }();
  var tailRecM = function(dict) {
    return dict.tailRecM;
  };
  var forever = function(dictMonadRec) {
    var tailRecM1 = tailRecM(dictMonadRec);
    var voidRight2 = voidRight(dictMonadRec.Monad0().Bind1().Apply0().Functor0());
    return function(ma) {
      return tailRecM1(function(u) {
        return voidRight2(new Loop(u))(ma);
      })(unit);
    };
  };

  // output/Control.Monad.Trans.Class/index.js
  var lift = function(dict) {
    return dict.lift;
  };

  // output/Effect.Class/index.js
  var liftEffect = function(dict) {
    return dict.liftEffect;
  };

  // output/Control.Monad.Except.Trans/index.js
  var map6 = /* @__PURE__ */ map(functorEither);
  var ExceptT = function(x) {
    return x;
  };
  var runExceptT = function(v) {
    return v;
  };
  var monadTransExceptT = {
    lift: function(dictMonad) {
      var bind19 = bind(dictMonad.Bind1());
      var pure17 = pure(dictMonad.Applicative0());
      return function(m) {
        return bind19(m)(function(a) {
          return pure17(new Right(a));
        });
      };
    }
  };
  var mapExceptT = function(f) {
    return function(v) {
      return f(v);
    };
  };
  var functorExceptT = function(dictFunctor) {
    var map16 = map(dictFunctor);
    return {
      map: function(f) {
        return mapExceptT(map16(map6(f)));
      }
    };
  };
  var except = function(dictApplicative) {
    var $185 = pure(dictApplicative);
    return function($186) {
      return ExceptT($185($186));
    };
  };
  var monadExceptT = function(dictMonad) {
    return {
      Applicative0: function() {
        return applicativeExceptT(dictMonad);
      },
      Bind1: function() {
        return bindExceptT(dictMonad);
      }
    };
  };
  var bindExceptT = function(dictMonad) {
    var bind19 = bind(dictMonad.Bind1());
    var pure17 = pure(dictMonad.Applicative0());
    return {
      bind: function(v) {
        return function(k) {
          return bind19(v)(either(function($187) {
            return pure17(Left.create($187));
          })(function(a) {
            var v1 = k(a);
            return v1;
          }));
        };
      },
      Apply0: function() {
        return applyExceptT(dictMonad);
      }
    };
  };
  var applyExceptT = function(dictMonad) {
    var functorExceptT1 = functorExceptT(dictMonad.Bind1().Apply0().Functor0());
    return {
      apply: ap(monadExceptT(dictMonad)),
      Functor0: function() {
        return functorExceptT1;
      }
    };
  };
  var applicativeExceptT = function(dictMonad) {
    return {
      pure: function() {
        var $188 = pure(dictMonad.Applicative0());
        return function($189) {
          return ExceptT($188(Right.create($189)));
        };
      }(),
      Apply0: function() {
        return applyExceptT(dictMonad);
      }
    };
  };
  var monadThrowExceptT = function(dictMonad) {
    var monadExceptT1 = monadExceptT(dictMonad);
    return {
      throwError: function() {
        var $198 = pure(dictMonad.Applicative0());
        return function($199) {
          return ExceptT($198(Left.create($199)));
        };
      }(),
      Monad0: function() {
        return monadExceptT1;
      }
    };
  };
  var altExceptT = function(dictSemigroup) {
    var append3 = append(dictSemigroup);
    return function(dictMonad) {
      var Bind1 = dictMonad.Bind1();
      var bind19 = bind(Bind1);
      var pure17 = pure(dictMonad.Applicative0());
      var functorExceptT1 = functorExceptT(Bind1.Apply0().Functor0());
      return {
        alt: function(v) {
          return function(v1) {
            return bind19(v)(function(rm) {
              if (rm instanceof Right) {
                return pure17(new Right(rm.value0));
              }
              ;
              if (rm instanceof Left) {
                return bind19(v1)(function(rn) {
                  if (rn instanceof Right) {
                    return pure17(new Right(rn.value0));
                  }
                  ;
                  if (rn instanceof Left) {
                    return pure17(new Left(append3(rm.value0)(rn.value0)));
                  }
                  ;
                  throw new Error("Failed pattern match at Control.Monad.Except.Trans (line 86, column 9 - line 88, column 49): " + [rn.constructor.name]);
                });
              }
              ;
              throw new Error("Failed pattern match at Control.Monad.Except.Trans (line 82, column 5 - line 88, column 49): " + [rm.constructor.name]);
            });
          };
        },
        Functor0: function() {
          return functorExceptT1;
        }
      };
    };
  };

  // output/Control.Monad.Except/index.js
  var unwrap4 = /* @__PURE__ */ unwrap();
  var runExcept = function($3) {
    return unwrap4(runExceptT($3));
  };

  // output/Data.Argonaut.Core/foreign.js
  function id(x) {
    return x;
  }
  function stringify(j) {
    return JSON.stringify(j);
  }
  function _caseJson(isNull3, isBool, isNum, isStr, isArr, isObj, j) {
    if (j == null)
      return isNull3();
    else if (typeof j === "boolean")
      return isBool(j);
    else if (typeof j === "number")
      return isNum(j);
    else if (typeof j === "string")
      return isStr(j);
    else if (Object.prototype.toString.call(j) === "[object Array]")
      return isArr(j);
    else
      return isObj(j);
  }

  // output/Foreign.Object/foreign.js
  function _copyST(m) {
    return function() {
      var r = {};
      for (var k in m) {
        if (hasOwnProperty.call(m, k)) {
          r[k] = m[k];
        }
      }
      return r;
    };
  }
  var empty2 = {};
  function runST(f) {
    return f();
  }
  function _fmapObject(m0, f) {
    var m = {};
    for (var k in m0) {
      if (hasOwnProperty.call(m0, k)) {
        m[k] = f(m0[k]);
      }
    }
    return m;
  }
  function _mapWithKey(m0, f) {
    var m = {};
    for (var k in m0) {
      if (hasOwnProperty.call(m0, k)) {
        m[k] = f(k)(m0[k]);
      }
    }
    return m;
  }
  function _foldM(bind19) {
    return function(f) {
      return function(mz) {
        return function(m) {
          var acc = mz;
          function g(k2) {
            return function(z) {
              return f(z)(k2)(m[k2]);
            };
          }
          for (var k in m) {
            if (hasOwnProperty.call(m, k)) {
              acc = bind19(acc)(g(k));
            }
          }
          return acc;
        };
      };
    };
  }
  function _lookup(no, yes, k, m) {
    return k in m ? yes(m[k]) : no;
  }
  function toArrayWithKey(f) {
    return function(m) {
      var r = [];
      for (var k in m) {
        if (hasOwnProperty.call(m, k)) {
          r.push(f(k)(m[k]));
        }
      }
      return r;
    };
  }
  var keys = Object.keys || toArrayWithKey(function(k) {
    return function() {
      return k;
    };
  });

  // output/Data.Array/foreign.js
  var replicateFill = function(count2, value13) {
    if (count2 < 1) {
      return [];
    }
    var result = new Array(count2);
    return result.fill(value13);
  };
  var replicatePolyfill = function(count2, value13) {
    var result = [];
    var n = 0;
    for (var i = 0; i < count2; i++) {
      result[n++] = value13;
    }
    return result;
  };
  var replicateImpl = typeof Array.prototype.fill === "function" ? replicateFill : replicatePolyfill;
  var fromFoldableImpl = function() {
    function Cons2(head4, tail3) {
      this.head = head4;
      this.tail = tail3;
    }
    var emptyList = {};
    function curryCons(head4) {
      return function(tail3) {
        return new Cons2(head4, tail3);
      };
    }
    function listToArray(list) {
      var result = [];
      var count2 = 0;
      var xs = list;
      while (xs !== emptyList) {
        result[count2++] = xs.head;
        xs = xs.tail;
      }
      return result;
    }
    return function(foldr4, xs) {
      return listToArray(foldr4(curryCons)(emptyList)(xs));
    };
  }();
  var unconsImpl = function(empty4, next, xs) {
    return xs.length === 0 ? empty4({}) : next(xs[0])(xs.slice(1));
  };
  var indexImpl = function(just, nothing, xs, i) {
    return i < 0 || i >= xs.length ? nothing : just(xs[i]);
  };
  var concat = function(xss) {
    if (xss.length <= 1e4) {
      return Array.prototype.concat.apply([], xss);
    }
    var result = [];
    for (var i = 0, l = xss.length; i < l; i++) {
      var xs = xss[i];
      for (var j = 0, m = xs.length; j < m; j++) {
        result.push(xs[j]);
      }
    }
    return result;
  };
  var sortByImpl = function() {
    function mergeFromTo(compare2, fromOrdering, xs1, xs2, from3, to) {
      var mid;
      var i;
      var j;
      var k;
      var x;
      var y;
      var c;
      mid = from3 + (to - from3 >> 1);
      if (mid - from3 > 1)
        mergeFromTo(compare2, fromOrdering, xs2, xs1, from3, mid);
      if (to - mid > 1)
        mergeFromTo(compare2, fromOrdering, xs2, xs1, mid, to);
      i = from3;
      j = mid;
      k = from3;
      while (i < mid && j < to) {
        x = xs2[i];
        y = xs2[j];
        c = fromOrdering(compare2(x)(y));
        if (c > 0) {
          xs1[k++] = y;
          ++j;
        } else {
          xs1[k++] = x;
          ++i;
        }
      }
      while (i < mid) {
        xs1[k++] = xs2[i++];
      }
      while (j < to) {
        xs1[k++] = xs2[j++];
      }
    }
    return function(compare2, fromOrdering, xs) {
      var out;
      if (xs.length < 2)
        return xs;
      out = xs.slice(0);
      mergeFromTo(compare2, fromOrdering, out, xs.slice(0), 0, xs.length);
      return out;
    };
  }();

  // output/Data.Array.ST/foreign.js
  function unsafeFreezeThawImpl(xs) {
    return xs;
  }
  var unsafeFreezeImpl = unsafeFreezeThawImpl;
  function copyImpl(xs) {
    return xs.slice();
  }
  var thawImpl = copyImpl;
  var sortByImpl2 = function() {
    function mergeFromTo(compare2, fromOrdering, xs1, xs2, from3, to) {
      var mid;
      var i;
      var j;
      var k;
      var x;
      var y;
      var c;
      mid = from3 + (to - from3 >> 1);
      if (mid - from3 > 1)
        mergeFromTo(compare2, fromOrdering, xs2, xs1, from3, mid);
      if (to - mid > 1)
        mergeFromTo(compare2, fromOrdering, xs2, xs1, mid, to);
      i = from3;
      j = mid;
      k = from3;
      while (i < mid && j < to) {
        x = xs2[i];
        y = xs2[j];
        c = fromOrdering(compare2(x)(y));
        if (c > 0) {
          xs1[k++] = y;
          ++j;
        } else {
          xs1[k++] = x;
          ++i;
        }
      }
      while (i < mid) {
        xs1[k++] = xs2[i++];
      }
      while (j < to) {
        xs1[k++] = xs2[j++];
      }
    }
    return function(compare2, fromOrdering, xs) {
      if (xs.length < 2)
        return xs;
      mergeFromTo(compare2, fromOrdering, xs, xs.slice(0), 0, xs.length);
      return xs;
    };
  }();
  var pushImpl = function(a, xs) {
    return xs.push(a);
  };

  // output/Control.Monad.ST.Uncurried/foreign.js
  var runSTFn1 = function runSTFn12(fn) {
    return function(a) {
      return function() {
        return fn(a);
      };
    };
  };
  var runSTFn2 = function runSTFn22(fn) {
    return function(a) {
      return function(b) {
        return function() {
          return fn(a, b);
        };
      };
    };
  };

  // output/Data.Array.ST/index.js
  var unsafeFreeze = /* @__PURE__ */ runSTFn1(unsafeFreezeImpl);
  var thaw = /* @__PURE__ */ runSTFn1(thawImpl);
  var withArray = function(f) {
    return function(xs) {
      return function __do2() {
        var result = thaw(xs)();
        f(result)();
        return unsafeFreeze(result)();
      };
    };
  };
  var push2 = /* @__PURE__ */ runSTFn2(pushImpl);

  // output/Data.Function.Uncurried/foreign.js
  var runFn3 = function(fn) {
    return function(a) {
      return function(b) {
        return function(c) {
          return fn(a, b, c);
        };
      };
    };
  };
  var runFn4 = function(fn) {
    return function(a) {
      return function(b) {
        return function(c) {
          return function(d) {
            return fn(a, b, c, d);
          };
        };
      };
    };
  };

  // output/Data.FunctorWithIndex/foreign.js
  var mapWithIndexArray = function(f) {
    return function(xs) {
      var l = xs.length;
      var result = Array(l);
      for (var i = 0; i < l; i++) {
        result[i] = f(i)(xs[i]);
      }
      return result;
    };
  };

  // output/Data.FunctorWithIndex/index.js
  var mapWithIndex = function(dict) {
    return dict.mapWithIndex;
  };
  var functorWithIndexArray = {
    mapWithIndex: mapWithIndexArray,
    Functor0: function() {
      return functorArray;
    }
  };

  // output/Data.Array/index.js
  var foldMap1 = /* @__PURE__ */ foldMap(foldableArray);
  var uncons = /* @__PURE__ */ function() {
    return runFn3(unconsImpl)($$const(Nothing.value))(function(x) {
      return function(xs) {
        return new Just({
          head: x,
          tail: xs
        });
      };
    });
  }();
  var snoc = function(xs) {
    return function(x) {
      return withArray(push2(x))(xs)();
    };
  };
  var index = /* @__PURE__ */ function() {
    return runFn4(indexImpl)(Just.create)(Nothing.value);
  }();
  var head = function(xs) {
    return index(xs)(0);
  };
  var foldMap2 = function(dictMonoid) {
    return foldMap1(dictMonoid);
  };

  // output/Data.FoldableWithIndex/index.js
  var foldr8 = /* @__PURE__ */ foldr(foldableArray);
  var mapWithIndex2 = /* @__PURE__ */ mapWithIndex(functorWithIndexArray);
  var foldl8 = /* @__PURE__ */ foldl(foldableArray);
  var foldrWithIndex = function(dict) {
    return dict.foldrWithIndex;
  };
  var foldMapWithIndexDefaultR = function(dictFoldableWithIndex) {
    var foldrWithIndex1 = foldrWithIndex(dictFoldableWithIndex);
    return function(dictMonoid) {
      var append3 = append(dictMonoid.Semigroup0());
      var mempty3 = mempty(dictMonoid);
      return function(f) {
        return foldrWithIndex1(function(i) {
          return function(x) {
            return function(acc) {
              return append3(f(i)(x))(acc);
            };
          };
        })(mempty3);
      };
    };
  };
  var foldableWithIndexArray = {
    foldrWithIndex: function(f) {
      return function(z) {
        var $291 = foldr8(function(v) {
          return function(y) {
            return f(v.value0)(v.value1)(y);
          };
        })(z);
        var $292 = mapWithIndex2(Tuple.create);
        return function($293) {
          return $291($292($293));
        };
      };
    },
    foldlWithIndex: function(f) {
      return function(z) {
        var $294 = foldl8(function(y) {
          return function(v) {
            return f(v.value0)(y)(v.value1);
          };
        })(z);
        var $295 = mapWithIndex2(Tuple.create);
        return function($296) {
          return $294($295($296));
        };
      };
    },
    foldMapWithIndex: function(dictMonoid) {
      return foldMapWithIndexDefaultR(foldableWithIndexArray)(dictMonoid);
    },
    Foldable0: function() {
      return foldableArray;
    }
  };

  // output/Data.TraversableWithIndex/index.js
  var traverseWithIndexDefault = function(dictTraversableWithIndex) {
    var sequence2 = sequence(dictTraversableWithIndex.Traversable2());
    var mapWithIndex4 = mapWithIndex(dictTraversableWithIndex.FunctorWithIndex0());
    return function(dictApplicative) {
      var sequence12 = sequence2(dictApplicative);
      return function(f) {
        var $174 = mapWithIndex4(f);
        return function($175) {
          return sequence12($174($175));
        };
      };
    };
  };
  var traverseWithIndex = function(dict) {
    return dict.traverseWithIndex;
  };
  var traversableWithIndexArray = {
    traverseWithIndex: function(dictApplicative) {
      return traverseWithIndexDefault(traversableWithIndexArray)(dictApplicative);
    },
    FunctorWithIndex0: function() {
      return functorWithIndexArray;
    },
    FoldableWithIndex1: function() {
      return foldableWithIndexArray;
    },
    Traversable2: function() {
      return traversableArray;
    }
  };

  // output/Foreign.Object.ST/foreign.js
  function poke2(k) {
    return function(v) {
      return function(m) {
        return function() {
          m[k] = v;
          return m;
        };
      };
    };
  }

  // output/Foreign.Object/index.js
  var foldr2 = /* @__PURE__ */ foldr(foldableArray);
  var identity7 = /* @__PURE__ */ identity(categoryFn);
  var values = /* @__PURE__ */ toArrayWithKey(function(v) {
    return function(v1) {
      return v1;
    };
  });
  var thawST = _copyST;
  var mutate = function(f) {
    return function(m) {
      return runST(function __do2() {
        var s = thawST(m)();
        f(s)();
        return s;
      });
    };
  };
  var mapWithKey = function(f) {
    return function(m) {
      return _mapWithKey(m, f);
    };
  };
  var lookup = /* @__PURE__ */ function() {
    return runFn4(_lookup)(Nothing.value)(Just.create);
  }();
  var insert = function(k) {
    return function(v) {
      return mutate(poke2(k)(v));
    };
  };
  var functorObject = {
    map: function(f) {
      return function(m) {
        return _fmapObject(m, f);
      };
    }
  };
  var functorWithIndexObject = {
    mapWithIndex: mapWithKey,
    Functor0: function() {
      return functorObject;
    }
  };
  var fold2 = /* @__PURE__ */ _foldM(applyFlipped);
  var foldMap3 = function(dictMonoid) {
    var append12 = append(dictMonoid.Semigroup0());
    var mempty3 = mempty(dictMonoid);
    return function(f) {
      return fold2(function(acc) {
        return function(k) {
          return function(v) {
            return append12(acc)(f(k)(v));
          };
        };
      })(mempty3);
    };
  };
  var foldableObject = {
    foldl: function(f) {
      return fold2(function(z) {
        return function(v) {
          return f(z);
        };
      });
    },
    foldr: function(f) {
      return function(z) {
        return function(m) {
          return foldr2(f)(z)(values(m));
        };
      };
    },
    foldMap: function(dictMonoid) {
      var foldMap13 = foldMap3(dictMonoid);
      return function(f) {
        return foldMap13($$const(f));
      };
    }
  };
  var foldableWithIndexObject = {
    foldlWithIndex: function(f) {
      return fold2(flip(f));
    },
    foldrWithIndex: function(f) {
      return function(z) {
        return function(m) {
          return foldr2(uncurry(f))(z)(toArrayWithKey(Tuple.create)(m));
        };
      };
    },
    foldMapWithIndex: function(dictMonoid) {
      return foldMap3(dictMonoid);
    },
    Foldable0: function() {
      return foldableObject;
    }
  };
  var traversableWithIndexObject = {
    traverseWithIndex: function(dictApplicative) {
      var Apply0 = dictApplicative.Apply0();
      var apply3 = apply(Apply0);
      var map16 = map(Apply0.Functor0());
      var pure17 = pure(dictApplicative);
      return function(f) {
        return function(ms) {
          return fold2(function(acc) {
            return function(k) {
              return function(v) {
                return apply3(map16(flip(insert(k)))(acc))(f(k)(v));
              };
            };
          })(pure17(empty2))(ms);
        };
      };
    },
    FunctorWithIndex0: function() {
      return functorWithIndexObject;
    },
    FoldableWithIndex1: function() {
      return foldableWithIndexObject;
    },
    Traversable2: function() {
      return traversableObject;
    }
  };
  var traversableObject = {
    traverse: function(dictApplicative) {
      var $96 = traverseWithIndex(traversableWithIndexObject)(dictApplicative);
      return function($97) {
        return $96($$const($97));
      };
    },
    sequence: function(dictApplicative) {
      return traverse(traversableObject)(dictApplicative)(identity7);
    },
    Functor0: function() {
      return functorObject;
    },
    Foldable1: function() {
      return foldableObject;
    }
  };

  // output/Data.Argonaut.Core/index.js
  var verbJsonType = function(def) {
    return function(f) {
      return function(g) {
        return g(def)(f);
      };
    };
  };
  var toJsonType = /* @__PURE__ */ function() {
    return verbJsonType(Nothing.value)(Just.create);
  }();
  var jsonEmptyObject = /* @__PURE__ */ id(empty2);
  var isJsonType = /* @__PURE__ */ verbJsonType(false)(/* @__PURE__ */ $$const(true));
  var caseJsonString = function(d) {
    return function(f) {
      return function(j) {
        return _caseJson($$const(d), $$const(d), $$const(d), f, $$const(d), $$const(d), j);
      };
    };
  };
  var toString = /* @__PURE__ */ toJsonType(caseJsonString);
  var caseJsonObject = function(d) {
    return function(f) {
      return function(j) {
        return _caseJson($$const(d), $$const(d), $$const(d), $$const(d), $$const(d), f, j);
      };
    };
  };
  var toObject = /* @__PURE__ */ toJsonType(caseJsonObject);
  var caseJsonNumber = function(d) {
    return function(f) {
      return function(j) {
        return _caseJson($$const(d), $$const(d), f, $$const(d), $$const(d), $$const(d), j);
      };
    };
  };
  var toNumber2 = /* @__PURE__ */ toJsonType(caseJsonNumber);
  var caseJsonNull = function(d) {
    return function(f) {
      return function(j) {
        return _caseJson(f, $$const(d), $$const(d), $$const(d), $$const(d), $$const(d), j);
      };
    };
  };
  var isNull = /* @__PURE__ */ isJsonType(caseJsonNull);
  var caseJsonArray = function(d) {
    return function(f) {
      return function(j) {
        return _caseJson($$const(d), $$const(d), $$const(d), $$const(d), f, $$const(d), j);
      };
    };
  };
  var toArray = /* @__PURE__ */ toJsonType(caseJsonArray);

  // output/Data.Argonaut.Parser/foreign.js
  function _jsonParser(fail3, succ2, s) {
    try {
      return succ2(JSON.parse(s));
    } catch (e) {
      return fail3(e.message);
    }
  }

  // output/Data.Argonaut.Parser/index.js
  var jsonParser = function(j) {
    return _jsonParser(Left.create, Right.create, j);
  };

  // output/Data.String.Common/foreign.js
  var joinWith = function(s) {
    return function(xs) {
      return xs.join(s);
    };
  };

  // output/JSURI/foreign.js
  function encodeURIComponent_to_RFC3986(input) {
    return input.replace(/[!'()*]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16);
    });
  }
  function _encodeFormURLComponent(fail3, succeed, input) {
    try {
      return succeed(encodeURIComponent_to_RFC3986(encodeURIComponent(input)).replace(/%20/g, "+"));
    } catch (err) {
      return fail3(err);
    }
  }

  // output/JSURI/index.js
  var encodeFormURLComponent = /* @__PURE__ */ function() {
    return runFn3(_encodeFormURLComponent)($$const(Nothing.value))(Just.create);
  }();

  // output/Data.FormURLEncoded/index.js
  var apply2 = /* @__PURE__ */ apply(applyMaybe);
  var map7 = /* @__PURE__ */ map(functorMaybe);
  var traverse2 = /* @__PURE__ */ traverse(traversableArray)(applicativeMaybe);
  var toArray2 = function(v) {
    return v;
  };
  var encode = /* @__PURE__ */ function() {
    var encodePart = function(v) {
      if (v.value1 instanceof Nothing) {
        return encodeFormURLComponent(v.value0);
      }
      ;
      if (v.value1 instanceof Just) {
        return apply2(map7(function(key) {
          return function(val) {
            return key + ("=" + val);
          };
        })(encodeFormURLComponent(v.value0)))(encodeFormURLComponent(v.value1.value0));
      }
      ;
      throw new Error("Failed pattern match at Data.FormURLEncoded (line 37, column 16 - line 39, column 114): " + [v.constructor.name]);
    };
    var $37 = map7(joinWith("&"));
    var $38 = traverse2(encodePart);
    return function($39) {
      return $37($38(toArray2($39)));
    };
  }();

  // output/Data.HTTP.Method/index.js
  var OPTIONS = /* @__PURE__ */ function() {
    function OPTIONS2() {
    }
    ;
    OPTIONS2.value = new OPTIONS2();
    return OPTIONS2;
  }();
  var GET = /* @__PURE__ */ function() {
    function GET2() {
    }
    ;
    GET2.value = new GET2();
    return GET2;
  }();
  var HEAD = /* @__PURE__ */ function() {
    function HEAD2() {
    }
    ;
    HEAD2.value = new HEAD2();
    return HEAD2;
  }();
  var POST = /* @__PURE__ */ function() {
    function POST2() {
    }
    ;
    POST2.value = new POST2();
    return POST2;
  }();
  var PUT = /* @__PURE__ */ function() {
    function PUT2() {
    }
    ;
    PUT2.value = new PUT2();
    return PUT2;
  }();
  var DELETE = /* @__PURE__ */ function() {
    function DELETE2() {
    }
    ;
    DELETE2.value = new DELETE2();
    return DELETE2;
  }();
  var TRACE = /* @__PURE__ */ function() {
    function TRACE2() {
    }
    ;
    TRACE2.value = new TRACE2();
    return TRACE2;
  }();
  var CONNECT = /* @__PURE__ */ function() {
    function CONNECT2() {
    }
    ;
    CONNECT2.value = new CONNECT2();
    return CONNECT2;
  }();
  var PROPFIND = /* @__PURE__ */ function() {
    function PROPFIND2() {
    }
    ;
    PROPFIND2.value = new PROPFIND2();
    return PROPFIND2;
  }();
  var PROPPATCH = /* @__PURE__ */ function() {
    function PROPPATCH2() {
    }
    ;
    PROPPATCH2.value = new PROPPATCH2();
    return PROPPATCH2;
  }();
  var MKCOL = /* @__PURE__ */ function() {
    function MKCOL2() {
    }
    ;
    MKCOL2.value = new MKCOL2();
    return MKCOL2;
  }();
  var COPY = /* @__PURE__ */ function() {
    function COPY2() {
    }
    ;
    COPY2.value = new COPY2();
    return COPY2;
  }();
  var MOVE = /* @__PURE__ */ function() {
    function MOVE2() {
    }
    ;
    MOVE2.value = new MOVE2();
    return MOVE2;
  }();
  var LOCK = /* @__PURE__ */ function() {
    function LOCK2() {
    }
    ;
    LOCK2.value = new LOCK2();
    return LOCK2;
  }();
  var UNLOCK = /* @__PURE__ */ function() {
    function UNLOCK2() {
    }
    ;
    UNLOCK2.value = new UNLOCK2();
    return UNLOCK2;
  }();
  var PATCH = /* @__PURE__ */ function() {
    function PATCH2() {
    }
    ;
    PATCH2.value = new PATCH2();
    return PATCH2;
  }();
  var unCustomMethod = function(v) {
    return v;
  };
  var showMethod = {
    show: function(v) {
      if (v instanceof OPTIONS) {
        return "OPTIONS";
      }
      ;
      if (v instanceof GET) {
        return "GET";
      }
      ;
      if (v instanceof HEAD) {
        return "HEAD";
      }
      ;
      if (v instanceof POST) {
        return "POST";
      }
      ;
      if (v instanceof PUT) {
        return "PUT";
      }
      ;
      if (v instanceof DELETE) {
        return "DELETE";
      }
      ;
      if (v instanceof TRACE) {
        return "TRACE";
      }
      ;
      if (v instanceof CONNECT) {
        return "CONNECT";
      }
      ;
      if (v instanceof PROPFIND) {
        return "PROPFIND";
      }
      ;
      if (v instanceof PROPPATCH) {
        return "PROPPATCH";
      }
      ;
      if (v instanceof MKCOL) {
        return "MKCOL";
      }
      ;
      if (v instanceof COPY) {
        return "COPY";
      }
      ;
      if (v instanceof MOVE) {
        return "MOVE";
      }
      ;
      if (v instanceof LOCK) {
        return "LOCK";
      }
      ;
      if (v instanceof UNLOCK) {
        return "UNLOCK";
      }
      ;
      if (v instanceof PATCH) {
        return "PATCH";
      }
      ;
      throw new Error("Failed pattern match at Data.HTTP.Method (line 43, column 1 - line 59, column 23): " + [v.constructor.name]);
    }
  };
  var print = /* @__PURE__ */ either(/* @__PURE__ */ show(showMethod))(unCustomMethod);

  // output/Data.NonEmpty/index.js
  var NonEmpty = /* @__PURE__ */ function() {
    function NonEmpty2(value0, value1) {
      this.value0 = value0;
      this.value1 = value1;
    }
    ;
    NonEmpty2.create = function(value0) {
      return function(value1) {
        return new NonEmpty2(value0, value1);
      };
    };
    return NonEmpty2;
  }();
  var singleton3 = function(dictPlus) {
    var empty4 = empty(dictPlus);
    return function(a) {
      return new NonEmpty(a, empty4);
    };
  };

  // output/Data.List.Types/index.js
  var Nil = /* @__PURE__ */ function() {
    function Nil2() {
    }
    ;
    Nil2.value = new Nil2();
    return Nil2;
  }();
  var Cons = /* @__PURE__ */ function() {
    function Cons2(value0, value1) {
      this.value0 = value0;
      this.value1 = value1;
    }
    ;
    Cons2.create = function(value0) {
      return function(value1) {
        return new Cons2(value0, value1);
      };
    };
    return Cons2;
  }();
  var NonEmptyList = function(x) {
    return x;
  };
  var toList = function(v) {
    return new Cons(v.value0, v.value1);
  };
  var listMap = function(f) {
    var chunkedRevMap = function($copy_v) {
      return function($copy_v1) {
        var $tco_var_v = $copy_v;
        var $tco_done = false;
        var $tco_result;
        function $tco_loop(v, v1) {
          if (v1 instanceof Cons && (v1.value1 instanceof Cons && v1.value1.value1 instanceof Cons)) {
            $tco_var_v = new Cons(v1, v);
            $copy_v1 = v1.value1.value1.value1;
            return;
          }
          ;
          var unrolledMap = function(v2) {
            if (v2 instanceof Cons && (v2.value1 instanceof Cons && v2.value1.value1 instanceof Nil)) {
              return new Cons(f(v2.value0), new Cons(f(v2.value1.value0), Nil.value));
            }
            ;
            if (v2 instanceof Cons && v2.value1 instanceof Nil) {
              return new Cons(f(v2.value0), Nil.value);
            }
            ;
            return Nil.value;
          };
          var reverseUnrolledMap = function($copy_v2) {
            return function($copy_v3) {
              var $tco_var_v2 = $copy_v2;
              var $tco_done1 = false;
              var $tco_result2;
              function $tco_loop2(v2, v3) {
                if (v2 instanceof Cons && (v2.value0 instanceof Cons && (v2.value0.value1 instanceof Cons && v2.value0.value1.value1 instanceof Cons))) {
                  $tco_var_v2 = v2.value1;
                  $copy_v3 = new Cons(f(v2.value0.value0), new Cons(f(v2.value0.value1.value0), new Cons(f(v2.value0.value1.value1.value0), v3)));
                  return;
                }
                ;
                $tco_done1 = true;
                return v3;
              }
              ;
              while (!$tco_done1) {
                $tco_result2 = $tco_loop2($tco_var_v2, $copy_v3);
              }
              ;
              return $tco_result2;
            };
          };
          $tco_done = true;
          return reverseUnrolledMap(v)(unrolledMap(v1));
        }
        ;
        while (!$tco_done) {
          $tco_result = $tco_loop($tco_var_v, $copy_v1);
        }
        ;
        return $tco_result;
      };
    };
    return chunkedRevMap(Nil.value);
  };
  var functorList = {
    map: listMap
  };
  var foldableList = {
    foldr: function(f) {
      return function(b) {
        var rev3 = function() {
          var go2 = function($copy_v) {
            return function($copy_v1) {
              var $tco_var_v = $copy_v;
              var $tco_done = false;
              var $tco_result;
              function $tco_loop(v, v1) {
                if (v1 instanceof Nil) {
                  $tco_done = true;
                  return v;
                }
                ;
                if (v1 instanceof Cons) {
                  $tco_var_v = new Cons(v1.value0, v);
                  $copy_v1 = v1.value1;
                  return;
                }
                ;
                throw new Error("Failed pattern match at Data.List.Types (line 107, column 7 - line 107, column 23): " + [v.constructor.name, v1.constructor.name]);
              }
              ;
              while (!$tco_done) {
                $tco_result = $tco_loop($tco_var_v, $copy_v1);
              }
              ;
              return $tco_result;
            };
          };
          return go2(Nil.value);
        }();
        var $284 = foldl(foldableList)(flip(f))(b);
        return function($285) {
          return $284(rev3($285));
        };
      };
    },
    foldl: function(f) {
      var go2 = function($copy_b) {
        return function($copy_v) {
          var $tco_var_b = $copy_b;
          var $tco_done1 = false;
          var $tco_result;
          function $tco_loop(b, v) {
            if (v instanceof Nil) {
              $tco_done1 = true;
              return b;
            }
            ;
            if (v instanceof Cons) {
              $tco_var_b = f(b)(v.value0);
              $copy_v = v.value1;
              return;
            }
            ;
            throw new Error("Failed pattern match at Data.List.Types (line 111, column 12 - line 113, column 30): " + [v.constructor.name]);
          }
          ;
          while (!$tco_done1) {
            $tco_result = $tco_loop($tco_var_b, $copy_v);
          }
          ;
          return $tco_result;
        };
      };
      return go2;
    },
    foldMap: function(dictMonoid) {
      var append22 = append(dictMonoid.Semigroup0());
      var mempty3 = mempty(dictMonoid);
      return function(f) {
        return foldl(foldableList)(function(acc) {
          var $286 = append22(acc);
          return function($287) {
            return $286(f($287));
          };
        })(mempty3);
      };
    }
  };
  var foldr3 = /* @__PURE__ */ foldr(foldableList);
  var semigroupList = {
    append: function(xs) {
      return function(ys) {
        return foldr3(Cons.create)(ys)(xs);
      };
    }
  };
  var append1 = /* @__PURE__ */ append(semigroupList);
  var semigroupNonEmptyList = {
    append: function(v) {
      return function(as$prime) {
        return new NonEmpty(v.value0, append1(v.value1)(toList(as$prime)));
      };
    }
  };
  var altList = {
    alt: append1,
    Functor0: function() {
      return functorList;
    }
  };
  var plusList = /* @__PURE__ */ function() {
    return {
      empty: Nil.value,
      Alt0: function() {
        return altList;
      }
    };
  }();

  // output/Data.List.NonEmpty/index.js
  var singleton4 = /* @__PURE__ */ function() {
    var $200 = singleton3(plusList);
    return function($201) {
      return NonEmptyList($200($201));
    };
  }();
  var head2 = function(v) {
    return v.value0;
  };

  // output/Data.Nullable/foreign.js
  var nullImpl = null;
  function nullable(a, r, f) {
    return a == null ? r : f(a);
  }
  function notNull(x) {
    return x;
  }

  // output/Data.Nullable/index.js
  var toNullable = /* @__PURE__ */ maybe(nullImpl)(notNull);
  var toMaybe = function(n) {
    return nullable(n, Nothing.value, Just.create);
  };

  // output/Effect.Aff/foreign.js
  var Aff = function() {
    var EMPTY2 = {};
    var PURE = "Pure";
    var THROW = "Throw";
    var CATCH = "Catch";
    var SYNC = "Sync";
    var ASYNC = "Async";
    var BIND = "Bind";
    var BRACKET = "Bracket";
    var FORK = "Fork";
    var SEQ = "Sequential";
    var MAP = "Map";
    var APPLY = "Apply";
    var ALT = "Alt";
    var CONS = "Cons";
    var RESUME = "Resume";
    var RELEASE = "Release";
    var FINALIZER = "Finalizer";
    var FINALIZED = "Finalized";
    var FORKED = "Forked";
    var FIBER = "Fiber";
    var THUNK = "Thunk";
    function Aff2(tag, _1, _2, _3) {
      this.tag = tag;
      this._1 = _1;
      this._2 = _2;
      this._3 = _3;
    }
    function AffCtr(tag) {
      var fn = function(_1, _2, _3) {
        return new Aff2(tag, _1, _2, _3);
      };
      fn.tag = tag;
      return fn;
    }
    function nonCanceler2(error3) {
      return new Aff2(PURE, void 0);
    }
    function runEff(eff) {
      try {
        eff();
      } catch (error3) {
        setTimeout(function() {
          throw error3;
        }, 0);
      }
    }
    function runSync(left3, right, eff) {
      try {
        return right(eff());
      } catch (error3) {
        return left3(error3);
      }
    }
    function runAsync(left3, eff, k) {
      try {
        return eff(k)();
      } catch (error3) {
        k(left3(error3))();
        return nonCanceler2;
      }
    }
    var Scheduler = function() {
      var limit = 1024;
      var size5 = 0;
      var ix = 0;
      var queue = new Array(limit);
      var draining = false;
      function drain() {
        var thunk;
        draining = true;
        while (size5 !== 0) {
          size5--;
          thunk = queue[ix];
          queue[ix] = void 0;
          ix = (ix + 1) % limit;
          thunk();
        }
        draining = false;
      }
      return {
        isDraining: function() {
          return draining;
        },
        enqueue: function(cb) {
          var i, tmp;
          if (size5 === limit) {
            tmp = draining;
            drain();
            draining = tmp;
          }
          queue[(ix + size5) % limit] = cb;
          size5++;
          if (!draining) {
            drain();
          }
        }
      };
    }();
    function Supervisor(util) {
      var fibers = {};
      var fiberId = 0;
      var count2 = 0;
      return {
        register: function(fiber) {
          var fid = fiberId++;
          fiber.onComplete({
            rethrow: true,
            handler: function(result) {
              return function() {
                count2--;
                delete fibers[fid];
              };
            }
          })();
          fibers[fid] = fiber;
          count2++;
        },
        isEmpty: function() {
          return count2 === 0;
        },
        killAll: function(killError, cb) {
          return function() {
            if (count2 === 0) {
              return cb();
            }
            var killCount = 0;
            var kills = {};
            function kill(fid) {
              kills[fid] = fibers[fid].kill(killError, function(result) {
                return function() {
                  delete kills[fid];
                  killCount--;
                  if (util.isLeft(result) && util.fromLeft(result)) {
                    setTimeout(function() {
                      throw util.fromLeft(result);
                    }, 0);
                  }
                  if (killCount === 0) {
                    cb();
                  }
                };
              })();
            }
            for (var k in fibers) {
              if (fibers.hasOwnProperty(k)) {
                killCount++;
                kill(k);
              }
            }
            fibers = {};
            fiberId = 0;
            count2 = 0;
            return function(error3) {
              return new Aff2(SYNC, function() {
                for (var k2 in kills) {
                  if (kills.hasOwnProperty(k2)) {
                    kills[k2]();
                  }
                }
              });
            };
          };
        }
      };
    }
    var SUSPENDED = 0;
    var CONTINUE = 1;
    var STEP_BIND = 2;
    var STEP_RESULT = 3;
    var PENDING = 4;
    var RETURN = 5;
    var COMPLETED = 6;
    function Fiber(util, supervisor, aff) {
      var runTick = 0;
      var status = SUSPENDED;
      var step2 = aff;
      var fail3 = null;
      var interrupt = null;
      var bhead = null;
      var btail = null;
      var attempts = null;
      var bracketCount = 0;
      var joinId = 0;
      var joins = null;
      var rethrow = true;
      function run3(localRunTick) {
        var tmp, result, attempt;
        while (true) {
          tmp = null;
          result = null;
          attempt = null;
          switch (status) {
            case STEP_BIND:
              status = CONTINUE;
              try {
                step2 = bhead(step2);
                if (btail === null) {
                  bhead = null;
                } else {
                  bhead = btail._1;
                  btail = btail._2;
                }
              } catch (e) {
                status = RETURN;
                fail3 = util.left(e);
                step2 = null;
              }
              break;
            case STEP_RESULT:
              if (util.isLeft(step2)) {
                status = RETURN;
                fail3 = step2;
                step2 = null;
              } else if (bhead === null) {
                status = RETURN;
              } else {
                status = STEP_BIND;
                step2 = util.fromRight(step2);
              }
              break;
            case CONTINUE:
              switch (step2.tag) {
                case BIND:
                  if (bhead) {
                    btail = new Aff2(CONS, bhead, btail);
                  }
                  bhead = step2._2;
                  status = CONTINUE;
                  step2 = step2._1;
                  break;
                case PURE:
                  if (bhead === null) {
                    status = RETURN;
                    step2 = util.right(step2._1);
                  } else {
                    status = STEP_BIND;
                    step2 = step2._1;
                  }
                  break;
                case SYNC:
                  status = STEP_RESULT;
                  step2 = runSync(util.left, util.right, step2._1);
                  break;
                case ASYNC:
                  status = PENDING;
                  step2 = runAsync(util.left, step2._1, function(result2) {
                    return function() {
                      if (runTick !== localRunTick) {
                        return;
                      }
                      runTick++;
                      Scheduler.enqueue(function() {
                        if (runTick !== localRunTick + 1) {
                          return;
                        }
                        status = STEP_RESULT;
                        step2 = result2;
                        run3(runTick);
                      });
                    };
                  });
                  return;
                case THROW:
                  status = RETURN;
                  fail3 = util.left(step2._1);
                  step2 = null;
                  break;
                case CATCH:
                  if (bhead === null) {
                    attempts = new Aff2(CONS, step2, attempts, interrupt);
                  } else {
                    attempts = new Aff2(CONS, step2, new Aff2(CONS, new Aff2(RESUME, bhead, btail), attempts, interrupt), interrupt);
                  }
                  bhead = null;
                  btail = null;
                  status = CONTINUE;
                  step2 = step2._1;
                  break;
                case BRACKET:
                  bracketCount++;
                  if (bhead === null) {
                    attempts = new Aff2(CONS, step2, attempts, interrupt);
                  } else {
                    attempts = new Aff2(CONS, step2, new Aff2(CONS, new Aff2(RESUME, bhead, btail), attempts, interrupt), interrupt);
                  }
                  bhead = null;
                  btail = null;
                  status = CONTINUE;
                  step2 = step2._1;
                  break;
                case FORK:
                  status = STEP_RESULT;
                  tmp = Fiber(util, supervisor, step2._2);
                  if (supervisor) {
                    supervisor.register(tmp);
                  }
                  if (step2._1) {
                    tmp.run();
                  }
                  step2 = util.right(tmp);
                  break;
                case SEQ:
                  status = CONTINUE;
                  step2 = sequential2(util, supervisor, step2._1);
                  break;
              }
              break;
            case RETURN:
              bhead = null;
              btail = null;
              if (attempts === null) {
                status = COMPLETED;
                step2 = interrupt || fail3 || step2;
              } else {
                tmp = attempts._3;
                attempt = attempts._1;
                attempts = attempts._2;
                switch (attempt.tag) {
                  case CATCH:
                    if (interrupt && interrupt !== tmp && bracketCount === 0) {
                      status = RETURN;
                    } else if (fail3) {
                      status = CONTINUE;
                      step2 = attempt._2(util.fromLeft(fail3));
                      fail3 = null;
                    }
                    break;
                  case RESUME:
                    if (interrupt && interrupt !== tmp && bracketCount === 0 || fail3) {
                      status = RETURN;
                    } else {
                      bhead = attempt._1;
                      btail = attempt._2;
                      status = STEP_BIND;
                      step2 = util.fromRight(step2);
                    }
                    break;
                  case BRACKET:
                    bracketCount--;
                    if (fail3 === null) {
                      result = util.fromRight(step2);
                      attempts = new Aff2(CONS, new Aff2(RELEASE, attempt._2, result), attempts, tmp);
                      if (interrupt === tmp || bracketCount > 0) {
                        status = CONTINUE;
                        step2 = attempt._3(result);
                      }
                    }
                    break;
                  case RELEASE:
                    attempts = new Aff2(CONS, new Aff2(FINALIZED, step2, fail3), attempts, interrupt);
                    status = CONTINUE;
                    if (interrupt && interrupt !== tmp && bracketCount === 0) {
                      step2 = attempt._1.killed(util.fromLeft(interrupt))(attempt._2);
                    } else if (fail3) {
                      step2 = attempt._1.failed(util.fromLeft(fail3))(attempt._2);
                    } else {
                      step2 = attempt._1.completed(util.fromRight(step2))(attempt._2);
                    }
                    fail3 = null;
                    bracketCount++;
                    break;
                  case FINALIZER:
                    bracketCount++;
                    attempts = new Aff2(CONS, new Aff2(FINALIZED, step2, fail3), attempts, interrupt);
                    status = CONTINUE;
                    step2 = attempt._1;
                    break;
                  case FINALIZED:
                    bracketCount--;
                    status = RETURN;
                    step2 = attempt._1;
                    fail3 = attempt._2;
                    break;
                }
              }
              break;
            case COMPLETED:
              for (var k in joins) {
                if (joins.hasOwnProperty(k)) {
                  rethrow = rethrow && joins[k].rethrow;
                  runEff(joins[k].handler(step2));
                }
              }
              joins = null;
              if (interrupt && fail3) {
                setTimeout(function() {
                  throw util.fromLeft(fail3);
                }, 0);
              } else if (util.isLeft(step2) && rethrow) {
                setTimeout(function() {
                  if (rethrow) {
                    throw util.fromLeft(step2);
                  }
                }, 0);
              }
              return;
            case SUSPENDED:
              status = CONTINUE;
              break;
            case PENDING:
              return;
          }
        }
      }
      function onComplete(join4) {
        return function() {
          if (status === COMPLETED) {
            rethrow = rethrow && join4.rethrow;
            join4.handler(step2)();
            return function() {
            };
          }
          var jid = joinId++;
          joins = joins || {};
          joins[jid] = join4;
          return function() {
            if (joins !== null) {
              delete joins[jid];
            }
          };
        };
      }
      function kill(error3, cb) {
        return function() {
          if (status === COMPLETED) {
            cb(util.right(void 0))();
            return function() {
            };
          }
          var canceler = onComplete({
            rethrow: false,
            handler: function() {
              return cb(util.right(void 0));
            }
          })();
          switch (status) {
            case SUSPENDED:
              interrupt = util.left(error3);
              status = COMPLETED;
              step2 = interrupt;
              run3(runTick);
              break;
            case PENDING:
              if (interrupt === null) {
                interrupt = util.left(error3);
              }
              if (bracketCount === 0) {
                if (status === PENDING) {
                  attempts = new Aff2(CONS, new Aff2(FINALIZER, step2(error3)), attempts, interrupt);
                }
                status = RETURN;
                step2 = null;
                fail3 = null;
                run3(++runTick);
              }
              break;
            default:
              if (interrupt === null) {
                interrupt = util.left(error3);
              }
              if (bracketCount === 0) {
                status = RETURN;
                step2 = null;
                fail3 = null;
              }
          }
          return canceler;
        };
      }
      function join3(cb) {
        return function() {
          var canceler = onComplete({
            rethrow: false,
            handler: cb
          })();
          if (status === SUSPENDED) {
            run3(runTick);
          }
          return canceler;
        };
      }
      return {
        kill,
        join: join3,
        onComplete,
        isSuspended: function() {
          return status === SUSPENDED;
        },
        run: function() {
          if (status === SUSPENDED) {
            if (!Scheduler.isDraining()) {
              Scheduler.enqueue(function() {
                run3(runTick);
              });
            } else {
              run3(runTick);
            }
          }
        }
      };
    }
    function runPar(util, supervisor, par, cb) {
      var fiberId = 0;
      var fibers = {};
      var killId = 0;
      var kills = {};
      var early = new Error("[ParAff] Early exit");
      var interrupt = null;
      var root = EMPTY2;
      function kill(error3, par2, cb2) {
        var step2 = par2;
        var head4 = null;
        var tail3 = null;
        var count2 = 0;
        var kills2 = {};
        var tmp, kid;
        loop:
          while (true) {
            tmp = null;
            switch (step2.tag) {
              case FORKED:
                if (step2._3 === EMPTY2) {
                  tmp = fibers[step2._1];
                  kills2[count2++] = tmp.kill(error3, function(result) {
                    return function() {
                      count2--;
                      if (count2 === 0) {
                        cb2(result)();
                      }
                    };
                  });
                }
                if (head4 === null) {
                  break loop;
                }
                step2 = head4._2;
                if (tail3 === null) {
                  head4 = null;
                } else {
                  head4 = tail3._1;
                  tail3 = tail3._2;
                }
                break;
              case MAP:
                step2 = step2._2;
                break;
              case APPLY:
              case ALT:
                if (head4) {
                  tail3 = new Aff2(CONS, head4, tail3);
                }
                head4 = step2;
                step2 = step2._1;
                break;
            }
          }
        if (count2 === 0) {
          cb2(util.right(void 0))();
        } else {
          kid = 0;
          tmp = count2;
          for (; kid < tmp; kid++) {
            kills2[kid] = kills2[kid]();
          }
        }
        return kills2;
      }
      function join3(result, head4, tail3) {
        var fail3, step2, lhs, rhs, tmp, kid;
        if (util.isLeft(result)) {
          fail3 = result;
          step2 = null;
        } else {
          step2 = result;
          fail3 = null;
        }
        loop:
          while (true) {
            lhs = null;
            rhs = null;
            tmp = null;
            kid = null;
            if (interrupt !== null) {
              return;
            }
            if (head4 === null) {
              cb(fail3 || step2)();
              return;
            }
            if (head4._3 !== EMPTY2) {
              return;
            }
            switch (head4.tag) {
              case MAP:
                if (fail3 === null) {
                  head4._3 = util.right(head4._1(util.fromRight(step2)));
                  step2 = head4._3;
                } else {
                  head4._3 = fail3;
                }
                break;
              case APPLY:
                lhs = head4._1._3;
                rhs = head4._2._3;
                if (fail3) {
                  head4._3 = fail3;
                  tmp = true;
                  kid = killId++;
                  kills[kid] = kill(early, fail3 === lhs ? head4._2 : head4._1, function() {
                    return function() {
                      delete kills[kid];
                      if (tmp) {
                        tmp = false;
                      } else if (tail3 === null) {
                        join3(fail3, null, null);
                      } else {
                        join3(fail3, tail3._1, tail3._2);
                      }
                    };
                  });
                  if (tmp) {
                    tmp = false;
                    return;
                  }
                } else if (lhs === EMPTY2 || rhs === EMPTY2) {
                  return;
                } else {
                  step2 = util.right(util.fromRight(lhs)(util.fromRight(rhs)));
                  head4._3 = step2;
                }
                break;
              case ALT:
                lhs = head4._1._3;
                rhs = head4._2._3;
                if (lhs === EMPTY2 && util.isLeft(rhs) || rhs === EMPTY2 && util.isLeft(lhs)) {
                  return;
                }
                if (lhs !== EMPTY2 && util.isLeft(lhs) && rhs !== EMPTY2 && util.isLeft(rhs)) {
                  fail3 = step2 === lhs ? rhs : lhs;
                  step2 = null;
                  head4._3 = fail3;
                } else {
                  head4._3 = step2;
                  tmp = true;
                  kid = killId++;
                  kills[kid] = kill(early, step2 === lhs ? head4._2 : head4._1, function() {
                    return function() {
                      delete kills[kid];
                      if (tmp) {
                        tmp = false;
                      } else if (tail3 === null) {
                        join3(step2, null, null);
                      } else {
                        join3(step2, tail3._1, tail3._2);
                      }
                    };
                  });
                  if (tmp) {
                    tmp = false;
                    return;
                  }
                }
                break;
            }
            if (tail3 === null) {
              head4 = null;
            } else {
              head4 = tail3._1;
              tail3 = tail3._2;
            }
          }
      }
      function resolve2(fiber) {
        return function(result) {
          return function() {
            delete fibers[fiber._1];
            fiber._3 = result;
            join3(result, fiber._2._1, fiber._2._2);
          };
        };
      }
      function run3() {
        var status = CONTINUE;
        var step2 = par;
        var head4 = null;
        var tail3 = null;
        var tmp, fid;
        loop:
          while (true) {
            tmp = null;
            fid = null;
            switch (status) {
              case CONTINUE:
                switch (step2.tag) {
                  case MAP:
                    if (head4) {
                      tail3 = new Aff2(CONS, head4, tail3);
                    }
                    head4 = new Aff2(MAP, step2._1, EMPTY2, EMPTY2);
                    step2 = step2._2;
                    break;
                  case APPLY:
                    if (head4) {
                      tail3 = new Aff2(CONS, head4, tail3);
                    }
                    head4 = new Aff2(APPLY, EMPTY2, step2._2, EMPTY2);
                    step2 = step2._1;
                    break;
                  case ALT:
                    if (head4) {
                      tail3 = new Aff2(CONS, head4, tail3);
                    }
                    head4 = new Aff2(ALT, EMPTY2, step2._2, EMPTY2);
                    step2 = step2._1;
                    break;
                  default:
                    fid = fiberId++;
                    status = RETURN;
                    tmp = step2;
                    step2 = new Aff2(FORKED, fid, new Aff2(CONS, head4, tail3), EMPTY2);
                    tmp = Fiber(util, supervisor, tmp);
                    tmp.onComplete({
                      rethrow: false,
                      handler: resolve2(step2)
                    })();
                    fibers[fid] = tmp;
                    if (supervisor) {
                      supervisor.register(tmp);
                    }
                }
                break;
              case RETURN:
                if (head4 === null) {
                  break loop;
                }
                if (head4._1 === EMPTY2) {
                  head4._1 = step2;
                  status = CONTINUE;
                  step2 = head4._2;
                  head4._2 = EMPTY2;
                } else {
                  head4._2 = step2;
                  step2 = head4;
                  if (tail3 === null) {
                    head4 = null;
                  } else {
                    head4 = tail3._1;
                    tail3 = tail3._2;
                  }
                }
            }
          }
        root = step2;
        for (fid = 0; fid < fiberId; fid++) {
          fibers[fid].run();
        }
      }
      function cancel(error3, cb2) {
        interrupt = util.left(error3);
        var innerKills;
        for (var kid in kills) {
          if (kills.hasOwnProperty(kid)) {
            innerKills = kills[kid];
            for (kid in innerKills) {
              if (innerKills.hasOwnProperty(kid)) {
                innerKills[kid]();
              }
            }
          }
        }
        kills = null;
        var newKills = kill(error3, root, cb2);
        return function(killError) {
          return new Aff2(ASYNC, function(killCb) {
            return function() {
              for (var kid2 in newKills) {
                if (newKills.hasOwnProperty(kid2)) {
                  newKills[kid2]();
                }
              }
              return nonCanceler2;
            };
          });
        };
      }
      run3();
      return function(killError) {
        return new Aff2(ASYNC, function(killCb) {
          return function() {
            return cancel(killError, killCb);
          };
        });
      };
    }
    function sequential2(util, supervisor, par) {
      return new Aff2(ASYNC, function(cb) {
        return function() {
          return runPar(util, supervisor, par, cb);
        };
      });
    }
    Aff2.EMPTY = EMPTY2;
    Aff2.Pure = AffCtr(PURE);
    Aff2.Throw = AffCtr(THROW);
    Aff2.Catch = AffCtr(CATCH);
    Aff2.Sync = AffCtr(SYNC);
    Aff2.Async = AffCtr(ASYNC);
    Aff2.Bind = AffCtr(BIND);
    Aff2.Bracket = AffCtr(BRACKET);
    Aff2.Fork = AffCtr(FORK);
    Aff2.Seq = AffCtr(SEQ);
    Aff2.ParMap = AffCtr(MAP);
    Aff2.ParApply = AffCtr(APPLY);
    Aff2.ParAlt = AffCtr(ALT);
    Aff2.Fiber = Fiber;
    Aff2.Supervisor = Supervisor;
    Aff2.Scheduler = Scheduler;
    Aff2.nonCanceler = nonCanceler2;
    return Aff2;
  }();
  var _pure = Aff.Pure;
  var _throwError = Aff.Throw;
  function _catchError(aff) {
    return function(k) {
      return Aff.Catch(aff, k);
    };
  }
  function _map(f) {
    return function(aff) {
      if (aff.tag === Aff.Pure.tag) {
        return Aff.Pure(f(aff._1));
      } else {
        return Aff.Bind(aff, function(value13) {
          return Aff.Pure(f(value13));
        });
      }
    };
  }
  function _bind(aff) {
    return function(k) {
      return Aff.Bind(aff, k);
    };
  }
  var _liftEffect = Aff.Sync;
  var makeAff = Aff.Async;
  function _makeFiber(util, aff) {
    return function() {
      return Aff.Fiber(util, null, aff);
    };
  }
  var _delay = function() {
    function setDelay(n, k) {
      if (n === 0 && typeof setImmediate !== "undefined") {
        return setImmediate(k);
      } else {
        return setTimeout(k, n);
      }
    }
    function clearDelay(n, t) {
      if (n === 0 && typeof clearImmediate !== "undefined") {
        return clearImmediate(t);
      } else {
        return clearTimeout(t);
      }
    }
    return function(right, ms) {
      return Aff.Async(function(cb) {
        return function() {
          var timer = setDelay(ms, cb(right()));
          return function() {
            return Aff.Sync(function() {
              return right(clearDelay(ms, timer));
            });
          };
        };
      });
    };
  }();
  var _sequential = Aff.Seq;

  // output/Data.Profunctor/index.js
  var profunctorFn = {
    dimap: function(a2b) {
      return function(c2d) {
        return function(b2c) {
          return function($18) {
            return c2d(b2c(a2b($18)));
          };
        };
      };
    }
  };

  // output/Effect.Aff/index.js
  var $runtime_lazy3 = function(name16, moduleName, init3) {
    var state3 = 0;
    var val;
    return function(lineNumber) {
      if (state3 === 2)
        return val;
      if (state3 === 1)
        throw new ReferenceError(name16 + " was needed before it finished initializing (module " + moduleName + ", line " + lineNumber + ")", moduleName, lineNumber);
      state3 = 1;
      val = init3();
      state3 = 2;
      return val;
    };
  };
  var $$void2 = /* @__PURE__ */ $$void(functorEffect);
  var functorAff = {
    map: _map
  };
  var ffiUtil = /* @__PURE__ */ function() {
    var unsafeFromRight = function(v) {
      if (v instanceof Right) {
        return v.value0;
      }
      ;
      if (v instanceof Left) {
        return unsafeCrashWith("unsafeFromRight: Left");
      }
      ;
      throw new Error("Failed pattern match at Effect.Aff (line 412, column 21 - line 414, column 54): " + [v.constructor.name]);
    };
    var unsafeFromLeft = function(v) {
      if (v instanceof Left) {
        return v.value0;
      }
      ;
      if (v instanceof Right) {
        return unsafeCrashWith("unsafeFromLeft: Right");
      }
      ;
      throw new Error("Failed pattern match at Effect.Aff (line 407, column 20 - line 409, column 55): " + [v.constructor.name]);
    };
    var isLeft = function(v) {
      if (v instanceof Left) {
        return true;
      }
      ;
      if (v instanceof Right) {
        return false;
      }
      ;
      throw new Error("Failed pattern match at Effect.Aff (line 402, column 12 - line 404, column 21): " + [v.constructor.name]);
    };
    return {
      isLeft,
      fromLeft: unsafeFromLeft,
      fromRight: unsafeFromRight,
      left: Left.create,
      right: Right.create
    };
  }();
  var makeFiber = function(aff) {
    return _makeFiber(ffiUtil, aff);
  };
  var launchAff = function(aff) {
    return function __do2() {
      var fiber = makeFiber(aff)();
      fiber.run();
      return fiber;
    };
  };
  var launchAff_ = function($75) {
    return $$void2(launchAff($75));
  };
  var delay = function(v) {
    return _delay(Right.create, v);
  };
  var monadAff = {
    Applicative0: function() {
      return applicativeAff;
    },
    Bind1: function() {
      return bindAff;
    }
  };
  var bindAff = {
    bind: _bind,
    Apply0: function() {
      return $lazy_applyAff(0);
    }
  };
  var applicativeAff = {
    pure: _pure,
    Apply0: function() {
      return $lazy_applyAff(0);
    }
  };
  var $lazy_applyAff = /* @__PURE__ */ $runtime_lazy3("applyAff", "Effect.Aff", function() {
    return {
      apply: ap(monadAff),
      Functor0: function() {
        return functorAff;
      }
    };
  });
  var pure2 = /* @__PURE__ */ pure(applicativeAff);
  var bind1 = /* @__PURE__ */ bind(bindAff);
  var monadEffectAff = {
    liftEffect: _liftEffect,
    Monad0: function() {
      return monadAff;
    }
  };
  var monadThrowAff = {
    throwError: _throwError,
    Monad0: function() {
      return monadAff;
    }
  };
  var monadErrorAff = {
    catchError: _catchError,
    MonadThrow0: function() {
      return monadThrowAff;
    }
  };
  var monadRecAff = {
    tailRecM: function(k) {
      var go2 = function(a) {
        return bind1(k(a))(function(res) {
          if (res instanceof Done) {
            return pure2(res.value0);
          }
          ;
          if (res instanceof Loop) {
            return go2(res.value0);
          }
          ;
          throw new Error("Failed pattern match at Effect.Aff (line 104, column 7 - line 106, column 23): " + [res.constructor.name]);
        });
      };
      return go2;
    },
    Monad0: function() {
      return monadAff;
    }
  };
  var nonCanceler = /* @__PURE__ */ $$const(/* @__PURE__ */ pure2(unit));

  // output/Effect.Uncurried/foreign.js
  var mkEffectFn1 = function mkEffectFn12(fn) {
    return function(x) {
      return fn(x)();
    };
  };

  // output/Effect.Aff.Compat/index.js
  var fromEffectFnAff = function(v) {
    return makeAff(function(k) {
      return function __do2() {
        var v1 = v(function($9) {
          return k(Left.create($9))();
        }, function($10) {
          return k(Right.create($10))();
        });
        return function(e) {
          return makeAff(function(k2) {
            return function __do3() {
              v1(e, function($11) {
                return k2(Left.create($11))();
              }, function($12) {
                return k2(Right.create($12))();
              });
              return nonCanceler;
            };
          });
        };
      };
    });
  };

  // output/Foreign/foreign.js
  function tagOf(value13) {
    return Object.prototype.toString.call(value13).slice(8, -1);
  }
  var isArray4 = Array.isArray || function(value13) {
    return Object.prototype.toString.call(value13) === "[object Array]";
  };

  // output/Foreign/index.js
  var show2 = /* @__PURE__ */ show(showString);
  var show1 = /* @__PURE__ */ show(showInt);
  var ForeignError = /* @__PURE__ */ function() {
    function ForeignError2(value0) {
      this.value0 = value0;
    }
    ;
    ForeignError2.create = function(value0) {
      return new ForeignError2(value0);
    };
    return ForeignError2;
  }();
  var TypeMismatch = /* @__PURE__ */ function() {
    function TypeMismatch3(value0, value1) {
      this.value0 = value0;
      this.value1 = value1;
    }
    ;
    TypeMismatch3.create = function(value0) {
      return function(value1) {
        return new TypeMismatch3(value0, value1);
      };
    };
    return TypeMismatch3;
  }();
  var ErrorAtIndex = /* @__PURE__ */ function() {
    function ErrorAtIndex2(value0, value1) {
      this.value0 = value0;
      this.value1 = value1;
    }
    ;
    ErrorAtIndex2.create = function(value0) {
      return function(value1) {
        return new ErrorAtIndex2(value0, value1);
      };
    };
    return ErrorAtIndex2;
  }();
  var ErrorAtProperty = /* @__PURE__ */ function() {
    function ErrorAtProperty2(value0, value1) {
      this.value0 = value0;
      this.value1 = value1;
    }
    ;
    ErrorAtProperty2.create = function(value0) {
      return function(value1) {
        return new ErrorAtProperty2(value0, value1);
      };
    };
    return ErrorAtProperty2;
  }();
  var unsafeToForeign = unsafeCoerce2;
  var unsafeFromForeign = unsafeCoerce2;
  var renderForeignError = function(v) {
    if (v instanceof ForeignError) {
      return v.value0;
    }
    ;
    if (v instanceof ErrorAtIndex) {
      return "Error at array index " + (show1(v.value0) + (": " + renderForeignError(v.value1)));
    }
    ;
    if (v instanceof ErrorAtProperty) {
      return "Error at property " + (show2(v.value0) + (": " + renderForeignError(v.value1)));
    }
    ;
    if (v instanceof TypeMismatch) {
      return "Type mismatch: expected " + (v.value0 + (", found " + v.value1));
    }
    ;
    throw new Error("Failed pattern match at Foreign (line 78, column 1 - line 78, column 45): " + [v.constructor.name]);
  };
  var fail = function(dictMonad) {
    var $153 = throwError(monadThrowExceptT(dictMonad));
    return function($154) {
      return $153(singleton4($154));
    };
  };
  var unsafeReadTagged = function(dictMonad) {
    var pure17 = pure(applicativeExceptT(dictMonad));
    var fail1 = fail(dictMonad);
    return function(tag) {
      return function(value13) {
        if (tagOf(value13) === tag) {
          return pure17(unsafeFromForeign(value13));
        }
        ;
        if (otherwise) {
          return fail1(new TypeMismatch(tag, tagOf(value13)));
        }
        ;
        throw new Error("Failed pattern match at Foreign (line 123, column 1 - line 123, column 104): " + [tag.constructor.name, value13.constructor.name]);
      };
    };
  };

  // output/Affjax/index.js
  var pure3 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeExceptT(monadIdentity));
  var fail2 = /* @__PURE__ */ fail(monadIdentity);
  var unsafeReadTagged2 = /* @__PURE__ */ unsafeReadTagged(monadIdentity);
  var alt2 = /* @__PURE__ */ alt(/* @__PURE__ */ altExceptT(semigroupNonEmptyList)(monadIdentity));
  var composeKleisliFlipped2 = /* @__PURE__ */ composeKleisliFlipped(/* @__PURE__ */ bindExceptT(monadIdentity));
  var map8 = /* @__PURE__ */ map(functorMaybe);
  var any2 = /* @__PURE__ */ any(foldableArray)(heytingAlgebraBoolean);
  var eq2 = /* @__PURE__ */ eq(eqString);
  var bindFlipped2 = /* @__PURE__ */ bindFlipped(bindMaybe);
  var map1 = /* @__PURE__ */ map(functorArray);
  var mapFlipped2 = /* @__PURE__ */ mapFlipped(functorAff);
  var $$try2 = /* @__PURE__ */ $$try(monadErrorAff);
  var pure1 = /* @__PURE__ */ pure(applicativeAff);
  var RequestContentError = /* @__PURE__ */ function() {
    function RequestContentError2(value0) {
      this.value0 = value0;
    }
    ;
    RequestContentError2.create = function(value0) {
      return new RequestContentError2(value0);
    };
    return RequestContentError2;
  }();
  var ResponseBodyError = /* @__PURE__ */ function() {
    function ResponseBodyError2(value0, value1) {
      this.value0 = value0;
      this.value1 = value1;
    }
    ;
    ResponseBodyError2.create = function(value0) {
      return function(value1) {
        return new ResponseBodyError2(value0, value1);
      };
    };
    return ResponseBodyError2;
  }();
  var TimeoutError = /* @__PURE__ */ function() {
    function TimeoutError2() {
    }
    ;
    TimeoutError2.value = new TimeoutError2();
    return TimeoutError2;
  }();
  var RequestFailedError = /* @__PURE__ */ function() {
    function RequestFailedError2() {
    }
    ;
    RequestFailedError2.value = new RequestFailedError2();
    return RequestFailedError2;
  }();
  var XHROtherError = /* @__PURE__ */ function() {
    function XHROtherError2(value0) {
      this.value0 = value0;
    }
    ;
    XHROtherError2.create = function(value0) {
      return new XHROtherError2(value0);
    };
    return XHROtherError2;
  }();
  var request = function(driver2) {
    return function(req) {
      var parseJSON = function(v2) {
        if (v2 === "") {
          return pure3(jsonEmptyObject);
        }
        ;
        return either(function($74) {
          return fail2(ForeignError.create($74));
        })(pure3)(jsonParser(v2));
      };
      var fromResponse = function() {
        if (req.responseFormat instanceof $$ArrayBuffer) {
          return unsafeReadTagged2("ArrayBuffer");
        }
        ;
        if (req.responseFormat instanceof Blob3) {
          return unsafeReadTagged2("Blob");
        }
        ;
        if (req.responseFormat instanceof Document2) {
          return function(x) {
            return alt2(unsafeReadTagged2("Document")(x))(alt2(unsafeReadTagged2("XMLDocument")(x))(unsafeReadTagged2("HTMLDocument")(x)));
          };
        }
        ;
        if (req.responseFormat instanceof Json2) {
          return composeKleisliFlipped2(function($75) {
            return req.responseFormat.value0(parseJSON($75));
          })(unsafeReadTagged2("String"));
        }
        ;
        if (req.responseFormat instanceof $$String2) {
          return unsafeReadTagged2("String");
        }
        ;
        if (req.responseFormat instanceof Ignore) {
          return $$const(req.responseFormat.value0(pure3(unit)));
        }
        ;
        throw new Error("Failed pattern match at Affjax (line 274, column 18 - line 283, column 57): " + [req.responseFormat.constructor.name]);
      }();
      var extractContent = function(v2) {
        if (v2 instanceof ArrayView) {
          return new Right(v2.value0(unsafeToForeign));
        }
        ;
        if (v2 instanceof Blob2) {
          return new Right(unsafeToForeign(v2.value0));
        }
        ;
        if (v2 instanceof Document) {
          return new Right(unsafeToForeign(v2.value0));
        }
        ;
        if (v2 instanceof $$String) {
          return new Right(unsafeToForeign(v2.value0));
        }
        ;
        if (v2 instanceof FormData) {
          return new Right(unsafeToForeign(v2.value0));
        }
        ;
        if (v2 instanceof FormURLEncoded) {
          return note("Body contains values that cannot be encoded as application/x-www-form-urlencoded")(map8(unsafeToForeign)(encode(v2.value0)));
        }
        ;
        if (v2 instanceof Json) {
          return new Right(unsafeToForeign(stringify(v2.value0)));
        }
        ;
        throw new Error("Failed pattern match at Affjax (line 235, column 20 - line 250, column 69): " + [v2.constructor.name]);
      };
      var addHeader = function(mh) {
        return function(hs) {
          if (mh instanceof Just && !any2(on(eq2)(name)(mh.value0))(hs)) {
            return snoc(hs)(mh.value0);
          }
          ;
          return hs;
        };
      };
      var headers = function(reqContent) {
        return addHeader(map8(ContentType.create)(bindFlipped2(toMediaType)(reqContent)))(addHeader(map8(Accept.create)(toMediaType2(req.responseFormat)))(req.headers));
      };
      var ajaxRequest = function(v2) {
        return {
          method: print(req.method),
          url: req.url,
          headers: map1(function(h) {
            return {
              field: name(h),
              value: value(h)
            };
          })(headers(req.content)),
          content: v2,
          responseType: toResponseType(req.responseFormat),
          username: toNullable(req.username),
          password: toNullable(req.password),
          withCredentials: req.withCredentials,
          timeout: fromMaybe(0)(map8(function(v1) {
            return v1;
          })(req.timeout))
        };
      };
      var send = function(content3) {
        return mapFlipped2($$try2(fromEffectFnAff(_ajax(driver2, "AffjaxTimeoutErrorMessageIdent", "AffjaxRequestFailedMessageIdent", ResponseHeader.create, ajaxRequest(content3)))))(function(v2) {
          if (v2 instanceof Right) {
            var v1 = runExcept(fromResponse(v2.value0.body));
            if (v1 instanceof Left) {
              return new Left(new ResponseBodyError(head2(v1.value0), v2.value0));
            }
            ;
            if (v1 instanceof Right) {
              return new Right({
                headers: v2.value0.headers,
                status: v2.value0.status,
                statusText: v2.value0.statusText,
                body: v1.value0
              });
            }
            ;
            throw new Error("Failed pattern match at Affjax (line 209, column 9 - line 211, column 52): " + [v1.constructor.name]);
          }
          ;
          if (v2 instanceof Left) {
            return new Left(function() {
              var message2 = message(v2.value0);
              var $61 = message2 === "AffjaxTimeoutErrorMessageIdent";
              if ($61) {
                return TimeoutError.value;
              }
              ;
              var $62 = message2 === "AffjaxRequestFailedMessageIdent";
              if ($62) {
                return RequestFailedError.value;
              }
              ;
              return new XHROtherError(v2.value0);
            }());
          }
          ;
          throw new Error("Failed pattern match at Affjax (line 207, column 144 - line 219, column 28): " + [v2.constructor.name]);
        });
      };
      if (req.content instanceof Nothing) {
        return send(toNullable(Nothing.value));
      }
      ;
      if (req.content instanceof Just) {
        var v = extractContent(req.content.value0);
        if (v instanceof Right) {
          return send(toNullable(new Just(v.value0)));
        }
        ;
        if (v instanceof Left) {
          return pure1(new Left(new RequestContentError(v.value0)));
        }
        ;
        throw new Error("Failed pattern match at Affjax (line 199, column 7 - line 203, column 48): " + [v.constructor.name]);
      }
      ;
      throw new Error("Failed pattern match at Affjax (line 195, column 3 - line 203, column 48): " + [req.content.constructor.name]);
    };
  };
  var printError = function(v) {
    if (v instanceof RequestContentError) {
      return "There was a problem with the request content: " + v.value0;
    }
    ;
    if (v instanceof ResponseBodyError) {
      return "There was a problem with the response body: " + renderForeignError(v.value0);
    }
    ;
    if (v instanceof TimeoutError) {
      return "There was a problem making the request: timeout";
    }
    ;
    if (v instanceof RequestFailedError) {
      return "There was a problem making the request: request failed";
    }
    ;
    if (v instanceof XHROtherError) {
      return "There was a problem making the request: " + message(v.value0);
    }
    ;
    throw new Error("Failed pattern match at Affjax (line 113, column 14 - line 123, column 66): " + [v.constructor.name]);
  };
  var defaultRequest = /* @__PURE__ */ function() {
    return {
      method: new Left(GET.value),
      url: "/",
      headers: [],
      content: Nothing.value,
      username: Nothing.value,
      password: Nothing.value,
      withCredentials: false,
      responseFormat: ignore,
      timeout: Nothing.value
    };
  }();

  // output/Affjax.Web/foreign.js
  var driver = {
    newXHR: function() {
      return new XMLHttpRequest();
    },
    fixupUrl: function(url) {
      return url || "/";
    }
  };

  // output/Data.Argonaut.Decode.Error/index.js
  var show12 = /* @__PURE__ */ show(showInt);
  var TypeMismatch2 = /* @__PURE__ */ function() {
    function TypeMismatch3(value0) {
      this.value0 = value0;
    }
    ;
    TypeMismatch3.create = function(value0) {
      return new TypeMismatch3(value0);
    };
    return TypeMismatch3;
  }();
  var UnexpectedValue = /* @__PURE__ */ function() {
    function UnexpectedValue2(value0) {
      this.value0 = value0;
    }
    ;
    UnexpectedValue2.create = function(value0) {
      return new UnexpectedValue2(value0);
    };
    return UnexpectedValue2;
  }();
  var AtIndex = /* @__PURE__ */ function() {
    function AtIndex2(value0, value1) {
      this.value0 = value0;
      this.value1 = value1;
    }
    ;
    AtIndex2.create = function(value0) {
      return function(value1) {
        return new AtIndex2(value0, value1);
      };
    };
    return AtIndex2;
  }();
  var AtKey = /* @__PURE__ */ function() {
    function AtKey2(value0, value1) {
      this.value0 = value0;
      this.value1 = value1;
    }
    ;
    AtKey2.create = function(value0) {
      return function(value1) {
        return new AtKey2(value0, value1);
      };
    };
    return AtKey2;
  }();
  var Named = /* @__PURE__ */ function() {
    function Named2(value0, value1) {
      this.value0 = value0;
      this.value1 = value1;
    }
    ;
    Named2.create = function(value0) {
      return function(value1) {
        return new Named2(value0, value1);
      };
    };
    return Named2;
  }();
  var MissingValue = /* @__PURE__ */ function() {
    function MissingValue2() {
    }
    ;
    MissingValue2.value = new MissingValue2();
    return MissingValue2;
  }();
  var printJsonDecodeError = function(err) {
    var go2 = function(v) {
      if (v instanceof TypeMismatch2) {
        return "  Expected value of type '" + (v.value0 + "'.");
      }
      ;
      if (v instanceof UnexpectedValue) {
        return "  Unexpected value " + (stringify(v.value0) + ".");
      }
      ;
      if (v instanceof AtIndex) {
        return "  At array index " + (show12(v.value0) + (":\n" + go2(v.value1)));
      }
      ;
      if (v instanceof AtKey) {
        return "  At object key '" + (v.value0 + ("':\n" + go2(v.value1)));
      }
      ;
      if (v instanceof Named) {
        return "  Under '" + (v.value0 + ("':\n" + go2(v.value1)));
      }
      ;
      if (v instanceof MissingValue) {
        return "  No value was found.";
      }
      ;
      throw new Error("Failed pattern match at Data.Argonaut.Decode.Error (line 37, column 8 - line 43, column 44): " + [v.constructor.name]);
    };
    return "An error occurred while decoding a JSON value:\n" + go2(err);
  };

  // output/Data.Array.NonEmpty.Internal/foreign.js
  var traverse1Impl = function() {
    function Cont(fn) {
      this.fn = fn;
    }
    var emptyList = {};
    var ConsCell = function(head4, tail3) {
      this.head = head4;
      this.tail = tail3;
    };
    function finalCell(head4) {
      return new ConsCell(head4, emptyList);
    }
    function consList(x) {
      return function(xs) {
        return new ConsCell(x, xs);
      };
    }
    function listToArray(list) {
      var arr = [];
      var xs = list;
      while (xs !== emptyList) {
        arr.push(xs.head);
        xs = xs.tail;
      }
      return arr;
    }
    return function(apply3, map16, f) {
      var buildFrom = function(x, ys) {
        return apply3(map16(consList)(f(x)))(ys);
      };
      var go2 = function(acc, currentLen, xs) {
        if (currentLen === 0) {
          return acc;
        } else {
          var last3 = xs[currentLen - 1];
          return new Cont(function() {
            var built = go2(buildFrom(last3, acc), currentLen - 1, xs);
            return built;
          });
        }
      };
      return function(array2) {
        var acc = map16(finalCell)(f(array2[array2.length - 1]));
        var result = go2(acc, array2.length - 1, array2);
        while (result instanceof Cont) {
          result = result.fn();
        }
        return map16(listToArray)(result);
      };
    };
  }();

  // output/Data.String.CodePoints/foreign.js
  var hasArrayFrom = typeof Array.from === "function";
  var hasStringIterator = typeof Symbol !== "undefined" && Symbol != null && typeof Symbol.iterator !== "undefined" && typeof String.prototype[Symbol.iterator] === "function";
  var hasFromCodePoint = typeof String.prototype.fromCodePoint === "function";
  var hasCodePointAt = typeof String.prototype.codePointAt === "function";

  // output/Data.Argonaut.Decode.Decoders/index.js
  var pure4 = /* @__PURE__ */ pure(applicativeEither);
  var map9 = /* @__PURE__ */ map(functorEither);
  var lmap2 = /* @__PURE__ */ lmap(bifunctorEither);
  var composeKleisliFlipped3 = /* @__PURE__ */ composeKleisliFlipped(bindEither);
  var traverse5 = /* @__PURE__ */ traverse(traversableObject)(applicativeEither);
  var traverseWithIndex2 = /* @__PURE__ */ traverseWithIndex(traversableWithIndexArray)(applicativeEither);
  var getFieldOptional$prime = function(decoder) {
    return function(obj) {
      return function(str) {
        var decode = function(json2) {
          var $35 = isNull(json2);
          if ($35) {
            return pure4(Nothing.value);
          }
          ;
          return map9(Just.create)(lmap2(AtKey.create(str))(decoder(json2)));
        };
        return maybe(pure4(Nothing.value))(decode)(lookup(str)(obj));
      };
    };
  };
  var getField = function(decoder) {
    return function(obj) {
      return function(str) {
        return maybe(new Left(new AtKey(str, MissingValue.value)))(function() {
          var $48 = lmap2(AtKey.create(str));
          return function($49) {
            return $48(decoder($49));
          };
        }())(lookup(str)(obj));
      };
    };
  };
  var decodeString = /* @__PURE__ */ function() {
    return caseJsonString(new Left(new TypeMismatch2("String")))(Right.create);
  }();
  var decodeNumber = /* @__PURE__ */ function() {
    return caseJsonNumber(new Left(new TypeMismatch2("Number")))(Right.create);
  }();
  var decodeJObject = /* @__PURE__ */ function() {
    var $50 = note(new TypeMismatch2("Object"));
    return function($51) {
      return $50(toObject($51));
    };
  }();
  var decodeJArray = /* @__PURE__ */ function() {
    var $52 = note(new TypeMismatch2("Array"));
    return function($53) {
      return $52(toArray($53));
    };
  }();
  var decodeForeignObject = function(decoder) {
    return composeKleisliFlipped3(function() {
      var $86 = lmap2(Named.create("ForeignObject"));
      var $87 = traverse5(decoder);
      return function($88) {
        return $86($87($88));
      };
    }())(decodeJObject);
  };
  var decodeArray = function(decoder) {
    return composeKleisliFlipped3(function() {
      var $89 = lmap2(Named.create("Array"));
      var $90 = traverseWithIndex2(function(i) {
        var $92 = lmap2(AtIndex.create(i));
        return function($93) {
          return $92(decoder($93));
        };
      });
      return function($91) {
        return $89($90($91));
      };
    }())(decodeJArray);
  };

  // output/Record.Unsafe.Union/foreign.js
  function unsafeUnionFn(r1, r2) {
    var copy2 = {};
    for (var k1 in r2) {
      if ({}.hasOwnProperty.call(r2, k1)) {
        copy2[k1] = r2[k1];
      }
    }
    for (var k2 in r1) {
      if ({}.hasOwnProperty.call(r1, k2)) {
        copy2[k2] = r1[k2];
      }
    }
    return copy2;
  }

  // output/Record/index.js
  var disjointUnion = function() {
    return function() {
      return function(l) {
        return function(r) {
          return unsafeUnionFn(l, r);
        };
      };
    };
  };

  // output/Data.Argonaut.Decode.Class/index.js
  var decodeJsonString = {
    decodeJson: decodeString
  };
  var decodeJsonNumber = {
    decodeJson: decodeNumber
  };
  var decodeJsonJson = /* @__PURE__ */ function() {
    return {
      decodeJson: Right.create
    };
  }();
  var decodeJson = function(dict) {
    return dict.decodeJson;
  };
  var decodeForeignObject2 = function(dictDecodeJson) {
    return {
      decodeJson: decodeForeignObject(decodeJson(dictDecodeJson))
    };
  };
  var decodeArray2 = function(dictDecodeJson) {
    return {
      decodeJson: decodeArray(decodeJson(dictDecodeJson))
    };
  };

  // output/Data.Argonaut.Decode.Combinators/index.js
  var getFieldOptional$prime2 = function(dictDecodeJson) {
    return getFieldOptional$prime(decodeJson(dictDecodeJson));
  };
  var getField2 = function(dictDecodeJson) {
    return getField(decodeJson(dictDecodeJson));
  };

  // output/Data.Basic.Coordinates/index.js
  var bind2 = /* @__PURE__ */ bind(bindEither);
  var decodeJson1 = /* @__PURE__ */ decodeJson(/* @__PURE__ */ decodeArray2(decodeJsonNumber));
  var fromNumberArray = function(v) {
    if (v.length === 3) {
      return new Right({
        lon: v[0],
        lat: v[1],
        mbElev: new Just(v[2])
      });
    }
    ;
    if (v.length === 2) {
      return new Right({
        lon: v[0],
        lat: v[1],
        mbElev: Nothing.value
      });
    }
    ;
    return new Left(MissingValue.value);
  };
  var decodeJson2 = {
    decodeJson: function(json2) {
      return bind2(decodeJson1(json2))(function(array2) {
        return fromNumberArray(array2);
      });
    }
  };

  // output/Data.Basic.LineStringCoordinates/index.js
  var append2 = /* @__PURE__ */ append(semigroupArray);
  var bind3 = /* @__PURE__ */ bind(bindEither);
  var decodeJson3 = /* @__PURE__ */ decodeJson(/* @__PURE__ */ decodeArray2(decodeJson2));
  var toArray4 = function(v) {
    return append2([v.first])(append2([v.second])(v.rest));
  };
  var fromArray = function(xs) {
    var v = uncons(xs);
    if (v instanceof Just) {
      var v1 = uncons(v.value0.tail);
      if (v1 instanceof Just) {
        return new Right({
          first: v.value0.head,
          second: v1.value0.head,
          rest: v1.value0.tail
        });
      }
      ;
      if (v1 instanceof Nothing) {
        return new Left(MissingValue.value);
      }
      ;
      throw new Error("Failed pattern match at Data.Basic.LineStringCoordinates (line 36, column 5 - line 38, column 37): " + [v1.constructor.name]);
    }
    ;
    if (v instanceof Nothing) {
      return new Left(MissingValue.value);
    }
    ;
    throw new Error("Failed pattern match at Data.Basic.LineStringCoordinates (line 34, column 16 - line 39, column 31): " + [v.constructor.name]);
  };
  var decodeJsonLineStringCoordinates = {
    decodeJson: function(json2) {
      return bind3(decodeJson3(json2))(function(pointCoordinatesArray) {
        return fromArray(pointCoordinatesArray);
      });
    }
  };

  // output/Data.Basic.BoundingBox/index.js
  var bind4 = /* @__PURE__ */ bind(bindEither);
  var decodeJson4 = /* @__PURE__ */ decodeJson(decodeJsonNumber);
  var fromArray2 = function(v) {
    if (v.length === 4) {
      return new Right({
        sw: {
          lon: v[0],
          lat: v[1],
          mbElev: Nothing.value
        },
        ne: {
          lon: v[2],
          lat: v[3],
          mbElev: Nothing.value
        }
      });
    }
    ;
    return new Left(MissingValue.value);
  };
  var decodeJsonBoundingBox = {
    decodeJson: function(json2) {
      return bind4(decodeArray(decodeJson4)(json2))(function(array2) {
        return fromArray2(array2);
      });
    }
  };

  // output/Data.LineString/index.js
  var bind5 = /* @__PURE__ */ bind(bindEither);
  var decodeJson5 = /* @__PURE__ */ decodeJson(/* @__PURE__ */ decodeForeignObject2(decodeJsonJson));
  var getField3 = /* @__PURE__ */ getField2(decodeJsonLineStringCoordinates);
  var getFieldOptional$prime3 = /* @__PURE__ */ getFieldOptional$prime2(decodeJsonBoundingBox);
  var pure5 = /* @__PURE__ */ pure(applicativeEither);
  var decodeJsonLineString = {
    decodeJson: function(json2) {
      return bind5(decodeJson5(json2))(function(geometry) {
        return bind5(getField3(geometry)("coordinates"))(function(coordinates) {
          return bind5(getFieldOptional$prime3(geometry)("bbox"))(function(bbox) {
            return pure5({
              coordinates,
              bbox
            });
          });
        });
      });
    }
  };

  // output/Data.MultiLineString/index.js
  var bind6 = /* @__PURE__ */ bind(bindEither);
  var decodeJson6 = /* @__PURE__ */ decodeJson(/* @__PURE__ */ decodeForeignObject2(decodeJsonJson));
  var getField4 = /* @__PURE__ */ getField2(/* @__PURE__ */ decodeArray2(decodeJsonLineStringCoordinates));
  var getFieldOptional$prime4 = /* @__PURE__ */ getFieldOptional$prime2(decodeJsonBoundingBox);
  var pure6 = /* @__PURE__ */ pure(applicativeEither);
  var decodeJsonMultiLineString = {
    decodeJson: function(json2) {
      return bind6(decodeJson6(json2))(function(geometry) {
        return bind6(getField4(geometry)("coordinates"))(function(coordinates) {
          return bind6(getFieldOptional$prime4(geometry)("bbox"))(function(bbox) {
            return pure6({
              coordinates,
              bbox
            });
          });
        });
      });
    }
  };

  // output/Data.MultiPoint/index.js
  var bind7 = /* @__PURE__ */ bind(bindEither);
  var decodeJson7 = /* @__PURE__ */ decodeJson(/* @__PURE__ */ decodeForeignObject2(decodeJsonJson));
  var getField5 = /* @__PURE__ */ getField2(/* @__PURE__ */ decodeArray2(decodeJson2));
  var getFieldOptional$prime5 = /* @__PURE__ */ getFieldOptional$prime2(decodeJsonBoundingBox);
  var pure7 = /* @__PURE__ */ pure(applicativeEither);
  var decodeJsonMultiPoint = {
    decodeJson: function(json2) {
      return bind7(decodeJson7(json2))(function(geometry) {
        return bind7(getField5(geometry)("coordinates"))(function(coordinates) {
          return bind7(getFieldOptional$prime5(geometry)("bbox"))(function(bbox) {
            return pure7({
              coordinates,
              bbox
            });
          });
        });
      });
    }
  };

  // output/Data.Basic.LinearRingCoordinates/index.js
  var bind8 = /* @__PURE__ */ bind(bindEither);
  var decodeJson8 = /* @__PURE__ */ decodeJson(/* @__PURE__ */ decodeArray2(decodeJson2));
  var fromArray3 = function(xs) {
    var v = uncons(xs);
    if (v instanceof Just) {
      var v1 = uncons(v.value0.tail);
      if (v1 instanceof Just) {
        var v2 = uncons(v1.value0.tail);
        if (v2 instanceof Just) {
          var v3 = uncons(v2.value0.tail);
          if (v3 instanceof Just) {
            return new Right({
              first: v.value0.head,
              second: v1.value0.head,
              third: v2.value0.head,
              rest: new NonEmpty(v3.value0.head, v3.value0.tail)
            });
          }
          ;
          return new Left(MissingValue.value);
        }
        ;
        if (v2 instanceof Nothing) {
          return new Left(MissingValue.value);
        }
        ;
        throw new Error("Failed pattern match at Data.Basic.LinearRingCoordinates (line 42, column 15 - line 47, column 47): " + [v2.constructor.name]);
      }
      ;
      if (v1 instanceof Nothing) {
        return new Left(MissingValue.value);
      }
      ;
      throw new Error("Failed pattern match at Data.Basic.LinearRingCoordinates (line 40, column 9 - line 48, column 41): " + [v1.constructor.name]);
    }
    ;
    if (v instanceof Nothing) {
      return new Left(MissingValue.value);
    }
    ;
    throw new Error("Failed pattern match at Data.Basic.LinearRingCoordinates (line 38, column 3 - line 49, column 35): " + [v.constructor.name]);
  };
  var decodeLinearRingCoordinates = {
    decodeJson: function(json2) {
      return bind8(decodeJson8(json2))(function(linearRingArray) {
        return fromArray3(linearRingArray);
      });
    }
  };

  // output/Data.Basic.PolygonCoordinates/index.js
  var map10 = /* @__PURE__ */ map(functorEither);
  var decodeJson9 = /* @__PURE__ */ decodeJson(/* @__PURE__ */ decodeArray2(decodeLinearRingCoordinates));
  var PolygonCoordinates = function(x) {
    return x;
  };
  var decodeJsonPolygonCoordinates = {
    decodeJson: function(json2) {
      return map10(PolygonCoordinates)(decodeJson9(json2));
    }
  };

  // output/Data.MultiPolygon/index.js
  var bind9 = /* @__PURE__ */ bind(bindEither);
  var decodeJson10 = /* @__PURE__ */ decodeJson(/* @__PURE__ */ decodeForeignObject2(decodeJsonJson));
  var getField6 = /* @__PURE__ */ getField2(/* @__PURE__ */ decodeArray2(decodeJsonPolygonCoordinates));
  var getFieldOptional$prime6 = /* @__PURE__ */ getFieldOptional$prime2(decodeJsonBoundingBox);
  var pure8 = /* @__PURE__ */ pure(applicativeEither);
  var decodeMultiPolygon = {
    decodeJson: function(json2) {
      return bind9(decodeJson10(json2))(function(geometry) {
        return bind9(getField6(geometry)("coordinates"))(function(coordinates) {
          return bind9(getFieldOptional$prime6(geometry)("bbox"))(function(bbox) {
            return pure8({
              coordinates,
              bbox
            });
          });
        });
      });
    }
  };

  // output/Data.Point/index.js
  var bind10 = /* @__PURE__ */ bind(bindEither);
  var decodeJson11 = /* @__PURE__ */ decodeJson(/* @__PURE__ */ decodeForeignObject2(decodeJsonJson));
  var getField7 = /* @__PURE__ */ getField2(decodeJson2);
  var getFieldOptional$prime7 = /* @__PURE__ */ getFieldOptional$prime2(decodeJsonBoundingBox);
  var pure9 = /* @__PURE__ */ pure(applicativeEither);
  var decodeJsonPoint = {
    decodeJson: function(json2) {
      return bind10(decodeJson11(json2))(function(geometry) {
        return bind10(getField7(geometry)("coordinates"))(function(coordinates) {
          return bind10(getFieldOptional$prime7(geometry)("bbox"))(function(bbox) {
            return pure9({
              coordinates,
              bbox
            });
          });
        });
      });
    }
  };

  // output/Data.Polygon/index.js
  var bind11 = /* @__PURE__ */ bind(bindEither);
  var decodeJson12 = /* @__PURE__ */ decodeJson(/* @__PURE__ */ decodeForeignObject2(decodeJsonJson));
  var getField8 = /* @__PURE__ */ getField2(decodeJsonPolygonCoordinates);
  var getFieldOptional$prime8 = /* @__PURE__ */ getFieldOptional$prime2(decodeJsonBoundingBox);
  var pure10 = /* @__PURE__ */ pure(applicativeEither);
  var decodePolygon = {
    decodeJson: function(json2) {
      return bind11(decodeJson12(json2))(function(v) {
        return bind11(getField8(v)("coordinates"))(function(coordinates) {
          return bind11(getFieldOptional$prime8(v)("bbox"))(function(bbox) {
            return pure10({
              coordinates,
              bbox
            });
          });
        });
      });
    }
  };

  // output/Data.Geometry/index.js
  var map12 = /* @__PURE__ */ map(functorEither);
  var decodeJson13 = /* @__PURE__ */ decodeJson(decodeJsonPoint);
  var decodeJson14 = /* @__PURE__ */ decodeJson(decodeJsonMultiPoint);
  var decodeJson22 = /* @__PURE__ */ decodeJson(decodeJsonLineString);
  var decodeJson32 = /* @__PURE__ */ decodeJson(decodeJsonMultiLineString);
  var decodeJson42 = /* @__PURE__ */ decodeJson(decodePolygon);
  var decodeJson52 = /* @__PURE__ */ decodeJson(decodeMultiPolygon);
  var pure11 = /* @__PURE__ */ pure(applicativeEither);
  var bind12 = /* @__PURE__ */ bind(bindEither);
  var decodeJson62 = /* @__PURE__ */ decodeJson(/* @__PURE__ */ decodeForeignObject2(decodeJsonJson));
  var getFieldOptional$prime9 = /* @__PURE__ */ getFieldOptional$prime2(decodeJsonBoundingBox);
  var getField9 = /* @__PURE__ */ getField2(decodeJsonString);
  var NoGeometry = /* @__PURE__ */ function() {
    function NoGeometry2() {
    }
    ;
    NoGeometry2.value = new NoGeometry2();
    return NoGeometry2;
  }();
  var Point$prime = /* @__PURE__ */ function() {
    function Point$prime2(value0) {
      this.value0 = value0;
    }
    ;
    Point$prime2.create = function(value0) {
      return new Point$prime2(value0);
    };
    return Point$prime2;
  }();
  var MultiPoint$prime = /* @__PURE__ */ function() {
    function MultiPoint$prime2(value0) {
      this.value0 = value0;
    }
    ;
    MultiPoint$prime2.create = function(value0) {
      return new MultiPoint$prime2(value0);
    };
    return MultiPoint$prime2;
  }();
  var LineString$prime = /* @__PURE__ */ function() {
    function LineString$prime2(value0) {
      this.value0 = value0;
    }
    ;
    LineString$prime2.create = function(value0) {
      return new LineString$prime2(value0);
    };
    return LineString$prime2;
  }();
  var MultiLineString$prime = /* @__PURE__ */ function() {
    function MultiLineString$prime2(value0) {
      this.value0 = value0;
    }
    ;
    MultiLineString$prime2.create = function(value0) {
      return new MultiLineString$prime2(value0);
    };
    return MultiLineString$prime2;
  }();
  var Polygon$prime = /* @__PURE__ */ function() {
    function Polygon$prime2(value0) {
      this.value0 = value0;
    }
    ;
    Polygon$prime2.create = function(value0) {
      return new Polygon$prime2(value0);
    };
    return Polygon$prime2;
  }();
  var MultiPolygon$prime = /* @__PURE__ */ function() {
    function MultiPolygon$prime2(value0) {
      this.value0 = value0;
    }
    ;
    MultiPolygon$prime2.create = function(value0) {
      return new MultiPolygon$prime2(value0);
    };
    return MultiPolygon$prime2;
  }();
  var GeometryCollection$prime = /* @__PURE__ */ function() {
    function GeometryCollection$prime2(value0) {
      this.value0 = value0;
    }
    ;
    GeometryCollection$prime2.create = function(value0) {
      return new GeometryCollection$prime2(value0);
    };
    return GeometryCollection$prime2;
  }();
  var geometryFrom = function(v) {
    return function(v1) {
      if (v === "Point") {
        return map12(Point$prime.create)(decodeJson13(v1));
      }
      ;
      if (v === "MultiPoint") {
        return map12(MultiPoint$prime.create)(decodeJson14(v1));
      }
      ;
      if (v === "LineString") {
        return map12(LineString$prime.create)(decodeJson22(v1));
      }
      ;
      if (v === "MultiLineString") {
        return map12(MultiLineString$prime.create)(decodeJson32(v1));
      }
      ;
      if (v === "Polygon") {
        return map12(Polygon$prime.create)(decodeJson42(v1));
      }
      ;
      if (v === "MultiPolygon") {
        return map12(MultiPolygon$prime.create)(decodeJson52(v1));
      }
      ;
      if (v === "GeometryCollection") {
        return map12(GeometryCollection$prime.create)(decodeJson(decodeGeometryCollection)(v1));
      }
      ;
      if (v === "null") {
        return pure11(NoGeometry.value);
      }
      ;
      return new Left(new UnexpectedValue(v1));
    };
  };
  var decodeGeometryCollection = {
    decodeJson: function(json2) {
      return bind12(decodeJson62(json2))(function(geometry) {
        return bind12(getField2(decodeArray2(decodeGeometry))(geometry)("geometries"))(function(geometries) {
          return bind12(getFieldOptional$prime9(geometry)("bbox"))(function(bbox) {
            return pure11({
              geometries,
              bbox
            });
          });
        });
      });
    }
  };
  var decodeGeometry = {
    decodeJson: function(json2) {
      var $161 = isNull(json2);
      if ($161) {
        return pure11(NoGeometry.value);
      }
      ;
      return bind12(decodeJson62(json2))(function(geometry) {
        return bind12(getField9(geometry)("type"))(function(geometryType) {
          return geometryFrom(geometryType)(json2);
        });
      });
    }
  };

  // output/Data.Geometry.Feature/index.js
  var pure12 = /* @__PURE__ */ pure(applicativeEither);
  var bind13 = /* @__PURE__ */ bind(bindEither);
  var decodeJson15 = /* @__PURE__ */ decodeJson(/* @__PURE__ */ decodeForeignObject2(decodeJsonJson));
  var getField10 = /* @__PURE__ */ getField2(decodeGeometry);
  var getFieldOptional$prime10 = /* @__PURE__ */ getFieldOptional$prime2(decodeJsonBoundingBox);
  var FeatureIdString = /* @__PURE__ */ function() {
    function FeatureIdString2(value0) {
      this.value0 = value0;
    }
    ;
    FeatureIdString2.create = function(value0) {
      return new FeatureIdString2(value0);
    };
    return FeatureIdString2;
  }();
  var FeatureIdNumber = /* @__PURE__ */ function() {
    function FeatureIdNumber2(value0) {
      this.value0 = value0;
    }
    ;
    FeatureIdNumber2.create = function(value0) {
      return new FeatureIdNumber2(value0);
    };
    return FeatureIdNumber2;
  }();
  var featurePropertiesDecodeJson = {
    decodeJson: function(json2) {
      return pure12(json2);
    }
  };
  var getFieldOptional$prime1 = /* @__PURE__ */ getFieldOptional$prime2(featurePropertiesDecodeJson);
  var featureIdDecodeJson = {
    decodeJson: function(json2) {
      var v = toNumber2(json2);
      if (v instanceof Just) {
        return new Right(new FeatureIdNumber(v.value0));
      }
      ;
      var v1 = toString(json2);
      if (v1 instanceof Just) {
        return new Right(new FeatureIdString(v1.value0));
      }
      ;
      return new Left(new TypeMismatch2("Expected String or Number for FeatureId"));
    }
  };
  var getFieldOptional$prime22 = /* @__PURE__ */ getFieldOptional$prime2(featureIdDecodeJson);
  var decodeJsonFeature = {
    decodeJson: function(json2) {
      return bind13(decodeJson15(json2))(function(feature) {
        return bind13(getField10(feature)("geometry"))(function(geometry) {
          return bind13(getFieldOptional$prime1(feature)("properties"))(function(properties) {
            return bind13(getFieldOptional$prime22(feature)("id"))(function(id2) {
              return bind13(getFieldOptional$prime10(feature)("bbox"))(function(bbox) {
                return pure12({
                  geometry,
                  properties,
                  id: id2,
                  bbox
                });
              });
            });
          });
        });
      });
    }
  };

  // output/Data.FeatureCollection/index.js
  var bind14 = /* @__PURE__ */ bind(bindEither);
  var decodeJson16 = /* @__PURE__ */ decodeJson(/* @__PURE__ */ decodeForeignObject2(decodeJsonJson));
  var getField11 = /* @__PURE__ */ getField2(/* @__PURE__ */ decodeArray2(decodeJsonFeature));
  var getFieldOptional$prime11 = /* @__PURE__ */ getFieldOptional$prime2(decodeJsonBoundingBox);
  var pure13 = /* @__PURE__ */ pure(applicativeEither);
  var featureCollectionDecodeJson = {
    decodeJson: function(json2) {
      return bind14(decodeJson16(json2))(function(geometry) {
        return bind14(getField11(geometry)("features"))(function(features) {
          return bind14(getFieldOptional$prime11(geometry)("bbox"))(function(bbox) {
            return pure13({
              features,
              bbox
            });
          });
        });
      });
    }
  };

  // output/Data.JSDate/foreign.js
  function toInstantImpl(just) {
    return function(nothing) {
      return function(date2) {
        var t = date2.getTime();
        return isNaN(t) ? nothing : just(t);
      };
    };
  }
  function parse2(dateString) {
    return function() {
      return new Date(dateString);
    };
  }

  // output/Data.JSDate/index.js
  var map11 = /* @__PURE__ */ map(functorFn);
  var map13 = /* @__PURE__ */ map(functorMaybe);
  var toInstant = /* @__PURE__ */ function() {
    return composeKleisliFlipped(bindMaybe)(function($21) {
      return instant(Milliseconds($21));
    })(toInstantImpl(Just.create)(Nothing.value));
  }();
  var toDateTime2 = /* @__PURE__ */ map11(/* @__PURE__ */ map13(toDateTime))(toInstant);

  // output/Data.Profunctor.Choice/index.js
  var left = function(dict) {
    return dict.left;
  };
  var choiceFn = {
    left: function(v) {
      return function(v1) {
        if (v1 instanceof Left) {
          return new Left(v(v1.value0));
        }
        ;
        if (v1 instanceof Right) {
          return new Right(v1.value0);
        }
        ;
        throw new Error("Failed pattern match at Data.Profunctor.Choice (line 32, column 1 - line 35, column 16): " + [v.constructor.name, v1.constructor.name]);
      };
    },
    right: /* @__PURE__ */ map(functorEither),
    Profunctor0: function() {
      return profunctorFn;
    }
  };

  // output/App.Data.Route/index.js
  var pure14 = /* @__PURE__ */ pure(applicativeEffect);
  var bind15 = /* @__PURE__ */ bind(/* @__PURE__ */ bindExceptT(monadEffect));
  var except2 = /* @__PURE__ */ except(applicativeEffect);
  var decodeJson17 = /* @__PURE__ */ decodeJson(/* @__PURE__ */ decodeForeignObject2(decodeJsonJson));
  var getField12 = /* @__PURE__ */ getField2(/* @__PURE__ */ decodeArray2(/* @__PURE__ */ decodeArray2(decodeJsonString)));
  var lift3 = /* @__PURE__ */ lift(monadTransExceptT)(monadEffect);
  var traverse3 = /* @__PURE__ */ traverse(traversableArray)(applicativeEffect);
  var pure15 = /* @__PURE__ */ pure(applicativeEither);
  var foldMap4 = /* @__PURE__ */ foldMap2(monoidArray);
  var throwError2 = /* @__PURE__ */ throwError(monadThrowEither);
  var left2 = /* @__PURE__ */ left(choiceFn);
  var decodeJson18 = /* @__PURE__ */ decodeJson(featureCollectionDecodeJson);
  var pure22 = /* @__PURE__ */ pure(/* @__PURE__ */ applicativeExceptT(monadEffect));
  var parseTimestamp = function(s) {
    return function __do2() {
      var iso = parse2(s)();
      var v = toDateTime2(iso);
      if (v instanceof Just) {
        return v.value0;
      }
      ;
      if (v instanceof Nothing) {
        return $$throw("Failed to parse timestamp: " + s)();
      }
      ;
      throw new Error("Failed pattern match at App.Data.Route (line 46, column 3 - line 48, column 58): " + [v.constructor.name]);
    };
  };
  var parseTimestamps = function(v) {
    if (v.properties instanceof Nothing) {
      return $$throw("Feature has no properties");
    }
    ;
    if (v.properties instanceof Just) {
      return function __do2() {
        var a = runExceptT(bind15(except2(decodeJson17(v.properties.value0)))(function(obj) {
          return bind15(except2(getField12(obj)("coordTimes")))(function(cts) {
            return lift3(traverse3(parseTimestamp)(concat(cts)));
          });
        }))();
        return either(function($43) {
          return $$throw(printJsonDecodeError($43));
        })(pure14)(a)();
      };
    }
    ;
    throw new Error("Failed pattern match at App.Data.Route (line 52, column 3 - line 59, column 53): " + [v.properties.constructor.name]);
  };
  var parseCoordinates = function(v) {
    if (v.geometry instanceof MultiLineString$prime) {
      return pure15(foldMap4(toArray4)(v.geometry.value0.coordinates));
    }
    ;
    return throwError2("Feature geometry is not a MultiLineString");
  };
  var parseRoute = function(json2) {
    return function __do2() {
      var route = runExceptT(bind15(except2(left2(printJsonDecodeError)(decodeJson18(json2))))(function(v) {
        var v1 = head(v.features);
        if (v1 instanceof Nothing) {
          return lift3($$throw("No features in FeatureCollection"));
        }
        ;
        if (v1 instanceof Just) {
          return bind15(lift3(parseTimestamps(v1.value0)))(function(timestamps) {
            return bind15(except2(parseCoordinates(v1.value0)))(function(points) {
              return pure22({
                timestamps,
                points
              });
            });
          });
        }
        ;
        throw new Error("Failed pattern match at App.Data.Route (line 35, column 5 - line 40, column 44): " + [v1.constructor.name]);
      }))();
      return either($$throw)(pure14)(route)();
    };
  };

  // output/App.Request/index.js
  var bind16 = /* @__PURE__ */ bind(bindAff);
  var throwError3 = /* @__PURE__ */ throwError(monadThrowAff);
  var liftEffect2 = /* @__PURE__ */ liftEffect(monadEffectAff);
  var getRoute = /* @__PURE__ */ function() {
    var req = {
      content: defaultRequest.content,
      method: defaultRequest.method,
      password: defaultRequest.password,
      timeout: defaultRequest.timeout,
      username: defaultRequest.username,
      withCredentials: defaultRequest.withCredentials,
      url: "data/route.json",
      headers: [new RequestHeader("Access-Control-Allow-Origin", "*"), new RequestHeader("Contenty-Type", "application/json")],
      responseFormat: json
    };
    return bind16(request(driver)(req))(function(resp) {
      if (resp instanceof Left) {
        return throwError3(error2(printError(resp.value0)));
      }
      ;
      if (resp instanceof Right) {
        return liftEffect2(parseRoute(resp.value0.body));
      }
      ;
      throw new Error("Failed pattern match at App.Request (line 80, column 3 - line 82, column 51): " + [resp.constructor.name]);
    });
  }();

  // node_modules/@babel/runtime/helpers/esm/extends.js
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target5) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target5[key] = source[key];
          }
        }
      }
      return target5;
    };
    return _extends.apply(this, arguments);
  }

  // node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }

  // node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray(arr);
  }

  // node_modules/@babel/runtime/helpers/esm/iterableToArray.js
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
      return Array.from(iter);
  }

  // node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray(o, minLen);
  }

  // node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  // node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  // node_modules/react-map-gl/dist/esm/components/interactive-map.js
  var React5 = __toESM(require_react());
  var import_react11 = __toESM(require_react());
  var PropTypes3 = __toESM(require_prop_types());

  // node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }

  // node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
  function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e, n, i, u, a = [], f = true, o = false;
      try {
        if (i = (t = t.call(r)).next, 0 === l) {
          if (Object(t) !== t)
            return;
          f = false;
        } else
          for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true)
            ;
      } catch (r2) {
        o = true, n = r2;
      } finally {
        try {
          if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u))
            return;
        } finally {
          if (o)
            throw n;
        }
      }
      return a;
    }
  }

  // node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  // node_modules/@babel/runtime/helpers/esm/slicedToArray.js
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  // node_modules/react-map-gl/dist/esm/components/static-map.js
  var React4 = __toESM(require_react());
  var import_react10 = __toESM(require_react());
  var PropTypes2 = __toESM(require_prop_types());

  // node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
  var MapShim = function() {
    if (typeof Map !== "undefined") {
      return Map;
    }
    function getIndex(arr, key) {
      var result = -1;
      arr.some(function(entry, index5) {
        if (entry[0] === key) {
          result = index5;
          return true;
        }
        return false;
      });
      return result;
    }
    return function() {
      function class_1() {
        this.__entries__ = [];
      }
      Object.defineProperty(class_1.prototype, "size", {
        get: function() {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      });
      class_1.prototype.get = function(key) {
        var index5 = getIndex(this.__entries__, key);
        var entry = this.__entries__[index5];
        return entry && entry[1];
      };
      class_1.prototype.set = function(key, value13) {
        var index5 = getIndex(this.__entries__, key);
        if (~index5) {
          this.__entries__[index5][1] = value13;
        } else {
          this.__entries__.push([key, value13]);
        }
      };
      class_1.prototype.delete = function(key) {
        var entries = this.__entries__;
        var index5 = getIndex(entries, key);
        if (~index5) {
          entries.splice(index5, 1);
        }
      };
      class_1.prototype.has = function(key) {
        return !!~getIndex(this.__entries__, key);
      };
      class_1.prototype.clear = function() {
        this.__entries__.splice(0);
      };
      class_1.prototype.forEach = function(callback, ctx) {
        if (ctx === void 0) {
          ctx = null;
        }
        for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
          var entry = _a[_i];
          callback.call(ctx, entry[1], entry[0]);
        }
      };
      return class_1;
    }();
  }();
  var isBrowser8 = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
  var global$1 = function() {
    if (typeof global !== "undefined" && global.Math === Math) {
      return global;
    }
    if (typeof self !== "undefined" && self.Math === Math) {
      return self;
    }
    if (typeof window !== "undefined" && window.Math === Math) {
      return window;
    }
    return Function("return this")();
  }();
  var requestAnimationFrame$1 = function() {
    if (typeof requestAnimationFrame === "function") {
      return requestAnimationFrame.bind(global$1);
    }
    return function(callback) {
      return setTimeout(function() {
        return callback(Date.now());
      }, 1e3 / 60);
    };
  }();
  var trailingTimeout = 2;
  function throttle(callback, delay2) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    function resolvePending() {
      if (leadingCall) {
        leadingCall = false;
        callback();
      }
      if (trailingCall) {
        proxy();
      }
    }
    function timeoutCallback() {
      requestAnimationFrame$1(resolvePending);
    }
    function proxy() {
      var timeStamp = Date.now();
      if (leadingCall) {
        if (timeStamp - lastCallTime < trailingTimeout) {
          return;
        }
        trailingCall = true;
      } else {
        leadingCall = true;
        trailingCall = false;
        setTimeout(timeoutCallback, delay2);
      }
      lastCallTime = timeStamp;
    }
    return proxy;
  }
  var REFRESH_DELAY = 20;
  var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
  var mutationObserverSupported = typeof MutationObserver !== "undefined";
  var ResizeObserverController = function() {
    function ResizeObserverController2() {
      this.connected_ = false;
      this.mutationEventsAdded_ = false;
      this.mutationsObserver_ = null;
      this.observers_ = [];
      this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
      this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    ResizeObserverController2.prototype.addObserver = function(observer) {
      if (!~this.observers_.indexOf(observer)) {
        this.observers_.push(observer);
      }
      if (!this.connected_) {
        this.connect_();
      }
    };
    ResizeObserverController2.prototype.removeObserver = function(observer) {
      var observers2 = this.observers_;
      var index5 = observers2.indexOf(observer);
      if (~index5) {
        observers2.splice(index5, 1);
      }
      if (!observers2.length && this.connected_) {
        this.disconnect_();
      }
    };
    ResizeObserverController2.prototype.refresh = function() {
      var changesDetected = this.updateObservers_();
      if (changesDetected) {
        this.refresh();
      }
    };
    ResizeObserverController2.prototype.updateObservers_ = function() {
      var activeObservers = this.observers_.filter(function(observer) {
        return observer.gatherActive(), observer.hasActive();
      });
      activeObservers.forEach(function(observer) {
        return observer.broadcastActive();
      });
      return activeObservers.length > 0;
    };
    ResizeObserverController2.prototype.connect_ = function() {
      if (!isBrowser8 || this.connected_) {
        return;
      }
      document.addEventListener("transitionend", this.onTransitionEnd_);
      window.addEventListener("resize", this.refresh);
      if (mutationObserverSupported) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);
        this.mutationsObserver_.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      } else {
        document.addEventListener("DOMSubtreeModified", this.refresh);
        this.mutationEventsAdded_ = true;
      }
      this.connected_ = true;
    };
    ResizeObserverController2.prototype.disconnect_ = function() {
      if (!isBrowser8 || !this.connected_) {
        return;
      }
      document.removeEventListener("transitionend", this.onTransitionEnd_);
      window.removeEventListener("resize", this.refresh);
      if (this.mutationsObserver_) {
        this.mutationsObserver_.disconnect();
      }
      if (this.mutationEventsAdded_) {
        document.removeEventListener("DOMSubtreeModified", this.refresh);
      }
      this.mutationsObserver_ = null;
      this.mutationEventsAdded_ = false;
      this.connected_ = false;
    };
    ResizeObserverController2.prototype.onTransitionEnd_ = function(_a) {
      var _b = _a.propertyName, propertyName = _b === void 0 ? "" : _b;
      var isReflowProperty = transitionKeys.some(function(key) {
        return !!~propertyName.indexOf(key);
      });
      if (isReflowProperty) {
        this.refresh();
      }
    };
    ResizeObserverController2.getInstance = function() {
      if (!this.instance_) {
        this.instance_ = new ResizeObserverController2();
      }
      return this.instance_;
    };
    ResizeObserverController2.instance_ = null;
    return ResizeObserverController2;
  }();
  var defineConfigurable = function(target5, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
      var key = _a[_i];
      Object.defineProperty(target5, key, {
        value: props[key],
        enumerable: false,
        writable: false,
        configurable: true
      });
    }
    return target5;
  };
  var getWindowOf = function(target5) {
    var ownerGlobal = target5 && target5.ownerDocument && target5.ownerDocument.defaultView;
    return ownerGlobal || global$1;
  };
  var emptyRect = createRectInit(0, 0, 0, 0);
  function toFloat(value13) {
    return parseFloat(value13) || 0;
  }
  function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function(size5, position2) {
      var value13 = styles["border-" + position2 + "-width"];
      return size5 + toFloat(value13);
    }, 0);
  }
  function getPaddings(styles) {
    var positions = ["top", "right", "bottom", "left"];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
      var position2 = positions_1[_i];
      var value13 = styles["padding-" + position2];
      paddings[position2] = toFloat(value13);
    }
    return paddings;
  }
  function getSVGContentRect(target5) {
    var bbox = target5.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
  }
  function getHTMLElementContentRect(target5) {
    var clientWidth = target5.clientWidth, clientHeight = target5.clientHeight;
    if (!clientWidth && !clientHeight) {
      return emptyRect;
    }
    var styles = getWindowOf(target5).getComputedStyle(target5);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    var width8 = toFloat(styles.width), height8 = toFloat(styles.height);
    if (styles.boxSizing === "border-box") {
      if (Math.round(width8 + horizPad) !== clientWidth) {
        width8 -= getBordersSize(styles, "left", "right") + horizPad;
      }
      if (Math.round(height8 + vertPad) !== clientHeight) {
        height8 -= getBordersSize(styles, "top", "bottom") + vertPad;
      }
    }
    if (!isDocumentElement(target5)) {
      var vertScrollbar = Math.round(width8 + horizPad) - clientWidth;
      var horizScrollbar = Math.round(height8 + vertPad) - clientHeight;
      if (Math.abs(vertScrollbar) !== 1) {
        width8 -= vertScrollbar;
      }
      if (Math.abs(horizScrollbar) !== 1) {
        height8 -= horizScrollbar;
      }
    }
    return createRectInit(paddings.left, paddings.top, width8, height8);
  }
  var isSVGGraphicsElement = function() {
    if (typeof SVGGraphicsElement !== "undefined") {
      return function(target5) {
        return target5 instanceof getWindowOf(target5).SVGGraphicsElement;
      };
    }
    return function(target5) {
      return target5 instanceof getWindowOf(target5).SVGElement && typeof target5.getBBox === "function";
    };
  }();
  function isDocumentElement(target5) {
    return target5 === getWindowOf(target5).document.documentElement;
  }
  function getContentRect(target5) {
    if (!isBrowser8) {
      return emptyRect;
    }
    if (isSVGGraphicsElement(target5)) {
      return getSVGContentRect(target5);
    }
    return getHTMLElementContentRect(target5);
  }
  function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width8 = _a.width, height8 = _a.height;
    var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    defineConfigurable(rect, {
      x,
      y,
      width: width8,
      height: height8,
      top: y,
      right: x + width8,
      bottom: height8 + y,
      left: x
    });
    return rect;
  }
  function createRectInit(x, y, width8, height8) {
    return { x, y, width: width8, height: height8 };
  }
  var ResizeObservation = function() {
    function ResizeObservation2(target5) {
      this.broadcastWidth = 0;
      this.broadcastHeight = 0;
      this.contentRect_ = createRectInit(0, 0, 0, 0);
      this.target = target5;
    }
    ResizeObservation2.prototype.isActive = function() {
      var rect = getContentRect(this.target);
      this.contentRect_ = rect;
      return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
    };
    ResizeObservation2.prototype.broadcastRect = function() {
      var rect = this.contentRect_;
      this.broadcastWidth = rect.width;
      this.broadcastHeight = rect.height;
      return rect;
    };
    return ResizeObservation2;
  }();
  var ResizeObserverEntry = function() {
    function ResizeObserverEntry2(target5, rectInit) {
      var contentRect = createReadOnlyRect(rectInit);
      defineConfigurable(this, { target: target5, contentRect });
    }
    return ResizeObserverEntry2;
  }();
  var ResizeObserverSPI = function() {
    function ResizeObserverSPI2(callback, controller, callbackCtx) {
      this.activeObservations_ = [];
      this.observations_ = new MapShim();
      if (typeof callback !== "function") {
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      }
      this.callback_ = callback;
      this.controller_ = controller;
      this.callbackCtx_ = callbackCtx;
    }
    ResizeObserverSPI2.prototype.observe = function(target5) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target5 instanceof getWindowOf(target5).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (observations.has(target5)) {
        return;
      }
      observations.set(target5, new ResizeObservation(target5));
      this.controller_.addObserver(this);
      this.controller_.refresh();
    };
    ResizeObserverSPI2.prototype.unobserve = function(target5) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target5 instanceof getWindowOf(target5).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (!observations.has(target5)) {
        return;
      }
      observations.delete(target5);
      if (!observations.size) {
        this.controller_.removeObserver(this);
      }
    };
    ResizeObserverSPI2.prototype.disconnect = function() {
      this.clearActive();
      this.observations_.clear();
      this.controller_.removeObserver(this);
    };
    ResizeObserverSPI2.prototype.gatherActive = function() {
      var _this = this;
      this.clearActive();
      this.observations_.forEach(function(observation) {
        if (observation.isActive()) {
          _this.activeObservations_.push(observation);
        }
      });
    };
    ResizeObserverSPI2.prototype.broadcastActive = function() {
      if (!this.hasActive()) {
        return;
      }
      var ctx = this.callbackCtx_;
      var entries = this.activeObservations_.map(function(observation) {
        return new ResizeObserverEntry(observation.target, observation.broadcastRect());
      });
      this.callback_.call(ctx, entries, ctx);
      this.clearActive();
    };
    ResizeObserverSPI2.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    };
    ResizeObserverSPI2.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI2;
  }();
  var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
  var ResizeObserver = function() {
    function ResizeObserver2(callback) {
      if (!(this instanceof ResizeObserver2)) {
        throw new TypeError("Cannot call a class as a function.");
      }
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      var controller = ResizeObserverController.getInstance();
      var observer = new ResizeObserverSPI(callback, controller, this);
      observers.set(this, observer);
    }
    return ResizeObserver2;
  }();
  [
    "observe",
    "unobserve",
    "disconnect"
  ].forEach(function(method2) {
    ResizeObserver.prototype[method2] = function() {
      var _a;
      return (_a = observers.get(this))[method2].apply(_a, arguments);
    };
  });
  var index3 = function() {
    if (typeof global$1.ResizeObserver !== "undefined") {
      return global$1.ResizeObserver;
    }
    return ResizeObserver;
  }();
  var ResizeObserver_es_default = index3;

  // node_modules/@babel/runtime/helpers/esm/classCallCheck.js
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  // node_modules/@babel/runtime/helpers/esm/createClass.js
  function _defineProperties(target5, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target5, toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  // node_modules/react-map-gl/dist/esm/mapbox/mapbox.js
  var PropTypes = __toESM(require_prop_types());

  // node_modules/react-map-gl/dist/esm/utils/globals.js
  var window_6 = typeof window !== "undefined" ? window : global;
  var document_5 = typeof document !== "undefined" ? document : {};

  // node_modules/react-map-gl/dist/esm/utils/style-utils.js
  function ownKeys(object12, enumerableOnly) {
    var keys3 = Object.keys(object12);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object12);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object12, sym).enumerable;
        });
      keys3.push.apply(keys3, symbols);
    }
    return keys3;
  }
  function _objectSpread(target5) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target5, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target5, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target5, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target5;
  }
  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray2(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step2 = it.next();
      normalCompletion = step2.done;
      return step2;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray2(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray2(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray2(o, minLen);
  }
  function _arrayLikeToArray2(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var refProps = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
  function normalizeStyle(style) {
    if (!style) {
      return null;
    }
    if (typeof style === "string") {
      return style;
    }
    if (style.toJS) {
      style = style.toJS();
    }
    var layerIndex = {};
    var _iterator = _createForOfIteratorHelper(style.layers), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var layer = _step.value;
        layerIndex[layer.id] = layer;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    var layers = style.layers.map(function(layer2) {
      var layerRef = layerIndex[layer2.ref];
      var normalizedLayer = null;
      if ("interactive" in layer2) {
        normalizedLayer = _objectSpread({}, layer2);
        delete normalizedLayer.interactive;
      }
      if (layerRef) {
        normalizedLayer = normalizedLayer || _objectSpread({}, layer2);
        delete normalizedLayer.ref;
        var _iterator2 = _createForOfIteratorHelper(refProps), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var propName = _step2.value;
            if (propName in layerRef) {
              normalizedLayer[propName] = layerRef[propName];
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
      return normalizedLayer || layer2;
    });
    return _objectSpread(_objectSpread({}, style), {}, {
      layers
    });
  }

  // node_modules/react-map-gl/dist/esm/mapbox/mapbox.js
  function noop5() {
  }
  function defaultOnError(event) {
    if (event) {
      console.error(event.error);
    }
  }
  var propTypes = {
    container: PropTypes.object,
    gl: PropTypes.object,
    mapboxApiAccessToken: PropTypes.string,
    mapboxApiUrl: PropTypes.string,
    attributionControl: PropTypes.bool,
    preserveDrawingBuffer: PropTypes.bool,
    reuseMaps: PropTypes.bool,
    transformRequest: PropTypes.func,
    mapOptions: PropTypes.object,
    mapStyle: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
    preventStyleDiffing: PropTypes.bool,
    visible: PropTypes.bool,
    asyncRender: PropTypes.bool,
    onLoad: PropTypes.func,
    onError: PropTypes.func,
    width: PropTypes.number,
    height: PropTypes.number,
    viewState: PropTypes.object,
    longitude: PropTypes.number,
    latitude: PropTypes.number,
    zoom: PropTypes.number,
    bearing: PropTypes.number,
    pitch: PropTypes.number,
    altitude: PropTypes.number
  };
  var defaultProps5 = {
    container: document_5.body,
    mapboxApiAccessToken: getAccessToken(),
    mapboxApiUrl: "https://api.mapbox.com",
    preserveDrawingBuffer: false,
    attributionControl: true,
    reuseMaps: false,
    mapOptions: {},
    mapStyle: "mapbox://styles/mapbox/light-v8",
    preventStyleDiffing: false,
    visible: true,
    asyncRender: false,
    onLoad: noop5,
    onError: defaultOnError,
    width: 0,
    height: 0,
    longitude: 0,
    latitude: 0,
    zoom: 0,
    bearing: 0,
    pitch: 0,
    altitude: 1.5
  };
  function getAccessToken() {
    var accessToken = null;
    if (typeof window !== "undefined" && window.location) {
      var match = window.location.search.match(/access_token=([^&\/]*)/);
      accessToken = match && match[1];
    }
    if (!accessToken && typeof process !== "undefined") {
      accessToken = accessToken || process.env.MapboxAccessToken || process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;
    }
    return accessToken || "no-token";
  }
  function checkPropTypes2(props) {
    var component2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "component";
    if (props.debug) {
      PropTypes.checkPropTypes(propTypes, props, "prop", component2);
    }
  }
  var Mapbox = function() {
    function Mapbox2(props) {
      var _this = this;
      _classCallCheck(this, Mapbox2);
      _defineProperty(this, "props", defaultProps5);
      _defineProperty(this, "width", 0);
      _defineProperty(this, "height", 0);
      _defineProperty(this, "_fireLoadEvent", function() {
        _this.props.onLoad({
          type: "load",
          target: _this._map
        });
      });
      _defineProperty(this, "_handleError", function(event) {
        _this.props.onError(event);
      });
      if (!props.mapboxgl) {
        throw new Error("Mapbox not available");
      }
      this.mapboxgl = props.mapboxgl;
      if (!Mapbox2.initialized) {
        Mapbox2.initialized = true;
        this._checkStyleSheet(this.mapboxgl.version);
      }
      this._initialize(props);
    }
    _createClass(Mapbox2, [{
      key: "finalize",
      value: function finalize() {
        this._destroy();
        return this;
      }
    }, {
      key: "setProps",
      value: function setProps(props) {
        this._update(this.props, props);
        return this;
      }
    }, {
      key: "redraw",
      value: function redraw() {
        var map16 = this._map;
        if (map16.style) {
          if (map16._frame) {
            map16._frame.cancel();
            map16._frame = null;
          }
          map16._render();
        }
      }
    }, {
      key: "getMap",
      value: function getMap() {
        return this._map;
      }
    }, {
      key: "_reuse",
      value: function _reuse(props) {
        this._map = Mapbox2.savedMap;
        var oldContainer = this._map.getContainer();
        var newContainer = props.container;
        newContainer.classList.add("mapboxgl-map");
        while (oldContainer.childNodes.length > 0) {
          newContainer.appendChild(oldContainer.childNodes[0]);
        }
        this._map._container = newContainer;
        Mapbox2.savedMap = null;
        if (props.mapStyle) {
          this._map.setStyle(normalizeStyle(props.mapStyle), {
            diff: false
          });
        }
        if (this._map.isStyleLoaded()) {
          this._fireLoadEvent();
        } else {
          this._map.once("styledata", this._fireLoadEvent);
        }
      }
    }, {
      key: "_create",
      value: function _create(props) {
        if (props.reuseMaps && Mapbox2.savedMap) {
          this._reuse(props);
        } else {
          if (props.gl) {
            var getContext = HTMLCanvasElement.prototype.getContext;
            HTMLCanvasElement.prototype.getContext = function() {
              HTMLCanvasElement.prototype.getContext = getContext;
              return props.gl;
            };
          }
          var mapOptions = {
            container: props.container,
            center: [0, 0],
            zoom: 8,
            pitch: 0,
            bearing: 0,
            maxZoom: 24,
            style: normalizeStyle(props.mapStyle),
            interactive: false,
            trackResize: false,
            attributionControl: props.attributionControl,
            preserveDrawingBuffer: props.preserveDrawingBuffer
          };
          if (props.transformRequest) {
            mapOptions.transformRequest = props.transformRequest;
          }
          this._map = new this.mapboxgl.Map(Object.assign({}, mapOptions, props.mapOptions));
          this._map.once("load", this._fireLoadEvent);
          this._map.on("error", this._handleError);
        }
        return this;
      }
    }, {
      key: "_destroy",
      value: function _destroy() {
        if (!this._map) {
          return;
        }
        if (this.props.reuseMaps && !Mapbox2.savedMap) {
          Mapbox2.savedMap = this._map;
          this._map.off("load", this._fireLoadEvent);
          this._map.off("error", this._handleError);
          this._map.off("styledata", this._fireLoadEvent);
        } else {
          this._map.remove();
        }
        this._map = null;
      }
    }, {
      key: "_initialize",
      value: function _initialize(props) {
        var _this2 = this;
        props = Object.assign({}, defaultProps5, props);
        checkPropTypes2(props, "Mapbox");
        this.mapboxgl.accessToken = props.mapboxApiAccessToken || defaultProps5.mapboxApiAccessToken;
        this.mapboxgl.baseApiUrl = props.mapboxApiUrl;
        this._create(props);
        var _props = props, container = _props.container;
        Object.defineProperty(container, "offsetWidth", {
          configurable: true,
          get: function get3() {
            return _this2.width;
          }
        });
        Object.defineProperty(container, "clientWidth", {
          configurable: true,
          get: function get3() {
            return _this2.width;
          }
        });
        Object.defineProperty(container, "offsetHeight", {
          configurable: true,
          get: function get3() {
            return _this2.height;
          }
        });
        Object.defineProperty(container, "clientHeight", {
          configurable: true,
          get: function get3() {
            return _this2.height;
          }
        });
        var canvas = this._map.getCanvas();
        if (canvas) {
          canvas.style.outline = "none";
        }
        this._updateMapViewport({}, props);
        this._updateMapSize({}, props);
        this.props = props;
      }
    }, {
      key: "_update",
      value: function _update(oldProps, newProps) {
        if (!this._map) {
          return;
        }
        newProps = Object.assign({}, this.props, newProps);
        checkPropTypes2(newProps, "Mapbox");
        var viewportChanged = this._updateMapViewport(oldProps, newProps);
        var sizeChanged = this._updateMapSize(oldProps, newProps);
        this._updateMapStyle(oldProps, newProps);
        if (!newProps.asyncRender && (viewportChanged || sizeChanged)) {
          this.redraw();
        }
        this.props = newProps;
      }
    }, {
      key: "_updateMapStyle",
      value: function _updateMapStyle(oldProps, newProps) {
        var styleChanged = oldProps.mapStyle !== newProps.mapStyle;
        if (styleChanged) {
          this._map.setStyle(normalizeStyle(newProps.mapStyle), {
            diff: !newProps.preventStyleDiffing
          });
        }
      }
    }, {
      key: "_updateMapSize",
      value: function _updateMapSize(oldProps, newProps) {
        var sizeChanged = oldProps.width !== newProps.width || oldProps.height !== newProps.height;
        if (sizeChanged) {
          this.width = newProps.width;
          this.height = newProps.height;
          this._map.resize();
        }
        return sizeChanged;
      }
    }, {
      key: "_updateMapViewport",
      value: function _updateMapViewport(oldProps, newProps) {
        var oldViewState = this._getViewState(oldProps);
        var newViewState = this._getViewState(newProps);
        var viewportChanged = newViewState.latitude !== oldViewState.latitude || newViewState.longitude !== oldViewState.longitude || newViewState.zoom !== oldViewState.zoom || newViewState.pitch !== oldViewState.pitch || newViewState.bearing !== oldViewState.bearing || newViewState.altitude !== oldViewState.altitude;
        if (viewportChanged) {
          this._map.jumpTo(this._viewStateToMapboxProps(newViewState));
          if (newViewState.altitude !== oldViewState.altitude) {
            this._map.transform.altitude = newViewState.altitude;
          }
        }
        return viewportChanged;
      }
    }, {
      key: "_getViewState",
      value: function _getViewState(props) {
        var _ref = props.viewState || props, longitude = _ref.longitude, latitude = _ref.latitude, zoom = _ref.zoom, _ref$pitch = _ref.pitch, pitch = _ref$pitch === void 0 ? 0 : _ref$pitch, _ref$bearing = _ref.bearing, bearing = _ref$bearing === void 0 ? 0 : _ref$bearing, _ref$altitude = _ref.altitude, altitude = _ref$altitude === void 0 ? 1.5 : _ref$altitude;
        return {
          longitude,
          latitude,
          zoom,
          pitch,
          bearing,
          altitude
        };
      }
    }, {
      key: "_checkStyleSheet",
      value: function _checkStyleSheet() {
        var mapboxVersion = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "0.47.0";
        if (typeof document_5 === "undefined") {
          return;
        }
        try {
          var testElement = document_5.createElement("div");
          testElement.className = "mapboxgl-map";
          testElement.style.display = "none";
          document_5.body.appendChild(testElement);
          var isCssLoaded = window.getComputedStyle(testElement).position !== "static";
          if (!isCssLoaded) {
            var link = document_5.createElement("link");
            link.setAttribute("rel", "stylesheet");
            link.setAttribute("type", "text/css");
            link.setAttribute("href", "https://api.tiles.mapbox.com/mapbox-gl-js/v".concat(mapboxVersion, "/mapbox-gl.css"));
            document_5.head.appendChild(link);
          }
        } catch (error3) {
        }
      }
    }, {
      key: "_viewStateToMapboxProps",
      value: function _viewStateToMapboxProps(viewState) {
        return {
          center: [viewState.longitude, viewState.latitude],
          zoom: viewState.zoom,
          bearing: viewState.bearing,
          pitch: viewState.pitch
        };
      }
    }]);
    return Mapbox2;
  }();
  _defineProperty(Mapbox, "initialized", false);
  _defineProperty(Mapbox, "propTypes", propTypes);
  _defineProperty(Mapbox, "defaultProps", defaultProps5);
  _defineProperty(Mapbox, "savedMap", null);

  // node_modules/react-map-gl/dist/esm/utils/mapboxgl.browser.js
  var import_mapbox_gl = __toESM(require_mapbox_gl());

  // node_modules/react-map-gl/dist/esm/utils/math-utils.js
  var EPSILON4 = 1e-7;
  function isArray5(value13) {
    return Array.isArray(value13) || ArrayBuffer.isView(value13);
  }
  function equals3(a, b) {
    if (a === b) {
      return true;
    }
    if (isArray5(a) && isArray5(b)) {
      if (a.length !== b.length) {
        return false;
      }
      for (var i = 0; i < a.length; ++i) {
        if (!equals3(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    return Math.abs(a - b) <= EPSILON4;
  }
  function clamp3(value13, min5, max6) {
    return Math.max(min5, Math.min(max6, value13));
  }
  function lerp4(a, b, t) {
    if (isArray5(a)) {
      return a.map(function(ai, i) {
        return lerp4(ai, b[i], t);
      });
    }
    return t * b + (1 - t) * a;
  }

  // node_modules/react-map-gl/dist/esm/utils/assert.js
  function assert11(condition, message2) {
    if (!condition) {
      throw new Error(message2 || "react-map-gl: assertion failed.");
    }
  }

  // node_modules/react-map-gl/dist/esm/utils/map-state.js
  function ownKeys2(object12, enumerableOnly) {
    var keys3 = Object.keys(object12);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object12);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object12, sym).enumerable;
        });
      keys3.push.apply(keys3, symbols);
    }
    return keys3;
  }
  function _objectSpread2(target5) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys2(Object(source), true).forEach(function(key) {
          _defineProperty(target5, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target5, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys2(Object(source)).forEach(function(key) {
          Object.defineProperty(target5, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target5;
  }
  var MAPBOX_LIMITS = {
    minZoom: 0,
    maxZoom: 24,
    minPitch: 0,
    maxPitch: 60
  };
  var DEFAULT_STATE = {
    pitch: 0,
    bearing: 0,
    altitude: 1.5
  };
  var PITCH_MOUSE_THRESHOLD2 = 5;
  var PITCH_ACCEL2 = 1.2;
  var MapState2 = function() {
    function MapState3(_ref) {
      var width8 = _ref.width, height8 = _ref.height, latitude = _ref.latitude, longitude = _ref.longitude, zoom = _ref.zoom, _ref$bearing = _ref.bearing, bearing = _ref$bearing === void 0 ? DEFAULT_STATE.bearing : _ref$bearing, _ref$pitch = _ref.pitch, pitch = _ref$pitch === void 0 ? DEFAULT_STATE.pitch : _ref$pitch, _ref$altitude = _ref.altitude, altitude = _ref$altitude === void 0 ? DEFAULT_STATE.altitude : _ref$altitude, _ref$maxZoom = _ref.maxZoom, maxZoom = _ref$maxZoom === void 0 ? MAPBOX_LIMITS.maxZoom : _ref$maxZoom, _ref$minZoom = _ref.minZoom, minZoom = _ref$minZoom === void 0 ? MAPBOX_LIMITS.minZoom : _ref$minZoom, _ref$maxPitch = _ref.maxPitch, maxPitch = _ref$maxPitch === void 0 ? MAPBOX_LIMITS.maxPitch : _ref$maxPitch, _ref$minPitch = _ref.minPitch, minPitch = _ref$minPitch === void 0 ? MAPBOX_LIMITS.minPitch : _ref$minPitch, transitionDuration = _ref.transitionDuration, transitionEasing3 = _ref.transitionEasing, transitionInterpolator = _ref.transitionInterpolator, transitionInterruption = _ref.transitionInterruption, startPanLngLat = _ref.startPanLngLat, startZoomLngLat = _ref.startZoomLngLat, startRotatePos = _ref.startRotatePos, startBearing = _ref.startBearing, startPitch = _ref.startPitch, startZoom = _ref.startZoom;
      _classCallCheck(this, MapState3);
      assert11(Number.isFinite(width8), "`width` must be supplied");
      assert11(Number.isFinite(height8), "`height` must be supplied");
      assert11(Number.isFinite(longitude), "`longitude` must be supplied");
      assert11(Number.isFinite(latitude), "`latitude` must be supplied");
      assert11(Number.isFinite(zoom), "`zoom` must be supplied");
      this._viewportProps = this._applyConstraints({
        width: width8,
        height: height8,
        latitude,
        longitude,
        zoom,
        bearing,
        pitch,
        altitude,
        maxZoom,
        minZoom,
        maxPitch,
        minPitch,
        transitionDuration,
        transitionEasing: transitionEasing3,
        transitionInterpolator,
        transitionInterruption
      });
      this._state = {
        startPanLngLat,
        startZoomLngLat,
        startRotatePos,
        startBearing,
        startPitch,
        startZoom
      };
    }
    _createClass(MapState3, [{
      key: "getViewportProps",
      value: function getViewportProps() {
        return this._viewportProps;
      }
    }, {
      key: "getState",
      value: function getState2() {
        return this._state;
      }
    }, {
      key: "panStart",
      value: function panStart(_ref2) {
        var pos = _ref2.pos;
        return this._getUpdatedMapState({
          startPanLngLat: this._unproject(pos)
        });
      }
    }, {
      key: "pan",
      value: function pan(_ref3) {
        var pos = _ref3.pos, startPos = _ref3.startPos;
        var startPanLngLat = this._state.startPanLngLat || this._unproject(startPos);
        if (!startPanLngLat) {
          return this;
        }
        var _this$_calculateNewLn = this._calculateNewLngLat({
          startPanLngLat,
          pos
        }), _this$_calculateNewLn2 = _slicedToArray(_this$_calculateNewLn, 2), longitude = _this$_calculateNewLn2[0], latitude = _this$_calculateNewLn2[1];
        return this._getUpdatedMapState({
          longitude,
          latitude
        });
      }
    }, {
      key: "panEnd",
      value: function panEnd() {
        return this._getUpdatedMapState({
          startPanLngLat: null
        });
      }
    }, {
      key: "rotateStart",
      value: function rotateStart(_ref4) {
        var pos = _ref4.pos;
        return this._getUpdatedMapState({
          startRotatePos: pos,
          startBearing: this._viewportProps.bearing,
          startPitch: this._viewportProps.pitch
        });
      }
    }, {
      key: "rotate",
      value: function rotate2(_ref5) {
        var pos = _ref5.pos, _ref5$deltaAngleX = _ref5.deltaAngleX, deltaAngleX = _ref5$deltaAngleX === void 0 ? 0 : _ref5$deltaAngleX, _ref5$deltaAngleY = _ref5.deltaAngleY, deltaAngleY = _ref5$deltaAngleY === void 0 ? 0 : _ref5$deltaAngleY;
        var _this$_state = this._state, startRotatePos = _this$_state.startRotatePos, startBearing = _this$_state.startBearing, startPitch = _this$_state.startPitch;
        if (!Number.isFinite(startBearing) || !Number.isFinite(startPitch)) {
          return this;
        }
        var newRotation;
        if (pos) {
          newRotation = this._calculateNewPitchAndBearing(_objectSpread2(_objectSpread2({}, this._getRotationParams(pos, startRotatePos)), {}, {
            startBearing,
            startPitch
          }));
        } else {
          newRotation = {
            bearing: startBearing + deltaAngleX,
            pitch: startPitch + deltaAngleY
          };
        }
        return this._getUpdatedMapState(newRotation);
      }
    }, {
      key: "rotateEnd",
      value: function rotateEnd() {
        return this._getUpdatedMapState({
          startBearing: null,
          startPitch: null
        });
      }
    }, {
      key: "zoomStart",
      value: function zoomStart(_ref6) {
        var pos = _ref6.pos;
        return this._getUpdatedMapState({
          startZoomLngLat: this._unproject(pos),
          startZoom: this._viewportProps.zoom
        });
      }
    }, {
      key: "zoom",
      value: function zoom(_ref7) {
        var pos = _ref7.pos, startPos = _ref7.startPos, scale4 = _ref7.scale;
        assert11(scale4 > 0, "`scale` must be a positive number");
        var _this$_state2 = this._state, startZoom = _this$_state2.startZoom, startZoomLngLat = _this$_state2.startZoomLngLat;
        if (!Number.isFinite(startZoom)) {
          startZoom = this._viewportProps.zoom;
          startZoomLngLat = this._unproject(startPos) || this._unproject(pos);
        }
        assert11(startZoomLngLat, "`startZoomLngLat` prop is required for zoom behavior to calculate where to position the map.");
        var zoom2 = this._calculateNewZoom({
          scale: scale4,
          startZoom: startZoom || 0
        });
        var zoomedViewport = new WebMercatorViewport(Object.assign({}, this._viewportProps, {
          zoom: zoom2
        }));
        var _zoomedViewport$getMa = zoomedViewport.getMapCenterByLngLatPosition({
          lngLat: startZoomLngLat,
          pos
        }), _zoomedViewport$getMa2 = _slicedToArray(_zoomedViewport$getMa, 2), longitude = _zoomedViewport$getMa2[0], latitude = _zoomedViewport$getMa2[1];
        return this._getUpdatedMapState({
          zoom: zoom2,
          longitude,
          latitude
        });
      }
    }, {
      key: "zoomEnd",
      value: function zoomEnd() {
        return this._getUpdatedMapState({
          startZoomLngLat: null,
          startZoom: null
        });
      }
    }, {
      key: "_getUpdatedMapState",
      value: function _getUpdatedMapState(newProps) {
        return new MapState3(Object.assign({}, this._viewportProps, this._state, newProps));
      }
    }, {
      key: "_applyConstraints",
      value: function _applyConstraints(props) {
        var maxZoom = props.maxZoom, minZoom = props.minZoom, zoom = props.zoom;
        props.zoom = clamp3(zoom, minZoom, maxZoom);
        var maxPitch = props.maxPitch, minPitch = props.minPitch, pitch = props.pitch;
        props.pitch = clamp3(pitch, minPitch, maxPitch);
        Object.assign(props, normalizeViewportProps(props));
        return props;
      }
    }, {
      key: "_unproject",
      value: function _unproject(pos) {
        var viewport = new WebMercatorViewport(this._viewportProps);
        return pos && viewport.unproject(pos);
      }
    }, {
      key: "_calculateNewLngLat",
      value: function _calculateNewLngLat(_ref8) {
        var startPanLngLat = _ref8.startPanLngLat, pos = _ref8.pos;
        var viewport = new WebMercatorViewport(this._viewportProps);
        return viewport.getMapCenterByLngLatPosition({
          lngLat: startPanLngLat,
          pos
        });
      }
    }, {
      key: "_calculateNewZoom",
      value: function _calculateNewZoom(_ref9) {
        var scale4 = _ref9.scale, startZoom = _ref9.startZoom;
        var _this$_viewportProps = this._viewportProps, maxZoom = _this$_viewportProps.maxZoom, minZoom = _this$_viewportProps.minZoom;
        var zoom = startZoom + Math.log2(scale4);
        return clamp3(zoom, minZoom, maxZoom);
      }
    }, {
      key: "_calculateNewPitchAndBearing",
      value: function _calculateNewPitchAndBearing(_ref10) {
        var deltaScaleX = _ref10.deltaScaleX, deltaScaleY = _ref10.deltaScaleY, startBearing = _ref10.startBearing, startPitch = _ref10.startPitch;
        deltaScaleY = clamp3(deltaScaleY, -1, 1);
        var _this$_viewportProps2 = this._viewportProps, minPitch = _this$_viewportProps2.minPitch, maxPitch = _this$_viewportProps2.maxPitch;
        var bearing = startBearing + 180 * deltaScaleX;
        var pitch = startPitch;
        if (deltaScaleY > 0) {
          pitch = startPitch + deltaScaleY * (maxPitch - startPitch);
        } else if (deltaScaleY < 0) {
          pitch = startPitch - deltaScaleY * (minPitch - startPitch);
        }
        return {
          pitch,
          bearing
        };
      }
    }, {
      key: "_getRotationParams",
      value: function _getRotationParams(pos, startPos) {
        var deltaX = pos[0] - startPos[0];
        var deltaY = pos[1] - startPos[1];
        var centerY = pos[1];
        var startY = startPos[1];
        var _this$_viewportProps3 = this._viewportProps, width8 = _this$_viewportProps3.width, height8 = _this$_viewportProps3.height;
        var deltaScaleX = deltaX / width8;
        var deltaScaleY = 0;
        if (deltaY > 0) {
          if (Math.abs(height8 - startY) > PITCH_MOUSE_THRESHOLD2) {
            deltaScaleY = deltaY / (startY - height8) * PITCH_ACCEL2;
          }
        } else if (deltaY < 0) {
          if (startY > PITCH_MOUSE_THRESHOLD2) {
            deltaScaleY = 1 - centerY / startY;
          }
        }
        deltaScaleY = Math.min(1, Math.max(-1, deltaScaleY));
        return {
          deltaScaleX,
          deltaScaleY
        };
      }
    }]);
    return MapState3;
  }();

  // node_modules/react-map-gl/dist/esm/utils/map-constraints.js
  function decapitalize(s) {
    return s[0].toLowerCase() + s.slice(1);
  }
  function checkVisibilityConstraints(props) {
    var constraints = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : MAPBOX_LIMITS;
    for (var constraintName in constraints) {
      var type = constraintName.slice(0, 3);
      var propName = decapitalize(constraintName.slice(3));
      if (type === "min" && props[propName] < constraints[constraintName]) {
        return false;
      }
      if (type === "max" && props[propName] > constraints[constraintName]) {
        return false;
      }
    }
    return true;
  }

  // node_modules/react-map-gl/dist/esm/components/map-context.js
  var React3 = __toESM(require_react());
  var import_react8 = __toESM(require_react());
  function ownKeys3(object12, enumerableOnly) {
    var keys3 = Object.keys(object12);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object12);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object12, sym).enumerable;
        });
      keys3.push.apply(keys3, symbols);
    }
    return keys3;
  }
  function _objectSpread3(target5) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys3(Object(source), true).forEach(function(key) {
          _defineProperty(target5, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target5, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys3(Object(source)).forEach(function(key) {
          Object.defineProperty(target5, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target5;
  }
  var MapContext = (0, import_react8.createContext)({
    viewport: null,
    map: null,
    container: null,
    onViewportChange: null,
    onViewStateChange: null,
    eventManager: null
  });
  var MapContextProvider = MapContext.Provider;
  function WrappedProvider(_ref) {
    var value13 = _ref.value, children = _ref.children;
    var _useState = (0, import_react8.useState)(null), _useState2 = _slicedToArray(_useState, 2), map16 = _useState2[0], setMap = _useState2[1];
    var context = (0, import_react8.useContext)(MapContext);
    value13 = _objectSpread3(_objectSpread3({
      setMap
    }, context), {}, {
      map: context && context.map || map16
    }, value13);
    return React3.createElement(MapContextProvider, {
      value: value13
    }, children);
  }
  MapContext.Provider = WrappedProvider;
  var map_context_default = MapContext;

  // node_modules/react-map-gl/dist/esm/utils/use-isomorphic-layout-effect.js
  var import_react9 = __toESM(require_react());
  var useIsomorphicLayoutEffect2 = typeof window !== "undefined" ? import_react9.useLayoutEffect : import_react9.useEffect;
  var use_isomorphic_layout_effect_default2 = useIsomorphicLayoutEffect2;

  // node_modules/react-map-gl/dist/esm/components/static-map.js
  function ownKeys4(object12, enumerableOnly) {
    var keys3 = Object.keys(object12);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object12);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object12, sym).enumerable;
        });
      keys3.push.apply(keys3, symbols);
    }
    return keys3;
  }
  function _objectSpread4(target5) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys4(Object(source), true).forEach(function(key) {
          _defineProperty(target5, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target5, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys4(Object(source)).forEach(function(key) {
          Object.defineProperty(target5, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target5;
  }
  var TOKEN_DOC_URL = "https://visgl.github.io/react-map-gl/docs/get-started/mapbox-tokens";
  var NO_TOKEN_WARNING = "A valid API access token is required to use Mapbox data";
  function noop6() {
  }
  function getViewport(_ref) {
    var props = _ref.props, width8 = _ref.width, height8 = _ref.height;
    return new WebMercatorViewport(_objectSpread4(_objectSpread4(_objectSpread4({}, props), props.viewState), {}, {
      width: width8,
      height: height8
    }));
  }
  var UNAUTHORIZED_ERROR_CODE = 401;
  var CONTAINER_STYLE = {
    position: "absolute",
    width: "100%",
    height: "100%",
    overflow: "hidden"
  };
  var propTypes2 = Object.assign({}, Mapbox.propTypes, {
    width: PropTypes2.oneOfType([PropTypes2.number, PropTypes2.string]),
    height: PropTypes2.oneOfType([PropTypes2.number, PropTypes2.string]),
    onResize: PropTypes2.func,
    disableTokenWarning: PropTypes2.bool,
    visible: PropTypes2.bool,
    className: PropTypes2.string,
    style: PropTypes2.object,
    visibilityConstraints: PropTypes2.object
  });
  var defaultProps6 = Object.assign({}, Mapbox.defaultProps, {
    disableTokenWarning: false,
    visible: true,
    onResize: noop6,
    className: "",
    style: null,
    visibilityConstraints: MAPBOX_LIMITS
  });
  function NoTokenWarning() {
    var style = {
      position: "absolute",
      left: 0,
      top: 0
    };
    return React4.createElement("div", {
      key: "warning",
      id: "no-token-warning",
      style
    }, React4.createElement("h3", {
      key: "header"
    }, NO_TOKEN_WARNING), React4.createElement("div", {
      key: "text"
    }, "For information on setting up your basemap, read"), React4.createElement("a", {
      key: "link",
      href: TOKEN_DOC_URL
    }, "Note on Map Tokens"));
  }
  function getRefHandles2(mapboxRef) {
    return {
      getMap: function getMap() {
        return mapboxRef.current && mapboxRef.current.getMap();
      },
      queryRenderedFeatures: function queryRenderedFeatures(geometry) {
        var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var map16 = mapboxRef.current && mapboxRef.current.getMap();
        return map16 && map16.queryRenderedFeatures(geometry, options2);
      }
    };
  }
  var StaticMap = (0, import_react10.forwardRef)(function(props, ref) {
    var _useState = (0, import_react10.useState)(true), _useState2 = _slicedToArray(_useState, 2), accessTokenValid = _useState2[0], setTokenState = _useState2[1];
    var _useState3 = (0, import_react10.useState)({
      width: 0,
      height: 0
    }), _useState4 = _slicedToArray(_useState3, 2), size5 = _useState4[0], setSize3 = _useState4[1];
    var mapboxRef = (0, import_react10.useRef)(null);
    var mapDivRef = (0, import_react10.useRef)(null);
    var containerRef = (0, import_react10.useRef)(null);
    var overlayRef = (0, import_react10.useRef)(null);
    var context = (0, import_react10.useContext)(map_context_default);
    use_isomorphic_layout_effect_default2(function() {
      if (!StaticMap.supported()) {
        return void 0;
      }
      var mapbox = new Mapbox(_objectSpread4(_objectSpread4(_objectSpread4({}, props), size5), {}, {
        mapboxgl: import_mapbox_gl.default,
        container: mapDivRef.current,
        onError: function onError(evt) {
          var statusCode = evt.error && evt.error.status || evt.status;
          if (statusCode === UNAUTHORIZED_ERROR_CODE && accessTokenValid) {
            console.error(NO_TOKEN_WARNING);
            setTokenState(false);
          }
          props.onError(evt);
        }
      }));
      mapboxRef.current = mapbox;
      if (context && context.setMap) {
        context.setMap(mapbox.getMap());
      }
      var resizeObserver = new ResizeObserver_es_default(function(entries) {
        if (entries[0].contentRect) {
          var _entries$0$contentRec = entries[0].contentRect, _width = _entries$0$contentRec.width, _height = _entries$0$contentRec.height;
          setSize3({
            width: _width,
            height: _height
          });
          props.onResize({
            width: _width,
            height: _height
          });
        }
      });
      resizeObserver.observe(containerRef.current);
      return function() {
        mapbox.finalize();
        mapboxRef.current = null;
        resizeObserver.disconnect();
      };
    }, []);
    use_isomorphic_layout_effect_default2(function() {
      if (mapboxRef.current) {
        mapboxRef.current.setProps(_objectSpread4(_objectSpread4({}, props), size5));
      }
    });
    var map16 = mapboxRef.current && mapboxRef.current.getMap();
    (0, import_react10.useImperativeHandle)(ref, function() {
      return getRefHandles2(mapboxRef);
    }, []);
    var preventScroll = (0, import_react10.useCallback)(function(_ref2) {
      var target5 = _ref2.target;
      if (target5 === overlayRef.current) {
        target5.scrollTo(0, 0);
      }
    }, []);
    var overlays = map16 && React4.createElement(MapContextProvider, {
      value: _objectSpread4(_objectSpread4({}, context), {}, {
        viewport: context.viewport || getViewport(_objectSpread4({
          map: map16,
          props
        }, size5)),
        map: map16,
        container: context.container || containerRef.current
      })
    }, React4.createElement("div", {
      key: "map-overlays",
      className: "overlays",
      ref: overlayRef,
      style: CONTAINER_STYLE,
      onScroll: preventScroll
    }, props.children));
    var className = props.className, width8 = props.width, height8 = props.height, style = props.style, visibilityConstraints = props.visibilityConstraints;
    var mapContainerStyle = Object.assign({
      position: "relative"
    }, style, {
      width: width8,
      height: height8
    });
    var visible = props.visible && checkVisibilityConstraints(props.viewState || props, visibilityConstraints);
    var mapStyle2 = Object.assign({}, CONTAINER_STYLE, {
      visibility: visible ? "inherit" : "hidden"
    });
    return React4.createElement("div", {
      key: "map-container",
      ref: containerRef,
      style: mapContainerStyle
    }, React4.createElement("div", {
      key: "map-mapbox",
      ref: mapDivRef,
      style: mapStyle2,
      className
    }), overlays, !accessTokenValid && !props.disableTokenWarning && React4.createElement(NoTokenWarning, null));
  });
  StaticMap.supported = function() {
    return import_mapbox_gl.default && import_mapbox_gl.default.supported();
  };
  StaticMap.propTypes = propTypes2;
  StaticMap.defaultProps = defaultProps6;
  var static_map_default = StaticMap;

  // node_modules/react-map-gl/dist/esm/utils/transition/transition-interpolator.js
  function _createForOfIteratorHelper2(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray3(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step2 = it.next();
      normalCompletion = step2.done;
      return step2;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray3(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray3(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray3(o, minLen);
  }
  function _arrayLikeToArray3(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  var TransitionInterpolator2 = function() {
    function TransitionInterpolator3() {
      _classCallCheck(this, TransitionInterpolator3);
      _defineProperty(this, "propNames", []);
    }
    _createClass(TransitionInterpolator3, [{
      key: "arePropsEqual",
      value: function arePropsEqual(currentProps, nextProps) {
        var _iterator = _createForOfIteratorHelper2(this.propNames || []), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var key = _step.value;
            if (!equals3(currentProps[key], nextProps[key])) {
              return false;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return true;
      }
    }, {
      key: "initializeProps",
      value: function initializeProps(startProps, endProps) {
        return {
          start: startProps,
          end: endProps
        };
      }
    }, {
      key: "interpolateProps",
      value: function interpolateProps(startProps, endProps, t) {
        assert11(false, "interpolateProps is not implemented");
      }
    }, {
      key: "getDuration",
      value: function getDuration(startProps, endProps) {
        return endProps.transitionDuration;
      }
    }]);
    return TransitionInterpolator3;
  }();

  // node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }

  // node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }

  // node_modules/@babel/runtime/helpers/esm/inherits.js
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass)
      _setPrototypeOf(subClass, superClass);
  }

  // node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
  function _possibleConstructorReturn(self2, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self2);
  }

  // node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf(o);
  }

  // node_modules/react-map-gl/dist/esm/utils/transition/transition-utils.js
  var WRAPPED_ANGULAR_PROPS = {
    longitude: 1,
    bearing: 1
  };
  function isValid2(prop) {
    return Number.isFinite(prop) || Array.isArray(prop);
  }
  function isWrappedAngularProp(propName) {
    return propName in WRAPPED_ANGULAR_PROPS;
  }
  function getEndValueByShortestPath(propName, startValue, endValue) {
    if (isWrappedAngularProp(propName) && Math.abs(endValue - startValue) > 180) {
      endValue = endValue < 0 ? endValue + 360 : endValue - 360;
    }
    return endValue;
  }

  // node_modules/react-map-gl/dist/esm/utils/transition/viewport-fly-to-interpolator.js
  function _createForOfIteratorHelper3(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray4(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step2 = it.next();
      normalCompletion = step2.done;
      return step2;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray4(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray4(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray4(o, minLen);
  }
  function _arrayLikeToArray4(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var VIEWPORT_TRANSITION_PROPS2 = ["longitude", "latitude", "zoom", "bearing", "pitch"];
  var REQUIRED_PROPS = ["latitude", "longitude", "zoom", "width", "height"];
  var LINEARLY_INTERPOLATED_PROPS = ["bearing", "pitch"];
  var DEFAULT_OPTS2 = {
    speed: 1.2,
    curve: 1.414
  };
  var ViewportFlyToInterpolator = function(_TransitionInterpolat) {
    _inherits(ViewportFlyToInterpolator2, _TransitionInterpolat);
    var _super = _createSuper(ViewportFlyToInterpolator2);
    function ViewportFlyToInterpolator2() {
      var _this;
      var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, ViewportFlyToInterpolator2);
      _this = _super.call(this);
      _defineProperty(_assertThisInitialized(_this), "propNames", VIEWPORT_TRANSITION_PROPS2);
      _this.props = Object.assign({}, DEFAULT_OPTS2, props);
      return _this;
    }
    _createClass(ViewportFlyToInterpolator2, [{
      key: "initializeProps",
      value: function initializeProps(startProps, endProps) {
        var startViewportProps = {};
        var endViewportProps = {};
        var _iterator = _createForOfIteratorHelper3(REQUIRED_PROPS), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var key = _step.value;
            var startValue = startProps[key];
            var endValue = endProps[key];
            assert11(isValid2(startValue) && isValid2(endValue), "".concat(key, " must be supplied for transition"));
            startViewportProps[key] = startValue;
            endViewportProps[key] = getEndValueByShortestPath(key, startValue, endValue);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        var _iterator2 = _createForOfIteratorHelper3(LINEARLY_INTERPOLATED_PROPS), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var _key = _step2.value;
            var _startValue = startProps[_key] || 0;
            var _endValue = endProps[_key] || 0;
            startViewportProps[_key] = _startValue;
            endViewportProps[_key] = getEndValueByShortestPath(_key, _startValue, _endValue);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        return {
          start: startViewportProps,
          end: endViewportProps
        };
      }
    }, {
      key: "interpolateProps",
      value: function interpolateProps(startProps, endProps, t) {
        var viewport = flyToViewport(startProps, endProps, t, this.props);
        var _iterator3 = _createForOfIteratorHelper3(LINEARLY_INTERPOLATED_PROPS), _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
            var key = _step3.value;
            viewport[key] = lerp4(startProps[key], endProps[key], t);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        return viewport;
      }
    }, {
      key: "getDuration",
      value: function getDuration(startProps, endProps) {
        var transitionDuration = endProps.transitionDuration;
        if (transitionDuration === "auto") {
          transitionDuration = getFlyToDuration(startProps, endProps, this.props);
        }
        return transitionDuration;
      }
    }]);
    return ViewportFlyToInterpolator2;
  }(TransitionInterpolator2);

  // node_modules/react-map-gl/dist/esm/utils/transition/linear-interpolator.js
  function _createForOfIteratorHelper4(o, allowArrayLike) {
    var it;
    if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray5(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it)
          o = it;
        var i = 0;
        var F = function F2() {
        };
        return { s: F, n: function n() {
          if (i >= o.length)
            return { done: true };
          return { done: false, value: o[i++] };
        }, e: function e(_e) {
          throw _e;
        }, f: F };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true, didErr = false, err;
    return { s: function s() {
      it = o[Symbol.iterator]();
    }, n: function n() {
      var step2 = it.next();
      normalCompletion = step2.done;
      return step2;
    }, e: function e(_e2) {
      didErr = true;
      err = _e2;
    }, f: function f() {
      try {
        if (!normalCompletion && it["return"] != null)
          it["return"]();
      } finally {
        if (didErr)
          throw err;
      }
    } };
  }
  function _unsupportedIterableToArray5(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray5(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor)
      n = o.constructor.name;
    if (n === "Map" || n === "Set")
      return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
      return _arrayLikeToArray5(o, minLen);
  }
  function _arrayLikeToArray5(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }
  function _createSuper2(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct2();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct2() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  var VIEWPORT_TRANSITION_PROPS3 = ["longitude", "latitude", "zoom", "bearing", "pitch"];
  var LinearInterpolator2 = function(_TransitionInterpolat) {
    _inherits(LinearInterpolator3, _TransitionInterpolat);
    var _super = _createSuper2(LinearInterpolator3);
    function LinearInterpolator3() {
      var _this;
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, LinearInterpolator3);
      _this = _super.call(this);
      if (Array.isArray(opts)) {
        opts = {
          transitionProps: opts
        };
      }
      _this.propNames = opts.transitionProps || VIEWPORT_TRANSITION_PROPS3;
      if (opts.around) {
        _this.around = opts.around;
      }
      return _this;
    }
    _createClass(LinearInterpolator3, [{
      key: "initializeProps",
      value: function initializeProps(startProps, endProps) {
        var startViewportProps = {};
        var endViewportProps = {};
        if (this.around) {
          startViewportProps.around = this.around;
          var aroundLngLat = new WebMercatorViewport(startProps).unproject(this.around);
          Object.assign(endViewportProps, endProps, {
            around: new WebMercatorViewport(endProps).project(aroundLngLat),
            aroundLngLat
          });
        }
        var _iterator = _createForOfIteratorHelper4(this.propNames), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var key = _step.value;
            var startValue = startProps[key];
            var endValue = endProps[key];
            assert11(isValid2(startValue) && isValid2(endValue), "".concat(key, " must be supplied for transition"));
            startViewportProps[key] = startValue;
            endViewportProps[key] = getEndValueByShortestPath(key, startValue, endValue);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return {
          start: startViewportProps,
          end: endViewportProps
        };
      }
    }, {
      key: "interpolateProps",
      value: function interpolateProps(startProps, endProps, t) {
        var viewport = {};
        var _iterator2 = _createForOfIteratorHelper4(this.propNames), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var key = _step2.value;
            viewport[key] = lerp4(startProps[key], endProps[key], t);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        if (endProps.around) {
          var _WebMercatorViewport$ = new WebMercatorViewport(Object.assign({}, endProps, viewport)).getMapCenterByLngLatPosition({
            lngLat: endProps.aroundLngLat,
            pos: lerp4(startProps.around, endProps.around, t)
          }), _WebMercatorViewport$2 = _slicedToArray(_WebMercatorViewport$, 2), longitude = _WebMercatorViewport$2[0], latitude = _WebMercatorViewport$2[1];
          viewport.longitude = longitude;
          viewport.latitude = latitude;
        }
        return viewport;
      }
    }]);
    return LinearInterpolator3;
  }(TransitionInterpolator2);

  // node_modules/react-map-gl/dist/esm/utils/transition-manager.js
  var noop7 = function noop8() {
  };
  function cropEasingFunction(easing, x0) {
    var y0 = easing(x0);
    return function(t) {
      return 1 / (1 - y0) * (easing(t * (1 - x0) + x0) - y0);
    };
  }
  var TRANSITION_EVENTS2 = {
    BREAK: 1,
    SNAP_TO_END: 2,
    IGNORE: 3,
    UPDATE: 4
  };
  var DEFAULT_PROPS3 = {
    transitionDuration: 0,
    transitionEasing: function transitionEasing(t) {
      return t;
    },
    transitionInterpolator: new LinearInterpolator2(),
    transitionInterruption: TRANSITION_EVENTS2.BREAK,
    onTransitionStart: noop7,
    onTransitionInterrupt: noop7,
    onTransitionEnd: noop7
  };
  var TransitionManager2 = function() {
    function TransitionManager3() {
      var _this = this;
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, TransitionManager3);
      _defineProperty(this, "_animationFrame", null);
      _defineProperty(this, "_onTransitionFrame", function() {
        _this._animationFrame = requestAnimationFrame(_this._onTransitionFrame);
        _this._updateViewport();
      });
      this.props = null;
      this.onViewportChange = opts.onViewportChange || noop7;
      this.onStateChange = opts.onStateChange || noop7;
      this.time = opts.getTime || Date.now;
    }
    _createClass(TransitionManager3, [{
      key: "getViewportInTransition",
      value: function getViewportInTransition() {
        return this._animationFrame ? this.state.propsInTransition : null;
      }
    }, {
      key: "processViewportChange",
      value: function processViewportChange(nextProps) {
        var currentProps = this.props;
        this.props = nextProps;
        if (!currentProps || this._shouldIgnoreViewportChange(currentProps, nextProps)) {
          return false;
        }
        if (this._isTransitionEnabled(nextProps)) {
          var startProps = Object.assign({}, currentProps);
          var endProps = Object.assign({}, nextProps);
          if (this._isTransitionInProgress()) {
            currentProps.onTransitionInterrupt();
            if (this.state.interruption === TRANSITION_EVENTS2.SNAP_TO_END) {
              Object.assign(startProps, this.state.endProps);
            } else {
              Object.assign(startProps, this.state.propsInTransition);
            }
            if (this.state.interruption === TRANSITION_EVENTS2.UPDATE) {
              var currentTime2 = this.time();
              var x0 = (currentTime2 - this.state.startTime) / this.state.duration;
              endProps.transitionDuration = this.state.duration - (currentTime2 - this.state.startTime);
              endProps.transitionEasing = cropEasingFunction(this.state.easing, x0);
              endProps.transitionInterpolator = startProps.transitionInterpolator;
            }
          }
          endProps.onTransitionStart();
          this._triggerTransition(startProps, endProps);
          return true;
        }
        if (this._isTransitionInProgress()) {
          currentProps.onTransitionInterrupt();
          this._endTransition();
        }
        return false;
      }
    }, {
      key: "_isTransitionInProgress",
      value: function _isTransitionInProgress() {
        return Boolean(this._animationFrame);
      }
    }, {
      key: "_isTransitionEnabled",
      value: function _isTransitionEnabled(props) {
        var transitionDuration = props.transitionDuration, transitionInterpolator = props.transitionInterpolator;
        return (transitionDuration > 0 || transitionDuration === "auto") && Boolean(transitionInterpolator);
      }
    }, {
      key: "_isUpdateDueToCurrentTransition",
      value: function _isUpdateDueToCurrentTransition(props) {
        if (this.state.propsInTransition) {
          return this.state.interpolator.arePropsEqual(props, this.state.propsInTransition);
        }
        return false;
      }
    }, {
      key: "_shouldIgnoreViewportChange",
      value: function _shouldIgnoreViewportChange(currentProps, nextProps) {
        if (!currentProps) {
          return true;
        }
        if (this._isTransitionInProgress()) {
          return this.state.interruption === TRANSITION_EVENTS2.IGNORE || this._isUpdateDueToCurrentTransition(nextProps);
        }
        if (this._isTransitionEnabled(nextProps)) {
          return nextProps.transitionInterpolator.arePropsEqual(currentProps, nextProps);
        }
        return true;
      }
    }, {
      key: "_triggerTransition",
      value: function _triggerTransition(startProps, endProps) {
        assert11(this._isTransitionEnabled(endProps));
        if (this._animationFrame) {
          cancelAnimationFrame(this._animationFrame);
        }
        var transitionInterpolator = endProps.transitionInterpolator;
        var duration2 = transitionInterpolator.getDuration ? transitionInterpolator.getDuration(startProps, endProps) : endProps.transitionDuration;
        if (duration2 === 0) {
          return;
        }
        var initialProps = endProps.transitionInterpolator.initializeProps(startProps, endProps);
        var interactionState = {
          inTransition: true,
          isZooming: startProps.zoom !== endProps.zoom,
          isPanning: startProps.longitude !== endProps.longitude || startProps.latitude !== endProps.latitude,
          isRotating: startProps.bearing !== endProps.bearing || startProps.pitch !== endProps.pitch
        };
        this.state = {
          duration: duration2,
          easing: endProps.transitionEasing,
          interpolator: endProps.transitionInterpolator,
          interruption: endProps.transitionInterruption,
          startTime: this.time(),
          startProps: initialProps.start,
          endProps: initialProps.end,
          animation: null,
          propsInTransition: {}
        };
        this._onTransitionFrame();
        this.onStateChange(interactionState);
      }
    }, {
      key: "_endTransition",
      value: function _endTransition() {
        if (this._animationFrame) {
          cancelAnimationFrame(this._animationFrame);
          this._animationFrame = null;
        }
        this.onStateChange({
          inTransition: false,
          isZooming: false,
          isPanning: false,
          isRotating: false
        });
      }
    }, {
      key: "_updateViewport",
      value: function _updateViewport() {
        var currentTime2 = this.time();
        var _this$state = this.state, startTime = _this$state.startTime, duration2 = _this$state.duration, easing = _this$state.easing, interpolator = _this$state.interpolator, startProps = _this$state.startProps, endProps = _this$state.endProps;
        var shouldEnd = false;
        var t = (currentTime2 - startTime) / duration2;
        if (t >= 1) {
          t = 1;
          shouldEnd = true;
        }
        t = easing(t);
        var viewport = interpolator.interpolateProps(startProps, endProps, t);
        var mapState = new MapState2(Object.assign({}, this.props, viewport));
        this.state.propsInTransition = mapState.getViewportProps();
        this.onViewportChange(this.state.propsInTransition, this.props);
        if (shouldEnd) {
          this._endTransition();
          this.props.onTransitionEnd();
        }
      }
    }]);
    return TransitionManager3;
  }();
  _defineProperty(TransitionManager2, "defaultProps", DEFAULT_PROPS3);

  // node_modules/react-map-gl/dist/esm/utils/map-controller.js
  function ownKeys5(object12, enumerableOnly) {
    var keys3 = Object.keys(object12);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object12);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object12, sym).enumerable;
        });
      keys3.push.apply(keys3, symbols);
    }
    return keys3;
  }
  function _objectSpread5(target5) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys5(Object(source), true).forEach(function(key) {
          _defineProperty(target5, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target5, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys5(Object(source)).forEach(function(key) {
          Object.defineProperty(target5, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target5;
  }
  var NO_TRANSITION_PROPS2 = {
    transitionDuration: 0
  };
  var LINEAR_TRANSITION_PROPS = {
    transitionDuration: 300,
    transitionEasing: function transitionEasing2(t) {
      return t;
    },
    transitionInterpolator: new LinearInterpolator2(),
    transitionInterruption: TRANSITION_EVENTS2.BREAK
  };
  var DEFAULT_INERTIA2 = 300;
  var INERTIA_EASING2 = function INERTIA_EASING3(t) {
    return 1 - (1 - t) * (1 - t);
  };
  var EVENT_TYPES2 = {
    WHEEL: ["wheel"],
    PAN: ["panstart", "panmove", "panend"],
    PINCH: ["pinchstart", "pinchmove", "pinchend"],
    TRIPLE_PAN: ["tripanstart", "tripanmove", "tripanend"],
    DOUBLE_TAP: ["doubletap"],
    KEYBOARD: ["keydown"]
  };
  var MapController2 = function() {
    function MapController3() {
      var _this = this;
      _classCallCheck(this, MapController3);
      _defineProperty(this, "events", []);
      _defineProperty(this, "scrollZoom", true);
      _defineProperty(this, "dragPan", true);
      _defineProperty(this, "dragRotate", true);
      _defineProperty(this, "doubleClickZoom", true);
      _defineProperty(this, "touchZoom", true);
      _defineProperty(this, "touchRotate", false);
      _defineProperty(this, "keyboard", true);
      _defineProperty(this, "_interactionState", {
        isDragging: false
      });
      _defineProperty(this, "_events", {});
      _defineProperty(this, "_setInteractionState", function(newState) {
        Object.assign(_this._interactionState, newState);
        if (_this.onStateChange) {
          _this.onStateChange(_this._interactionState);
        }
      });
      _defineProperty(this, "_onTransition", function(newViewport, oldViewport) {
        _this.onViewportChange(newViewport, _this._interactionState, oldViewport);
      });
      this.handleEvent = this.handleEvent.bind(this);
      this._transitionManager = new TransitionManager2({
        onViewportChange: this._onTransition,
        onStateChange: this._setInteractionState
      });
    }
    _createClass(MapController3, [{
      key: "handleEvent",
      value: function handleEvent(event) {
        this.mapState = this.getMapState();
        var eventStartBlocked = this._eventStartBlocked;
        switch (event.type) {
          case "panstart":
            return eventStartBlocked ? false : this._onPanStart(event);
          case "panmove":
            return this._onPan(event);
          case "panend":
            return this._onPanEnd(event);
          case "pinchstart":
            return eventStartBlocked ? false : this._onPinchStart(event);
          case "pinchmove":
            return this._onPinch(event);
          case "pinchend":
            return this._onPinchEnd(event);
          case "tripanstart":
            return eventStartBlocked ? false : this._onTriplePanStart(event);
          case "tripanmove":
            return this._onTriplePan(event);
          case "tripanend":
            return this._onTriplePanEnd(event);
          case "doubletap":
            return this._onDoubleTap(event);
          case "wheel":
            return this._onWheel(event);
          case "keydown":
            return this._onKeyDown(event);
          default:
            return false;
        }
      }
    }, {
      key: "getCenter",
      value: function getCenter(event) {
        var _event$offsetCenter = event.offsetCenter, x = _event$offsetCenter.x, y = _event$offsetCenter.y;
        return [x, y];
      }
    }, {
      key: "isFunctionKeyPressed",
      value: function isFunctionKeyPressed(event) {
        var srcEvent = event.srcEvent;
        return Boolean(srcEvent.metaKey || srcEvent.altKey || srcEvent.ctrlKey || srcEvent.shiftKey);
      }
    }, {
      key: "blockEvents",
      value: function blockEvents(timeout) {
        var _this2 = this;
        var timer = setTimeout(function() {
          if (_this2._eventStartBlocked === timer) {
            _this2._eventStartBlocked = null;
          }
        }, timeout);
        this._eventStartBlocked = timer;
      }
    }, {
      key: "updateViewport",
      value: function updateViewport2(newMapState, extraProps, interactionState) {
        var oldViewport = this.mapState instanceof MapState2 ? this.mapState.getViewportProps() : this.mapState;
        var newViewport = _objectSpread5(_objectSpread5({}, newMapState.getViewportProps()), extraProps);
        var viewStateChanged = Object.keys(newViewport).some(function(key) {
          return oldViewport[key] !== newViewport[key];
        });
        this._state = newMapState.getState();
        this._setInteractionState(interactionState);
        if (viewStateChanged) {
          this.onViewportChange(newViewport, this._interactionState, oldViewport);
        }
      }
    }, {
      key: "getMapState",
      value: function getMapState(overrides) {
        return new MapState2(_objectSpread5(_objectSpread5(_objectSpread5({}, this.mapStateProps), this._state), overrides));
      }
    }, {
      key: "isDragging",
      value: function isDragging() {
        return this._interactionState.isDragging;
      }
    }, {
      key: "setOptions",
      value: function setOptions(options2) {
        var onViewportChange = options2.onViewportChange, onStateChange = options2.onStateChange, _options$eventManager = options2.eventManager, eventManager = _options$eventManager === void 0 ? this.eventManager : _options$eventManager, _options$isInteractiv = options2.isInteractive, isInteractive = _options$isInteractiv === void 0 ? true : _options$isInteractiv, _options$scrollZoom = options2.scrollZoom, scrollZoom = _options$scrollZoom === void 0 ? this.scrollZoom : _options$scrollZoom, _options$dragPan = options2.dragPan, dragPan = _options$dragPan === void 0 ? this.dragPan : _options$dragPan, _options$dragRotate = options2.dragRotate, dragRotate = _options$dragRotate === void 0 ? this.dragRotate : _options$dragRotate, _options$doubleClickZ = options2.doubleClickZoom, doubleClickZoom = _options$doubleClickZ === void 0 ? this.doubleClickZoom : _options$doubleClickZ, _options$touchZoom = options2.touchZoom, touchZoom = _options$touchZoom === void 0 ? this.touchZoom : _options$touchZoom, _options$touchRotate = options2.touchRotate, touchRotate = _options$touchRotate === void 0 ? this.touchRotate : _options$touchRotate, _options$keyboard = options2.keyboard, keyboard = _options$keyboard === void 0 ? this.keyboard : _options$keyboard;
        this.onViewportChange = onViewportChange;
        this.onStateChange = onStateChange;
        var prevOptions = this.mapStateProps || {};
        var dimensionChanged = prevOptions.height !== options2.height || prevOptions.width !== options2.width;
        this.mapStateProps = options2;
        if (dimensionChanged) {
          this.mapState = prevOptions;
          this.updateViewport(new MapState2(options2));
        }
        this._transitionManager.processViewportChange(options2);
        if (this.eventManager !== eventManager) {
          this.eventManager = eventManager;
          this._events = {};
          this.toggleEvents(this.events, true);
        }
        this.toggleEvents(EVENT_TYPES2.WHEEL, isInteractive && Boolean(scrollZoom));
        this.toggleEvents(EVENT_TYPES2.PAN, isInteractive && Boolean(dragPan || dragRotate));
        this.toggleEvents(EVENT_TYPES2.PINCH, isInteractive && Boolean(touchZoom || touchRotate));
        this.toggleEvents(EVENT_TYPES2.TRIPLE_PAN, isInteractive && Boolean(touchRotate));
        this.toggleEvents(EVENT_TYPES2.DOUBLE_TAP, isInteractive && Boolean(doubleClickZoom));
        this.toggleEvents(EVENT_TYPES2.KEYBOARD, isInteractive && Boolean(keyboard));
        this.scrollZoom = scrollZoom;
        this.dragPan = dragPan;
        this.dragRotate = dragRotate;
        this.doubleClickZoom = doubleClickZoom;
        this.touchZoom = touchZoom;
        this.touchRotate = touchRotate;
        this.keyboard = keyboard;
      }
    }, {
      key: "toggleEvents",
      value: function toggleEvents(eventNames, enabled) {
        var _this3 = this;
        if (this.eventManager) {
          eventNames.forEach(function(eventName) {
            if (_this3._events[eventName] !== enabled) {
              _this3._events[eventName] = enabled;
              if (enabled) {
                _this3.eventManager.on(eventName, _this3.handleEvent);
              } else {
                _this3.eventManager.off(eventName, _this3.handleEvent);
              }
            }
          });
        }
      }
    }, {
      key: "_onPanStart",
      value: function _onPanStart(event) {
        var pos = this.getCenter(event);
        this._panRotate = this.isFunctionKeyPressed(event) || event.rightButton;
        var newMapState = this._panRotate ? this.mapState.rotateStart({
          pos
        }) : this.mapState.panStart({
          pos
        });
        this.updateViewport(newMapState, NO_TRANSITION_PROPS2, {
          isDragging: true
        });
        return true;
      }
    }, {
      key: "_onPan",
      value: function _onPan(event) {
        if (!this.isDragging()) {
          return false;
        }
        return this._panRotate ? this._onPanRotate(event) : this._onPanMove(event);
      }
    }, {
      key: "_onPanEnd",
      value: function _onPanEnd(event) {
        if (!this.isDragging()) {
          return false;
        }
        return this._panRotate ? this._onPanRotateEnd(event) : this._onPanMoveEnd(event);
      }
    }, {
      key: "_onPanMove",
      value: function _onPanMove(event) {
        if (!this.dragPan) {
          return false;
        }
        var pos = this.getCenter(event);
        var newMapState = this.mapState.pan({
          pos
        });
        this.updateViewport(newMapState, NO_TRANSITION_PROPS2, {
          isPanning: true
        });
        return true;
      }
    }, {
      key: "_onPanMoveEnd",
      value: function _onPanMoveEnd(event) {
        if (this.dragPan) {
          var _this$dragPan$inertia = this.dragPan.inertia, inertia = _this$dragPan$inertia === void 0 ? DEFAULT_INERTIA2 : _this$dragPan$inertia;
          if (inertia && event.velocity) {
            var pos = this.getCenter(event);
            var endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
            var newControllerState = this.mapState.pan({
              pos: endPos
            }).panEnd();
            this.updateViewport(newControllerState, _objectSpread5(_objectSpread5({}, LINEAR_TRANSITION_PROPS), {}, {
              transitionDuration: inertia,
              transitionEasing: INERTIA_EASING2
            }), {
              isDragging: false,
              isPanning: true
            });
            return true;
          }
        }
        var newMapState = this.mapState.panEnd();
        this.updateViewport(newMapState, null, {
          isDragging: false,
          isPanning: false
        });
        return true;
      }
    }, {
      key: "_onPanRotate",
      value: function _onPanRotate(event) {
        if (!this.dragRotate) {
          return false;
        }
        var pos = this.getCenter(event);
        var newMapState = this.mapState.rotate({
          pos
        });
        this.updateViewport(newMapState, NO_TRANSITION_PROPS2, {
          isRotating: true
        });
        return true;
      }
    }, {
      key: "_onPanRotateEnd",
      value: function _onPanRotateEnd(event) {
        if (this.dragRotate) {
          var _this$dragRotate$iner = this.dragRotate.inertia, inertia = _this$dragRotate$iner === void 0 ? DEFAULT_INERTIA2 : _this$dragRotate$iner;
          if (inertia && event.velocity) {
            var pos = this.getCenter(event);
            var endPos = [pos[0] + event.velocityX * inertia / 2, pos[1] + event.velocityY * inertia / 2];
            var newControllerState = this.mapState.rotate({
              pos: endPos
            }).rotateEnd();
            this.updateViewport(newControllerState, _objectSpread5(_objectSpread5({}, LINEAR_TRANSITION_PROPS), {}, {
              transitionDuration: inertia,
              transitionEasing: INERTIA_EASING2
            }), {
              isDragging: false,
              isRotating: true
            });
            return true;
          }
        }
        var newMapState = this.mapState.panEnd();
        this.updateViewport(newMapState, null, {
          isDragging: false,
          isRotating: false
        });
        return true;
      }
    }, {
      key: "_onWheel",
      value: function _onWheel(event) {
        if (!this.scrollZoom) {
          return false;
        }
        var _this$scrollZoom = this.scrollZoom, _this$scrollZoom$spee = _this$scrollZoom.speed, speed = _this$scrollZoom$spee === void 0 ? 0.01 : _this$scrollZoom$spee, _this$scrollZoom$smoo = _this$scrollZoom.smooth, smooth = _this$scrollZoom$smoo === void 0 ? false : _this$scrollZoom$smoo;
        event.preventDefault();
        var pos = this.getCenter(event);
        var delta = event.delta;
        var scale4 = 2 / (1 + Math.exp(-Math.abs(delta * speed)));
        if (delta < 0 && scale4 !== 0) {
          scale4 = 1 / scale4;
        }
        var newMapState = this.mapState.zoom({
          pos,
          scale: scale4
        });
        if (newMapState.getViewportProps().zoom === this.mapStateProps.zoom) {
          return false;
        }
        this.updateViewport(newMapState, _objectSpread5(_objectSpread5({}, LINEAR_TRANSITION_PROPS), {}, {
          transitionInterpolator: new LinearInterpolator2({
            around: pos
          }),
          transitionDuration: smooth ? 250 : 1
        }), {
          isPanning: true,
          isZooming: true
        });
        return true;
      }
    }, {
      key: "_onPinchStart",
      value: function _onPinchStart(event) {
        var pos = this.getCenter(event);
        var newMapState = this.mapState.zoomStart({
          pos
        }).rotateStart({
          pos
        });
        this._startPinchRotation = event.rotation;
        this._lastPinchEvent = event;
        this.updateViewport(newMapState, NO_TRANSITION_PROPS2, {
          isDragging: true
        });
        return true;
      }
    }, {
      key: "_onPinch",
      value: function _onPinch(event) {
        if (!this.isDragging()) {
          return false;
        }
        if (!this.touchZoom && !this.touchRotate) {
          return false;
        }
        var newMapState = this.mapState;
        if (this.touchZoom) {
          var scale4 = event.scale;
          var pos = this.getCenter(event);
          newMapState = newMapState.zoom({
            pos,
            scale: scale4
          });
        }
        if (this.touchRotate) {
          var rotation = event.rotation;
          newMapState = newMapState.rotate({
            deltaAngleX: this._startPinchRotation - rotation
          });
        }
        this.updateViewport(newMapState, NO_TRANSITION_PROPS2, {
          isDragging: true,
          isPanning: Boolean(this.touchZoom),
          isZooming: Boolean(this.touchZoom),
          isRotating: Boolean(this.touchRotate)
        });
        this._lastPinchEvent = event;
        return true;
      }
    }, {
      key: "_onPinchEnd",
      value: function _onPinchEnd(event) {
        if (!this.isDragging()) {
          return false;
        }
        if (this.touchZoom) {
          var _this$touchZoom$inert = this.touchZoom.inertia, inertia = _this$touchZoom$inert === void 0 ? DEFAULT_INERTIA2 : _this$touchZoom$inert;
          var _lastPinchEvent = this._lastPinchEvent;
          if (inertia && _lastPinchEvent && event.scale !== _lastPinchEvent.scale) {
            var pos = this.getCenter(event);
            var _newMapState = this.mapState.rotateEnd();
            var z = Math.log2(event.scale);
            var velocityZ = (z - Math.log2(_lastPinchEvent.scale)) / (event.deltaTime - _lastPinchEvent.deltaTime);
            var endScale = Math.pow(2, z + velocityZ * inertia / 2);
            _newMapState = _newMapState.zoom({
              pos,
              scale: endScale
            }).zoomEnd();
            this.updateViewport(_newMapState, _objectSpread5(_objectSpread5({}, LINEAR_TRANSITION_PROPS), {}, {
              transitionInterpolator: new LinearInterpolator2({
                around: pos
              }),
              transitionDuration: inertia,
              transitionEasing: INERTIA_EASING2
            }), {
              isDragging: false,
              isPanning: Boolean(this.touchZoom),
              isZooming: Boolean(this.touchZoom),
              isRotating: false
            });
            this.blockEvents(inertia);
            return true;
          }
        }
        var newMapState = this.mapState.zoomEnd().rotateEnd();
        this._state.startPinchRotation = 0;
        this.updateViewport(newMapState, null, {
          isDragging: false,
          isPanning: false,
          isZooming: false,
          isRotating: false
        });
        this._startPinchRotation = null;
        this._lastPinchEvent = null;
        return true;
      }
    }, {
      key: "_onTriplePanStart",
      value: function _onTriplePanStart(event) {
        var pos = this.getCenter(event);
        var newMapState = this.mapState.rotateStart({
          pos
        });
        this.updateViewport(newMapState, NO_TRANSITION_PROPS2, {
          isDragging: true
        });
        return true;
      }
    }, {
      key: "_onTriplePan",
      value: function _onTriplePan(event) {
        if (!this.isDragging()) {
          return false;
        }
        if (!this.touchRotate) {
          return false;
        }
        var pos = this.getCenter(event);
        pos[0] -= event.deltaX;
        var newMapState = this.mapState.rotate({
          pos
        });
        this.updateViewport(newMapState, NO_TRANSITION_PROPS2, {
          isRotating: true
        });
        return true;
      }
    }, {
      key: "_onTriplePanEnd",
      value: function _onTriplePanEnd(event) {
        if (!this.isDragging()) {
          return false;
        }
        if (this.touchRotate) {
          var _this$touchRotate$ine = this.touchRotate.inertia, inertia = _this$touchRotate$ine === void 0 ? DEFAULT_INERTIA2 : _this$touchRotate$ine;
          if (inertia && event.velocityY) {
            var pos = this.getCenter(event);
            var endPos = [pos[0], pos[1] += event.velocityY * inertia / 2];
            var _newMapState2 = this.mapState.rotate({
              pos: endPos
            });
            this.updateViewport(_newMapState2, _objectSpread5(_objectSpread5({}, LINEAR_TRANSITION_PROPS), {}, {
              transitionDuration: inertia,
              transitionEasing: INERTIA_EASING2
            }), {
              isDragging: false,
              isRotating: true
            });
            this.blockEvents(inertia);
            return false;
          }
        }
        var newMapState = this.mapState.rotateEnd();
        this.updateViewport(newMapState, null, {
          isDragging: false,
          isRotating: false
        });
        return true;
      }
    }, {
      key: "_onDoubleTap",
      value: function _onDoubleTap(event) {
        if (!this.doubleClickZoom) {
          return false;
        }
        var pos = this.getCenter(event);
        var isZoomOut = this.isFunctionKeyPressed(event);
        var newMapState = this.mapState.zoom({
          pos,
          scale: isZoomOut ? 0.5 : 2
        });
        this.updateViewport(newMapState, Object.assign({}, LINEAR_TRANSITION_PROPS, {
          transitionInterpolator: new LinearInterpolator2({
            around: pos
          })
        }), {
          isZooming: true
        });
        return true;
      }
    }, {
      key: "_onKeyDown",
      value: function _onKeyDown(event) {
        if (!this.keyboard) {
          return false;
        }
        var funcKey = this.isFunctionKeyPressed(event);
        var _this$keyboard = this.keyboard, _this$keyboard$zoomSp = _this$keyboard.zoomSpeed, zoomSpeed = _this$keyboard$zoomSp === void 0 ? 2 : _this$keyboard$zoomSp, _this$keyboard$moveSp = _this$keyboard.moveSpeed, moveSpeed = _this$keyboard$moveSp === void 0 ? 100 : _this$keyboard$moveSp, _this$keyboard$rotate = _this$keyboard.rotateSpeedX, rotateSpeedX = _this$keyboard$rotate === void 0 ? 15 : _this$keyboard$rotate, _this$keyboard$rotate2 = _this$keyboard.rotateSpeedY, rotateSpeedY = _this$keyboard$rotate2 === void 0 ? 10 : _this$keyboard$rotate2;
        var mapStateProps = this.mapStateProps;
        var newMapState;
        switch (event.srcEvent.keyCode) {
          case 189:
            if (funcKey) {
              newMapState = this.getMapState({
                zoom: mapStateProps.zoom - Math.log2(zoomSpeed) - 1
              });
            } else {
              newMapState = this.getMapState({
                zoom: mapStateProps.zoom - Math.log2(zoomSpeed)
              });
            }
            break;
          case 187:
            if (funcKey) {
              newMapState = this.getMapState({
                zoom: mapStateProps.zoom + Math.log2(zoomSpeed) + 1
              });
            } else {
              newMapState = this.getMapState({
                zoom: mapStateProps.zoom + Math.log2(zoomSpeed)
              });
            }
            break;
          case 37:
            if (funcKey) {
              newMapState = this.getMapState({
                bearing: mapStateProps.bearing - rotateSpeedX
              });
            } else {
              newMapState = this.mapState.pan({
                pos: [moveSpeed, 0],
                startPos: [0, 0]
              });
            }
            break;
          case 39:
            if (funcKey) {
              newMapState = this.getMapState({
                bearing: mapStateProps.bearing + rotateSpeedX
              });
            } else {
              newMapState = this.mapState.pan({
                pos: [-moveSpeed, 0],
                startPos: [0, 0]
              });
            }
            break;
          case 38:
            if (funcKey) {
              newMapState = this.getMapState({
                pitch: mapStateProps.pitch + rotateSpeedY
              });
            } else {
              newMapState = this.mapState.pan({
                pos: [0, moveSpeed],
                startPos: [0, 0]
              });
            }
            break;
          case 40:
            if (funcKey) {
              newMapState = this.getMapState({
                pitch: mapStateProps.pitch - rotateSpeedY
              });
            } else {
              newMapState = this.mapState.pan({
                pos: [0, -moveSpeed],
                startPos: [0, 0]
              });
            }
            break;
          default:
            return false;
        }
        return this.updateViewport(newMapState, LINEAR_TRANSITION_PROPS);
      }
    }]);
    return MapController3;
  }();

  // node_modules/react-map-gl/dist/esm/components/interactive-map.js
  function ownKeys6(object12, enumerableOnly) {
    var keys3 = Object.keys(object12);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object12);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object12, sym).enumerable;
        });
      keys3.push.apply(keys3, symbols);
    }
    return keys3;
  }
  function _objectSpread6(target5) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys6(Object(source), true).forEach(function(key) {
          _defineProperty(target5, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target5, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys6(Object(source)).forEach(function(key) {
          Object.defineProperty(target5, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target5;
  }
  var propTypes3 = Object.assign({}, static_map_default.propTypes, {
    maxZoom: PropTypes3.number,
    minZoom: PropTypes3.number,
    maxPitch: PropTypes3.number,
    minPitch: PropTypes3.number,
    onViewStateChange: PropTypes3.func,
    onViewportChange: PropTypes3.func,
    onInteractionStateChange: PropTypes3.func,
    transitionDuration: PropTypes3.oneOfType([PropTypes3.number, PropTypes3.string]),
    transitionInterpolator: PropTypes3.object,
    transitionInterruption: PropTypes3.number,
    transitionEasing: PropTypes3.func,
    onTransitionStart: PropTypes3.func,
    onTransitionInterrupt: PropTypes3.func,
    onTransitionEnd: PropTypes3.func,
    scrollZoom: PropTypes3.oneOfType([PropTypes3.bool, PropTypes3.object]),
    dragPan: PropTypes3.oneOfType([PropTypes3.bool, PropTypes3.object]),
    dragRotate: PropTypes3.oneOfType([PropTypes3.bool, PropTypes3.object]),
    doubleClickZoom: PropTypes3.bool,
    touchZoom: PropTypes3.oneOfType([PropTypes3.bool, PropTypes3.object]),
    touchRotate: PropTypes3.oneOfType([PropTypes3.bool, PropTypes3.object]),
    keyboard: PropTypes3.oneOfType([PropTypes3.bool, PropTypes3.object]),
    onHover: PropTypes3.func,
    onClick: PropTypes3.func,
    onDblClick: PropTypes3.func,
    onContextMenu: PropTypes3.func,
    onMouseDown: PropTypes3.func,
    onMouseMove: PropTypes3.func,
    onMouseUp: PropTypes3.func,
    onTouchStart: PropTypes3.func,
    onTouchMove: PropTypes3.func,
    onTouchEnd: PropTypes3.func,
    onMouseEnter: PropTypes3.func,
    onMouseLeave: PropTypes3.func,
    onMouseOut: PropTypes3.func,
    onWheel: PropTypes3.func,
    touchAction: PropTypes3.string,
    eventRecognizerOptions: PropTypes3.object,
    clickRadius: PropTypes3.number,
    interactiveLayerIds: PropTypes3.array,
    getCursor: PropTypes3.func,
    controller: PropTypes3.instanceOf(MapController2)
  });
  var getDefaultCursor = function getDefaultCursor2(_ref) {
    var isDragging = _ref.isDragging, isHovering = _ref.isHovering;
    return isDragging ? "grabbing" : isHovering ? "pointer" : "grab";
  };
  var defaultProps7 = Object.assign({}, static_map_default.defaultProps, MAPBOX_LIMITS, TransitionManager2.defaultProps, {
    onViewStateChange: null,
    onViewportChange: null,
    onClick: null,
    onNativeClick: null,
    onHover: null,
    onContextMenu: function onContextMenu(event) {
      return event.preventDefault();
    },
    scrollZoom: true,
    dragPan: true,
    dragRotate: true,
    doubleClickZoom: true,
    touchZoom: true,
    touchRotate: false,
    keyboard: true,
    touchAction: "none",
    eventRecognizerOptions: {},
    clickRadius: 0,
    getCursor: getDefaultCursor
  });
  function normalizeEvent(event) {
    if (event.lngLat || !event.offsetCenter) {
      return event;
    }
    var _event$offsetCenter = event.offsetCenter, x = _event$offsetCenter.x, y = _event$offsetCenter.y;
    if (!Number.isFinite(x) || !Number.isFinite(y)) {
      return event;
    }
    var pos = [x, y];
    event.point = pos;
    event.lngLat = this.viewport.unproject(pos);
    return event;
  }
  function getFeatures2(pos) {
    var map16 = this.map;
    if (!map16 || !pos) {
      return null;
    }
    var queryParams = {};
    var size5 = this.props.clickRadius;
    if (this.props.interactiveLayerIds) {
      queryParams.layers = this.props.interactiveLayerIds;
    }
    try {
      return map16.queryRenderedFeatures(size5 ? [[pos[0] - size5, pos[1] + size5], [pos[0] + size5, pos[1] - size5]] : pos, queryParams);
    } catch (_unused) {
      return null;
    }
  }
  function onEvent(callbackName, event) {
    var func11 = this.props[callbackName];
    if (func11) {
      func11(normalizeEvent.call(this, event));
    }
  }
  function onPointerDown(event) {
    onEvent.call(this, event.pointerType === "touch" ? "onTouchStart" : "onMouseDown", event);
  }
  function onPointerUp(event) {
    onEvent.call(this, event.pointerType === "touch" ? "onTouchEnd" : "onMouseUp", event);
  }
  function onPointerMove(event) {
    onEvent.call(this, event.pointerType === "touch" ? "onTouchMove" : "onMouseMove", event);
    if (!this.state.isDragging) {
      var _this$props = this.props, onHover = _this$props.onHover, interactiveLayerIds = _this$props.interactiveLayerIds;
      var features;
      event = normalizeEvent.call(this, event);
      if (interactiveLayerIds || onHover) {
        features = getFeatures2.call(this, event.point);
      }
      var isHovering = Boolean(interactiveLayerIds && features && features.length > 0);
      var isEntering = isHovering && !this.state.isHovering;
      var isExiting = !isHovering && this.state.isHovering;
      if (onHover || isEntering) {
        event.features = features;
        if (onHover) {
          onHover(event);
        }
      }
      if (isEntering) {
        onEvent.call(this, "onMouseEnter", event);
      }
      if (isExiting) {
        onEvent.call(this, "onMouseLeave", event);
      }
      if (isEntering || isExiting) {
        this.setState({
          isHovering
        });
      }
    }
  }
  function onPointerClick(event) {
    var _this$props2 = this.props, onClick = _this$props2.onClick, onNativeClick = _this$props2.onNativeClick, onDblClick = _this$props2.onDblClick, doubleClickZoom = _this$props2.doubleClickZoom;
    var callbacks = [];
    var isDoubleClickEnabled = onDblClick || doubleClickZoom;
    switch (event.type) {
      case "anyclick":
        callbacks.push(onNativeClick);
        if (!isDoubleClickEnabled) {
          callbacks.push(onClick);
        }
        break;
      case "click":
        if (isDoubleClickEnabled) {
          callbacks.push(onClick);
        }
        break;
      default:
    }
    callbacks = callbacks.filter(Boolean);
    if (callbacks.length) {
      event = normalizeEvent.call(this, event);
      event.features = getFeatures2.call(this, event.point);
      callbacks.forEach(function(cb) {
        return cb(event);
      });
    }
  }
  function getRefHandles3(staticMapRef) {
    return {
      getMap: staticMapRef.current && staticMapRef.current.getMap,
      queryRenderedFeatures: staticMapRef.current && staticMapRef.current.queryRenderedFeatures
    };
  }
  var InteractiveMap = (0, import_react11.forwardRef)(function(props, ref) {
    var parentContext = (0, import_react11.useContext)(map_context_default);
    var controller = (0, import_react11.useMemo)(function() {
      return props.controller || new MapController2();
    }, []);
    var eventManager = (0, import_react11.useMemo)(function() {
      return new EventManager(null, {
        touchAction: props.touchAction,
        recognizerOptions: props.eventRecognizerOptions
      });
    }, []);
    var eventCanvasRef = (0, import_react11.useRef)(null);
    var staticMapRef = (0, import_react11.useRef)(null);
    var _thisRef = (0, import_react11.useRef)({
      width: 0,
      height: 0,
      state: {
        isHovering: false,
        isDragging: false
      }
    });
    var thisRef = _thisRef.current;
    thisRef.props = props;
    thisRef.map = staticMapRef.current && staticMapRef.current.getMap();
    thisRef.setState = function(newState) {
      thisRef.state = _objectSpread6(_objectSpread6({}, thisRef.state), newState);
      eventCanvasRef.current.style.cursor = props.getCursor(thisRef.state);
    };
    var inRender = true;
    var viewportUpdateRequested;
    var stateUpdateRequested;
    var handleViewportChange = function handleViewportChange2(viewState, interactionState, oldViewState) {
      if (inRender) {
        viewportUpdateRequested = [viewState, interactionState, oldViewState];
        return;
      }
      var _thisRef$props = thisRef.props, onViewStateChange = _thisRef$props.onViewStateChange, onViewportChange = _thisRef$props.onViewportChange;
      if (onViewStateChange) {
        onViewStateChange({
          viewState,
          interactionState,
          oldViewState
        });
      }
      if (onViewportChange) {
        onViewportChange(viewState, interactionState, oldViewState);
      }
    };
    (0, import_react11.useImperativeHandle)(ref, function() {
      return getRefHandles3(staticMapRef);
    }, []);
    var context = (0, import_react11.useMemo)(function() {
      return _objectSpread6(_objectSpread6({}, parentContext), {}, {
        eventManager,
        container: parentContext.container || eventCanvasRef.current
      });
    }, [parentContext, eventCanvasRef.current]);
    context.onViewportChange = handleViewportChange;
    context.viewport = parentContext.viewport || getViewport(thisRef);
    thisRef.viewport = context.viewport;
    var handleInteractionStateChange = function handleInteractionStateChange2(interactionState) {
      var _interactionState$isD = interactionState.isDragging, isDragging = _interactionState$isD === void 0 ? false : _interactionState$isD;
      if (isDragging !== thisRef.state.isDragging) {
        thisRef.setState({
          isDragging
        });
      }
      if (inRender) {
        stateUpdateRequested = interactionState;
        return;
      }
      var onInteractionStateChange = thisRef.props.onInteractionStateChange;
      if (onInteractionStateChange) {
        onInteractionStateChange(interactionState);
      }
    };
    var updateControllerOpts = function updateControllerOpts2() {
      if (thisRef.width && thisRef.height) {
        controller.setOptions(_objectSpread6(_objectSpread6(_objectSpread6({}, thisRef.props), thisRef.props.viewState), {}, {
          isInteractive: Boolean(thisRef.props.onViewStateChange || thisRef.props.onViewportChange),
          onViewportChange: handleViewportChange,
          onStateChange: handleInteractionStateChange,
          eventManager,
          width: thisRef.width,
          height: thisRef.height
        }));
      }
    };
    var onResize = function onResize2(_ref2) {
      var width9 = _ref2.width, height9 = _ref2.height;
      thisRef.width = width9;
      thisRef.height = height9;
      updateControllerOpts();
      thisRef.props.onResize({
        width: width9,
        height: height9
      });
    };
    (0, import_react11.useEffect)(function() {
      eventManager.setElement(eventCanvasRef.current);
      eventManager.on({
        pointerdown: onPointerDown.bind(thisRef),
        pointermove: onPointerMove.bind(thisRef),
        pointerup: onPointerUp.bind(thisRef),
        pointerleave: onEvent.bind(thisRef, "onMouseOut"),
        click: onPointerClick.bind(thisRef),
        anyclick: onPointerClick.bind(thisRef),
        dblclick: onEvent.bind(thisRef, "onDblClick"),
        wheel: onEvent.bind(thisRef, "onWheel"),
        contextmenu: onEvent.bind(thisRef, "onContextMenu")
      });
      return function() {
        eventManager.destroy();
      };
    }, []);
    use_isomorphic_layout_effect_default2(function() {
      if (viewportUpdateRequested) {
        handleViewportChange.apply(void 0, _toConsumableArray(viewportUpdateRequested));
      }
      if (stateUpdateRequested) {
        handleInteractionStateChange(stateUpdateRequested);
      }
    });
    updateControllerOpts();
    var width8 = props.width, height8 = props.height, style = props.style, getCursor2 = props.getCursor;
    var eventCanvasStyle = (0, import_react11.useMemo)(function() {
      return _objectSpread6(_objectSpread6({
        position: "relative"
      }, style), {}, {
        width: width8,
        height: height8,
        cursor: getCursor2(thisRef.state)
      });
    }, [style, width8, height8, getCursor2, thisRef.state]);
    if (!viewportUpdateRequested || !thisRef._child) {
      thisRef._child = React5.createElement(MapContextProvider, {
        value: context
      }, React5.createElement("div", {
        key: "event-canvas",
        ref: eventCanvasRef,
        style: eventCanvasStyle
      }, React5.createElement(static_map_default, _extends({}, props, {
        width: "100%",
        height: "100%",
        style: null,
        onResize,
        ref: staticMapRef
      }))));
    }
    inRender = false;
    return thisRef._child;
  });
  InteractiveMap.supported = static_map_default.supported;
  InteractiveMap.propTypes = propTypes3;
  InteractiveMap.defaultProps = defaultProps7;
  var interactive_map_default = InteractiveMap;

  // node_modules/react-map-gl/dist/esm/components/source.js
  var React6 = __toESM(require_react());
  var import_react12 = __toESM(require_react());
  var import_react13 = __toESM(require_react());
  var PropTypes4 = __toESM(require_prop_types());

  // node_modules/react-map-gl/dist/esm/utils/deep-equal.js
  function deepEqual2(a, b) {
    if (a === b) {
      return true;
    }
    if (!a || !b) {
      return false;
    }
    if (Array.isArray(a)) {
      if (!Array.isArray(b) || a.length !== b.length) {
        return false;
      }
      for (var i = 0; i < a.length; i++) {
        if (!deepEqual2(a[i], b[i])) {
          return false;
        }
      }
      return true;
    } else if (Array.isArray(b)) {
      return false;
    }
    if (_typeof(a) === "object" && _typeof(b) === "object") {
      var aKeys = Object.keys(a);
      var bKeys = Object.keys(b);
      if (aKeys.length !== bKeys.length) {
        return false;
      }
      for (var _i = 0, _aKeys = aKeys; _i < _aKeys.length; _i++) {
        var key = _aKeys[_i];
        if (!b.hasOwnProperty(key)) {
          return false;
        }
        if (!deepEqual2(a[key], b[key])) {
          return false;
        }
      }
      return true;
    }
    return false;
  }

  // node_modules/react-map-gl/dist/esm/components/source.js
  function ownKeys7(object12, enumerableOnly) {
    var keys3 = Object.keys(object12);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object12);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object12, sym).enumerable;
        });
      keys3.push.apply(keys3, symbols);
    }
    return keys3;
  }
  function _objectSpread7(target5) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys7(Object(source), true).forEach(function(key) {
          _defineProperty(target5, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target5, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys7(Object(source)).forEach(function(key) {
          Object.defineProperty(target5, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target5;
  }
  var propTypes4 = {
    type: PropTypes4.string.isRequired,
    id: PropTypes4.string
  };
  var sourceCounter = 0;
  function createSource(map16, id2, props) {
    if (map16 && map16.style && map16.style._loaded) {
      var options2 = _objectSpread7({}, props);
      delete options2.id;
      delete options2.children;
      map16.addSource(id2, options2);
      return map16.getSource(id2);
    }
    return null;
  }
  function updateSource(source, props, prevProps) {
    assert11(props.id === prevProps.id, "source id changed");
    assert11(props.type === prevProps.type, "source type changed");
    var changedKey = "";
    var changedKeyCount = 0;
    for (var key in props) {
      if (key !== "children" && key !== "id" && !deepEqual2(prevProps[key], props[key])) {
        changedKey = key;
        changedKeyCount++;
      }
    }
    if (!changedKeyCount) {
      return;
    }
    var type = props.type;
    if (type === "geojson") {
      source.setData(props.data);
    } else if (type === "image") {
      source.updateImage({
        url: props.url,
        coordinates: props.coordinates
      });
    } else if ((type === "canvas" || type === "video") && changedKeyCount === 1 && changedKey === "coordinates") {
      source.setCoordinates(props.coordinates);
    } else if (type === "vector" && source.setUrl) {
      switch (changedKey) {
        case "url":
          source.setUrl(props.url);
          break;
        case "tiles":
          source.setTiles(props.tiles);
          break;
        default:
      }
    } else {
      console.warn("Unable to update <Source> prop: ".concat(changedKey));
    }
  }
  function Source(props) {
    var context = (0, import_react12.useContext)(map_context_default);
    var propsRef = (0, import_react12.useRef)({
      id: props.id,
      type: props.type
    });
    var _useState = (0, import_react12.useState)(0), _useState2 = _slicedToArray(_useState, 2), setStyleLoaded = _useState2[1];
    var id2 = (0, import_react12.useMemo)(function() {
      return props.id || "jsx-source-".concat(sourceCounter++);
    }, []);
    var map16 = context.map;
    (0, import_react12.useEffect)(function() {
      if (map16) {
        var forceUpdate = function forceUpdate2() {
          return setStyleLoaded(function(version) {
            return version + 1;
          });
        };
        map16.on("styledata", forceUpdate);
        return function() {
          map16.off("styledata", forceUpdate);
          requestAnimationFrame(function() {
            if (map16.style && map16.style._loaded && map16.getSource(id2)) {
              map16.removeSource(id2);
            }
          });
        };
      }
      return void 0;
    }, [map16, id2]);
    var source = map16 && map16.style && map16.getSource(id2);
    if (source) {
      updateSource(source, props, propsRef.current);
    } else {
      source = createSource(map16, id2, props);
    }
    propsRef.current = props;
    return source && React6.Children.map(props.children, function(child) {
      return child && (0, import_react13.cloneElement)(child, {
        source: id2
      });
    }) || null;
  }
  Source.propTypes = propTypes4;

  // node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target5 = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target5[key] = source[key];
    }
    return target5;
  }

  // node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
  function _objectWithoutProperties(source, excluded) {
    if (source == null)
      return {};
    var target5 = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target5[key] = source[key];
      }
    }
    return target5;
  }

  // node_modules/react-map-gl/dist/esm/components/layer.js
  var import_react14 = __toESM(require_react());
  var PropTypes5 = __toESM(require_prop_types());
  function ownKeys8(object12, enumerableOnly) {
    var keys3 = Object.keys(object12);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object12);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object12, sym).enumerable;
        });
      keys3.push.apply(keys3, symbols);
    }
    return keys3;
  }
  function _objectSpread8(target5) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys8(Object(source), true).forEach(function(key) {
          _defineProperty(target5, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target5, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys8(Object(source)).forEach(function(key) {
          Object.defineProperty(target5, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target5;
  }
  var LAYER_TYPES = ["fill", "line", "symbol", "circle", "fill-extrusion", "raster", "background", "heatmap", "hillshade"];
  var propTypes5 = {
    type: PropTypes5.oneOf(LAYER_TYPES).isRequired,
    id: PropTypes5.string,
    source: PropTypes5.string,
    beforeId: PropTypes5.string
  };
  function diffLayerStyles(map16, id2, props, prevProps) {
    var _props$layout = props.layout, layout = _props$layout === void 0 ? {} : _props$layout, _props$paint = props.paint, paint = _props$paint === void 0 ? {} : _props$paint, filter3 = props.filter, minzoom = props.minzoom, maxzoom = props.maxzoom, beforeId = props.beforeId, otherProps = _objectWithoutProperties(props, ["layout", "paint", "filter", "minzoom", "maxzoom", "beforeId"]);
    if (beforeId !== prevProps.beforeId) {
      map16.moveLayer(id2, beforeId);
    }
    if (layout !== prevProps.layout) {
      var prevLayout = prevProps.layout || {};
      for (var key in layout) {
        if (!deepEqual2(layout[key], prevLayout[key])) {
          map16.setLayoutProperty(id2, key, layout[key]);
        }
      }
      for (var _key in prevLayout) {
        if (!layout.hasOwnProperty(_key)) {
          map16.setLayoutProperty(id2, _key, void 0);
        }
      }
    }
    if (paint !== prevProps.paint) {
      var prevPaint = prevProps.paint || {};
      for (var _key2 in paint) {
        if (!deepEqual2(paint[_key2], prevPaint[_key2])) {
          map16.setPaintProperty(id2, _key2, paint[_key2]);
        }
      }
      for (var _key3 in prevPaint) {
        if (!paint.hasOwnProperty(_key3)) {
          map16.setPaintProperty(id2, _key3, void 0);
        }
      }
    }
    if (!deepEqual2(filter3, prevProps.filter)) {
      map16.setFilter(id2, filter3);
    }
    if (minzoom !== prevProps.minzoom || maxzoom !== prevProps.maxzoom) {
      map16.setLayerZoomRange(id2, minzoom, maxzoom);
    }
    for (var _key4 in otherProps) {
      if (!deepEqual2(otherProps[_key4], prevProps[_key4])) {
        map16.setLayerProperty(id2, _key4, otherProps[_key4]);
      }
    }
  }
  function createLayer2(map16, id2, props) {
    if (map16.style && map16.style._loaded) {
      var options2 = _objectSpread8(_objectSpread8({}, props), {}, {
        id: id2
      });
      delete options2.beforeId;
      map16.addLayer(options2, props.beforeId);
    }
  }
  function updateLayer(map16, id2, props, prevProps) {
    assert11(props.id === prevProps.id, "layer id changed");
    assert11(props.type === prevProps.type, "layer type changed");
    try {
      diffLayerStyles(map16, id2, props, prevProps);
    } catch (error3) {
      console.warn(error3);
    }
  }
  var layerCounter = 0;
  function Layer2(props) {
    var context = (0, import_react14.useContext)(map_context_default);
    var propsRef = (0, import_react14.useRef)({
      id: props.id,
      type: props.type
    });
    var _useState = (0, import_react14.useState)(0), _useState2 = _slicedToArray(_useState, 2), setStyleLoaded = _useState2[1];
    var id2 = (0, import_react14.useMemo)(function() {
      return props.id || "jsx-layer-".concat(layerCounter++);
    }, []);
    var map16 = context.map;
    (0, import_react14.useEffect)(function() {
      if (map16) {
        var forceUpdate = function forceUpdate2() {
          return setStyleLoaded(function(version) {
            return version + 1;
          });
        };
        map16.on("styledata", forceUpdate);
        return function() {
          map16.off("styledata", forceUpdate);
          if (map16.style && map16.style._loaded) {
            map16.removeLayer(id2);
          }
        };
      }
      return void 0;
    }, [map16]);
    var layer = map16 && map16.style && map16.getLayer(id2);
    if (layer) {
      updateLayer(map16, id2, props, propsRef.current);
    } else {
      createLayer2(map16, id2, props);
    }
    propsRef.current = props;
    return null;
  }
  Layer2.propTypes = propTypes5;

  // node_modules/react-map-gl/dist/esm/components/base-control.js
  var React7 = __toESM(require_react());
  var import_react16 = __toESM(require_react());

  // node_modules/react-map-gl/dist/esm/components/use-map-control.js
  var import_react15 = __toESM(require_react());
  var PropTypes6 = __toESM(require_prop_types());
  var mapControlDefaultProps = {
    captureScroll: false,
    captureDrag: true,
    captureClick: true,
    captureDoubleClick: true,
    capturePointerMove: false
  };
  var mapControlPropTypes = {
    captureScroll: PropTypes6.bool,
    captureDrag: PropTypes6.bool,
    captureClick: PropTypes6.bool,
    captureDoubleClick: PropTypes6.bool,
    capturePointerMove: PropTypes6.bool
  };
  function onMount(thisRef) {
    var ref = thisRef.containerRef.current;
    var eventManager = thisRef.context.eventManager;
    if (!ref || !eventManager) {
      return void 0;
    }
    var events = {
      wheel: function wheel(evt) {
        var props = thisRef.props;
        if (props.captureScroll) {
          evt.stopPropagation();
        }
        if (props.onScroll) {
          props.onScroll(evt, thisRef);
        }
      },
      panstart: function panstart(evt) {
        var props = thisRef.props;
        if (props.captureDrag) {
          evt.stopPropagation();
        }
        if (props.onDragStart) {
          props.onDragStart(evt, thisRef);
        }
      },
      anyclick: function anyclick(evt) {
        var props = thisRef.props;
        if (props.captureClick) {
          evt.stopPropagation();
        }
        if (props.onNativeClick) {
          props.onNativeClick(evt, thisRef);
        }
      },
      click: function click2(evt) {
        var props = thisRef.props;
        if (props.captureClick) {
          evt.stopPropagation();
        }
        if (props.onClick) {
          props.onClick(evt, thisRef);
        }
      },
      dblclick: function dblclick(evt) {
        var props = thisRef.props;
        if (props.captureDoubleClick) {
          evt.stopPropagation();
        }
        if (props.onDoubleClick) {
          props.onDoubleClick(evt, thisRef);
        }
      },
      pointermove: function pointermove(evt) {
        var props = thisRef.props;
        if (props.capturePointerMove) {
          evt.stopPropagation();
        }
        if (props.onPointerMove) {
          props.onPointerMove(evt, thisRef);
        }
      }
    };
    eventManager.watch(events, ref);
    return function() {
      eventManager.off(events);
    };
  }
  function useMapControl() {
    var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var context = (0, import_react15.useContext)(map_context_default);
    var containerRef = (0, import_react15.useRef)(null);
    var _thisRef = (0, import_react15.useRef)({
      props,
      state: {},
      context,
      containerRef
    });
    var thisRef = _thisRef.current;
    thisRef.props = props;
    thisRef.context = context;
    (0, import_react15.useEffect)(function() {
      return onMount(thisRef);
    }, [context.eventManager]);
    return thisRef;
  }

  // node_modules/react-map-gl/dist/esm/components/base-control.js
  function _createSuper3(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct3();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _isNativeReflectConstruct3() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  function Control(props) {
    var instance = props.instance;
    var _useMapControl = useMapControl(props), context = _useMapControl.context, containerRef = _useMapControl.containerRef;
    instance._context = context;
    instance._containerRef = containerRef;
    return instance._render();
  }
  var BaseControl = function(_PureComponent) {
    _inherits(BaseControl2, _PureComponent);
    var _super = _createSuper3(BaseControl2);
    function BaseControl2() {
      var _this;
      _classCallCheck(this, BaseControl2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "_context", {});
      _defineProperty(_assertThisInitialized(_this), "_containerRef", (0, import_react16.createRef)());
      _defineProperty(_assertThisInitialized(_this), "_onScroll", function(evt) {
      });
      _defineProperty(_assertThisInitialized(_this), "_onDragStart", function(evt) {
      });
      _defineProperty(_assertThisInitialized(_this), "_onDblClick", function(evt) {
      });
      _defineProperty(_assertThisInitialized(_this), "_onClick", function(evt) {
      });
      _defineProperty(_assertThisInitialized(_this), "_onPointerMove", function(evt) {
      });
      return _this;
    }
    _createClass(BaseControl2, [{
      key: "_render",
      value: function _render() {
        throw new Error("_render() not implemented");
      }
    }, {
      key: "render",
      value: function render2() {
        return React7.createElement(Control, _extends({
          instance: this
        }, this.props, {
          onScroll: this._onScroll,
          onDragStart: this._onDragStart,
          onDblClick: this._onDblClick,
          onClick: this._onClick,
          onPointerMove: this._onPointerMove
        }));
      }
    }]);
    return BaseControl2;
  }(import_react16.PureComponent);
  _defineProperty(BaseControl, "propTypes", mapControlPropTypes);
  _defineProperty(BaseControl, "defaultProps", mapControlDefaultProps);

  // node_modules/react-map-gl/dist/esm/components/marker.js
  var React8 = __toESM(require_react());
  var import_react18 = __toESM(require_react());
  var PropTypes8 = __toESM(require_prop_types());

  // node_modules/react-map-gl/dist/esm/components/draggable-control.js
  var PropTypes7 = __toESM(require_prop_types());
  var import_react17 = __toESM(require_react());
  function ownKeys9(object12, enumerableOnly) {
    var keys3 = Object.keys(object12);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object12);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object12, sym).enumerable;
        });
      keys3.push.apply(keys3, symbols);
    }
    return keys3;
  }
  function _objectSpread9(target5) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys9(Object(source), true).forEach(function(key) {
          _defineProperty(target5, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target5, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys9(Object(source)).forEach(function(key) {
          Object.defineProperty(target5, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target5;
  }
  var draggableControlPropTypes = Object.assign({}, mapControlPropTypes, {
    draggable: PropTypes7.bool,
    onDrag: PropTypes7.func,
    onDragEnd: PropTypes7.func,
    onDragStart: PropTypes7.func,
    offsetLeft: PropTypes7.number,
    offsetTop: PropTypes7.number
  });
  var draggableControlDefaultProps = Object.assign({}, mapControlDefaultProps, {
    draggable: false,
    offsetLeft: 0,
    offsetTop: 0
  });
  function getDragEventPosition(event) {
    var _event$offsetCenter = event.offsetCenter, x = _event$offsetCenter.x, y = _event$offsetCenter.y;
    return [x, y];
  }
  function getDragEventOffset(event, container) {
    var _event$center = event.center, x = _event$center.x, y = _event$center.y;
    if (container) {
      var rect = container.getBoundingClientRect();
      return [rect.left - x, rect.top - y];
    }
    return null;
  }
  function getDragLngLat(dragPos, dragOffset, props, context) {
    var x = dragPos[0] + dragOffset[0] - props.offsetLeft;
    var y = dragPos[1] + dragOffset[1] - props.offsetTop;
    return context.viewport.unproject([x, y]);
  }
  function onDragStart(event, _ref) {
    var props = _ref.props, callbacks = _ref.callbacks, state3 = _ref.state, context = _ref.context, containerRef = _ref.containerRef;
    var draggable2 = props.draggable;
    if (!draggable2) {
      return;
    }
    event.stopPropagation();
    var dragPos = getDragEventPosition(event);
    var dragOffset = getDragEventOffset(event, containerRef.current);
    state3.setDragPos(dragPos);
    state3.setDragOffset(dragOffset);
    if (callbacks.onDragStart && dragOffset) {
      var callbackEvent = Object.assign({}, event);
      callbackEvent.lngLat = getDragLngLat(dragPos, dragOffset, props, context);
      callbacks.onDragStart(callbackEvent);
    }
  }
  function onDrag(event, _ref2) {
    var props = _ref2.props, callbacks = _ref2.callbacks, state3 = _ref2.state, context = _ref2.context;
    event.stopPropagation();
    var dragPos = getDragEventPosition(event);
    state3.setDragPos(dragPos);
    var dragOffset = state3.dragOffset;
    if (callbacks.onDrag && dragOffset) {
      var callbackEvent = Object.assign({}, event);
      callbackEvent.lngLat = getDragLngLat(dragPos, dragOffset, props, context);
      callbacks.onDrag(callbackEvent);
    }
  }
  function onDragEnd(event, _ref3) {
    var props = _ref3.props, callbacks = _ref3.callbacks, state3 = _ref3.state, context = _ref3.context;
    event.stopPropagation();
    var dragPos = state3.dragPos, dragOffset = state3.dragOffset;
    state3.setDragPos(null);
    state3.setDragOffset(null);
    if (callbacks.onDragEnd && dragPos && dragOffset) {
      var callbackEvent = Object.assign({}, event);
      callbackEvent.lngLat = getDragLngLat(dragPos, dragOffset, props, context);
      callbacks.onDragEnd(callbackEvent);
    }
  }
  function onDragCancel(event, _ref4) {
    var state3 = _ref4.state;
    event.stopPropagation();
    state3.setDragPos(null);
    state3.setDragOffset(null);
  }
  function registerEvents(thisRef) {
    var eventManager = thisRef.context.eventManager;
    if (!eventManager || !thisRef.state.dragPos) {
      return void 0;
    }
    var events = {
      panmove: function panmove(evt) {
        return onDrag(evt, thisRef);
      },
      panend: function panend(evt) {
        return onDragEnd(evt, thisRef);
      },
      pancancel: function pancancel(evt) {
        return onDragCancel(evt, thisRef);
      }
    };
    eventManager.watch(events);
    return function() {
      eventManager.off(events);
    };
  }
  function useDraggableControl(props) {
    var _useState = (0, import_react17.useState)(null), _useState2 = _slicedToArray(_useState, 2), dragPos = _useState2[0], setDragPos = _useState2[1];
    var _useState3 = (0, import_react17.useState)(null), _useState4 = _slicedToArray(_useState3, 2), dragOffset = _useState4[0], setDragOffset = _useState4[1];
    var thisRef = useMapControl(_objectSpread9(_objectSpread9({}, props), {}, {
      onDragStart
    }));
    thisRef.callbacks = props;
    thisRef.state.dragPos = dragPos;
    thisRef.state.setDragPos = setDragPos;
    thisRef.state.dragOffset = dragOffset;
    thisRef.state.setDragOffset = setDragOffset;
    (0, import_react17.useEffect)(function() {
      return registerEvents(thisRef);
    }, [thisRef.context.eventManager, Boolean(dragPos)]);
    return thisRef;
  }

  // node_modules/react-map-gl/dist/esm/utils/crisp-pixel.js
  var pixelRatio = typeof window !== "undefined" && window.devicePixelRatio || 1;
  var crispPixel = function crispPixel2(size5) {
    return Math.round(size5 * pixelRatio) / pixelRatio;
  };
  var crispPercentage = function crispPercentage2(el, percentage) {
    var dimension = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "x";
    if (el === null) {
      return percentage;
    }
    var origSize = dimension === "x" ? el.offsetWidth : el.offsetHeight;
    return crispPixel(percentage / 100 * origSize) / origSize * 100;
  };

  // node_modules/react-map-gl/dist/esm/components/marker.js
  function ownKeys10(object12, enumerableOnly) {
    var keys3 = Object.keys(object12);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object12);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object12, sym).enumerable;
        });
      keys3.push.apply(keys3, symbols);
    }
    return keys3;
  }
  function _objectSpread10(target5) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys10(Object(source), true).forEach(function(key) {
          _defineProperty(target5, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target5, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys10(Object(source)).forEach(function(key) {
          Object.defineProperty(target5, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target5;
  }
  var propTypes6 = Object.assign({}, draggableControlPropTypes, {
    className: PropTypes8.string,
    longitude: PropTypes8.number.isRequired,
    latitude: PropTypes8.number.isRequired,
    style: PropTypes8.object
  });
  var defaultProps8 = Object.assign({}, draggableControlDefaultProps, {
    className: ""
  });
  function getPosition2(_ref) {
    var props = _ref.props, state3 = _ref.state, context = _ref.context;
    var longitude = props.longitude, latitude = props.latitude, offsetLeft2 = props.offsetLeft, offsetTop2 = props.offsetTop;
    var dragPos = state3.dragPos, dragOffset = state3.dragOffset;
    if (dragPos && dragOffset) {
      return [dragPos[0] + dragOffset[0], dragPos[1] + dragOffset[1]];
    }
    var _context$viewport$pro = context.viewport.project([longitude, latitude]), _context$viewport$pro2 = _slicedToArray(_context$viewport$pro, 2), x = _context$viewport$pro2[0], y = _context$viewport$pro2[1];
    x += offsetLeft2;
    y += offsetTop2;
    return [x, y];
  }
  function Marker(props) {
    var thisRef = useDraggableControl(props);
    var state3 = thisRef.state, containerRef = thisRef.containerRef;
    var children = props.children, className = props.className, draggable2 = props.draggable, style = props.style;
    var dragPos = state3.dragPos;
    var _getPosition = getPosition2(thisRef), _getPosition2 = _slicedToArray(_getPosition, 2), x = _getPosition2[0], y = _getPosition2[1];
    var transform2 = "translate(".concat(crispPixel(x), "px, ").concat(crispPixel(y), "px)");
    var cursor = draggable2 ? dragPos ? "grabbing" : "grab" : "auto";
    var control = (0, import_react18.useMemo)(function() {
      var containerStyle = _objectSpread10({
        position: "absolute",
        left: 0,
        top: 0,
        transform: transform2,
        cursor
      }, style);
      return React8.createElement("div", {
        className: "mapboxgl-marker ".concat(className),
        ref: thisRef.containerRef,
        style: containerStyle
      }, children);
    }, [children, className]);
    var container = containerRef.current;
    if (container) {
      container.style.transform = transform2;
      container.style.cursor = cursor;
    }
    return control;
  }
  Marker.defaultProps = defaultProps8;
  Marker.propTypes = propTypes6;
  var marker_default = React8.memo(Marker);

  // node_modules/react-map-gl/dist/esm/components/popup.js
  var React9 = __toESM(require_react());
  var import_react19 = __toESM(require_react());
  var PropTypes9 = __toESM(require_prop_types());

  // node_modules/react-map-gl/dist/esm/utils/dynamic-position.js
  var ANCHOR_POSITION = {
    top: {
      x: 0.5,
      y: 0
    },
    "top-left": {
      x: 0,
      y: 0
    },
    "top-right": {
      x: 1,
      y: 0
    },
    bottom: {
      x: 0.5,
      y: 1
    },
    "bottom-left": {
      x: 0,
      y: 1
    },
    "bottom-right": {
      x: 1,
      y: 1
    },
    left: {
      x: 0,
      y: 0.5
    },
    right: {
      x: 1,
      y: 0.5
    }
  };
  var ANCHOR_TYPES = Object.keys(ANCHOR_POSITION);
  function getDynamicPosition(_ref) {
    var x = _ref.x, y = _ref.y, width8 = _ref.width, height8 = _ref.height, selfWidth = _ref.selfWidth, selfHeight = _ref.selfHeight, anchor = _ref.anchor, _ref$padding = _ref.padding, padding = _ref$padding === void 0 ? 0 : _ref$padding;
    var _ANCHOR_POSITION$anch = ANCHOR_POSITION[anchor], anchorX = _ANCHOR_POSITION$anch.x, anchorY = _ANCHOR_POSITION$anch.y;
    var top3 = y - anchorY * selfHeight;
    var bottom3 = top3 + selfHeight;
    var cutoffY = Math.max(0, padding - top3) + Math.max(0, bottom3 - height8 + padding);
    if (cutoffY > 0) {
      var bestAnchorY = anchorY;
      var minCutoff = cutoffY;
      for (anchorY = 0; anchorY <= 1; anchorY += 0.5) {
        top3 = y - anchorY * selfHeight;
        bottom3 = top3 + selfHeight;
        cutoffY = Math.max(0, padding - top3) + Math.max(0, bottom3 - height8 + padding);
        if (cutoffY < minCutoff) {
          minCutoff = cutoffY;
          bestAnchorY = anchorY;
        }
      }
      anchorY = bestAnchorY;
    }
    var xStep = 0.5;
    if (anchorY === 0.5) {
      anchorX = Math.floor(anchorX);
      xStep = 1;
    }
    var left3 = x - anchorX * selfWidth;
    var right = left3 + selfWidth;
    var cutoffX = Math.max(0, padding - left3) + Math.max(0, right - width8 + padding);
    if (cutoffX > 0) {
      var bestAnchorX = anchorX;
      var _minCutoff = cutoffX;
      for (anchorX = 0; anchorX <= 1; anchorX += xStep) {
        left3 = x - anchorX * selfWidth;
        right = left3 + selfWidth;
        cutoffX = Math.max(0, padding - left3) + Math.max(0, right - width8 + padding);
        if (cutoffX < _minCutoff) {
          _minCutoff = cutoffX;
          bestAnchorX = anchorX;
        }
      }
      anchorX = bestAnchorX;
    }
    return ANCHOR_TYPES.find(function(positionType) {
      var anchorPosition = ANCHOR_POSITION[positionType];
      return anchorPosition.x === anchorX && anchorPosition.y === anchorY;
    }) || anchor;
  }

  // node_modules/react-map-gl/dist/esm/components/popup.js
  var propTypes7 = Object.assign({}, mapControlPropTypes, {
    className: PropTypes9.string,
    longitude: PropTypes9.number.isRequired,
    latitude: PropTypes9.number.isRequired,
    altitude: PropTypes9.number,
    offsetLeft: PropTypes9.number,
    offsetTop: PropTypes9.number,
    tipSize: PropTypes9.number,
    closeButton: PropTypes9.bool,
    closeOnClick: PropTypes9.bool,
    anchor: PropTypes9.oneOf(Object.keys(ANCHOR_POSITION)),
    dynamicPosition: PropTypes9.bool,
    sortByDepth: PropTypes9.bool,
    onClose: PropTypes9.func
  });
  var defaultProps9 = Object.assign({}, mapControlDefaultProps, {
    className: "",
    altitude: 0,
    offsetLeft: 0,
    offsetTop: 0,
    tipSize: 10,
    anchor: "bottom",
    dynamicPosition: true,
    sortByDepth: false,
    closeButton: true,
    closeOnClick: true,
    onClose: function onClose() {
    }
  });
  function getPosition3(props, viewport, el, _ref) {
    var _ref2 = _slicedToArray(_ref, 2), x = _ref2[0], y = _ref2[1];
    var anchor = props.anchor, dynamicPosition = props.dynamicPosition, tipSize = props.tipSize;
    if (el) {
      return dynamicPosition ? getDynamicPosition({
        x,
        y,
        anchor,
        padding: tipSize,
        width: viewport.width,
        height: viewport.height,
        selfWidth: el.clientWidth,
        selfHeight: el.clientHeight
      }) : anchor;
    }
    return anchor;
  }
  function getContainerStyle(props, viewport, el, _ref3, positionType) {
    var _ref4 = _slicedToArray(_ref3, 3), x = _ref4[0], y = _ref4[1], z = _ref4[2];
    var offsetLeft2 = props.offsetLeft, offsetTop2 = props.offsetTop, sortByDepth = props.sortByDepth;
    var anchorPosition = ANCHOR_POSITION[positionType];
    var left3 = x + offsetLeft2;
    var top3 = y + offsetTop2;
    var xPercentage = crispPercentage(el, -anchorPosition.x * 100);
    var yPercentage = crispPercentage(el, -anchorPosition.y * 100, "y");
    var style = {
      position: "absolute",
      transform: "\n      translate(".concat(xPercentage, "%, ").concat(yPercentage, "%)\n      translate(").concat(crispPixel(left3), "px, ").concat(crispPixel(top3), "px)\n    "),
      display: void 0,
      zIndex: void 0
    };
    if (!sortByDepth) {
      return style;
    }
    if (z > 1 || z < -1 || x < 0 || x > viewport.width || y < 0 || y > viewport.height) {
      style.display = "none";
    } else {
      style.zIndex = Math.floor((1 - z) / 2 * 1e5);
    }
    return style;
  }
  function Popup(props) {
    var contentRef = (0, import_react19.useRef)(null);
    var thisRef = useMapControl(props);
    var context = thisRef.context, containerRef = thisRef.containerRef;
    var _useState = (0, import_react19.useState)(false), _useState2 = _slicedToArray(_useState, 2), setLoaded = _useState2[1];
    (0, import_react19.useEffect)(function() {
      setLoaded(true);
    }, [contentRef.current]);
    (0, import_react19.useEffect)(function() {
      if (context.eventManager && props.closeOnClick) {
        var clickCallback = function clickCallback2() {
          return thisRef.props.onClose();
        };
        context.eventManager.on("anyclick", clickCallback);
        return function() {
          context.eventManager.off("anyclick", clickCallback);
        };
      }
      return void 0;
    }, [context.eventManager, props.closeOnClick]);
    var viewport = context.viewport;
    var className = props.className, longitude = props.longitude, latitude = props.latitude, altitude = props.altitude, tipSize = props.tipSize, closeButton = props.closeButton, children = props.children;
    var position2 = viewport.project([longitude, latitude, altitude]);
    var positionType = getPosition3(props, viewport, contentRef.current, position2);
    var containerStyle = getContainerStyle(props, viewport, containerRef.current, position2, positionType);
    var onClickCloseButton = (0, import_react19.useCallback)(function(evt) {
      thisRef.props.onClose();
      var eventManager = thisRef.context.eventManager;
      if (eventManager) {
        eventManager.once("click", function(e) {
          return e.stopPropagation();
        }, evt.target);
      }
    }, []);
    return React9.createElement("div", {
      className: "mapboxgl-popup mapboxgl-popup-anchor-".concat(positionType, " ").concat(className),
      style: containerStyle,
      ref: containerRef
    }, React9.createElement("div", {
      key: "tip",
      className: "mapboxgl-popup-tip",
      style: {
        borderWidth: tipSize
      }
    }), React9.createElement("div", {
      key: "content",
      ref: contentRef,
      className: "mapboxgl-popup-content"
    }, closeButton && React9.createElement("button", {
      key: "close-button",
      className: "mapboxgl-popup-close-button",
      type: "button",
      onClick: onClickCloseButton
    }, "\xD7"), children));
  }
  Popup.propTypes = propTypes7;
  Popup.defaultProps = defaultProps9;
  var popup_default = React9.memo(Popup);

  // node_modules/react-map-gl/dist/esm/components/attribution-control.js
  var React10 = __toESM(require_react());
  var import_react20 = __toESM(require_react());
  var PropTypes10 = __toESM(require_prop_types());
  function ownKeys11(object12, enumerableOnly) {
    var keys3 = Object.keys(object12);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object12);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object12, sym).enumerable;
        });
      keys3.push.apply(keys3, symbols);
    }
    return keys3;
  }
  function _objectSpread11(target5) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys11(Object(source), true).forEach(function(key) {
          _defineProperty(target5, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target5, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys11(Object(source)).forEach(function(key) {
          Object.defineProperty(target5, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target5;
  }
  var propTypes8 = Object.assign({}, mapControlPropTypes, {
    toggleLabel: PropTypes10.string,
    className: PropTypes10.string,
    style: PropTypes10.object,
    compact: PropTypes10.bool,
    customAttribution: PropTypes10.oneOfType([PropTypes10.string, PropTypes10.arrayOf(PropTypes10.string)])
  });
  var defaultProps10 = Object.assign({}, mapControlDefaultProps, {
    className: "",
    toggleLabel: "Toggle Attribution"
  });
  function setupAttributioncontrol(opts, map16, container, attributionContainer) {
    var control = new import_mapbox_gl.default.AttributionControl(opts);
    control._map = map16;
    control._container = container;
    control._innerContainer = attributionContainer;
    control._updateAttributions();
    control._updateEditLink();
    map16.on("styledata", control._updateData);
    map16.on("sourcedata", control._updateData);
    return control;
  }
  function removeAttributionControl(control) {
    control._map.off("styledata", control._updateData);
    control._map.off("sourcedata", control._updateData);
  }
  function AttributionControl(props) {
    var _useMapControl = useMapControl(props), context = _useMapControl.context, containerRef = _useMapControl.containerRef;
    var innerContainerRef = (0, import_react20.useRef)(null);
    var _useState = (0, import_react20.useState)(false), _useState2 = _slicedToArray(_useState, 2), showCompact = _useState2[0], setShowCompact = _useState2[1];
    (0, import_react20.useEffect)(function() {
      var control;
      if (context.map) {
        control = setupAttributioncontrol({
          customAttribution: props.customAttribution
        }, context.map, containerRef.current, innerContainerRef.current);
      }
      return function() {
        return control && removeAttributionControl(control);
      };
    }, [context.map]);
    var compact = props.compact === void 0 ? context.viewport.width <= 640 : props.compact;
    (0, import_react20.useEffect)(function() {
      if (!compact && showCompact) {
        setShowCompact(false);
      }
    }, [compact]);
    var toggleAttribution = (0, import_react20.useCallback)(function() {
      return setShowCompact(function(value13) {
        return !value13;
      });
    }, []);
    var style = (0, import_react20.useMemo)(function() {
      return _objectSpread11({
        position: "absolute"
      }, props.style);
    }, [props.style]);
    return React10.createElement("div", {
      style,
      className: props.className
    }, React10.createElement("div", {
      ref: containerRef,
      "aria-pressed": showCompact,
      className: "mapboxgl-ctrl mapboxgl-ctrl-attrib ".concat(compact ? "mapboxgl-compact" : "", " ").concat(showCompact ? "mapboxgl-compact-show" : "")
    }, React10.createElement("button", {
      type: "button",
      className: "mapboxgl-ctrl-attrib-button",
      title: props.toggleLabel,
      onClick: toggleAttribution
    }), React10.createElement("div", {
      ref: innerContainerRef,
      className: "mapboxgl-ctrl-attrib-inner",
      role: "list"
    })));
  }
  AttributionControl.propTypes = propTypes8;
  AttributionControl.defaultProps = defaultProps10;
  var attribution_control_default = React10.memo(AttributionControl);

  // node_modules/react-map-gl/dist/esm/components/fullscreen-control.js
  var PropTypes11 = __toESM(require_prop_types());
  var React11 = __toESM(require_react());
  var import_react21 = __toESM(require_react());
  function ownKeys12(object12, enumerableOnly) {
    var keys3 = Object.keys(object12);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object12);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object12, sym).enumerable;
        });
      keys3.push.apply(keys3, symbols);
    }
    return keys3;
  }
  function _objectSpread12(target5) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys12(Object(source), true).forEach(function(key) {
          _defineProperty(target5, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target5, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys12(Object(source)).forEach(function(key) {
          Object.defineProperty(target5, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target5;
  }
  var propTypes9 = Object.assign({}, mapControlPropTypes, {
    className: PropTypes11.string,
    style: PropTypes11.object,
    container: PropTypes11.object,
    label: PropTypes11.string
  });
  var defaultProps11 = Object.assign({}, mapControlDefaultProps, {
    className: "",
    container: null,
    label: "Toggle fullscreen"
  });
  function FullscreenControl(props) {
    var _useMapControl = useMapControl(props), context = _useMapControl.context, containerRef = _useMapControl.containerRef;
    var _useState = (0, import_react21.useState)(false), _useState2 = _slicedToArray(_useState, 2), isFullscreen = _useState2[0], setIsFullscreen = _useState2[1];
    var _useState3 = (0, import_react21.useState)(false), _useState4 = _slicedToArray(_useState3, 2), showButton = _useState4[0], setShowButton = _useState4[1];
    var _useState5 = (0, import_react21.useState)(null), _useState6 = _slicedToArray(_useState5, 2), mapboxFullscreenControl = _useState6[0], createMapboxFullscreenControl = _useState6[1];
    (0, import_react21.useEffect)(function() {
      var control = new import_mapbox_gl.default.FullscreenControl();
      createMapboxFullscreenControl(control);
      setShowButton(control._checkFullscreenSupport());
      var onFullscreenChange = function onFullscreenChange2() {
        var nextState = !control._fullscreen;
        control._fullscreen = nextState;
        setIsFullscreen(nextState);
      };
      document_5.addEventListener(control._fullscreenchange, onFullscreenChange);
      return function() {
        document_5.removeEventListener(control._fullscreenchange, onFullscreenChange);
      };
    }, []);
    var onClickFullscreen = function onClickFullscreen2() {
      if (mapboxFullscreenControl) {
        mapboxFullscreenControl._container = props.container || context.container;
        mapboxFullscreenControl._onClickFullscreen();
      }
    };
    var style = (0, import_react21.useMemo)(function() {
      return _objectSpread12({
        position: "absolute"
      }, props.style);
    }, [props.style]);
    if (!showButton) {
      return null;
    }
    var className = props.className, label4 = props.label;
    var type = isFullscreen ? "shrink" : "fullscreen";
    return React11.createElement("div", {
      style,
      className
    }, React11.createElement("div", {
      className: "mapboxgl-ctrl mapboxgl-ctrl-group",
      ref: containerRef
    }, React11.createElement("button", {
      key: type,
      className: "mapboxgl-ctrl-icon mapboxgl-ctrl-".concat(type),
      type: "button",
      title: label4,
      onClick: onClickFullscreen
    }, React11.createElement("span", {
      className: "mapboxgl-ctrl-icon",
      "aria-hidden": "true"
    }))));
  }
  FullscreenControl.propTypes = propTypes9;
  FullscreenControl.defaultProps = defaultProps11;
  var fullscreen_control_default = React11.memo(FullscreenControl);

  // node_modules/react-map-gl/dist/esm/components/geolocate-control.js
  var React12 = __toESM(require_react());
  var import_react22 = __toESM(require_react());
  var PropTypes12 = __toESM(require_prop_types());

  // node_modules/react-map-gl/dist/esm/utils/geolocate-utils.js
  var supported;
  function isGeolocationSupported() {
    if (supported !== void 0) {
      return Promise.resolve(supported);
    }
    if (window.navigator.permissions !== void 0) {
      return window.navigator.permissions.query({
        name: "geolocation"
      }).then(function(p) {
        supported = p.state !== "denied";
        return supported;
      });
    }
    supported = Boolean(window.navigator.geolocation);
    return Promise.resolve(supported);
  }

  // node_modules/react-map-gl/dist/esm/components/geolocate-control.js
  function ownKeys13(object12, enumerableOnly) {
    var keys3 = Object.keys(object12);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object12);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object12, sym).enumerable;
        });
      keys3.push.apply(keys3, symbols);
    }
    return keys3;
  }
  function _objectSpread13(target5) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys13(Object(source), true).forEach(function(key) {
          _defineProperty(target5, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target5, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys13(Object(source)).forEach(function(key) {
          Object.defineProperty(target5, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target5;
  }
  var noop9 = function noop10() {
  };
  var propTypes10 = Object.assign({}, mapControlPropTypes, {
    className: PropTypes12.string,
    style: PropTypes12.object,
    label: PropTypes12.string,
    disabledLabel: PropTypes12.string,
    auto: PropTypes12.bool,
    positionOptions: PropTypes12.object,
    fitBoundsOptions: PropTypes12.object,
    trackUserLocation: PropTypes12.bool,
    showUserLocation: PropTypes12.bool,
    showAccuracyCircle: PropTypes12.bool,
    showUserHeading: PropTypes12.bool,
    onViewStateChange: PropTypes12.func,
    onViewportChange: PropTypes12.func,
    onGeolocate: PropTypes12.func
  });
  var defaultProps12 = Object.assign({}, mapControlDefaultProps, {
    className: "",
    label: "Find My Location",
    disabledLabel: "Location Not Available",
    auto: false,
    positionOptions: {
      enableHighAccuracy: false,
      timeout: 6e3
    },
    fitBoundsOptions: {
      maxZoom: 15
    },
    trackUserLocation: false,
    showUserLocation: true,
    showUserHeading: false,
    showAccuracyCircle: true,
    onGeolocate: function onGeolocate() {
    }
  });
  function getBounds2(position2) {
    var center = new import_mapbox_gl.default.LngLat(position2.coords.longitude, position2.coords.latitude);
    var radius = position2.coords.accuracy;
    var bounds = center.toBounds(radius);
    return [[bounds._ne.lng, bounds._ne.lat], [bounds._sw.lng, bounds._sw.lat]];
  }
  function setupMapboxGeolocateControl(context, props, geolocateButton) {
    var control = new import_mapbox_gl.default.GeolocateControl(props);
    control._container = document_5.createElement("div");
    control._map = {
      on: function on2() {
      },
      _getUIString: function _getUIString() {
        return "";
      }
    };
    control._setupUI(true);
    control._map = context.map;
    control._geolocateButton = geolocateButton;
    var eventManager = context.eventManager;
    if (control.options.trackUserLocation && eventManager) {
      eventManager.on("panstart", function() {
        if (control._watchState === "ACTIVE_LOCK") {
          control._watchState = "BACKGROUND";
          geolocateButton.classList.add("mapboxgl-ctrl-geolocate-background");
          geolocateButton.classList.remove("mapboxgl-ctrl-geolocate-active");
        }
      });
    }
    control.on("geolocate", props.onGeolocate);
    return control;
  }
  function updateCamera(position2, _ref) {
    var context = _ref.context, props = _ref.props;
    var bounds = getBounds2(position2);
    var _context$viewport$fit = context.viewport.fitBounds(bounds, props.fitBoundsOptions), longitude = _context$viewport$fit.longitude, latitude = _context$viewport$fit.latitude, zoom = _context$viewport$fit.zoom;
    var newViewState = Object.assign({}, context.viewport, {
      longitude,
      latitude,
      zoom
    });
    var mapState = new MapState2(newViewState);
    var viewState = Object.assign({}, mapState.getViewportProps(), LINEAR_TRANSITION_PROPS);
    var onViewportChange = props.onViewportChange || context.onViewportChange || noop9;
    var onViewStateChange = props.onViewStateChange || context.onViewStateChange || noop9;
    onViewStateChange({
      viewState
    });
    onViewportChange(viewState);
  }
  function GeolocateControl(props) {
    var thisRef = useMapControl(props);
    var context = thisRef.context, containerRef = thisRef.containerRef;
    var geolocateButtonRef = (0, import_react22.useRef)(null);
    var _useState = (0, import_react22.useState)(null), _useState2 = _slicedToArray(_useState, 2), mapboxGeolocateControl = _useState2[0], createMapboxGeolocateControl = _useState2[1];
    var _useState3 = (0, import_react22.useState)(false), _useState4 = _slicedToArray(_useState3, 2), supportsGeolocation = _useState4[0], setSupportsGeolocation = _useState4[1];
    (0, import_react22.useEffect)(function() {
      var control;
      if (context.map) {
        isGeolocationSupported().then(function(result) {
          setSupportsGeolocation(result);
          if (geolocateButtonRef.current) {
            control = setupMapboxGeolocateControl(context, props, geolocateButtonRef.current);
            control._updateCamera = function(position2) {
              return updateCamera(position2, thisRef);
            };
            createMapboxGeolocateControl(control);
          }
        });
      }
      return function() {
        if (control) {
          control._clearWatch();
        }
      };
    }, [context.map]);
    var triggerGeolocate = (0, import_react22.useCallback)(function() {
      if (mapboxGeolocateControl) {
        mapboxGeolocateControl.options = thisRef.props;
        mapboxGeolocateControl.trigger();
      }
    }, [mapboxGeolocateControl]);
    (0, import_react22.useEffect)(function() {
      if (props.auto) {
        triggerGeolocate();
      }
    }, [mapboxGeolocateControl, props.auto]);
    (0, import_react22.useEffect)(function() {
      if (mapboxGeolocateControl) {
        mapboxGeolocateControl._onZoom();
      }
    }, [context.viewport.zoom]);
    var className = props.className, label4 = props.label, disabledLabel = props.disabledLabel, trackUserLocation = props.trackUserLocation;
    var style = (0, import_react22.useMemo)(function() {
      return _objectSpread13({
        position: "absolute"
      }, props.style);
    }, [props.style]);
    return React12.createElement("div", {
      style,
      className
    }, React12.createElement("div", {
      key: "geolocate-control",
      className: "mapboxgl-ctrl mapboxgl-ctrl-group",
      ref: containerRef
    }, React12.createElement("button", {
      key: "geolocate",
      className: "mapboxgl-ctrl-icon mapboxgl-ctrl-geolocate",
      ref: geolocateButtonRef,
      disabled: !supportsGeolocation,
      "aria-pressed": !trackUserLocation,
      type: "button",
      title: supportsGeolocation ? label4 : disabledLabel,
      "aria-label": supportsGeolocation ? label4 : disabledLabel,
      onClick: triggerGeolocate
    }, React12.createElement("span", {
      className: "mapboxgl-ctrl-icon",
      "aria-hidden": "true"
    }))));
  }
  GeolocateControl.propTypes = propTypes10;
  GeolocateControl.defaultProps = defaultProps12;
  var geolocate_control_default = React12.memo(GeolocateControl);

  // node_modules/react-map-gl/dist/esm/components/navigation-control.js
  var React13 = __toESM(require_react());
  var import_react23 = __toESM(require_react());
  var PropTypes13 = __toESM(require_prop_types());

  // node_modules/react-map-gl/dist/esm/utils/version.js
  function compareVersions(version1, version2) {
    var v1 = (version1 || "").split(".").map(Number);
    var v2 = (version2 || "").split(".").map(Number);
    for (var i = 0; i < 3; i++) {
      var part1 = v1[i] || 0;
      var part2 = v2[i] || 0;
      if (part1 < part2) {
        return -1;
      }
      if (part1 > part2) {
        return 1;
      }
    }
    return 0;
  }

  // node_modules/react-map-gl/dist/esm/components/navigation-control.js
  function ownKeys14(object12, enumerableOnly) {
    var keys3 = Object.keys(object12);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object12);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object12, sym).enumerable;
        });
      keys3.push.apply(keys3, symbols);
    }
    return keys3;
  }
  function _objectSpread14(target5) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys14(Object(source), true).forEach(function(key) {
          _defineProperty(target5, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target5, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys14(Object(source)).forEach(function(key) {
          Object.defineProperty(target5, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target5;
  }
  var noop11 = function noop12() {
  };
  var propTypes11 = Object.assign({}, mapControlPropTypes, {
    className: PropTypes13.string,
    style: PropTypes13.object,
    onViewStateChange: PropTypes13.func,
    onViewportChange: PropTypes13.func,
    showCompass: PropTypes13.bool,
    showZoom: PropTypes13.bool,
    zoomInLabel: PropTypes13.string,
    zoomOutLabel: PropTypes13.string,
    compassLabel: PropTypes13.string
  });
  var defaultProps13 = Object.assign({}, mapControlDefaultProps, {
    className: "",
    showCompass: true,
    showZoom: true,
    zoomInLabel: "Zoom In",
    zoomOutLabel: "Zoom Out",
    compassLabel: "Reset North"
  });
  var VERSION_LEGACY = 1;
  var VERSION_1_6 = 2;
  function getUIVersion(mapboxVersion) {
    return compareVersions(mapboxVersion, "1.6.0") >= 0 ? VERSION_1_6 : VERSION_LEGACY;
  }
  function updateViewport(context, props, opts) {
    var viewport = context.viewport;
    var mapState = new MapState2(Object.assign({}, viewport, opts));
    var viewState = Object.assign({}, mapState.getViewportProps(), LINEAR_TRANSITION_PROPS);
    var onViewportChange = props.onViewportChange || context.onViewportChange || noop11;
    var onViewStateChange = props.onViewStateChange || context.onViewStateChange || noop11;
    onViewStateChange({
      viewState
    });
    onViewportChange(viewState);
  }
  function renderButton(type, label4, callback, children) {
    return React13.createElement("button", {
      key: type,
      className: "mapboxgl-ctrl-icon mapboxgl-ctrl-".concat(type),
      type: "button",
      title: label4,
      onClick: callback
    }, children || React13.createElement("span", {
      className: "mapboxgl-ctrl-icon",
      "aria-hidden": "true"
    }));
  }
  function renderCompass(context) {
    var uiVersion = (0, import_react23.useMemo)(function() {
      return context.map ? getUIVersion(context.map.version) : VERSION_1_6;
    }, [context.map]);
    var bearing = context.viewport.bearing;
    var style = {
      transform: "rotate(".concat(-bearing, "deg)")
    };
    return uiVersion === VERSION_1_6 ? React13.createElement("span", {
      className: "mapboxgl-ctrl-icon",
      "aria-hidden": "true",
      style
    }) : React13.createElement("span", {
      className: "mapboxgl-ctrl-compass-arrow",
      style
    });
  }
  function NavigationControl(props) {
    var _useMapControl = useMapControl(props), context = _useMapControl.context, containerRef = _useMapControl.containerRef;
    var onZoomIn = function onZoomIn2() {
      updateViewport(context, props, {
        zoom: context.viewport.zoom + 1
      });
    };
    var onZoomOut = function onZoomOut2() {
      updateViewport(context, props, {
        zoom: context.viewport.zoom - 1
      });
    };
    var onResetNorth = function onResetNorth2() {
      updateViewport(context, props, {
        bearing: 0,
        pitch: 0
      });
    };
    var className = props.className, showCompass = props.showCompass, showZoom = props.showZoom, zoomInLabel = props.zoomInLabel, zoomOutLabel = props.zoomOutLabel, compassLabel = props.compassLabel;
    var style = (0, import_react23.useMemo)(function() {
      return _objectSpread14({
        position: "absolute"
      }, props.style);
    }, [props.style]);
    return React13.createElement("div", {
      style,
      className
    }, React13.createElement("div", {
      className: "mapboxgl-ctrl mapboxgl-ctrl-group",
      ref: containerRef
    }, showZoom && renderButton("zoom-in", zoomInLabel, onZoomIn), showZoom && renderButton("zoom-out", zoomOutLabel, onZoomOut), showCompass && renderButton("compass", compassLabel, onResetNorth, renderCompass(context))));
  }
  NavigationControl.propTypes = propTypes11;
  NavigationControl.defaultProps = defaultProps13;
  var navigation_control_default = React13.memo(NavigationControl);

  // node_modules/react-map-gl/dist/esm/components/scale-control.js
  var React14 = __toESM(require_react());
  var import_react24 = __toESM(require_react());
  var PropTypes14 = __toESM(require_prop_types());
  function ownKeys15(object12, enumerableOnly) {
    var keys3 = Object.keys(object12);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object12);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object12, sym).enumerable;
        });
      keys3.push.apply(keys3, symbols);
    }
    return keys3;
  }
  function _objectSpread15(target5) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys15(Object(source), true).forEach(function(key) {
          _defineProperty(target5, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target5, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys15(Object(source)).forEach(function(key) {
          Object.defineProperty(target5, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target5;
  }
  var propTypes12 = Object.assign({}, mapControlPropTypes, {
    className: PropTypes14.string,
    style: PropTypes14.object,
    maxWidth: PropTypes14.number,
    unit: PropTypes14.oneOf(["imperial", "metric", "nautical"])
  });
  var defaultProps14 = Object.assign({}, mapControlDefaultProps, {
    className: "",
    maxWidth: 100,
    unit: "metric"
  });
  function ScaleControl(props) {
    var _useMapControl = useMapControl(props), context = _useMapControl.context, containerRef = _useMapControl.containerRef;
    var _useState = (0, import_react24.useState)(null), _useState2 = _slicedToArray(_useState, 2), mapboxScaleControl = _useState2[0], createMapboxScaleControl = _useState2[1];
    (0, import_react24.useEffect)(function() {
      if (context.map) {
        var control = new import_mapbox_gl.default.ScaleControl();
        control._map = context.map;
        control._container = containerRef.current;
        createMapboxScaleControl(control);
      }
    }, [context.map]);
    if (mapboxScaleControl) {
      mapboxScaleControl.options = props;
      if (mapboxScaleControl._onMove)
        mapboxScaleControl._onMove();
    }
    var style = (0, import_react24.useMemo)(function() {
      return _objectSpread15({
        position: "absolute"
      }, props.style);
    }, [props.style]);
    return React14.createElement("div", {
      style,
      className: props.className
    }, React14.createElement("div", {
      ref: containerRef,
      className: "mapboxgl-ctrl mapboxgl-ctrl-scale"
    }));
  }
  ScaleControl.propTypes = propTypes12;
  ScaleControl.defaultProps = defaultProps14;
  var scale_control_default = React14.memo(ScaleControl);

  // node_modules/react-map-gl/dist/esm/overlays/canvas-overlay.js
  var React15 = __toESM(require_react());
  var import_react25 = __toESM(require_react());
  var PropTypes15 = __toESM(require_prop_types());
  var pixelRatio2 = typeof window !== "undefined" && window.devicePixelRatio || 1;
  var propTypes13 = Object.assign({}, mapControlPropTypes, {
    redraw: PropTypes15.func.isRequired
  });
  var defaultProps15 = {
    captureScroll: false,
    captureDrag: false,
    captureClick: false,
    captureDoubleClick: false,
    capturePointerMove: false
  };
  function CanvasOverlay(props) {
    var _useMapControl = useMapControl(props), context = _useMapControl.context, containerRef = _useMapControl.containerRef;
    var _useState = (0, import_react25.useState)(null), _useState2 = _slicedToArray(_useState, 2), ctx = _useState2[0], setDrawingContext = _useState2[1];
    (0, import_react25.useEffect)(function() {
      setDrawingContext(containerRef.current.getContext("2d"));
    }, []);
    var viewport = context.viewport, isDragging = context.isDragging;
    if (ctx) {
      ctx.save();
      ctx.scale(pixelRatio2, pixelRatio2);
      props.redraw({
        width: viewport.width,
        height: viewport.height,
        ctx,
        isDragging,
        project: viewport.project,
        unproject: viewport.unproject
      });
      ctx.restore();
    }
    return React15.createElement("canvas", {
      ref: containerRef,
      width: viewport.width * pixelRatio2,
      height: viewport.height * pixelRatio2,
      style: {
        width: "".concat(viewport.width, "px"),
        height: "".concat(viewport.height, "px"),
        position: "absolute",
        left: 0,
        top: 0
      }
    });
  }
  CanvasOverlay.propTypes = propTypes13;
  CanvasOverlay.defaultProps = defaultProps15;

  // node_modules/react-map-gl/dist/esm/overlays/html-overlay.js
  var React16 = __toESM(require_react());
  var PropTypes16 = __toESM(require_prop_types());
  function ownKeys16(object12, enumerableOnly) {
    var keys3 = Object.keys(object12);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object12);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object12, sym).enumerable;
        });
      keys3.push.apply(keys3, symbols);
    }
    return keys3;
  }
  function _objectSpread16(target5) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys16(Object(source), true).forEach(function(key) {
          _defineProperty(target5, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target5, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys16(Object(source)).forEach(function(key) {
          Object.defineProperty(target5, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target5;
  }
  var propTypes14 = Object.assign({}, mapControlPropTypes, {
    redraw: PropTypes16.func.isRequired,
    style: PropTypes16.object
  });
  var defaultProps16 = {
    captureScroll: false,
    captureDrag: false,
    captureClick: false,
    captureDoubleClick: false,
    capturePointerMove: false
  };
  function HTMLOverlay(props) {
    var _useMapControl = useMapControl(props), context = _useMapControl.context, containerRef = _useMapControl.containerRef;
    var viewport = context.viewport, isDragging = context.isDragging;
    var style = _objectSpread16({
      position: "absolute",
      left: 0,
      top: 0,
      width: viewport.width,
      height: viewport.height
    }, props.style);
    return React16.createElement("div", {
      ref: containerRef,
      style
    }, props.redraw({
      width: viewport.width,
      height: viewport.height,
      isDragging,
      project: viewport.project,
      unproject: viewport.unproject
    }));
  }
  HTMLOverlay.propTypes = propTypes14;
  HTMLOverlay.defaultProps = defaultProps16;

  // node_modules/react-map-gl/dist/esm/overlays/svg-overlay.js
  var React17 = __toESM(require_react());
  var PropTypes17 = __toESM(require_prop_types());
  function ownKeys17(object12, enumerableOnly) {
    var keys3 = Object.keys(object12);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object12);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object12, sym).enumerable;
        });
      keys3.push.apply(keys3, symbols);
    }
    return keys3;
  }
  function _objectSpread17(target5) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys17(Object(source), true).forEach(function(key) {
          _defineProperty(target5, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target5, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys17(Object(source)).forEach(function(key) {
          Object.defineProperty(target5, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target5;
  }
  var propTypes15 = Object.assign({}, mapControlPropTypes, {
    redraw: PropTypes17.func.isRequired,
    style: PropTypes17.object
  });
  var defaultProps17 = {
    captureScroll: false,
    captureDrag: false,
    captureClick: false,
    captureDoubleClick: false,
    capturePointerMove: false
  };
  function SVGOverlay(props) {
    var _useMapControl = useMapControl(props), context = _useMapControl.context, containerRef = _useMapControl.containerRef;
    var viewport = context.viewport, isDragging = context.isDragging;
    var style = _objectSpread17({
      position: "absolute",
      left: 0,
      top: 0
    }, props.style);
    return React17.createElement("svg", {
      width: viewport.width,
      height: viewport.height,
      ref: containerRef,
      style
    }, props.redraw({
      width: viewport.width,
      height: viewport.height,
      isDragging,
      project: viewport.project,
      unproject: viewport.unproject
    }));
  }
  SVGOverlay.propTypes = propTypes15;
  SVGOverlay.defaultProps = defaultProps17;

  // node_modules/react-map-gl/dist/esm/utils/set-rtl-text-plugin.js
  var setRTLTextPlugin = import_mapbox_gl.default ? import_mapbox_gl.default.setRTLTextPlugin : function() {
  };

  // output/MapGL/foreign.js
  var mapGL = interactive_map_default;
  var defaultProps18 = interactive_map_default.defaultProps;

  // output/MapGL/index.js
  var disjointUnion2 = /* @__PURE__ */ disjointUnion()();
  var mkProps = function() {
    return function() {
      return function(v) {
        return function(rest) {
          return disjointUnion2(rest)(v);
        };
      };
    };
  };

  // output/Web.HTML/foreign.js
  var windowImpl = function() {
    return window;
  };

  // output/Web.HTML.HTMLDocument/index.js
  var toNonElementParentNode = unsafeCoerce2;

  // output/Web.HTML.Window/foreign.js
  function document2(window3) {
    return function() {
      return window3.document;
    };
  }
  function innerWidth(window3) {
    return function() {
      return window3.innerWidth;
    };
  }
  function innerHeight(window3) {
    return function() {
      return window3.innerHeight;
    };
  }

  // output/App.Component.Map/index.js
  var pure16 = /* @__PURE__ */ pure(applicativeEffect);
  var mkProps2 = /* @__PURE__ */ mkProps()();
  var $$void3 = /* @__PURE__ */ $$void(functorEffect);
  var mempty2 = /* @__PURE__ */ mempty(/* @__PURE__ */ monoidEffect(monoidUnit));
  var createElement20 = /* @__PURE__ */ createElement5();
  var createLeafElement4 = /* @__PURE__ */ createLeafElement2();
  var forever2 = /* @__PURE__ */ forever(monadRecAff);
  var bind17 = /* @__PURE__ */ bind(bindAff);
  var liftEffect3 = /* @__PURE__ */ liftEffect(monadEffectAff);
  var discard2 = /* @__PURE__ */ discard(discardUnit);
  var discard1 = /* @__PURE__ */ discard2(bindAff);
  var mapboxApiAccessToken = "pk.eyJ1IjoiYmxpbmt5MzcxMyIsImEiOiJjamVvcXZtbGYwMXgzMzNwN2JlNGhuMHduIn0.ue2IR6wHG8b9eUoSfPhTuQ";
  var mapStyle = "mapbox://styles/mapbox/dark-v9";
  var initialViewport = function __do() {
    var win = windowImpl();
    var w = innerWidth(win)();
    var h = innerHeight(win)();
    return {
      width: toNumber(w),
      height: toNumber(h),
      longitude: -35,
      latitude: 36.7,
      zoom: 1.8,
      pitch: 0,
      bearing: 0
    };
  };
  var mapClass = /* @__PURE__ */ function() {
    var render2 = function($$this) {
      return function __do2() {
        var state3 = getState($$this)();
        var overlayProps = {
          viewport: state3.viewport,
          data: state3.data,
          discreteZoom: floor2(state3.viewport.zoom),
          time: state3.time
        };
        var mapProps = mkProps2(state3.viewport)({
          onViewportChange: function(newVp) {
            return $$void3(modifyState($$this)(function(v) {
              var $24 = {};
              for (var $25 in v) {
                if ({}.hasOwnProperty.call(v, $25)) {
                  $24[$25] = v[$25];
                }
                ;
              }
              ;
              $24.viewport = newVp;
              return $24;
            }))();
          },
          onClick: mkEffectFn1($$const(pure16(unit))),
          mapStyle,
          mapboxApiAccessToken,
          dragRotate: false,
          onLoad: mempty2,
          touchZoom: false,
          touchRotate: false
        });
        return createElement20(mapGL)(mapProps)([createLeafElement4(deckGLClass)(overlayProps)]);
      };
    };
    var componentDidMount = function($$this) {
      return launchAff_(forever2(bind17(liftEffect3(function __do2() {
        var st = getState($$this)();
        return pow(st.currentSpeedFactor)(2);
      }))(function(currentSpeedFactor) {
        return discard1(delay(50))(function() {
          return liftEffect3(modifyState($$this)(function(st) {
            var newTime = remainder(st.time + 5e-3 * currentSpeedFactor)(1.1);
            var $27 = {};
            for (var $28 in st) {
              if ({}.hasOwnProperty.call(st, $28)) {
                $27[$28] = st[$28];
              }
              ;
            }
            ;
            $27.time = newTime;
            return $27;
          }));
        });
      })));
    };
    return component()("Map")(function($$this) {
      return function __do2() {
        var vp = initialViewport();
        launchAff_(bind17(getRoute)(function(r) {
          var route = mkTripR(r);
          var start2 = head(route.path);
          var vp$prime = function() {
            if (start2 instanceof Nothing) {
              return vp;
            }
            ;
            if (start2 instanceof Just) {
              return {
                bearing: vp.bearing,
                height: vp.height,
                pitch: vp.pitch,
                width: vp.width,
                latitude: lat(start2.value0),
                longitude: lng(start2.value0),
                zoom: 13
              };
            }
            ;
            throw new Error("Failed pattern match at App.Component.Map (line 43, column 13 - line 45, column 88): " + [start2.constructor.name]);
          }();
          return liftEffect3(modifyState($$this)(function(v) {
            var $32 = {};
            for (var $33 in v) {
              if ({}.hasOwnProperty.call(v, $33)) {
                $32[$33] = v[$33];
              }
              ;
            }
            ;
            $32.data = [route];
            $32.viewport = vp$prime;
            return $32;
          }));
        }))();
        return {
          render: render2($$this),
          componentDidMount: componentDidMount($$this),
          state: {
            viewport: vp,
            data: [],
            time: 0,
            currentSpeedFactor: 0.75
          }
        };
      };
    });
  }();

  // output/ReactDOM/foreign.js
  var import_react_dom = __toESM(require_react_dom(), 1);
  var import_server = __toESM(require_server_browser(), 1);
  function renderImpl(element, container) {
    return import_react_dom.default.render(element, container);
  }
  var unmountComponentAtNodeImpl = import_react_dom.default.unmountComponentAtNode;
  var findDOMNodeImpl = import_react_dom.default.findDOMNode;
  var renderToStringImpl = import_server.default.renderToString;
  var renderToStaticMarkupImpl = import_server.default.renderToStaticMarkup;

  // output/ReactDOM/index.js
  var map14 = /* @__PURE__ */ map(functorEffect);
  var render = function(rEl) {
    return function(el) {
      return map14(toMaybe)(function() {
        return renderImpl(rEl, el);
      });
    };
  };

  // output/Web.DOM.NonElementParentNode/foreign.js
  function _getElementById(id2) {
    return function(node) {
      return function() {
        return node.getElementById(id2);
      };
    };
  }

  // output/Web.DOM.NonElementParentNode/index.js
  var map15 = /* @__PURE__ */ map(functorEffect);
  var getElementById = function(eid) {
    var $2 = map15(toMaybe);
    var $3 = _getElementById(eid);
    return function($4) {
      return $2($3($4));
    };
  };

  // output/App.Main/index.js
  var bind18 = /* @__PURE__ */ bind(bindEffect);
  var fromJust5 = /* @__PURE__ */ fromJust();
  var main = /* @__PURE__ */ function() {
    var elm$prime = function __do2() {
      var win = windowImpl();
      var doc = document2(win)();
      var elm = getElementById("root")(toNonElementParentNode(doc))();
      return fromJust5(elm);
    };
    return $$void(functorEffect)(bind18(elm$prime)(render(createLeafElement2()(mapClass)({}))));
  }();

  // <stdin>
  main();
})();
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
/**
 * @license React
 * react-dom-server-legacy.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react-dom-server.browser.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * react.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
